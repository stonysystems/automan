// Dafny program Main.i.dfy compiled into C#
// To recompile, you will need the libraries
//     System.Runtime.Numerics.dll System.Collections.Immutable.dll
// but the 'dotnet' tool in net6.0 should pick those up automatically.
// Optionally, you may want to include compiler switches like
//     /debug /nowarn:162,164,168,183,219,436,1717,1718

using System;
using System.Numerics;
using System.Collections;
[assembly: DafnyAssembly.DafnySourceAttribute(@"// dafny 3.13.1.50302
// Command Line Options: /compile:0 /spillTargetCode:3 /noVerify src/Dafny/Distributed/Services/ByzRSL/Main.i.dfy
// Main.i.dfy


module Main_i refines Main_s {

  import opened Native__NativeTypes_s

  import opened Host = Host_i

  import opened DS_s = RSL_DistributedSystem_i

  import opened DirectRefinement__Refinement_i

  import opened Concrete_NodeIdentity_i

  import opened AS_s = AbstractServiceRSL_s

  import opened MarshallProof_i

  import opened LiveByzRSL__CMessageRefinements_i

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__ConstantsState_i

  import opened LiveByzRSL__CTypes_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__PacketParsing_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__UdpRSL_i

  import opened LiveByzRSL__Unsendable_i

  import opened Collections__Maps2_s

  import opened Collections__Sets_i

  import opened Common__GenericMarshalling_i

  import opened Common__NodeIdentity_i

  import opened Common__SeqIsUniqueDef_i

  import opened DirectRefinement__StateMachine_i

  import opened Environment_s

  import opened Math__mod_auto_i

  import opened LiveByzRSL__CMessage_i
  method {:main} Main(ghost env: HostEnvironment)
    requires env.Valid() && env.ok.ok()
    requires env.udp.history() == []
    requires |env.constants.CommandLineArgs()| >= 2
    modifies set x: object {:trigger DS_s.H_s.ArbitraryObject(x)} | DS_s.H_s.ArbitraryObject(x)
    decreases *
  {
    var ok, host_state, config, servers, clients, id := DS_s.H_s.HostInitImpl(env);
    assert ok ==> DS_s.H_s.HostInit(host_state, config, id);
    while ok
      invariant ok ==> DS_s.H_s.HostStateInvariants(host_state, env)
      invariant ok ==> env.Valid() && env.ok.ok()
      decreases *
    {
      ghost var old_udp_history := env.udp.history();
      ghost var old_state := host_state;
      ghost var recvs, clocks, sends, ios;
      ok, host_state, recvs, clocks, sends, ios := DS_s.H_s.HostNextImpl(env, host_state);
      if ok {
        assert DS_s.H_s.HostNext(old_state, host_state, ios);
        assert recvs + clocks + sends == ios;
        assert env.udp.history() == old_udp_history + recvs + clocks + sends;
        assert forall e: LIoOp<EndPoint, seq<byte>> {:trigger e.LIoOpSend?} {:trigger e in sends} {:trigger e.LIoOpTimeoutReceive?} {:trigger e.LIoOpReadClock?} {:trigger e in clocks} {:trigger e.LIoOpReceive?} {:trigger e in recvs} :: (e in recvs ==> e.LIoOpReceive?) && (e in clocks ==> e.LIoOpReadClock? || e.LIoOpTimeoutReceive?) && (e in sends ==> e.LIoOpSend?);
        assert |clocks| <= 1;
      }
    }
  }

  import opened Native__Io_s

  import opened Collections__Seqs_s
}

abstract module Main_s {

  import opened Native__Io_s

  import opened DS_s : DistributedSystem_s

  import opened AS_s : AbstractService_s

  import opened Collections__Seqs_s
  method {:main} Main(ghost env: HostEnvironment)
    requires env.Valid() && env.ok.ok()
    requires env.udp.history() == []
    requires |env.constants.CommandLineArgs()| >= 2
    modifies set x: object {:trigger DS_s.H_s.ArbitraryObject(x)} | DS_s.H_s.ArbitraryObject(x)
    decreases *
  {
    var ok, host_state, config, servers, clients, id := DS_s.H_s.HostInitImpl(env);
    assert ok ==> DS_s.H_s.HostInit(host_state, config, id);
    while ok
      invariant ok ==> DS_s.H_s.HostStateInvariants(host_state, env)
      invariant ok ==> env.Valid() && env.ok.ok()
      decreases *
    {
      ghost var old_udp_history := env.udp.history();
      ghost var old_state := host_state;
      ghost var recvs, clocks, sends, ios;
      ok, host_state, recvs, clocks, sends, ios := DS_s.H_s.HostNextImpl(env, host_state);
      if ok {
        assert DS_s.H_s.HostNext(old_state, host_state, ios);
        assert recvs + clocks + sends == ios;
        assert env.udp.history() == old_udp_history + recvs + clocks + sends;
        assert forall e: LIoOp<EndPoint, seq<byte>> {:trigger e.LIoOpSend?} {:trigger e in sends} {:trigger e.LIoOpTimeoutReceive?} {:trigger e.LIoOpReadClock?} {:trigger e in clocks} {:trigger e.LIoOpReceive?} {:trigger e in recvs} :: (e in recvs ==> e.LIoOpReceive?) && (e in clocks ==> e.LIoOpReadClock? || e.LIoOpTimeoutReceive?) && (e in sends ==> e.LIoOpSend?);
        assert |clocks| <= 1;
      }
    }
  }
}

module Native__Io_s {

  import opened Native__NativeTypes_s

  import opened Environment_s
  class HostEnvironment {
    ghost var constants: HostConstants
    ghost var ok: OkState
    ghost var now: NowState
    ghost var udp: UdpState
    ghost var files: FileSystemState

    constructor {:axiom} ()
      requires false

    predicate Valid()
      reads this
      decreases {this}
    {
      true
    }
  }

  class HostConstants {
    constructor {:axiom} ()
      requires false

    function {:axiom} LocalAddress(): seq<byte>
      reads this
      decreases {this}

    function {:axiom} CommandLineArgs(): seq<seq<uint16>>
      reads this
      decreases {this}

    static method {:axiom} NumCommandLineArgs(ghost env: HostEnvironment) returns (n: uint32)
      requires env.Valid()
      ensures n as int == |env.constants.CommandLineArgs()|
      decreases env

    static method {:axiom} GetCommandLineArg(i: uint64, ghost env: HostEnvironment) returns (arg: array<uint16>)
      requires env.Valid()
      requires 0 <= i as int < |env.constants.CommandLineArgs()|
      ensures fresh(arg)
      ensures arg[..] == env.constants.CommandLineArgs()[i]
      decreases i, env
  }

  class OkState {
    constructor {:axiom} ()
      requires false

    function {:axiom} ok(): bool
      reads this
      decreases {this}
  }

  class NowState {
    constructor {:axiom} ()
      requires false

    function {:axiom} now(): int
      reads this
      decreases {this}
  }

  class Time {
    static method {:axiom} GetTime(ghost env: HostEnvironment) returns (t: uint64)
      requires env.Valid()
      modifies env.now, env.udp
      ensures t as int == env.now.now()
      ensures AdvanceTime(old(env.now.now()), env.now.now(), 0)
      ensures env.udp.history() == old(env.udp.history()) + [LIoOpReadClock(t as int)]
      decreases env

    static method {:axiom} GetDebugTimeTicks() returns (t: uint64)

    static method {:axiom} RecordTiming(name: array<char>, time: uint64)
      decreases name, time
  }

  datatype EndPoint = EndPoint(addr: seq<byte>, port: uint16)

  type UdpPacket = LPacket<EndPoint, seq<byte>>

  type UdpEvent = LIoOp<EndPoint, seq<byte>>

  class UdpState {
    constructor {:axiom} ()
      requires false

    function {:axiom} history(): seq<UdpEvent>
      reads this
      decreases {this}
  }

  class IPEndPoint {
    ghost var env: HostEnvironment

    function {:axiom} Address(): seq<byte>
      reads this
      decreases {this}

    function {:axiom} Port(): uint16
      reads this
      decreases {this}

    function EP(): EndPoint
      reads this
      decreases {this}
    {
      EndPoint(Address(), Port())
    }

    constructor {:axiom} ()
      requires false

    method {:axiom} GetAddress() returns (addr: array<byte>)
      ensures fresh(addr)
      ensures addr[..] == Address()
      ensures addr.Length == 4

    function method {:axiom} GetPort(): uint16
      reads this
      ensures GetPort() == Port()
      decreases {this}

    static method {:axiom} Construct(ipAddress: array<byte>, port: uint16, ghost env: HostEnvironment)
        returns (ok: bool, ep: IPEndPoint)
      requires env.Valid()
      modifies env.ok
      ensures env.ok.ok() == ok
      ensures ok ==> fresh(ep) && ep.env == env && ep.Address() == ipAddress[..] && ep.Port() == port
      decreases ipAddress, port, env
  }

  class UdpClient {
    ghost var env: HostEnvironment

    function {:axiom} LocalEndPoint(): EndPoint
      reads this
      decreases {this}

    function {:axiom} IsOpen(): bool
      reads this
      decreases {this}

    constructor {:axiom} ()
      requires false

    static method {:axiom} Construct(localEP: IPEndPoint, ghost env: HostEnvironment)
        returns (ok: bool, udp: UdpClient?)
      requires env.Valid()
      requires env.ok.ok()
      modifies env.ok
      ensures env.ok.ok() == ok
      ensures ok ==> fresh(udp) && udp.env == env && udp.IsOpen() && udp.LocalEndPoint() == localEP.EP()
      decreases localEP, env

    method {:axiom} Close() returns (ok: bool)
      requires env.Valid()
      requires env.ok.ok()
      requires this.IsOpen()
      modifies this, env.ok
      ensures env == old(env)
      ensures env.ok.ok() == ok

    method {:axiom} Receive(timeLimit: int32)
        returns (ok: bool, timedOut: bool, remote: IPEndPoint, buffer: array<byte>)
      requires env.Valid()
      requires env.ok.ok()
      requires IsOpen()
      requires timeLimit >= 0
      requires timeLimit as int * 1000 < 2147483648
      modifies this, env.ok, env.now, env.udp
      ensures env == old(env)
      ensures env.ok.ok() == ok
      ensures AdvanceTime(old(env.now.now()), env.now.now(), timeLimit as int)
      ensures LocalEndPoint() == old(LocalEndPoint())
      ensures ok ==> IsOpen()
      ensures ok ==> timedOut ==> env.udp.history() == old(env.udp.history()) + [LIoOpTimeoutReceive()]
      ensures ok ==> !timedOut ==> fresh(remote) && fresh(buffer) && env.udp.history() == old(env.udp.history()) + [LIoOpReceive(LPacket(LocalEndPoint(), remote.EP(), buffer[..]))] && buffer.Length < 18446744073709551616
      decreases timeLimit

    method {:axiom} Send(remote: IPEndPoint, buffer: array<byte>) returns (ok: bool)
      requires env.Valid()
      requires env.ok.ok()
      requires IsOpen()
      requires buffer.Length <= MaxPacketSize()
      modifies this, env.ok, env.udp
      ensures env == old(env)
      ensures env.ok.ok() == ok
      ensures LocalEndPoint() == old(LocalEndPoint())
      ensures ok ==> IsOpen()
      ensures ok ==> env.udp.history() == old(env.udp.history()) + [LIoOpSend(LPacket(remote.EP(), LocalEndPoint(), buffer[..]))]
      decreases remote, buffer
  }

  class FileSystemState { }

  class MutableSet<T(==,0,!new)> {
    static function method {:axiom} SetOf(s: MutableSet<T>): set<T>
      reads s
      decreases {s}, s

    static method {:axiom} EmptySet() returns (s: MutableSet<T>)
      ensures SetOf(s) == {}
      ensures fresh(s)

    constructor {:axiom} ()
      requires false

    method {:axiom} Size() returns (size: int)
      ensures size == |SetOf(this)|

    method {:axiom} SizeModest() returns (size: uint64)
      requires |SetOf(this)| < 18446744073709551616
      ensures size as int == |SetOf(this)|

    method {:axiom} Contains(x: T) returns (contains: bool)
      ensures contains == (x in SetOf(this))

    method {:axiom} Add(x: T)
      modifies this
      ensures SetOf(this) == old(SetOf(this)) + {x}

    method {:axiom} AddSet(s: MutableSet<T>)
      modifies this
      ensures SetOf(this) == old(SetOf(this)) + old(SetOf(s))
      decreases s

    method {:axiom} TransferSet(s: MutableSet<T>)
      modifies this, s
      ensures SetOf(this) == old(SetOf(s))
      ensures SetOf(s) == {}
      decreases s

    method {:axiom} Remove(x: T)
      modifies this
      ensures SetOf(this) == old(SetOf(this)) - {x}

    method {:axiom} RemoveAll()
      modifies this
      ensures SetOf(this) == {}
  }

  class MutableMap<K(==), V> {
    static function method {:axiom} MapOf(m: MutableMap<K, V>): map<K, V>
      reads m
      decreases {m}, m

    static method {:axiom} EmptyMap() returns (m: MutableMap<K, V>)
      ensures MapOf(m) == map[]
      ensures fresh(m)

    static method {:axiom} FromMap(dafny_map: map<K, V>) returns (m: MutableMap<K, V>)
      ensures MapOf(m) == dafny_map
      ensures fresh(m)
      decreases dafny_map

    constructor {:axiom} ()
      requires false

    function method {:axiom} Size(): int
      reads this
      ensures this.Size() == |MapOf(this)|
      decreases {this}

    method {:axiom} SizeModest() returns (size: uint64)
      requires |MapOf(this)| < 18446744073709551616
      ensures size as int == |MapOf(this)|

    method {:axiom} Contains(key: K) returns (contains: bool)
      ensures contains == (key in MapOf(this))

    method {:axiom} TryGetValue(key: K) returns (contains: bool, val: V)
      ensures contains == (key in MapOf(this))
      ensures contains ==> val == MapOf(this)[key]

    method {:axiom} Set(key: K, val: V)
      modifies this
      ensures MapOf(this) == old(MapOf(this))[key := val]

    method {:axiom} Remove(key: K)
      modifies this
      ensures MapOf(this) == map k: K {:trigger old(MapOf(this))[k]} {:trigger k in old(MapOf(this))} | k != key && k in old(MapOf(this)) :: old(MapOf(this))[k]
  }

  class Arrays {
    static method {:axiom} CopySeqIntoArray<A>(src: seq<A>, srcIndex: uint64, dst: array<A>, dstIndex: uint64, len: uint64)
      requires srcIndex as int + len as int <= |src|
      requires dstIndex as int + len as int <= dst.Length
      modifies dst
      ensures forall i: int {:trigger old(dst[..])[i]} {:trigger dst[i]} :: 0 <= i < dst.Length ==> dst[i] == if dstIndex as int <= i < dstIndex as int + len as int then src[i - dstIndex as int + srcIndex as int] else old(dst[..])[i]
      ensures forall i: int {:trigger src[i]} :: srcIndex as int <= i < srcIndex as int + len as int ==> src[i] == dst[i - srcIndex as int + dstIndex as int]
      decreases src, srcIndex, dst, dstIndex, len
  }

  function {:axiom} realTimeBound(): int

  predicate AdvanceTime(oldTime: int, newTime: int, delay: int)
    decreases oldTime, newTime, delay
  {
    oldTime <= newTime < oldTime + delay + realTimeBound()
  }

  function MaxPacketSize(): int
  {
    18446744073709551615
  }
}

module Native__NativeTypes_s {
  newtype {:nativeType ""sbyte""} sbyte = i: int
    | -128 <= i < 128

  newtype {:nativeType ""byte""} byte = i: int
    | 0 <= i < 256

  newtype {:nativeType ""short""} int16 = i: int
    | -32768 <= i < 32768

  newtype {:nativeType ""ushort""} uint16 = i: int
    | 0 <= i < 65536

  newtype {:nativeType ""int""} int32 = i: int
    | -2147483648 <= i < 2147483648

  newtype {:nativeType ""uint""} uint32 = i: int
    | 0 <= i < 4294967296

  newtype {:nativeType ""long""} int64 = i: int
    | -9223372036854775808 <= i < 9223372036854775808

  newtype {:nativeType ""ulong""} uint64 = i: int
    | 0 <= i < 18446744073709551616

  newtype {:nativeType ""sbyte""} nat8 = i: int
    | 0 <= i < 128

  newtype {:nativeType ""short""} nat16 = i: int
    | 0 <= i < 32768

  newtype {:nativeType ""int""} nat32 = i: int
    | 0 <= i < 2147483648

  newtype {:nativeType ""long""} nat64 = i: int
    | 0 <= i < 9223372036854775808
}

module Environment_s {

  import opened Collections__Maps2_s

  import opened Temporal__Temporal_s
  datatype LPacket<IdType, MessageType(==)> = LPacket(dst: IdType, src: IdType, msg: MessageType)

  datatype LIoOp<IdType, MessageType(==)> = LIoOpSend(s: LPacket<IdType, MessageType>) | LIoOpReceive(r: LPacket<IdType, MessageType>) | LIoOpTimeoutReceive | LIoOpReadClock(t: int)

  datatype LEnvStep<IdType, MessageType(==)> = LEnvStepHostIos(actor: IdType, ios: seq<LIoOp<IdType, MessageType>>) | LEnvStepDeliverPacket(p: LPacket<IdType, MessageType>) | LEnvStepAdvanceTime | LEnvStepStutter

  datatype LHostInfo<IdType, MessageType(==)> = LHostInfo(queue: seq<LPacket<IdType, MessageType>>)

  datatype LEnvironment<IdType, MessageType(==)> = LEnvironment(time: int, sentPackets: set<LPacket<IdType, MessageType>>, hostInfo: map<IdType, LHostInfo<IdType, MessageType>>, nextStep: LEnvStep<IdType, MessageType>)

  predicate IsValidLIoOp<IdType, MessageType>(io: LIoOp<IdType, MessageType>, actor: IdType, e: LEnvironment<IdType, MessageType>)
    decreases io, e
  {
    match io
    case LIoOpSend(s) =>
      s.src == actor
    case LIoOpReceive(r) =>
      r.dst == actor
    case LIoOpTimeoutReceive() =>
      true
    case LIoOpReadClock(t) =>
      true
  }

  predicate LIoOpOrderingOKForAction<IdType, MessageType>(io1: LIoOp<IdType, MessageType>, io2: LIoOp<IdType, MessageType>)
    decreases io1, io2
  {
    io1.LIoOpReceive? || io2.LIoOpSend?
  }

  predicate LIoOpSeqCompatibleWithReduction<IdType, MessageType>(ios: seq<LIoOp<IdType, MessageType>>)
    decreases ios
  {
    forall i: int {:trigger ios[i], ios[i + 1]} :: 
      0 <= i < |ios| - 1 ==>
        LIoOpOrderingOKForAction(ios[i], ios[i + 1])
  }

  predicate IsValidLEnvStep<IdType, MessageType>(e: LEnvironment<IdType, MessageType>, step: LEnvStep<IdType, MessageType>)
    decreases e, step
  {
    match step
    case LEnvStepHostIos(actor, ios) =>
      (forall io: LIoOp<IdType, MessageType> {:trigger IsValidLIoOp(io, actor, e)} {:trigger io in ios} :: 
        io in ios ==>
          IsValidLIoOp(io, actor, e)) &&
      LIoOpSeqCompatibleWithReduction(ios)
    case LEnvStepDeliverPacket(p) =>
      p in e.sentPackets
    case LEnvStepAdvanceTime() =>
      true
    case LEnvStepStutter() =>
      true
  }

  predicate LEnvironment_Init<IdType, MessageType>(e: LEnvironment<IdType, MessageType>)
    decreases e
  {
    |e.sentPackets| == 0 &&
    e.time >= 0
  }

  predicate LEnvironment_PerformIos<IdType, MessageType>(e: LEnvironment<IdType, MessageType>, e': LEnvironment<IdType, MessageType>, actor: IdType, ios: seq<LIoOp<IdType, MessageType>>)
    decreases e, e', ios
  {
    e'.sentPackets == e.sentPackets + (set io: LIoOp<IdType, MessageType> {:trigger io.s} {:trigger io.LIoOpSend?} {:trigger io in ios} | io in ios && io.LIoOpSend? :: io.s) &&
    (forall io: LIoOp<IdType, MessageType> {:trigger io.r} {:trigger io.LIoOpReceive?} {:trigger io in ios} :: 
      io in ios &&
      io.LIoOpReceive? ==>
        io.r in e.sentPackets) &&
    e'.time == e.time
  }

  predicate LEnvironment_AdvanceTime<IdType, MessageType>(e: LEnvironment<IdType, MessageType>, e': LEnvironment<IdType, MessageType>)
    decreases e, e'
  {
    e'.time > e.time &&
    e'.sentPackets == e.sentPackets
  }

  predicate LEnvironment_Stutter<IdType, MessageType>(e: LEnvironment<IdType, MessageType>, e': LEnvironment<IdType, MessageType>)
    decreases e, e'
  {
    e'.time == e.time &&
    e'.sentPackets == e.sentPackets
  }

  predicate LEnvironment_Next<IdType, MessageType>(e: LEnvironment<IdType, MessageType>, e': LEnvironment<IdType, MessageType>)
    decreases e, e'
  {
    IsValidLEnvStep(e, e.nextStep) &&
    match e.nextStep case LEnvStepHostIos(actor, ios) => LEnvironment_PerformIos(e, e', actor, ios) case LEnvStepDeliverPacket(p) => LEnvironment_Stutter(e, e') case LEnvStepAdvanceTime => LEnvironment_AdvanceTime(e, e') case LEnvStepStutter => LEnvironment_Stutter(e, e')
  }

  function {:opaque} {:fuel 0, 0} EnvironmentNextTemporal<IdType, MessageType>(b: Behavior<LEnvironment<IdType, MessageType>>): temporal
    requires imaptotal(b)
    ensures forall i: int {:trigger sat(i, EnvironmentNextTemporal(b))} :: sat(i, EnvironmentNextTemporal(b)) <==> LEnvironment_Next(b[i], b[nextstep(i)])
  {
    stepmap(imap i: int {:trigger nextstep(i)} | true :: LEnvironment_Next(b[i], b[nextstep(i)]))
  }

  predicate LEnvironment_BehaviorSatisfiesSpec<IdType, MessageType>(b: Behavior<LEnvironment<IdType, MessageType>>)
  {
    imaptotal(b) &&
    LEnvironment_Init(b[0]) &&
    sat(0, always(EnvironmentNextTemporal(b)))
  }
}

module Collections__Maps2_s {
  function method mapdomain<KT, VT>(m: map<KT, VT>): set<KT>
    decreases m
  {
    set k: KT {:trigger k in m} | k in m :: k
  }

  function method mapremove<KT, VT>(m: map<KT, VT>, k: KT): map<KT, VT>
    decreases m
  {
    map ki: KT {:trigger m[ki]} {:trigger ki in m} | ki in m && ki != k :: m[ki]
  }

  predicate imaptotal<KT(!new), VT>(m: imap<KT, VT>)
  {
    forall k: KT {:trigger m[k]} {:trigger k in m} :: 
      k in m
  }
}

module Temporal__Temporal_s {

  import opened Collections__Maps2_s
  type temporal = imap<int, bool>

  type Behavior<S> = imap<int, S>

  function stepmap(f: imap<int, bool>): temporal
    ensures forall i: int {:trigger f[i]} {:trigger sat(i, stepmap(f))} {:trigger i in f} :: i in f ==> sat(i, stepmap(f)) == f[i]
  {
    f
  }

  predicate sat(s: int, t: temporal)
    decreases s
  {
    s in t &&
    t[s]
  }

  function {:opaque} {:fuel 0, 0} and(x: temporal, y: temporal): temporal
    ensures forall i: int {:trigger sat(i, and(x, y))} :: sat(i, and(x, y)) == (sat(i, x) && sat(i, y))
  {
    stepmap(imap i: int {:trigger sat(i, y)} {:trigger sat(i, x)} | true :: sat(i, x) && sat(i, y))
  }

  function {:opaque} {:fuel 0, 0} or(x: temporal, y: temporal): temporal
    ensures forall i: int {:trigger sat(i, or(x, y))} :: sat(i, or(x, y)) == (sat(i, x) || sat(i, y))
  {
    stepmap(imap i: int {:trigger sat(i, y)} {:trigger sat(i, x)} | true :: sat(i, x) || sat(i, y))
  }

  function {:opaque} {:fuel 0, 0} imply(x: temporal, y: temporal): temporal
    ensures forall i: int {:trigger sat(i, imply(x, y))} :: sat(i, imply(x, y)) == (sat(i, x) ==> sat(i, y))
  {
    stepmap(imap i: int {:trigger sat(i, y)} {:trigger sat(i, x)} | true :: sat(i, x) ==> sat(i, y))
  }

  function {:opaque} {:fuel 0, 0} equiv(x: temporal, y: temporal): temporal
    ensures forall i: int {:trigger sat(i, equiv(x, y))} :: sat(i, equiv(x, y)) == (sat(i, x) <==> sat(i, y))
  {
    stepmap(imap i: int {:trigger sat(i, y)} {:trigger sat(i, x)} | true :: sat(i, x) <==> sat(i, y))
  }

  function {:opaque} {:fuel 0, 0} not(x: temporal): temporal
    ensures forall i: int {:trigger sat(i, not(x))} :: sat(i, not(x)) == !sat(i, x)
  {
    stepmap(imap i: int {:trigger sat(i, x)} | true :: !sat(i, x))
  }

  function nextstep(i: int): int
    decreases i
  {
    i + 1
  }

  function {:opaque} {:fuel 0, 0} next(x: temporal): temporal
    ensures forall i: int {:trigger sat(i, next(x))} :: sat(i, next(x)) == sat(nextstep(i), x)
  {
    stepmap(imap i: int {:trigger nextstep(i)} | true :: sat(nextstep(i), x))
  }

  function {:opaque} {:fuel 0, 0} always(x: temporal): temporal
  {
    stepmap(imap i: int {:trigger sat(i, always(x))} | true :: forall j: int {:trigger sat(j, x)} :: i <= j ==> sat(j, x))
  }

  function {:opaque} {:fuel 0, 0} eventual(x: temporal): temporal
  {
    stepmap(imap i: int {:trigger sat(i, eventual(x))} | true :: exists j: int {:trigger sat(j, x)} :: i <= j && sat(j, x))
  }
}

abstract module DistributedSystem_s {

  import H_s : Host_s

  import opened Collections__Maps2_s

  import opened Native__Io_s

  import opened Environment_s

  import opened Native__NativeTypes_s
  datatype DS_State = DS_State(config: H_s.ConcreteConfiguration, environment: LEnvironment<EndPoint, seq<byte>>, servers: map<EndPoint, H_s.HostState>, clients: set<EndPoint>)

  predicate ValidPhysicalAddress(endPoint: EndPoint)
    decreases endPoint
  {
    |endPoint.addr| == 4 &&
    0 <= endPoint.port <= 65535
  }

  predicate ValidPhysicalPacket(p: LPacket<EndPoint, seq<byte>>)
    decreases p
  {
    ValidPhysicalAddress(p.src) &&
    ValidPhysicalAddress(p.dst) &&
    |p.msg| < 18446744073709551616
  }

  predicate ValidPhysicalIo(io: LIoOp<EndPoint, seq<byte>>)
    decreases io
  {
    (io.LIoOpReceive? ==>
      ValidPhysicalPacket(io.r)) &&
    (io.LIoOpSend? ==>
      ValidPhysicalPacket(io.s))
  }

  predicate ValidPhysicalEnvironmentStep(step: LEnvStep<EndPoint, seq<byte>>)
    decreases step
  {
    step.LEnvStepHostIos? ==>
      forall io: LIoOp<EndPoint, seq<byte>> {:trigger io in step.ios} {:trigger ValidPhysicalIo(io)} :: 
        io in step.ios ==>
          ValidPhysicalIo(io)
  }

  predicate DS_Init(s: DS_State, config: H_s.ConcreteConfiguration)
    reads *
    decreases {}, s
  {
    s.config == config &&
    H_s.ConcreteConfigInit(s.config, mapdomain(s.servers), s.clients) &&
    LEnvironment_Init(s.environment) &&
    forall id: EndPoint {:trigger s.servers[id]} {:trigger id in s.servers} :: 
      id in s.servers ==>
        _default.HostInit(s.servers[id], config, id)
  }

  predicate DS_NextOneServer(s: DS_State, s': DS_State, id: EndPoint, ios: seq<LIoOp<EndPoint, seq<byte>>>)
    requires id in s.servers
    reads *
    decreases {}, s, s', id, ios
  {
    id in s'.servers &&
    H_s.HostNext(s.servers[id], s'.servers[id], ios) &&
    s'.servers == s.servers[id := s'.servers[id]]
  }

  predicate DS_Next(s: DS_State, s': DS_State)
    reads *
    decreases {}, s, s'
  {
    s'.config == s.config &&
    s'.clients == s.clients &&
    LEnvironment_Next(s.environment, s'.environment) &&
    ValidPhysicalEnvironmentStep(s.environment.nextStep) &&
    if s.environment.nextStep.LEnvStepHostIos? && s.environment.nextStep.actor in s.servers then DS_NextOneServer(s, s', s.environment.nextStep.actor, s.environment.nextStep.ios) else s'.servers == s.servers
  }
}

abstract module Host_s {

  import opened Native__Io_s

  import opened Environment_s

  import opened Native__NativeTypes_s
  type HostState

  type ConcreteConfiguration

  predicate HostInit(host_state: HostState, config: ConcreteConfiguration, id: EndPoint)
    reads *
    decreases {}, id

  predicate HostNext(host_state: HostState, host_state': HostState, ios: seq<LIoOp<EndPoint, seq<byte>>>)
    reads *
    decreases {}, ios

  predicate ConcreteConfigInit(config: ConcreteConfiguration, servers: set<EndPoint>, clients: set<EndPoint>)
    decreases servers, clients

  predicate HostStateInvariants(host_state: HostState, env: HostEnvironment)
    reads *
    decreases {}, env

  predicate ConcreteConfigurationInvariants(config: ConcreteConfiguration)

  function ParseCommandLineConfiguration(args: seq<seq<uint16>>): (ConcreteConfiguration, set<EndPoint>, set<EndPoint>)
    decreases args

  function ParseCommandLineId(ip: seq<uint16>, port: seq<uint16>): EndPoint
    decreases ip, port

  predicate ArbitraryObject(o: object)
    decreases o
  {
    true
  }

  method HostInitImpl(ghost env: HostEnvironment)
      returns (ok: bool, host_state: HostState, config: ConcreteConfiguration, ghost servers: set<EndPoint>, ghost clients: set<EndPoint>, id: EndPoint)
    requires env.Valid()
    requires env.ok.ok()
    requires |env.constants.CommandLineArgs()| >= 2
    modifies set x: object {:trigger ArbitraryObject(x)} | ArbitraryObject(x)
    ensures ok ==> env.Valid() && env.ok.ok()
    ensures ok ==> |env.constants.CommandLineArgs()| >= 2
    ensures ok ==> HostStateInvariants(host_state, env)
    ensures ok ==> ConcreteConfigurationInvariants(config)
    ensures ok ==> var args: seq<seq<uint16>> := env.constants.CommandLineArgs(); var (parsed_config: ConcreteConfiguration, parsed_servers: set<EndPoint>, parsed_clients: set<EndPoint>) := ParseCommandLineConfiguration(args[0 .. |args| - 2]); config == parsed_config && servers == parsed_servers && clients == parsed_clients && ConcreteConfigInit(parsed_config, parsed_servers, parsed_clients)
    ensures ok ==> var args: seq<seq<uint16>> := env.constants.CommandLineArgs(); id == ParseCommandLineId(args[|args| - 2], args[|args| - 1]) && HostInit(host_state, config, id)
    decreases env

  method HostNextImpl(ghost env: HostEnvironment, host_state: HostState)
      returns (ok: bool, host_state': HostState, ghost recvs: seq<UdpEvent>, ghost clocks: seq<UdpEvent>, ghost sends: seq<UdpEvent>, ghost ios: seq<LIoOp<EndPoint, seq<byte>>>)
    requires env.Valid() && env.ok.ok()
    requires HostStateInvariants(host_state, env)
    modifies set x: object {:trigger ArbitraryObject(x)} | ArbitraryObject(x)
    ensures ok <==> env.Valid() && env.ok.ok()
    ensures ok ==> HostStateInvariants(host_state', env)
    ensures ok ==> HostNext(host_state, host_state', ios)
    ensures ok ==> recvs + clocks + sends == ios
    ensures ok ==> env.udp.history() == old(env.udp.history()) + (recvs + clocks + sends)
    ensures forall e: LIoOp<EndPoint, seq<byte>> {:trigger e.LIoOpSend?} {:trigger e in sends} {:trigger e.LIoOpTimeoutReceive?} {:trigger e.LIoOpReadClock?} {:trigger e in clocks} {:trigger e.LIoOpReceive?} {:trigger e in recvs} :: (e in recvs ==> e.LIoOpReceive?) && (e in clocks ==> e.LIoOpReadClock? || e.LIoOpTimeoutReceive?) && (e in sends ==> e.LIoOpSend?)
    ensures |clocks| <= 1
    decreases env
}

abstract module AbstractService_s {

  import opened Native__Io_s

  import opened Environment_s

  import opened Native__NativeTypes_s
  type ServiceState

  predicate Service_Init(s: ServiceState, serverAddresses: set<EndPoint>)
    decreases serverAddresses

  predicate Service_Next(s: ServiceState, s': ServiceState)

  predicate Service_Correspondence(concretePkts: set<LPacket<EndPoint, seq<byte>>>, serviceState: ServiceState)
    decreases concretePkts
}

module Collections__Seqs_s {
  function last<T>(s: seq<T>): T
    requires |s| > 0
    decreases s
  {
    s[|s| - 1]
  }

  function all_but_last<T>(s: seq<T>): seq<T>
    requires |s| > 0
    ensures |all_but_last(s)| == |s| - 1
    decreases s
  {
    s[..|s| - 1]
  }
}

module Host_i refines Host_s {

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__ConstantsState_i

  import opened LiveByzRSL__CConfiguration_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__ParametersState_i

  import opened LiveByzRSL__QRelations_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__ReplicaImplClass_i

  import opened LiveByzRSL__ReplicaImplMain_i

  import opened LiveByzRSL__UdpRSL_i

  import opened LiveByzRSL__Unsendable_i

  import opened CmdLineParser_i

  import opened LiveByzRSL__CmdLineParser_i

  import opened Collections__Sets_i

  import opened Common__NodeIdentity_i

  import opened Common__SeqIsUnique_i

  import opened Common__SeqIsUniqueDef_i
  datatype CScheduler = CScheduler(ghost sched: LScheduler, replica_impl: ReplicaImpl)

  type HostState = CScheduler

  type ConcreteConfiguration = CConstants

  predicate ConcreteConfigurationInvariants(config: ConcreteConfiguration)
    decreases config
  {
    CConstantsIsValid(config)
  }

  predicate ConcreteConfigInit(config: ConcreteConfiguration, servers: set<EndPoint>, clients: set<EndPoint>)
    decreases config, servers, clients
  {
    CConstantsIsValid(config) &&
    MapSeqToSet(config.config.replica_ids, (x: EndPoint) => x) == servers &&
    (forall e: EndPoint {:trigger EndPointIsAbstractable(e)} {:trigger e in servers} :: 
      e in servers ==>
        EndPointIsAbstractable(e)) &&
    forall e: EndPoint {:trigger EndPointIsAbstractable(e)} {:trigger e in clients} :: 
      e in clients ==>
        EndPointIsAbstractable(e)
  }

  function ConcreteConfigToServers(config: ConcreteConfiguration): set<EndPoint>
    decreases config
  {
    MapSeqToSet(config.config.replica_ids, (x: EndPoint) => x)
  }

  predicate HostStateInvariants(host_state: HostState, env: HostEnvironment)
    reads *
    decreases {}, host_state, env
  {
    host_state.replica_impl.Valid() &&
    host_state.replica_impl.Env() == env &&
    host_state.sched == host_state.replica_impl.AbstractifyToLScheduler()
  }

  predicate HostInit(host_state: HostState, config: ConcreteConfiguration, id: EndPoint)
    reads *
    decreases {}, host_state, config, id
  {
    host_state.replica_impl.Valid() &&
    host_state.replica_impl.replica.constants.all == config &&
    config.config.replica_ids[host_state.replica_impl.replica.constants.my_index] == id &&
    LSchedulerInit(host_state.sched, AbstractifyCReplicaConstantsToLReplicaConstants(host_state.replica_impl.replica.constants))
  }

  predicate HostNext(host_state: HostState, host_state': HostState, ios: seq<LIoOp<EndPoint, seq<byte>>>)
    reads *
    decreases {}, host_state, host_state', ios
  {
    UdpEventLogIsAbstractable(ios) &&
    OnlySentMarshallableData(ios) &&
    (LSchedulerNext(host_state.sched, host_state'.sched, AbstractifyRawLogToIos(ios)) || HostNextIgnoreUnsendable(host_state.sched, host_state'.sched, ios))
  }

  function ParseCommandLineConfiguration(args: seq<seq<uint16>>): (ConcreteConfiguration, set<EndPoint>, set<EndPoint>)
    decreases args
  {
    ghost var paxos_config: CConfiguration := paxos_config_parsing(args);
    ghost var params: CParameters := StaticParams();
    ghost var endpoints_set: set<EndPoint> := set e: EndPoint {:trigger e in paxos_config.replica_ids} | e in paxos_config.replica_ids;
    (CConstants(paxos_config, params), endpoints_set, {})
  }

  method {:timeLimitMultiplier 4} /*{:_timeLimit 40}*/ HostInitImpl(ghost env: HostEnvironment)
      returns (ok: bool, host_state: HostState, config: ConcreteConfiguration, ghost servers: set<EndPoint>, ghost clients: set<EndPoint>, id: EndPoint)
    requires env.Valid()
    requires env.ok.ok()
    requires |env.constants.CommandLineArgs()| >= 2
    modifies set x: object {:trigger ArbitraryObject(x)} | ArbitraryObject(x)
    ensures ok ==> env.Valid() && env.ok.ok()
    ensures ok ==> |env.constants.CommandLineArgs()| >= 2
    ensures ok ==> HostStateInvariants(host_state, env)
    ensures ok ==> ConcreteConfigurationInvariants(config)
    ensures ok ==> var args: seq<seq<uint16>> := env.constants.CommandLineArgs(); var (parsed_config: ConcreteConfiguration, parsed_servers: set<EndPoint>, parsed_clients: set<EndPoint>) := ParseCommandLineConfiguration(args[0 .. |args| - 2]); config == parsed_config && servers == parsed_servers && clients == parsed_clients && ConcreteConfigInit(parsed_config, parsed_servers, parsed_clients)
    ensures ok ==> var args: seq<seq<uint16>> := env.constants.CommandLineArgs(); id == ParseCommandLineId(args[|args| - 2], args[|args| - 1]) && HostInit(host_state, config, id)
    decreases env
  {
    var pconfig: CConfiguration, my_index;
    ok, pconfig, my_index := parse_cmd_line(env);
    var lschedule: LScheduler;
    var repImpl: ReplicaImpl := new ReplicaImpl();
    host_state := CScheduler(lschedule, repImpl);
    if !ok {
      return;
    }
    assert env.constants == old(env.constants);
    id := pconfig.replica_ids[my_index];
    var scheduler := new ReplicaImpl();
    var constants := InitReplicaConstantsState(id, pconfig);
    assert constants.all.config == pconfig;
    assert constants.all.config.replica_ids[constants.my_index] == id;
    calc {
      constants.my_index as int;
      {
        reveal SeqIsUnique();
      }
      my_index as int;
    }
    assert env.Valid() && env.ok.ok();
    assert CReplicaConstantsIsValid(constants);
    assert WellFormedLConfiguration(AbstractifyCReplicaConstantsToLReplicaConstants(constants).all.config);
    ok := scheduler.Replica_Init(constants, env);
    if !ok {
      return;
    }
    host_state := CScheduler(scheduler.AbstractifyToLScheduler(), scheduler);
    config := constants.all;
    servers := set e: EndPoint {:trigger e in constants.all.config.replica_ids} | e in constants.all.config.replica_ids;
    clients := {};
    assert env.constants == old(env.constants);
    ghost var args := env.constants.CommandLineArgs();
    ghost var tuple := ParseCommandLineConfiguration(args[0 .. |args| - 2]);
    ghost var parsed_config, parsed_servers, parsed_clients := tuple.0, tuple.1, tuple.2;
    assert config.config == parsed_config.config;
    assert config.params == parsed_config.params;
    assert config == parsed_config;
    assert servers == parsed_servers;
    assert clients == parsed_clients;
    assert ConcreteConfigInit(parsed_config, parsed_servers, parsed_clients);
  }

  function ParseCommandLineId(ip: seq<uint16>, port: seq<uint16>): EndPoint
    decreases ip, port
  {
    paxos_parse_id(ip, port)
  }

  predicate EventsConsistent(recvs: seq<UdpEvent>, clocks: seq<UdpEvent>, sends: seq<UdpEvent>)
    decreases recvs, clocks, sends
  {
    forall e: LIoOp<EndPoint, seq<byte>> {:trigger e.LIoOpSend?} {:trigger e in sends} {:trigger e.LIoOpTimeoutReceive?} {:trigger e.LIoOpReadClock?} {:trigger e in clocks} {:trigger e.LIoOpReceive?} {:trigger e in recvs} :: 
      (e in recvs ==>
        e.LIoOpReceive?) &&
      (e in clocks ==>
        e.LIoOpReadClock? || e.LIoOpTimeoutReceive?) &&
      (e in sends ==>
        e.LIoOpSend?)
  }

  ghost method RemoveRecvs(events: seq<UdpEvent>) returns (recvs: seq<UdpEvent>, rest: seq<UdpEvent>)
    ensures forall e: LIoOp<EndPoint, seq<byte>> {:trigger e.LIoOpReceive?} {:trigger e in recvs} :: e in recvs ==> e.LIoOpReceive?
    ensures events == recvs + rest
    ensures rest != [] ==> !rest[0].LIoOpReceive?
    ensures NetEventsReductionCompatible(events) ==> NetEventsReductionCompatible(rest)
    decreases events
  {
    recvs := [];
    rest := [];
    ghost var i := 0;
    while i < |events|
      invariant 0 <= i <= |events|
      invariant forall e: LIoOp<EndPoint, seq<byte>> {:trigger e.LIoOpReceive?} {:trigger e in recvs} :: e in recvs ==> e.LIoOpReceive?
      invariant recvs == events[0 .. i]
      decreases |events| - i
    {
      if !events[i].LIoOpReceive? {
        rest := events[i..];
        return;
      }
      recvs := recvs + [events[i]];
      i := i + 1;
    }
  }

  predicate NetEventsReductionCompatible(events: seq<UdpEvent>)
    decreases events
  {
    forall i: int, _t#0: int {:trigger events[_t#0], events[i]} | _t#0 == i + 1 :: 
      0 <= i &&
      i < |events| - 1 ==>
        events[i].LIoOpReceive? || events[_t#0].LIoOpSend?
  }

  lemma lemma_RemainingEventsAreSends(events: seq<UdpEvent>)
    requires NetEventsReductionCompatible(events)
    requires |events| > 0
    requires !events[0].LIoOpReceive?
    ensures forall e: LIoOp<EndPoint, seq<byte>> {:trigger e.LIoOpSend?} {:trigger e in events[1..]} :: e in events[1..] ==> e.LIoOpSend?
    decreases events
  {
  }

  ghost method PartitionEvents(events: seq<UdpEvent>)
      returns (recvs: seq<UdpEvent>, clocks: seq<UdpEvent>, sends: seq<UdpEvent>)
    requires NetEventsReductionCompatible(events)
    ensures events == recvs + clocks + sends
    ensures EventsConsistent(recvs, clocks, sends)
    ensures |clocks| <= 1
    decreases events
  {
    ghost var rest;
    recvs, rest := RemoveRecvs(events);
    assert NetEventsReductionCompatible(rest);
    if |rest| > 0 && (rest[0].LIoOpReadClock? || rest[0].LIoOpTimeoutReceive?) {
      clocks := [rest[0]];
      sends := rest[1..];
      lemma_RemainingEventsAreSends(rest);
    } else {
      clocks := [];
      sends := rest;
      if |rest| > 0 {
        lemma_RemainingEventsAreSends(rest);
      }
    }
  }

  lemma lemma_ProtocolIosRespectReduction(s: LScheduler, s': LScheduler, ios: seq<RslIo>)
    requires Q_LScheduler_Next(s, s', ios)
    ensures LIoOpSeqCompatibleWithReduction(ios)
    decreases s, s', ios
  {
  }

  lemma lemma_NetEventsRespectReduction(s: LScheduler, s': LScheduler, ios: seq<RslIo>, events: seq<UdpEvent>)
    requires LIoOpSeqCompatibleWithReduction(ios)
    requires RawIoConsistentWithSpecIO(events, ios)
    ensures NetEventsReductionCompatible(events)
    decreases s, s', ios, events
  {
  }

  method {:timeLimitMultiplier 3} /*{:_timeLimit 30}*/ HostNextImpl(ghost env: HostEnvironment, host_state: HostState)
      returns (ok: bool, host_state': HostState, ghost recvs: seq<UdpEvent>, ghost clocks: seq<UdpEvent>, ghost sends: seq<UdpEvent>, ghost ios: seq<LIoOp<EndPoint, seq<byte>>>)
    requires env.Valid() && env.ok.ok()
    requires HostStateInvariants(host_state, env)
    modifies set x: object {:trigger ArbitraryObject(x)} | ArbitraryObject(x)
    ensures ok <==> env.Valid() && env.ok.ok()
    ensures ok ==> HostStateInvariants(host_state', env)
    ensures ok ==> HostNext(host_state, host_state', ios)
    ensures ok ==> recvs + clocks + sends == ios
    ensures ok ==> env.udp.history() == old(env.udp.history()) + (recvs + clocks + sends)
    ensures forall e: LIoOp<EndPoint, seq<byte>> {:trigger e.LIoOpSend?} {:trigger e in sends} {:trigger e.LIoOpTimeoutReceive?} {:trigger e.LIoOpReadClock?} {:trigger e in clocks} {:trigger e.LIoOpReceive?} {:trigger e in recvs} :: (e in recvs ==> e.LIoOpReceive?) && (e in clocks ==> e.LIoOpReadClock? || e.LIoOpTimeoutReceive?) && (e in sends ==> e.LIoOpSend?)
    ensures |clocks| <= 1
    decreases env, host_state
  {
    var lschedule: LScheduler;
    var repImpl: ReplicaImpl := new ReplicaImpl();
    host_state' := CScheduler(lschedule, repImpl);
    var okay, netEventLog, abstract_ios := Replica_Next_main(host_state.replica_impl);
    if okay {
      calc {
        Q_LScheduler_Next(host_state.sched, host_state.replica_impl.AbstractifyToLScheduler(), abstract_ios);
        {
          reveal Q_LScheduler_Next();
        }
        LSchedulerNext(host_state.sched, host_state.replica_impl.AbstractifyToLScheduler(), abstract_ios);
      }
      assert AbstractifyRawLogToIos(netEventLog) == abstract_ios;
      if LSchedulerNext(host_state.sched, host_state.replica_impl.AbstractifyToLScheduler(), abstract_ios) {
        lemma_ProtocolIosRespectReduction(host_state.sched, host_state.replica_impl.AbstractifyToLScheduler(), abstract_ios);
      }
      lemma_NetEventsRespectReduction(host_state.sched, host_state.replica_impl.AbstractifyToLScheduler(), abstract_ios, netEventLog);
      recvs, clocks, sends := PartitionEvents(netEventLog);
      ios := recvs + clocks + sends;
      assert ios == netEventLog;
      host_state' := CScheduler(host_state.replica_impl.AbstractifyToLScheduler(), host_state.replica_impl);
    } else {
      recvs := [];
      clocks := [];
      sends := [];
    }
    ok := okay;
    reveal Q_LScheduler_Next();
    assert host_state.replica_impl.Env() == env;
  }

  predicate ArbitraryObject(o: object)
    decreases o
  {
    true
  }

  import opened Native__Io_s

  import opened Environment_s

  import opened Native__NativeTypes_s
}

module LiveByzRSL__ReplicaImplMain_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened Collections__Seqs_i

  import opened Math__mod_auto_i

  import opened LiveByzRSL__CClockReading_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__QRelations_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__ReplicaImplClass_i

  import opened LiveByzRSL__ReplicaImplLemmas_i

  import opened LiveByzRSL__ReplicaImplNoReceiveClock_i

  import opened LiveByzRSL__ReplicaImplNoReceiveNoClock_i

  import opened LiveByzRSL__ReplicaImplProcessPacketX_i

  import opened LiveByzRSL__ReplicaModel_i

  import opened LiveByzRSL__UdpRSL_i

  import opened LiveByzRSL__Unsendable_i

  import opened Common__UdpClient_i
  method rollActionIndex(a: uint64) returns (a': uint64)
    requires 0 <= a as int < 12
    ensures a' as int == (a as int + 1) % LReplicaNumActions()
    decreases a
  {
    lemma_mod_auto(12);
    if a >= 11 {
      a' := 0;
    } else {
      a' := a + 1;
    }
  }

  method {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ ReplicaNextMainProcessPacketX(r: ReplicaImpl)
      returns (ok: bool, ghost netEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires r.nextActionIndex == 0
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures r.Env().Valid() && r.Env().ok.ok() ==> ok
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && (Q_LScheduler_Next(old(r.AbstractifyToLScheduler()), r.AbstractifyToLScheduler(), ios) || HostNextIgnoreUnsendable(old(r.AbstractifyToLScheduler()), r.AbstractifyToLScheduler(), netEventLog)) && RawIoConsistentWithSpecIO(netEventLog, ios) && OnlySentMarshallableData(netEventLog) && old(r.Env().udp.history()) + netEventLog == r.Env().udp.history()
    decreases r
  {
    ghost var replica_old := old(r.AbstractifyToLReplica());
    ghost var scheduler_old := old(r.AbstractifyToLScheduler());
    assert scheduler_old.nextActionIndex == 0;
    assert scheduler_old.replica == replica_old;
    ok, netEventLog, ios := Replica_Next_ProcessPacketX(r);
    if !ok {
      return;
    }
    assert r.Valid();
    ghost var net_client_old := r.netClient;
    ghost var net_addr_old := r.netClient.LocalEndPoint();
    assert UdpClientIsValid(net_client_old);
    ghost var replica := r.AbstractifyToLReplica();
    r.nextActionIndex := 1;
    ghost var scheduler := r.AbstractifyToLScheduler();
    assert net_client_old == r.netClient;
    assert UdpClientIsValid(r.netClient);
    assert net_addr_old == r.netClient.LocalEndPoint();
    assert r.Valid();
    calc {
      scheduler.nextActionIndex;
      r.nextActionIndex as int;
      1;
      {
        lemma_mod_auto(LReplicaNumActions());
      }
      1 % LReplicaNumActions();
      (scheduler_old.nextActionIndex + 1) % LReplicaNumActions();
    }
    if Q_LReplica_Next_ProcessPacket(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios) {
      lemma_EstablishQLSchedulerNext(replica_old, replica, ios, scheduler_old, scheduler);
      assert Q_LScheduler_Next(old(r.AbstractifyToLScheduler()), r.AbstractifyToLScheduler(), ios);
    } else {
      assert IosReflectIgnoringUnsendable(netEventLog);
      assert old(r.AbstractifyToLReplica()) == r.AbstractifyToLReplica();
      assert HostNextIgnoreUnsendable(old(r.AbstractifyToLScheduler()), r.AbstractifyToLScheduler(), netEventLog);
    }
  }

  method ReplicaNextMainNoClock(r: ReplicaImpl)
      returns (ok: bool, ghost netEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires r.nextActionIndex == 1 || r.nextActionIndex == 2 || r.nextActionIndex == 4 || r.nextActionIndex == 5 || r.nextActionIndex == 6 || r.nextActionIndex == 7 || r.nextActionIndex == 8
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures r.Env().Valid() && r.Env().ok.ok() ==> ok
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && Q_LScheduler_Next(old(r.AbstractifyToLScheduler()), r.AbstractifyToLScheduler(), ios) && RawIoConsistentWithSpecIO(netEventLog, ios) && OnlySentMarshallableData(netEventLog) && old(r.Env().udp.history()) + netEventLog == r.Env().udp.history()
    decreases r
  {
    var curActionIndex := r.nextActionIndex;
    ghost var replica_old := old(r.AbstractifyToLReplica());
    ghost var scheduler_old := old(r.AbstractifyToLScheduler());
    assert scheduler_old.replica == replica_old;
    ok, netEventLog, ios := Replica_NoReceive_NoClock_Next(r);
    if !ok {
      return;
    }
    assert r.Valid();
    ghost var net_client_old := r.netClient;
    ghost var net_addr_old := r.netClient.LocalEndPoint();
    assert UdpClientIsValid(net_client_old);
    ghost var replica := r.AbstractifyToLReplica();
    var nextActionIndex' := r.nextActionIndex + 1;
    r.nextActionIndex := nextActionIndex';
    ghost var scheduler := r.AbstractifyToLScheduler();
    assert net_client_old == r.netClient;
    assert UdpClientIsValid(r.netClient);
    assert net_addr_old == r.netClient.LocalEndPoint();
    assert r.Valid();
    calc {
      scheduler.nextActionIndex;
      r.nextActionIndex as int;
      nextActionIndex' as int;
      {
        lemma_mod_auto(LReplicaNumActions());
      }
      (curActionIndex + 1) as int % LReplicaNumActions();
      (scheduler_old.nextActionIndex + 1) % LReplicaNumActions();
    }
    lemma_EstablishQLSchedulerNext(replica_old, replica, ios, scheduler_old, scheduler);
    assert Q_LScheduler_Next(old(r.AbstractifyToLScheduler()), r.AbstractifyToLScheduler(), ios);
  }

  method ReplicaNextMainReadClock(r: ReplicaImpl)
      returns (ok: bool, ghost netEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires r.nextActionIndex == 3 || r.nextActionIndex == 9 || r.nextActionIndex == 10 || r.nextActionIndex == 11
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures r.Env().Valid() && r.Env().ok.ok() ==> ok
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && Q_LScheduler_Next(old(r.AbstractifyToLScheduler()), r.AbstractifyToLScheduler(), ios) && RawIoConsistentWithSpecIO(netEventLog, ios) && OnlySentMarshallableData(netEventLog) && old(r.Env().udp.history()) + netEventLog == r.Env().udp.history()
    decreases r
  {
    var curActionIndex := r.nextActionIndex;
    ghost var replica_old := old(r.AbstractifyToLReplica());
    ghost var scheduler_old := old(r.AbstractifyToLScheduler());
    assert scheduler_old.replica == replica_old;
    ok, netEventLog, ios := Replica_NoReceive_ReadClock_Next(r);
    if !ok {
      return;
    }
    assert r.Valid();
    ghost var net_client_old := r.netClient;
    ghost var net_addr_old := r.netClient.LocalEndPoint();
    assert UdpClientIsValid(net_client_old);
    ghost var replica := r.AbstractifyToLReplica();
    var nextActionIndex' := rollActionIndex(r.nextActionIndex);
    r.nextActionIndex := nextActionIndex';
    ghost var scheduler := r.AbstractifyToLScheduler();
    assert net_client_old == r.netClient;
    assert UdpClientIsValid(r.netClient);
    assert net_addr_old == r.netClient.LocalEndPoint();
    assert r.Valid();
    calc {
      scheduler.nextActionIndex;
      r.nextActionIndex as int;
      nextActionIndex' as int;
      (curActionIndex + 1) as int % LReplicaNumActions();
      (scheduler_old.nextActionIndex + 1) % LReplicaNumActions();
    }
    lemma_EstablishQLSchedulerNext(replica_old, replica, ios, scheduler_old, scheduler);
    assert Q_LScheduler_Next(old(r.AbstractifyToLScheduler()), r.AbstractifyToLScheduler(), ios);
  }

  method Replica_Next_main(r: ReplicaImpl)
      returns (ok: bool, ghost netEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures r.Env().Valid() && r.Env().ok.ok() ==> ok
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && (Q_LScheduler_Next(old(r.AbstractifyToLScheduler()), r.AbstractifyToLScheduler(), ios) || HostNextIgnoreUnsendable(old(r.AbstractifyToLScheduler()), r.AbstractifyToLScheduler(), netEventLog)) && RawIoConsistentWithSpecIO(netEventLog, ios) && OnlySentMarshallableData(netEventLog) && old(r.Env().udp.history()) + netEventLog == r.Env().udp.history()
    decreases r
  {
    if r.nextActionIndex == 0 {
      ok, netEventLog, ios := ReplicaNextMainProcessPacketX(r);
    } else if r.nextActionIndex == 1 || r.nextActionIndex == 2 || r.nextActionIndex == 4 || r.nextActionIndex == 5 || r.nextActionIndex == 6 || r.nextActionIndex == 7 || r.nextActionIndex == 8 {
      ok, netEventLog, ios := ReplicaNextMainNoClock(r);
    } else if r.nextActionIndex == 3 || 9 <= r.nextActionIndex <= 11 {
      ok, netEventLog, ios := ReplicaNextMainReadClock(r);
    }
  }
}

module Collections__Seqs_i {

  import opened Collections__Seqs_s

  import opened Collections__Multisets_s
  lemma SeqAdditionIsAssociative<T>(a: seq<T>, b: seq<T>, c: seq<T>)
    ensures a + (b + c) == a + b + c
    decreases a, b, c
  {
  }

  predicate ItemAtPositionInSeq<T>(s: seq<T>, v: T, idx: int)
    decreases s, idx
  {
    0 <= idx < |s| &&
    s[idx] == v
  }

  predicate method CItemAtPositionInSeq<T(==)>(s: seq<T>, v: T, idx: int)
    decreases s, idx
  {
    0 <= idx < |s| &&
    s[idx] == v
  }

  lemma Lemma_ItemInSeqAtASomePosition<T>(s: seq<T>, v: T)
    requires v in s
    ensures exists idx: int {:trigger ItemAtPositionInSeq(s, v, idx)} :: ItemAtPositionInSeq(s, v, idx)
    decreases s
  {
  }

  function method FindIndexInSeq<T(==)>(s: seq<T>, v: T): int
    ensures var r: int := FindIndexInSeq(s, v); if r >= 0 then r < |s| && s[r] == v else v !in s
    decreases s
  {
    if |s| == 0 then
      -1
    else if s[0] == v then
      0
    else
      var r: int := FindIndexInSeq(s[1..], v); if r == -1 then -1 else r + 1
  }

  lemma Lemma_IdenticalSingletonSequencesHaveIdenticalElement<T>(x: T, y: T)
    requires [x] == [y]
    ensures x == y
  {
  }

  function SeqCat<T>(seqs: seq<seq<T>>): seq<T>
    decreases seqs
  {
    if |seqs| == 0 then
      []
    else
      seqs[0] + SeqCat(seqs[1..])
  }

  function SeqCatRev<T>(seqs: seq<seq<T>>): seq<T>
    decreases seqs
  {
    if |seqs| == 0 then
      []
    else
      SeqCatRev(all_but_last(seqs)) + last(seqs)
  }

  lemma /*{:_induction A, B}*/ lemma_SeqCat_adds<T>(A: seq<seq<T>>, B: seq<seq<T>>)
    ensures SeqCat(A + B) == SeqCat(A) + SeqCat(B)
    decreases A, B
  {
  }

  lemma /*{:_induction A, B}*/ lemma_SeqCatRev_adds<T>(A: seq<seq<T>>, B: seq<seq<T>>)
    ensures SeqCatRev(A + B) == SeqCatRev(A) + SeqCatRev(B)
    decreases A, B
  {
  }

  lemma /*{:_induction seqs}*/ lemma_SeqCat_equivalent<T>(seqs: seq<seq<T>>)
    ensures SeqCat(seqs) == SeqCatRev(seqs)
    decreases seqs
  {
  }

  predicate Sorted_COperationNumber_seq(a: seq<int>, low: int, high: int)
    requires 0 <= low <= high <= |a|
    decreases a, low, high
  {
    forall i: int, j: int {:trigger a[j], a[i]} :: 
      low <= i < j < high ==>
        a[i] <= a[j]
  }

  predicate NeighborSorted_COperationNumber_seq(a: seq<int>, low: int, high: int)
    requires 0 <= low <= high <= |a|
    decreases a, low, high
  {
    forall i: int {:trigger a[i - 1], a[i]} :: 
      low < i < high ==>
        a[i - 1] <= a[i]
  }

  method InsertSort(a: seq<int>) returns (sorted: seq<int>)
    ensures forall i: int, j: int {:trigger sorted[j], sorted[i]} :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
    ensures Sorted_COperationNumber_seq(sorted, 0, |sorted|)
    ensures |a| == |sorted|
    ensures multiset(a) == multiset(sorted)
    decreases a
  {
    if |a| <= 1 {
      sorted := a;
      assert |a| == |sorted|;
      assert multiset(a) == multiset(sorted);
    } else {
      var last := a[|a| - 1];
      var rest := a[..|a| - 1];
      assert rest + [last] == a;
      assert multiset(a) == multiset([last]) + multiset(rest);
      var sortedRest := InsertSort(rest);
      assert multiset(sortedRest) == multiset(rest);
      assert |sortedRest| == |rest|;
      sorted := Insert(sortedRest, last);
      assert multiset(sorted) == multiset(sortedRest) + multiset([last]);
    }
  }

  method Insert(sortedSeq: seq<int>, value: int) returns (newSeq: seq<int>)
    requires forall i: int, j: int {:trigger sortedSeq[j], sortedSeq[i]} :: 0 <= i < j < |sortedSeq| ==> sortedSeq[i] <= sortedSeq[j]
    ensures forall i: int, j: int {:trigger newSeq[j], newSeq[i]} :: 0 <= i < j < |newSeq| ==> newSeq[i] <= newSeq[j]
    ensures |newSeq| == |sortedSeq| + 1
    ensures multiset(newSeq) == multiset(sortedSeq) + multiset([value])
    ensures |newSeq| > 0
    decreases sortedSeq, value
  {
    if |sortedSeq| == 0 {
      newSeq := [value];
    } else {
      if value <= sortedSeq[0] {
        newSeq := [value] + sortedSeq;
      } else {
        var res := Insert(sortedSeq[1..], value);
        assert multiset(res) == multiset(sortedSeq[1..]) + multiset([value]);
        assert forall i: int, j: int {:trigger res[j], res[i]} :: 0 <= i < j < |res| ==> res[i] <= res[j];
        newSeq := [sortedSeq[0]] + res;
        assert multiset(newSeq) == multiset([sortedSeq[0]]) + multiset(res);
        assert multiset(newSeq) == multiset([sortedSeq[0]]) + multiset(sortedSeq[1..]) + multiset([value]);
        assert sortedSeq == [sortedSeq[0]] + sortedSeq[1..];
        assert multiset(sortedSeq) == multiset([sortedSeq[0]]) + multiset(sortedSeq[1..]);
        assert multiset(res) == multiset(sortedSeq[1..]) + multiset([value]);
        assert multiset(res) == multiset(sortedSeq[1..]) + multiset([value]);
        ghost var ss := sortedSeq[1..] + [value];
        assert multiset(ss) == multiset(res);
        MultisetContains(ss, res);
      }
    }
  }
}

module Collections__Multisets_s {
  function RestrictMultiset<S(!new)>(m: multiset<S>, f: S -> bool): multiset<S>
    requires forall x: S {:trigger f.requires(x)} :: f.requires(x)
    reads set _x0: S, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    ensures RestrictMultiset(m, f) <= m
    ensures forall x: S {:trigger m[x]} {:trigger f(x)} {:trigger RestrictMultiset(m, f)[x]} :: RestrictMultiset(m, f)[x] == if f(x) then m[x] else 0
    decreases set _x0: S, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, m
  {
    if |m| == 0 then
      multiset{}
    else
      ghost var x: S :| x in m; ghost var m_without_x: multiset<S> := m[x := 0]; if f(x) then RestrictMultiset(m_without_x, f)[x := m[x]] else RestrictMultiset(m_without_x, f)
  }

  lemma MultisetContains(ss: seq<int>, res: seq<int>)
    requires multiset(ss) == multiset(res)
    ensures forall j: int {:trigger res[j]} :: 0 <= j < |res| ==> res[j] in ss
    decreases ss, res
  {
  }
}

module Math__mod_auto_i {

  import opened Math__mod_auto_proofs_i

  import opened Math__div_nonlinear_i

  import opened Math__mul_nonlinear_i

  import opened Math__mul_i
  predicate eq_mod(x: int, y: int, n: int)
    requires n > 0
    decreases x, y, n
  {
    (x - y) % n == 0
  }

  predicate ModAuto(n: int)
    requires n > 0
    decreases n
  {
    n % n == -n % n == 0 &&
    (forall x: int {:trigger x % n % n} :: 
      x % n % n == x % n) &&
    (forall x: int {:trigger x % n} :: 
      0 <= x < n <==> x % n == x) &&
    (forall x: int, y: int {:trigger (x + y) % n} :: 
      ghost var z: int := x % n + y % n; (0 <= z < n && (x + y) % n == z) || (n <= z < n + n && (x + y) % n == z - n)) &&
    forall x: int, y: int {:trigger (x - y) % n} :: 
      ghost var z: int := x % n - y % n; (0 <= z < n && (x - y) % n == z) || (-n <= z < 0 && (x - y) % n == z + n)
  }

  lemma lemma_QuotientAndRemainderUnique(x: int, q: int, r: int, n: int)
    requires n > 0
    requires 0 <= r < n
    requires x == q * n + r
    ensures q == x / n
    ensures r == x % n
    decreases if q > 0 then q else -q
  {
  }

  lemma lemma_mod_auto(n: int)
    requires n > 0
    ensures ModAuto(n)
    decreases n
  {
  }

  predicate TModAutoLe(x: int, y: int)
    decreases x, y
  {
    x <= y
  }

  lemma lemma_mod_auto_induction(n: int, x: int, f: int -> bool)
    requires n > 0
    requires ModAuto(n) ==> (forall i: int {:trigger TModAutoLe(0, i)} :: TModAutoLe(0, i) && i < n ==> f(i)) && (forall i: int {:trigger TModAutoLe(0, i)} :: TModAutoLe(0, i) && f(i) ==> f(i + n)) && forall i: int {:trigger TModAutoLe(i + 1, n)} :: TModAutoLe(i + 1, n) && f(i) ==> f(i - n)
    ensures ModAuto(n)
    ensures f(x)
    decreases n, x
  {
  }

  lemma lemma_mod_auto_induction_forall(n: int, f: int -> bool)
    requires n > 0
    requires ModAuto(n) ==> (forall i: int {:trigger TModAutoLe(0, i)} :: TModAutoLe(0, i) && i < n ==> f(i)) && (forall i: int {:trigger TModAutoLe(0, i)} :: TModAutoLe(0, i) && f(i) ==> f(i + n)) && forall i: int {:trigger TModAutoLe(i + 1, n)} :: TModAutoLe(i + 1, n) && f(i) ==> f(i - n)
    ensures ModAuto(n)
    ensures forall i: int {:trigger f(i)} :: f(i)
    decreases n
  {
  }
}

module Math__mod_auto_proofs_i {

  import opened Math__mul_auto_i

  import opened Math__mul_nonlinear_i

  import opened Math__mul_i

  import opened Math__div_nonlinear_i
  lemma lemma_mod_induction_helper(n: int, f: int -> bool, x: int)
    requires n > 0
    requires forall i: int {:trigger f(i)} :: 0 <= i < n ==> f(i)
    requires forall i: int {:trigger f(i), f(i + n)} :: i >= 0 && f(i) ==> f(i + n)
    requires forall i: int {:trigger f(i), f(i - n)} :: i < n && f(i) ==> f(i - n)
    ensures f(x)
    decreases if x >= n then x else -x
  {
  }

  lemma lemma_mod_induction_forall(n: int, f: int -> bool)
    requires n > 0
    requires forall i: int {:trigger f(i)} :: 0 <= i < n ==> f(i)
    requires forall i: int {:trigger f(i), f(i + n)} :: i >= 0 && f(i) ==> f(i + n)
    requires forall i: int {:trigger f(i), f(i - n)} :: i < n && f(i) ==> f(i - n)
    ensures forall i: int {:trigger f(i)} :: f(i)
    decreases n
  {
  }

  lemma lemma_mod_induction_forall2(n: int, f: (int, int) -> bool)
    requires n > 0
    requires forall i: int, j: int {:trigger f(i, j)} :: 0 <= i < n && 0 <= j < n ==> f(i, j)
    requires forall i: int, j: int {:trigger f(i, j), f(i + n, j)} :: i >= 0 && f(i, j) ==> f(i + n, j)
    requires forall i: int, j: int {:trigger f(i, j), f(i, j + n)} :: j >= 0 && f(i, j) ==> f(i, j + n)
    requires forall i: int, j: int {:trigger f(i, j), f(i - n, j)} :: i < n && f(i, j) ==> f(i - n, j)
    requires forall i: int, j: int {:trigger f(i, j), f(i, j - n)} :: j < n && f(i, j) ==> f(i, j - n)
    ensures forall i: int, j: int {:trigger f(i, j)} :: f(i, j)
    decreases n
  {
  }

  lemma lemma_mod_auto_basics(n: int)
    requires n > 0
    ensures forall x: int {:trigger (x + n) % n} :: (x + n) % n == x % n
    ensures forall x: int {:trigger (x - n) % n} :: (x - n) % n == x % n
    ensures forall x: int {:trigger (x + n) / n} :: (x + n) / n == x / n + 1
    ensures forall x: int {:trigger (x - n) / n} :: (x - n) / n == x / n - 1
    ensures forall x: int {:trigger x % n} :: 0 <= x < n <==> x % n == x
    decreases n
  {
  }
}

module Math__mul_auto_i {

  import opened Math__mul_auto_proofs_i
  predicate MulAuto()
  {
    (forall x: int, y: int {:trigger x * y} :: 
      x * y == y * x) &&
    (forall x: int, y: int, z: int {:trigger (x + y) * z} :: 
      (x + y) * z == x * z + y * z) &&
    forall x: int, y: int, z: int {:trigger (x - y) * z} :: 
      (x - y) * z == x * z - y * z
  }

  lemma lemma_mul_auto()
    ensures MulAuto()
  {
  }

  predicate TMulAutoLe(x: int, y: int)
    decreases x, y
  {
    x <= y
  }

  lemma lemma_mul_auto_induction(x: int, f: int -> bool)
    requires MulAuto() ==> f(0) && (forall i: int {:trigger TMulAutoLe(0, i)} :: TMulAutoLe(0, i) && f(i) ==> f(i + 1)) && forall i: int {:trigger TMulAutoLe(i, 0)} :: TMulAutoLe(i, 0) && f(i) ==> f(i - 1)
    ensures MulAuto()
    ensures f(x)
    decreases x
  {
  }

  lemma lemma_mul_auto_induction_forall(f: int -> bool)
    requires MulAuto() ==> f(0) && (forall i: int {:trigger TMulAutoLe(0, i)} :: TMulAutoLe(0, i) && f(i) ==> f(i + 1)) && forall i: int {:trigger TMulAutoLe(i, 0)} :: TMulAutoLe(i, 0) && f(i) ==> f(i - 1)
    ensures MulAuto()
    ensures forall i: int {:trigger f(i)} :: f(i)
  {
  }
}

module Math__mul_auto_proofs_i {

  import opened Math__mul_nonlinear_i
  lemma lemma_mul_induction_helper(f: int -> bool, x: int)
    requires f(0)
    requires forall i: int {:trigger f(i), f(i + 1)} :: i >= 0 && f(i) ==> f(i + 1)
    requires forall i: int {:trigger f(i), f(i - 1)} :: i <= 0 && f(i) ==> f(i - 1)
    ensures f(x)
    decreases if x >= 0 then x else -x
  {
  }

  lemma lemma_mul_induction_forall(f: int -> bool)
    requires f(0)
    requires forall i: int {:trigger f(i), f(i + 1)} :: i >= 0 && f(i) ==> f(i + 1)
    requires forall i: int {:trigger f(i), f(i - 1)} :: i <= 0 && f(i) ==> f(i - 1)
    ensures forall i: int {:trigger f(i)} :: f(i)
  {
  }

  lemma lemma_mul_auto_commutes()
    ensures forall x: int, y: int {:trigger x * y} :: x * y == y * x
  {
  }

  lemma lemma_mul_auto_succ()
    ensures forall x: int, y: int {:trigger (x + 1) * y} :: (x + 1) * y == x * y + y
    ensures forall x: int, y: int {:trigger (x - 1) * y} :: (x - 1) * y == x * y - y
  {
  }

  lemma lemma_mul_auto_distributes()
    ensures forall x: int, y: int, z: int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z
    ensures forall x: int, y: int, z: int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z
  {
  }
}

module Math__mul_nonlinear_i {
  lemma lemma_mul_strictly_positive(x: int, y: int)
    ensures 0 < x && 0 < y ==> 0 < x * y
    decreases x, y
  {
  }

  lemma lemma_mul_nonzero(x: int, y: int)
    ensures x * y != 0 <==> x != 0 && y != 0
    decreases x, y
  {
  }

  lemma lemma_mul_is_associative(x: int, y: int, z: int)
    ensures x * y * z == x * y * z
    decreases x, y, z
  {
  }

  lemma lemma_mul_is_distributive_add(x: int, y: int, z: int)
    ensures x * (y + z) == x * y + x * z
    decreases x, y, z
  {
  }

  lemma lemma_mul_ordering(x: int, y: int)
    requires 0 < x
    requires 0 < y
    requires 0 <= x * y
    ensures x <= x * y && y <= x * y
    decreases x, y
  {
  }

  lemma lemma_mul_strict_inequality(x: int, y: int, z: int)
    requires x < y
    requires z > 0
    ensures x * z < y * z
    decreases x, y, z
  {
  }

  lemma lemma_mul_by_zero_is_zero(x: int)
    ensures 0 * x == 0
    ensures x * 0 == 0
    decreases x
  {
  }
}

module Math__mul_i {

  import opened Math__mul_nonlinear_i

  import opened Math__mul_auto_i
  function mul(x: int, y: int): int
    decreases x, y
  {
    x * y
  }

  function mul_recursive(x: int, y: int): int
    decreases x, y
  {
    if x >= 0 then
      mul_pos(x, y)
    else
      -1 * mul_pos(-1 * x, y)
  }

  function {:opaque} {:fuel 0, 0} mul_pos(x: int, y: int): int
    requires x >= 0
    decreases x, y
  {
    if x == 0 then
      0
    else
      y + mul_pos(x - 1, y)
  }

  lemma lemma_mul_is_mul_recursive(x: int, y: int)
    ensures x * y == mul_recursive(x, y)
    decreases x, y
  {
  }

  lemma /*{:_induction x, y}*/ lemma_mul_is_mul_pos(x: int, y: int)
    requires x >= 0
    ensures x * y == mul_pos(x, y)
    decreases x, y
  {
  }

  lemma lemma_mul_basics(x: int)
    ensures 0 * x == 0
    ensures x * 0 == 0
    ensures 1 * x == x
    ensures x * 1 == x
    decreases x
  {
  }

  lemma lemma_mul_is_commutative(x: int, y: int)
    ensures x * y == y * x
    decreases x, y
  {
  }

  lemma lemma_mul_ordering_general()
    ensures forall x: int, y: int {:trigger x * y} :: (0 < x && 0 < y && 0 <= x * y ==> x <= x * y) && (0 < x && 0 < y && 0 <= x * y ==> y <= x * y)
  {
  }

  lemma lemma_mul_is_mul_boogie(x: int, y: int)
    decreases x, y
  {
  }

  lemma lemma_mul_inequality(x: int, y: int, z: int)
    requires x <= y
    requires z >= 0
    ensures x * z <= y * z
    decreases x, y, z
  {
  }

  lemma lemma_mul_upper_bound(x: int, x_bound: int, y: int, y_bound: int)
    requires x <= x_bound
    requires y <= y_bound
    requires 0 <= x
    requires 0 <= y
    ensures x * y <= x_bound * y_bound
    decreases x, x_bound, y, y_bound
  {
  }

  lemma lemma_mul_strict_upper_bound(x: int, x_bound: int, y: int, y_bound: int)
    requires x < x_bound
    requires y < y_bound
    requires 0 <= x
    requires 0 <= y
    ensures x * y < x_bound * y_bound
    decreases x, x_bound, y, y_bound
  {
  }

  lemma lemma_mul_left_inequality(x: int, y: int, z: int)
    requires x > 0
    ensures y <= z ==> x * y <= x * z
    ensures y < z ==> x * y < x * z
    decreases x, y, z
  {
  }

  lemma lemma_mul_strict_inequality_converse(x: int, y: int, z: int)
    requires x * z < y * z
    requires z >= 0
    ensures x < y
    decreases x, y, z
  {
  }

  lemma lemma_mul_inequality_converse(x: int, y: int, z: int)
    requires x * z <= y * z
    requires z > 0
    ensures x <= y
    decreases x, y, z
  {
  }

  lemma lemma_mul_equality_converse(x: int, y: int, z: int)
    requires x * z == y * z
    requires 0 < z
    ensures x == y
    decreases x, y, z
  {
  }

  lemma lemma_mul_is_distributive_add_other_way(x: int, y: int, z: int)
    ensures (y + z) * x == y * x + z * x
    decreases x, y, z
  {
  }

  lemma lemma_mul_is_distributive_sub(x: int, y: int, z: int)
    ensures x * (y - z) == x * y - x * z
    decreases x, y, z
  {
  }

  lemma lemma_mul_is_distributive(x: int, y: int, z: int)
    ensures x * (y + z) == x * y + x * z
    ensures x * (y - z) == x * y - x * z
    ensures (y + z) * x == y * x + z * x
    ensures (y - z) * x == y * x - z * x
    ensures x * (y + z) == (y + z) * x
    ensures x * (y - z) == (y - z) * x
    ensures x * y == y * x
    ensures x * z == z * x
    decreases x, y, z
  {
  }

  lemma lemma_mul_strictly_increases(x: int, y: int)
    requires 1 < x
    requires 0 < y
    ensures y < x * y
    decreases x, y
  {
  }

  lemma lemma_mul_increases(x: int, y: int)
    requires 0 < x
    requires 0 < y
    ensures y <= x * y
    decreases x, y
  {
  }

  lemma lemma_mul_nonnegative(x: int, y: int)
    requires 0 <= x
    requires 0 <= y
    ensures 0 <= x * y
    decreases x, y
  {
  }

  lemma lemma_mul_unary_negation(x: int, y: int)
    ensures -x * y == -(x * y) == x * -y
    decreases x, y
  {
  }

  lemma lemma_mul_one_to_one_pos(m: int, x: int, y: int)
    requires 0 < m
    requires m * x == m * y
    ensures x == y
    decreases m, x, y
  {
  }

  lemma lemma_mul_one_to_one(m: int, x: int, y: int)
    requires m != 0
    requires m * x == m * y
    ensures x == y
    decreases m, x, y
  {
  }

  lemma lemma_mul_is_mul_recursive_forall()
    ensures forall x: int, y: int {:trigger mul_recursive(x, y)} :: x * y == mul_recursive(x, y)
  {
  }

  lemma lemma_mul_basics_forall()
    ensures forall x: int {:trigger 0 * x} :: 0 * x == 0
    ensures forall x: int {:trigger x * 0} :: x * 0 == 0
    ensures forall x: int {:trigger 1 * x} :: 1 * x == x
    ensures forall x: int {:trigger x * 1} :: x * 1 == x
  {
  }

  lemma lemma_mul_is_commutative_forall()
    ensures forall x: int, y: int {:trigger x * y} :: x * y == y * x
  {
  }

  lemma lemma_mul_ordering_forall()
    ensures forall x: int, y: int {:trigger x * y} :: (0 < x && 0 < y && 0 <= x * y ==> x <= x * y) && (0 < x && 0 < y && 0 <= x * y ==> y <= x * y)
  {
  }

  lemma lemma_mul_strict_inequality_forall()
    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x < y && z > 0 ==> x * z < y * z
  {
  }

  lemma lemma_mul_inequality_forall()
    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x <= y && z >= 0 ==> x * z <= y * z
  {
  }

  lemma lemma_mul_strict_inequality_converse_forall()
    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x * z < y * z && z >= 0 ==> x < y
  {
  }

  lemma lemma_mul_inequality_converse_forall()
    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x * z <= y * z && z > 0 ==> x <= y
  {
  }

  lemma lemma_mul_is_distributive_add_forall()
    ensures forall x: int, y: int, z: int {:trigger x * (y + z)} :: x * (y + z) == x * y + x * z
  {
  }

  lemma lemma_mul_is_distributive_sub_forall()
    ensures forall x: int, y: int, z: int {:trigger x * (y - z)} :: x * (y - z) == x * y - x * z
  {
  }

  lemma lemma_mul_is_distributive_forall()
    ensures forall x: int, y: int, z: int {:trigger x * (y + z)} :: x * (y + z) == x * y + x * z
    ensures forall x: int, y: int, z: int {:trigger x * (y - z)} :: x * (y - z) == x * y - x * z
    ensures forall x: int, y: int, z: int {:trigger (y + z) * x} :: (y + z) * x == y * x + z * x
    ensures forall x: int, y: int, z: int {:trigger (y - z) * x} :: (y - z) * x == y * x - z * x
  {
  }

  lemma lemma_mul_is_associative_forall()
    ensures forall x: int, y: int, z: int {:trigger x * y * z} {:trigger x * y * z} :: x * y * z == x * y * z
  {
  }

  lemma lemma_mul_nonzero_forall()
    ensures forall x: int, y: int {:trigger x * y} :: x * y != 0 <==> x != 0 && y != 0
  {
  }

  lemma lemma_mul_nonnegative_forall()
    ensures forall x: int, y: int {:trigger x * y} :: 0 <= x && 0 <= y ==> 0 <= x * y
  {
  }

  lemma lemma_mul_unary_negation_forall()
    ensures forall x: int, y: int {:trigger -x * y} {:trigger x * -y} :: -x * y == -(x * y) && -(x * y) == x * -y
  {
  }

  lemma lemma_mul_strictly_increases_forall()
    ensures forall x: int, y: int {:trigger x * y} :: 1 < x && 0 < y ==> y < x * y
  {
  }

  lemma lemma_mul_increases_forall()
    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 0 < y ==> y <= x * y
  {
  }

  lemma lemma_mul_strictly_positive_forall()
    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 0 < y ==> 0 < x * y
  {
  }

  lemma lemma_mul_one_to_one_forall()
    ensures forall m: int, x: int, y: int {:trigger m * x, m * y} :: m != 0 && m * x == m * y ==> x == y
  {
  }

  lemma lemma_mul_by_zero_is_zero_forall()
    ensures forall x: int {:trigger 0 * x} {:trigger x * 0} :: x * 0 == 0 * x && 0 * x == 0
  {
  }

  lemma lemma_mul_properties()
    ensures forall x: int, y: int {:trigger x * y} :: x * y == y * x
    ensures forall x: int {:trigger x * 1} {:trigger 1 * x} :: x * 1 == 1 * x && 1 * x == x
    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x < y && z > 0 ==> x * z < y * z
    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x <= y && z >= 0 ==> x * z <= y * z
    ensures forall x: int, y: int, z: int {:trigger x * (y + z)} :: x * (y + z) == x * y + x * z
    ensures forall x: int, y: int, z: int {:trigger x * (y - z)} :: x * (y - z) == x * y - x * z
    ensures forall x: int, y: int, z: int {:trigger (y + z) * x} :: (y + z) * x == y * x + z * x
    ensures forall x: int, y: int, z: int {:trigger (y - z) * x} :: (y - z) * x == y * x - z * x
    ensures forall x: int, y: int, z: int {:trigger x * y * z} {:trigger x * y * z} :: x * y * z == x * y * z
    ensures forall x: int, y: int {:trigger x * y} :: x * y != 0 <==> x != 0 && y != 0
    ensures forall x: int, y: int {:trigger x * y} :: 0 <= x && 0 <= y ==> 0 <= x * y
    ensures forall x: int, y: int {:trigger x * y} :: (0 < x && 0 < y && 0 <= x * y ==> x <= x * y) && (0 < x && 0 < y && 0 <= x * y ==> y <= x * y)
    ensures forall x: int, y: int {:trigger x * y} :: 1 < x && 0 < y ==> y < x * y
    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 0 < y ==> y <= x * y
    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 0 < y ==> 0 < x * y
  {
  }

  function INTERNAL_mul_recursive(x: int, y: int): int
    decreases x, y
  {
    mul_recursive(x, y)
  }
}

module Math__div_nonlinear_i {
  lemma lemma_div_of_0(d: int)
    requires d != 0
    ensures 0 / d == 0
    decreases d
  {
  }

  lemma lemma_div_by_self(d: int)
    requires d != 0
    ensures d / d == 1
    decreases d
  {
  }

  lemma lemma_small_div()
    ensures forall d: int, x: int {:trigger x / d} :: 0 <= x < d && d > 0 ==> x / d == 0
  {
  }

  lemma lemma_mod_of_zero_is_zero(m: int)
    requires 0 < m
    ensures 0 % m == 0
    decreases m
  {
  }

  lemma lemma_fundamental_div_mod(x: int, d: int)
    requires d != 0
    ensures x == d * x / d + x % d
    decreases x, d
  {
  }

  lemma lemma_0_mod_anything()
    ensures forall m: int {:trigger 0 % m} :: m > 0 ==> 0 % m == 0
  {
  }

  lemma lemma_small_mod(x: nat, m: nat)
    requires x < m
    requires 0 < m
    ensures x % m == x
    decreases x, m
  {
  }

  lemma lemma_mod_range(x: int, m: int)
    requires m > 0
    ensures 0 <= x % m < m
    decreases x, m
  {
  }

  lemma lemma_real_div_gt(x: real, y: real)
    requires x > y
    requires x >= 0.0
    requires y > 0.0
    ensures x / y > 1 as real
    decreases x, y
  {
  }
}

module LiveByzRSL__Replica_i {

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__ClockReading_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__Proposer_i

  import opened LiveByzRSL__Acceptor_i

  import opened LiveByzRSL__Learner_i

  import opened LiveByzRSL__Election_i

  import opened LiveByzRSL__Executor_i

  import opened LiveByzRSL__Broadcast_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__CheckValSafety_i

  import opened Common__UpperBound_s

  import opened Collections__CountMatches_i

  import opened Environment_s
  datatype LReplica = LReplica(constants: LReplicaConstants, nextHeartbeatTime: int, proposer: LProposer, acceptor: LAcceptor, learner: LLearner, executor: LExecutor)

  datatype LScheduler = LScheduler(replica: LReplica, nextActionIndex: int)

  predicate LReplicaInit(r: LReplica, c: LReplicaConstants)
    requires WellFormedLConfiguration(c.all.config)
    decreases r, c
  {
    r.constants == c &&
    r.nextHeartbeatTime == 0 &&
    LProposerInit(r.proposer, c) &&
    LAcceptorInit(r.acceptor, c) &&
    LLearnerInit(r.learner, c) &&
    LExecutorInit(r.executor, c)
  }

  predicate LReplicaNextProcessInvalid(s: LReplica, s': LReplica, received_packet: RslPacket, sent_packets: seq<RslPacket>)
    requires received_packet.msg.RslMessage_Invalid?
    decreases s, s', received_packet, sent_packets
  {
    s' == s &&
    sent_packets == []
  }

  predicate LReplicaNextProcessRequest(s: LReplica, s': LReplica, received_packet: RslPacket, sent_packets: seq<RslPacket>)
    requires received_packet.msg.RslMessage_Request?
    decreases s, s', received_packet, sent_packets
  {
    if received_packet.src in s.executor.reply_cache && s.executor.reply_cache[received_packet.src].Reply? && received_packet.msg.seqno_req <= s.executor.reply_cache[received_packet.src].seqno then
      LExecutorProcessRequest(s.executor, received_packet, sent_packets) &&
      s' == s
    else
      LProposerProcessRequest(s.proposer, s'.proposer, received_packet) && sent_packets == [] && s' == s.(proposer := s'.proposer)
  }

  predicate LReplicaNextSpontaneousMaybeEnterNewViewAndSend1a(s: LReplica, s': LReplica, sent_packets: seq<RslPacket>)
    decreases s, s', sent_packets
  {
    LProposerMaybeEnterNewViewAndSend1a(s.proposer, s'.proposer, sent_packets) &&
    LAcceptorMaybeEnterNewView(s.acceptor, s'.acceptor) &&
    s' == s.(proposer := s'.proposer, acceptor := s'.acceptor)
  }

  predicate LReplicaNextProcess1a(s: LReplica, s': LReplica, received_packet: RslPacket, sent_packets: seq<RslPacket>)
    requires received_packet.msg.RslMessage_1a?
    decreases s, s', received_packet, sent_packets
  {
    LAcceptorProcess1a(s.acceptor, s'.acceptor, received_packet, sent_packets) &&
    s' == s.(acceptor := s'.acceptor)
  }

  predicate LReplicaNextProcess1b(s: LReplica, s': LReplica, received_packet: RslPacket, sent_packets: seq<RslPacket>)
    requires received_packet.msg.RslMessage_1b?
    decreases s, s', received_packet, sent_packets
  {
    if received_packet.src in s.proposer.constants.all.config.replica_ids && received_packet.msg.bal_1b == s.proposer.max_ballot_i_sent_1a && s.proposer.current_state == 1 && forall other_packet: LPacket<NodeIdentity, RslMessage> {:trigger other_packet.src} {:trigger other_packet in s.proposer.received_1b_packets} :: other_packet in s.proposer.received_1b_packets ==> other_packet.src != received_packet.src then
      LProposerProcess1b(s.proposer, s'.proposer, received_packet) &&
      LAcceptorTruncateLog(s.acceptor, s'.acceptor, received_packet.msg.log_truncation_point) &&
      sent_packets == [] &&
      s' == s.(proposer := s'.proposer, acceptor := s'.acceptor)
    else if received_packet.src in s.acceptor.constants.all.config.replica_ids && forall other_packet: LPacket<NodeIdentity, RslMessage> {:trigger other_packet.src} {:trigger other_packet in s.acceptor.received_1b_packets} :: other_packet in s.acceptor.received_1b_packets ==> other_packet.src != received_packet.src then
      LAcceptorProcess1b(s.acceptor, s'.acceptor, received_packet) &&
      s' == s.(acceptor := s'.acceptor) &&
      sent_packets == []
    else
      s' == s && sent_packets == []
  }

  predicate LReplicaNextSpontaneousMaybeEnterPhase2(s: LReplica, s': LReplica, sent_packets: seq<RslPacket>)
    decreases s, s', sent_packets
  {
    LProposerMaybeEnterPhase2(s.proposer, s'.proposer, s.acceptor.log_truncation_point, sent_packets) &&
    s' == s.(proposer := s'.proposer)
  }

  predicate LReplicaNextProcessStartingPhase2(s: LReplica, s': LReplica, received_packet: RslPacket, sent_packets: seq<RslPacket>)
    requires received_packet.msg.RslMessage_StartingPhase2?
    decreases s, s', received_packet, sent_packets
  {
    LExecutorProcessStartingPhase2(s.executor, s'.executor, received_packet, sent_packets) &&
    s' == s.(executor := s'.executor)
  }

  predicate LReplicaNextReadClockMaybeNominateValueAndSend1c(s: LReplica, s': LReplica, clock: ClockReading, sent_packets: seq<RslPacket>)
    decreases s, s', clock, sent_packets
  {
    LProposerMaybeNominateValueAndSend1c(s.proposer, s'.proposer, clock.t, s.acceptor.log_truncation_point, sent_packets) &&
    s' == s.(proposer := s'.proposer)
  }

  predicate LReplicaNextProcess1c(s: LReplica, s': LReplica, received_packet: RslPacket, sent_packets: seq<RslPacket>)
    requires received_packet.msg.RslMessage_1c?
    decreases s, s', received_packet, sent_packets
  {
    ghost var m: RslMessage := received_packet.msg;
    ghost var packets_1b: seq<RslPacket> := s.acceptor.received_1b_packets;
    ghost var byzq: int := LByzQuorumSize(s.constants.all.config);
    ghost var wq: int := LMinQuorumSize(s.constants.all.config);
    ghost var req_is_valid_from_client: bool := forall req: Request {:trigger CheckRequestValid(s.proposer.election_state, req)} {:trigger req in m.val_1c} :: req in m.val_1c ==> CheckRequestValid(s.proposer.election_state, req);
    ghost var req_is_safe: bool := if s.proposer.current_state == 2 then true else if LSeqOfMessage1b(packets_1b) then LAllAcceptorsHadNoProposal(packets_1b, m.opn_1c) || LValIsSafeAt(m.val_1c, packets_1b, m.opn_1c, byzq, wq) else false;
    if received_packet.src in s.acceptor.constants.all.config.replica_ids && req_is_valid_from_client && req_is_safe && BalLeq(s.acceptor.max_bal, m.bal_1c) && LeqUpperBound(m.opn_1c, s.acceptor.constants.all.params.max_integer_val) then
      LAcceptorProcess1c(s.acceptor, s'.acceptor, received_packet, sent_packets) &&
      s' == s.(acceptor := s'.acceptor)
    else
      s' == s && sent_packets == []
  }

  predicate LReplicaNextProcess2av(s: LReplica, s': LReplica, received_packet: RslPacket, sent_packets: seq<RslPacket>)
    requires received_packet.msg.RslMessage_2av?
    decreases s, s', received_packet, sent_packets
  {
    ghost var opn: OperationNumber := received_packet.msg.opn_2av;
    ghost var src: NodeIdentity := received_packet.src;
    ghost var op_sendable: bool := s.acceptor.opn_to_be_send_2b < opn || (s.acceptor.opn_to_be_send_2b == opn && s.acceptor.val_to_be_sent_2b.ValToBeSent2bUnknown?);
    if op_sendable && src in s.acceptor.constants.all.config.replica_ids then
      LAcceptorProcess2av(s.acceptor, s'.acceptor, received_packet) &&
      s' == s.(acceptor := s'.acceptor) &&
      sent_packets == []
    else
      s' == s && sent_packets == []
  }

  predicate LReplicaNextSpontaneousMaybeDecide2bVal(s: LReplica, s': LReplica, sent_packets: seq<RslPacket>)
    decreases s, s', sent_packets
  {
    ghost var opn: OperationNumber := s.acceptor.opn_to_be_send_2b;
    ghost var quorum: int := LByzQuorumSize(s.acceptor.constants.all.config);
    if s.acceptor.val_to_be_sent_2b.ValToBeSent2bUnknown? && opn in s.acceptor.received_2avs && |s.acceptor.received_2avs[opn].received_2av_packets| >= quorum && AcceptorStateCorrect(s.acceptor.received_2avs, s.acceptor.max_bal, s.constants.all.config) && HasReceivedSame2avFromByzQuorum(s.acceptor.received_2avs[opn], quorum) then
      exists p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in s.acceptor.received_2avs[opn].received_2av_packets} :: 
        p in s.acceptor.received_2avs[opn].received_2av_packets &&
        CountMatchedValInReceived2avs(s.acceptor.received_2avs[opn].received_2av_packets, p.msg.val_2av) >= quorum &&
        LAcceptorDecide2bVal(s.acceptor, s'.acceptor, s.acceptor.max_bal, opn, p.msg.val_2av) &&
        s' == s.(acceptor := s'.acceptor) &&
        sent_packets == []
    else
      s' == s && sent_packets == []
  }

  predicate LReplicaNextSpontaneousMaybeSend2b(s: LReplica, s': LReplica, sent_packets: seq<RslPacket>)
    decreases s, s', sent_packets
  {
    if s.acceptor.val_to_be_sent_2b.ValToBeSent2bKnown? && s.acceptor.val_to_be_sent_2b.bal == s.acceptor.max_bal then
      LAcceptorSent2b(s.acceptor, s'.acceptor, sent_packets) &&
      s' == s.(acceptor := s'.acceptor)
    else
      s' == s && sent_packets == []
  }

  predicate LReplicaNextProcess2b(s: LReplica, s': LReplica, received_packet: RslPacket, sent_packets: seq<RslPacket>)
    requires received_packet.msg.RslMessage_2b?
    decreases s, s', received_packet, sent_packets
  {
    ghost var opn: OperationNumber := received_packet.msg.opn_2b;
    ghost var src: NodeIdentity := received_packet.src;
    ghost var op_learnable: bool := s.executor.ops_complete < opn || (s.executor.ops_complete == opn && s.executor.next_op_to_execute.OutstandingOpUnknown?);
    if op_learnable && src in s.learner.constants.all.config.replica_ids then
      LLearnerProcess2b(s.learner, s'.learner, received_packet) &&
      sent_packets == [] &&
      s' == s.(learner := s'.learner)
    else
      s' == s && sent_packets == []
  }

  predicate LReplicaNextProcessReply(s: LReplica, s': LReplica, received_packet: RslPacket, sent_packets: seq<RslPacket>)
    requires received_packet.msg.RslMessage_Reply?
    decreases s, s', received_packet, sent_packets
  {
    sent_packets == [] &&
    s' == s
  }

  predicate LReplicaNextProcessHeartbeat(s: LReplica, s': LReplica, received_packet: RslPacket, clock: int, sent_packets: seq<RslPacket>)
    requires received_packet.msg.RslMessage_Heartbeat?
    decreases s, s', received_packet, clock, sent_packets
  {
    LProposerProcessHeartbeat(s.proposer, s'.proposer, received_packet, clock) &&
    LAcceptorProcessHeartbeat(s.acceptor, s'.acceptor, received_packet) &&
    sent_packets == [] &&
    s' == s.(proposer := s'.proposer, acceptor := s'.acceptor)
  }

  predicate LReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(s: LReplica, s': LReplica, sent_packets: seq<RslPacket>)
    decreases s, s', sent_packets
  {
    exists opn: int {:trigger LAcceptorTruncateLog(s.acceptor, s'.acceptor, opn)} {:trigger IsLogTruncationPointValid(opn, s.acceptor.last_checkpointed_operation, s.constants.all.config)} {:trigger opn in s.acceptor.last_checkpointed_operation} :: 
      opn in s.acceptor.last_checkpointed_operation &&
      IsLogTruncationPointValid(opn, s.acceptor.last_checkpointed_operation, s.constants.all.config) &&
      if opn > s.acceptor.log_truncation_point then LAcceptorTruncateLog(s.acceptor, s'.acceptor, opn) && s' == s.(acceptor := s'.acceptor) && sent_packets == [] else s' == s && sent_packets == []
  }

  predicate LReplicaNextSpontaneousMaybeMakeDecision(s: LReplica, s': LReplica, sent_packets: seq<RslPacket>)
    decreases s, s', sent_packets
  {
    ghost var opn: int := s.executor.ops_complete;
    ghost var quorum: int := LMinQuorumSize(s.acceptor.constants.all.config);
    if s.executor.next_op_to_execute.OutstandingOpUnknown? && opn in s.learner.unexecuted_learner_state && LearnerStateCorrect(s.learner.unexecuted_learner_state, s.learner.max_ballot_seen, s.constants.all.config) && |s.learner.unexecuted_learner_state[opn].received_2bs| >= quorum && HasReceivedSame2bFromWeakQuorum(s.learner.unexecuted_learner_state[opn], quorum) then
      exists p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in s.learner.unexecuted_learner_state[opn].received_2bs} :: 
        p in s.learner.unexecuted_learner_state[opn].received_2bs &&
        CountMatchedValInReceived2bs(s.learner.unexecuted_learner_state[opn].received_2bs, p.msg.val_2b) >= quorum &&
        LExecutorGetDecision(s.executor, s'.executor, s.learner.max_ballot_seen, opn, p.msg.val_2b) &&
        s' == s.(executor := s'.executor) &&
        sent_packets == []
    else
      s' == s && sent_packets == []
  }

  predicate LReplicaNextSpontaneousMaybeExecute(s: LReplica, s': LReplica, sent_packets: seq<RslPacket>)
    decreases s, s', sent_packets
  {
    if s.executor.next_op_to_execute.OutstandingOpKnown? && LtUpperBound(s.executor.ops_complete, s.executor.constants.all.params.max_integer_val) && LReplicaConstantsValid(s.executor.constants) then
      ghost var v: RequestBatch := s.executor.next_op_to_execute.v;
      LProposerResetViewTimerDueToExecution(s.proposer, s'.proposer, v) &&
      LLearnerForgetDecision(s.learner, s'.learner, s.executor.ops_complete) &&
      LAcceptorForgetReceived2avs(s.acceptor, s'.acceptor, s.executor.ops_complete) &&
      LExecutorExecute(s.executor, s'.executor, sent_packets) &&
      s' == s.(acceptor := s'.acceptor, proposer := s'.proposer, learner := s'.learner, executor := s'.executor)
    else
      s' == s && sent_packets == []
  }

  predicate LReplicaNextReadClockMaybeSendHeartbeat(s: LReplica, s': LReplica, clock: ClockReading, sent_packets: seq<RslPacket>)
    decreases s, s', clock, sent_packets
  {
    if clock.t < s.nextHeartbeatTime then
      s' == s &&
      sent_packets == []
    else
      s'.nextHeartbeatTime == UpperBoundedAddition(clock.t, s.constants.all.params.heartbeat_period, s.constants.all.params.max_integer_val) && LBroadcastToEveryone(s.constants.all.config, s.constants.my_index, RslMessage_Heartbeat(s.proposer.election_state.current_view, s.constants.my_index in s.proposer.election_state.current_view_suspectors, s.executor.ops_complete), sent_packets) && s' == s.(nextHeartbeatTime := s'.nextHeartbeatTime)
  }

  predicate LReplicaNextReadClockCheckForViewTimeout(s: LReplica, s': LReplica, clock: ClockReading, sent_packets: seq<RslPacket>)
    decreases s, s', clock, sent_packets
  {
    LProposerCheckForViewTimeout(s.proposer, s'.proposer, clock.t) &&
    sent_packets == [] &&
    s' == s.(proposer := s'.proposer)
  }

  predicate LReplicaNextReadClockCheckForQuorumOfViewSuspicions(s: LReplica, s': LReplica, clock: ClockReading, sent_packets: seq<RslPacket>)
    decreases s, s', clock, sent_packets
  {
    LProposerCheckForQuorumOfViewSuspicions(s.proposer, s'.proposer, clock.t) &&
    sent_packets == [] &&
    s' == s.(proposer := s'.proposer)
  }

  function {:opaque} {:fuel 0, 0} ExtractSentPacketsFromIos(ios: seq<RslIo>): seq<RslPacket>
    ensures forall p: LPacket<EndPoint, RslMessage> {:trigger LIoOpSend(p)} {:trigger p in ExtractSentPacketsFromIos(ios)} :: p in ExtractSentPacketsFromIos(ios) <==> LIoOpSend(p) in ios
    decreases ios
  {
    if |ios| == 0 then
      []
    else if ios[0].LIoOpSend? then
      [ios[0].s] + ExtractSentPacketsFromIos(ios[1..])
    else
      ExtractSentPacketsFromIos(ios[1..])
  }

  predicate LReplicaNextReadClockAndProcessPacket(s: LReplica, s': LReplica, ios: seq<RslIo>)
    requires |ios| >= 1
    requires ios[0].LIoOpReceive?
    requires ios[0].r.msg.RslMessage_Heartbeat?
    decreases s, s', ios
  {
    |ios| > 1 &&
    ios[1].LIoOpReadClock? &&
    (forall io: LIoOp<NodeIdentity, RslMessage> {:trigger io.LIoOpSend?} {:trigger io in ios[2..]} :: 
      io in ios[2..] ==>
        io.LIoOpSend?) &&
    LReplicaNextProcessHeartbeat(s, s', ios[0].r, ios[1].t, ExtractSentPacketsFromIos(ios))
  }

  predicate LReplicaNextProcessPacketWithoutReadingClock(s: LReplica, s': LReplica, ios: seq<RslIo>)
    requires |ios| >= 1
    requires ios[0].LIoOpReceive?
    requires !ios[0].r.msg.RslMessage_Heartbeat?
    decreases s, s', ios
  {
    (forall io: LIoOp<NodeIdentity, RslMessage> {:trigger io.LIoOpSend?} {:trigger io in ios[1..]} :: 
      io in ios[1..] ==>
        io.LIoOpSend?) &&
    ghost var sent_packets: seq<RslPacket> := ExtractSentPacketsFromIos(ios); match ios[0].r.msg case RslMessage_Invalid => LReplicaNextProcessInvalid(s, s', ios[0].r, sent_packets) case RslMessage_Request(_v0, _v1) => LReplicaNextProcessRequest(s, s', ios[0].r, sent_packets) case RslMessage_1a(_v2) => LReplicaNextProcess1a(s, s', ios[0].r, sent_packets) case RslMessage_1b(_v3, _v4, _v5) => LReplicaNextProcess1b(s, s', ios[0].r, sent_packets) case RslMessage_StartingPhase2(_v6, _v7) => LReplicaNextProcessStartingPhase2(s, s', ios[0].r, sent_packets) case RslMessage_1c(_v8, _v9, _v10) => LReplicaNextProcess1c(s, s', ios[0].r, sent_packets) case RslMessage_2av(_v11, _v12, _v13) => LReplicaNextProcess2av(s, s', ios[0].r, sent_packets) case RslMessage_2b(_v14, _v15, _v16) => LReplicaNextProcess2b(s, s', ios[0].r, sent_packets) case RslMessage_Reply(_v17, _v18) => LReplicaNextProcessReply(s, s', ios[0].r, sent_packets)
  }

  predicate LReplicaNextProcessPacket(s: LReplica, s': LReplica, ios: seq<RslIo>)
    decreases s, s', ios
  {
    |ios| >= 1 &&
    if ios[0].LIoOpTimeoutReceive? then s' == s && |ios| == 1 else ios[0].LIoOpReceive? && if ios[0].r.msg.RslMessage_Heartbeat? then LReplicaNextReadClockAndProcessPacket(s, s', ios) else LReplicaNextProcessPacketWithoutReadingClock(s, s', ios)
  }

  function LReplicaNumActions(): int
  {
    12
  }

  predicate SpontaneousIos(ios: seq<RslIo>, clocks: int)
    requires 0 <= clocks <= 1
    decreases ios, clocks
  {
    clocks <= |ios| &&
    (forall i: int {:trigger ios[i]} :: 
      0 <= i < clocks ==>
        ios[i].LIoOpReadClock?) &&
    forall i: int {:trigger ios[i]} :: 
      clocks <= i < |ios| ==>
        ios[i].LIoOpSend?
  }

  function SpontaneousClock(ios: seq<RslIo>): ClockReading
    decreases ios
  {
    if SpontaneousIos(ios, 1) then
      ClockReading(ios[0].t)
    else
      ClockReading(0)
  }

  predicate LReplicaNoReceiveNext(s: LReplica, nextActionIndex: int, s': LReplica, ios: seq<RslIo>)
    decreases s, nextActionIndex, s', ios
  {
    ghost var sent_packets: seq<RslPacket> := ExtractSentPacketsFromIos(ios);
    if nextActionIndex == 1 then
      SpontaneousIos(ios, 0) &&
      LReplicaNextSpontaneousMaybeEnterNewViewAndSend1a(s, s', sent_packets)
    else if nextActionIndex == 2 then
      SpontaneousIos(ios, 0) &&
      LReplicaNextSpontaneousMaybeEnterPhase2(s, s', sent_packets)
    else if nextActionIndex == 3 then
      SpontaneousIos(ios, 1) &&
      LReplicaNextReadClockMaybeNominateValueAndSend1c(s, s', SpontaneousClock(ios), sent_packets)
    else if nextActionIndex == 4 then
      SpontaneousIos(ios, 0) &&
      LReplicaNextSpontaneousMaybeDecide2bVal(s, s', sent_packets)
    else if nextActionIndex == 5 then
      SpontaneousIos(ios, 0) &&
      LReplicaNextSpontaneousMaybeSend2b(s, s', sent_packets)
    else if nextActionIndex == 6 then
      SpontaneousIos(ios, 0) &&
      LReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(s, s', sent_packets)
    else if nextActionIndex == 7 then
      SpontaneousIos(ios, 0) &&
      LReplicaNextSpontaneousMaybeMakeDecision(s, s', sent_packets)
    else if nextActionIndex == 8 then
      SpontaneousIos(ios, 0) &&
      LReplicaNextSpontaneousMaybeExecute(s, s', sent_packets)
    else if nextActionIndex == 9 then
      SpontaneousIos(ios, 1) &&
      LReplicaNextReadClockCheckForViewTimeout(s, s', SpontaneousClock(ios), sent_packets)
    else if nextActionIndex == 10 then
      SpontaneousIos(ios, 1) &&
      LReplicaNextReadClockCheckForQuorumOfViewSuspicions(s, s', SpontaneousClock(ios), sent_packets)
    else
      nextActionIndex == 11 && SpontaneousIos(ios, 1) && LReplicaNextReadClockMaybeSendHeartbeat(s, s', SpontaneousClock(ios), sent_packets)
  }

  predicate LSchedulerInit(s: LScheduler, c: LReplicaConstants)
    requires WellFormedLConfiguration(c.all.config)
    decreases s, c
  {
    LReplicaInit(s.replica, c) &&
    s.nextActionIndex == 0
  }

  predicate LSchedulerNext(s: LScheduler, s': LScheduler, ios: seq<RslIo>)
    decreases s, s', ios
  {
    s'.nextActionIndex == (s.nextActionIndex + 1) % LReplicaNumActions() &&
    if s.nextActionIndex == 0 then LReplicaNextProcessPacket(s.replica, s'.replica, ios) else LReplicaNoReceiveNext(s.replica, s.nextActionIndex, s'.replica, ios)
  }
}

module LiveByzRSL__Configuration_i {

  import opened LiveByzRSL__Types_i

  import opened Collections__Sets_i

  import opened Collections__Seqs_i

  import opened Concrete_NodeIdentity_i
  datatype LConfiguration = LConfiguration(clientIds: set<NodeIdentity>, replica_ids: seq<NodeIdentity>)

  function LMinQuorumSize(c: LConfiguration): int
    decreases c
  {
    |c.replica_ids| / 2 + 1
  }

  function LByzQuorumSize(c: LConfiguration): int
    decreases c
  {
    2 * |c.replica_ids| / 3 + 1
  }

  lemma Lemma_TwoByzantineQuorumsIntersect(c: LConfiguration)
    ensures 2 * LByzQuorumSize(c) > |c.replica_ids|
    decreases c
  {
  }

  lemma Lemma_TwoMinQuorumsIntersect(c: LConfiguration)
    ensures 2 * LMinQuorumSize(c) > |c.replica_ids|
    decreases c
  {
  }

  predicate ReplicasDistinct(replica_ids: seq<NodeIdentity>, i: int, j: int)
    decreases replica_ids, i, j
  {
    0 <= i < |replica_ids| &&
    0 <= j < |replica_ids| &&
    replica_ids[i] == replica_ids[j] ==>
      i == j
  }

  predicate ReplicasIsUnique(replica_ids: seq<NodeIdentity>)
    decreases replica_ids
  {
    forall i: int, j: int {:trigger replica_ids[j], replica_ids[i]} :: 
      0 <= i < |replica_ids| &&
      0 <= j < |replica_ids| &&
      replica_ids[i] == replica_ids[j] ==>
        i == j
  }

  predicate WellFormedLConfiguration(c: LConfiguration)
    decreases c
  {
    0 < |c.replica_ids| &&
    (forall i: int, j: int {:trigger ReplicasDistinct(c.replica_ids, i, j)} :: 
      ReplicasDistinct(c.replica_ids, i, j)) &&
    ReplicasIsUnique(c.replica_ids)
  }

  predicate IsReplicaIndex(idx: int, id: NodeIdentity, c: LConfiguration)
    decreases idx, id, c
  {
    0 <= idx < |c.replica_ids| &&
    c.replica_ids[idx] == id
  }

  function GetReplicaIndex(id: NodeIdentity, c: LConfiguration): int
    requires id in c.replica_ids
    ensures ghost var idx: int := GetReplicaIndex(id, c); IsReplicaIndex(idx, id, c)
    decreases id, c
  {
    FindIndexInSeq(c.replica_ids, id)
  }

  lemma lemma_DiffReplicaHasDiffIndex(id1: NodeIdentity, id2: NodeIdentity, c: LConfiguration)
    requires id1 != id2
    requires id1 in c.replica_ids && id2 in c.replica_ids
    ensures GetReplicaIndex(id1, c) != GetReplicaIndex(id2, c)
    decreases id1, id2, c
  {
  }

  lemma lemma_GetReplicaIndexIsUnique(c: LConfiguration, idx: int)
    requires WellFormedLConfiguration(c)
    requires 0 <= idx < |c.replica_ids|
    ensures GetReplicaIndex(c.replica_ids[idx], c) == idx
    decreases c, idx
  {
  }
}

module LiveByzRSL__Types_i {

  import opened AppStateMachine_i

  import opened Concrete_NodeIdentity_i
  type OperationNumber = int

  datatype Ballot = Ballot(seqno: int, proposer_id: int)

  datatype Request = Request(client: NodeIdentity, seqno: int, request: AppMessage)

  datatype Reply = Reply(client: NodeIdentity, seqno: int, reply: AppMessage)

  type RequestBatch = seq<Request>

  type ReplyCache = map<NodeIdentity, Reply>

  datatype Vote = Vote(max_value_bal: Ballot, ghost max_val: RequestBatch)

  type Votes = map<OperationNumber, Vote>

  predicate BalLt(ba: Ballot, bb: Ballot)
    decreases ba, bb
  {
    ba.seqno < bb.seqno || (ba.seqno == bb.seqno && ba.proposer_id < bb.proposer_id)
  }

  predicate BalLeq(ba: Ballot, bb: Ballot)
    decreases ba, bb
  {
    ba.seqno < bb.seqno || (ba.seqno == bb.seqno && ba.proposer_id <= bb.proposer_id)
  }

  lemma lemma_BalLtMiddle(ba: Ballot, bb: Ballot)
    requires !BalLt(ba, bb)
    requires ba != bb
    ensures BalLt(bb, ba)
    decreases ba, bb
  {
  }

  lemma lemma_BalLtProperties()
    ensures forall ba: Ballot, bb: Ballot {:trigger BalLt(bb, ba)} {:trigger BalLt(ba, bb)} :: !BalLt(ba, bb) && ba != bb ==> BalLt(bb, ba)
    ensures forall ba: Ballot, bb: Ballot {:trigger BalLt(ba, bb)} {:trigger BalLeq(ba, bb)} :: BalLeq(ba, bb) ==> BalLt(ba, bb) || ba == bb
    ensures forall ba: Ballot, bb: Ballot, bc: Ballot {:trigger BalLt(ba, bc), BalLt(bb, bc)} {:trigger BalLt(bb, bc), BalLt(ba, bb)} :: BalLt(ba, bb) && BalLt(bb, bc) ==> BalLt(ba, bc)
    ensures forall ba: Ballot, bb: Ballot, bc: Ballot {:trigger BalLt(ba, bc), BalLeq(bb, bc)} {:trigger BalLeq(bb, bc), BalLt(ba, bb)} :: BalLt(ba, bb) && BalLeq(bb, bc) ==> BalLt(ba, bc)
    ensures forall ba: Ballot, bb: Ballot, bc: Ballot {:trigger BalLt(ba, bc), BalLt(bb, bc)} {:trigger BalLt(bb, bc), BalLeq(ba, bb)} :: BalLeq(ba, bb) && BalLt(bb, bc) ==> BalLt(ba, bc)
  {
  }
}

module AppStateMachine_i refines AppStateMachine_s {
  type AppState = uint64

  datatype AppMessage' = AppIncrementRequest | AppIncrementReply(response: uint64) | AppInvalidReply

  type AppMessage = AppMessage'

  function AppInitialize(): AppState
  {
    0
  }

  function CappedIncr(v: uint64): uint64
    decreases v
  {
    if v == 18446744073709551615 then
      v
    else
      v + 1
  }

  function AppHandleRequest(m: AppState, request: AppMessage): (AppState, AppMessage)
    decreases m, request
  {
    if request.AppIncrementRequest? then
      (CappedIncr(m), AppIncrementReply(CappedIncr(m)))
    else
      (m, AppInvalidReply())
  }

  function MarshallAppMessage(m: AppMessage): seq<byte>
    decreases m
  {
    match m {
      case AppIncrementRequest() =>
        [0, 0, 0, 0, 0, 0, 0, 0]
      case AppIncrementReply(response) =>
        [0, 0, 0, 0, 0, 0, 0, 1] + Uint64ToBytes(response)
      case AppInvalidReply() =>
        [0, 0, 0, 0, 0, 0, 0, 2]
    }
  }

  function Uint64ToBytes(u: uint64): seq<byte>
    decreases u
  {
    [(u / 72057594037927936) as byte, (u / 281474976710656 % 256) as byte, (u / 1099511627776 % 256) as byte, (u / 4294967296 % 256) as byte, (u / 16777216 % 256) as byte, (u / 65536 % 256) as byte, (u / 256 % 256) as byte, (u % 256) as byte]
  }

  import opened Native__NativeTypes_s

  import opened Native__Io_s
}

abstract module AppStateMachine_s {

  import opened Native__NativeTypes_s

  import opened Native__Io_s
  type AppState

  type AppMessage

  function AppInitialize(): AppState

  function AppHandleRequest(m: AppState, request: AppMessage): (AppState, AppMessage)

  function MarshallAppMessage(m: AppMessage): seq<byte>
}

module Concrete_NodeIdentity_i refines Common__NodeIdentity_s {

  import opened Native__Io_s

  export Spec
    provides NodeIdentity


  export
    reveals *
    provides Native__Io_s
    reveals NodeIdentity

  type /*{:_provided}*/ NodeIdentity = EndPoint
}

abstract module Common__NodeIdentity_s {
  type NodeIdentity(==)
}

module Collections__Sets_i {
  lemma ThingsIKnowAboutSubset<T>(x: set<T>, y: set<T>)
    requires x < y
    ensures |x| < |y|
    decreases x, y
  {
  }

  lemma SubsetCardinality<T>(x: set<T>, y: set<T>)
    ensures x < y ==> |x| < |y|
    ensures x <= y ==> |x| <= |y|
    decreases x, y
  {
  }

  lemma ItIsASingletonSet<T>(foo: set<T>, x: T)
    requires foo == {x}
    ensures |foo| == 1
    decreases foo
  {
  }

  lemma ThingsIKnowAboutASingletonSet<T>(foo: set<T>, x: T, y: T)
    requires |foo| == 1
    requires x in foo
    requires y in foo
    ensures x == y
    decreases foo
  {
  }

  predicate Injective<X(!new), Y>(f: X --> Y)
    requires forall x: X {:trigger f.requires(x)} :: f.requires(x)
    reads set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    decreases set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
  {
    forall x1: X, x2: X {:trigger f(x2), f(x1)} :: 
      f(x1) == f(x2) ==>
        x1 == x2
  }

  predicate InjectiveOver<X(!new), Y>(xs: set<X>, ys: set<Y>, f: X --> Y)
    requires forall x: X {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)
    reads set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    decreases set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, xs, ys
  {
    forall x1: X, x2: X {:trigger f(x2), f(x1)} {:trigger f(x2), x1 in xs} {:trigger f(x1), x2 in xs} {:trigger x2 in xs, x1 in xs} :: 
      x1 in xs &&
      x2 in xs &&
      f(x1) in ys &&
      f(x2) in ys &&
      f(x1) == f(x2) ==>
        x1 == x2
  }

  predicate InjectiveOverSeq<X(!new), Y>(xs: seq<X>, ys: set<Y>, f: X --> Y)
    requires forall x: X {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)
    reads set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    decreases set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, xs, ys
  {
    forall x1: X, x2: X {:trigger f(x2), f(x1)} {:trigger f(x2), x1 in xs} {:trigger f(x1), x2 in xs} {:trigger x2 in xs, x1 in xs} :: 
      x1 in xs &&
      x2 in xs &&
      f(x1) in ys &&
      f(x2) in ys &&
      f(x1) == f(x2) ==>
        x1 == x2
  }

  lemma lemma_MapSetCardinality<X, Y>(xs: set<X>, ys: set<Y>, f: X --> Y)
    requires forall x: X {:trigger f.requires(x)} :: f.requires(x)
    requires Injective(f)
    requires forall x: X {:trigger f(x)} {:trigger x in xs} :: x in xs <==> f(x) in ys
    requires forall y: Y {:trigger y in ys} :: y in ys ==> exists x: X {:trigger f(x)} {:trigger x in xs} :: x in xs && y == f(x)
    ensures |xs| == |ys|
    decreases xs, ys
  {
  }

  lemma lemma_MapSetCardinalityOver<X, Y>(xs: set<X>, ys: set<Y>, f: X --> Y)
    requires forall x: X {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)
    requires InjectiveOver(xs, ys, f)
    requires forall x: X {:trigger f(x)} {:trigger x in xs} :: x in xs ==> f(x) in ys
    requires forall y: Y {:trigger y in ys} :: y in ys ==> exists x: X {:trigger f(x)} {:trigger x in xs} :: x in xs && y == f(x)
    ensures |xs| == |ys|
    decreases xs, ys
  {
  }

  lemma lemma_MapSubsetCardinalityOver<X, Y>(xs: set<X>, ys: set<Y>, f: X --> Y)
    requires forall x: X {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)
    requires InjectiveOver(xs, ys, f)
    requires forall x: X {:trigger f(x)} {:trigger x in xs} :: x in xs ==> f(x) in ys
    ensures |xs| <= |ys|
    decreases xs, ys
  {
  }

  lemma lemma_MapSubseqCardinalityOver<X, Y>(xs: seq<X>, ys: set<Y>, f: X --> Y)
    requires forall x: X {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)
    requires forall i: int, j: int {:trigger xs[j], xs[i]} :: 0 <= i < |xs| && 0 <= j < |xs| && i != j ==> xs[i] != xs[j]
    requires InjectiveOverSeq(xs, ys, f)
    requires forall x: X {:trigger f(x)} {:trigger x in xs} :: x in xs ==> f(x) in ys
    ensures |xs| <= |ys|
    decreases xs, ys
  {
  }

  function MapSetToSet<X(!new), Y>(xs: set<X>, f: X --> Y): set<Y>
    requires forall x: X {:trigger f.requires(x)} :: f.requires(x)
    requires Injective(f)
    reads set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    ensures forall x: X {:trigger f(x)} {:trigger x in xs} :: x in xs <==> f(x) in MapSetToSet(xs, f)
    ensures |xs| == |MapSetToSet(xs, f)|
    decreases set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, xs
  {
    ghost var ys: set<Y> := set x: X {:trigger f(x)} {:trigger x in xs} | x in xs :: f(x);
    lemma_MapSetCardinality(xs, ys, f);
    ys
  }

  function MapSetToSetOver<X(!new), Y>(xs: set<X>, f: X --> Y): set<Y>
    requires forall x: X {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)
    requires InjectiveOver(xs, set x: X {:trigger f(x)} {:trigger x in xs} | x in xs :: f(x), f)
    reads set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    ensures forall x: X {:trigger f(x)} {:trigger x in xs} :: x in xs ==> f(x) in MapSetToSetOver(xs, f)
    ensures |xs| == |MapSetToSetOver(xs, f)|
    decreases set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, xs
  {
    ghost var ys: set<Y> := set x: X {:trigger f(x)} {:trigger x in xs} | x in xs :: f(x);
    lemma_MapSetCardinalityOver(xs, ys, f);
    ys
  }

  function MapSeqToSet<X(!new), Y>(xs: seq<X>, f: X --> Y): set<Y>
    requires forall x: X {:trigger f.requires(x)} :: f.requires(x)
    requires Injective(f)
    reads set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    ensures forall x: X {:trigger f(x)} {:trigger x in xs} :: x in xs <==> f(x) in MapSeqToSet(xs, f)
    decreases set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, xs
  {
    set x: X {:trigger f(x)} {:trigger x in xs} | x in xs :: f(x)
  }

  function SeqToSet<X(!new)>(xs: seq<X>): set<X>
    decreases xs
  {
    set x: X {:trigger x in xs} | x in xs
  }

  lemma lemma_SubsetCardinality<X>(xs: set<X>, ys: set<X>, f: X --> bool)
    requires forall x: X {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)
    requires forall x: X {:trigger f(x)} {:trigger x in xs} {:trigger x in ys} :: (x in ys ==> x in xs) && (x in ys ==> f(x))
    ensures |ys| <= |xs|
    decreases xs, ys
  {
  }

  function MakeSubset<X(!new)>(xs: set<X>, f: X -> bool): set<X>
    requires forall x: X {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)
    reads set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    ensures forall x: X {:trigger f(x)} {:trigger x in xs} {:trigger x in MakeSubset(xs, f)} :: x in MakeSubset(xs, f) <==> x in xs && f(x)
    ensures |MakeSubset(xs, f)| <= |xs|
    decreases set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, xs
  {
    ghost var ys: set<X> := set x: X {:trigger f(x)} {:trigger x in xs} | x in xs && f(x);
    lemma_SubsetCardinality(xs, ys, f);
    ys
  }

  lemma lemma_UnionCardinality<X>(xs: set<X>, ys: set<X>, us: set<X>)
    requires us == xs + ys
    ensures |us| >= |xs|
    decreases ys
  {
  }

  function SetOfNumbersInRightExclusiveRange(a: int, b: int): set<int>
    requires a <= b
    ensures forall opn: int {:trigger opn in SetOfNumbersInRightExclusiveRange(a, b)} :: a <= opn < b ==> opn in SetOfNumbersInRightExclusiveRange(a, b)
    ensures forall opn: int {:trigger opn in SetOfNumbersInRightExclusiveRange(a, b)} :: (opn in SetOfNumbersInRightExclusiveRange(a, b) ==> a <= opn) && (opn in SetOfNumbersInRightExclusiveRange(a, b) ==> opn < b)
    ensures |SetOfNumbersInRightExclusiveRange(a, b)| == b - a
    decreases b - a
  {
    if a == b then
      {}
    else
      {a} + SetOfNumbersInRightExclusiveRange(a + 1, b)
  }

  lemma lemma_CardinalityOfBoundedSet(s: set<int>, a: int, b: int)
    requires forall opn: int {:trigger opn in s} :: (opn in s ==> a <= opn) && (opn in s ==> opn < b)
    requires a <= b
    ensures |s| <= b - a
    decreases s, a, b
  {
  }

  function intsetmax(s: set<int>): int
    requires |s| > 0
    ensures ghost var m: int := intsetmax(s); m in s && forall i: int {:trigger i in s} :: i in s ==> m >= i
    decreases s
  {
    ghost var x: int :| x in s;
    if |s| == 1 then
      assert |s - {x}| == 0;
      x
    else
      ghost var sy: set<int> := s - {x}; ghost var y: int := intsetmax(sy); assert forall i: int {:trigger i in sy} {:trigger i in s} :: i in s ==> i in sy || i == x; if x > y then x else y
  }
}

module LiveByzRSL__Environment_i {

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__Message_i

  import opened Environment_s

  import opened Concrete_NodeIdentity_i
  type RslEnvironment = LEnvironment<NodeIdentity, RslMessage>

  type RslPacket = LPacket<NodeIdentity, RslMessage>

  type RslIo = LIoOp<NodeIdentity, RslMessage>

  function ConcatenatePaxosIos(s: seq<seq<RslIo>>): seq<RslIo>
    decreases s
  {
    if |s| == 0 then
      []
    else
      s[0] + ConcatenatePaxosIos(s[1..])
  }
}

module LiveByzRSL__Message_i {

  import opened LiveByzRSL__Types_i

  import opened AppStateMachine_i
  datatype RslMessage = RslMessage_Invalid | RslMessage_Request(seqno_req: int, val: AppMessage) | RslMessage_1a(bal_1a: Ballot) | RslMessage_1b(bal_1b: Ballot, log_truncation_point: OperationNumber, votes: Votes) | RslMessage_1c(bal_1c: Ballot, opn_1c: OperationNumber, val_1c: RequestBatch) | RslMessage_2av(bal_2av: Ballot, opn_2av: OperationNumber, val_2av: RequestBatch) | RslMessage_2b(bal_2b: Ballot, opn_2b: OperationNumber, val_2b: RequestBatch) | RslMessage_Heartbeat(bal_heartbeat: Ballot, suspicious: bool, opn_ckpt: OperationNumber) | RslMessage_Reply(seqno_reply: int, reply: AppMessage) | RslMessage_StartingPhase2(bal_2: Ballot, logTruncationPoint_2: OperationNumber)
}

module LiveByzRSL__ClockReading_i {
  datatype ClockReading = ClockReading(t: int)
}

module LiveByzRSL__Constants_i {

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Parameters_i
  datatype LConstants = LConstants(config: LConfiguration, params: LParameters)

  datatype LReplicaConstants = LReplicaConstants(my_index: int, all: LConstants)

  predicate LReplicaConstantsValid(c: LReplicaConstants)
    decreases c
  {
    0 <= c.my_index < |c.all.config.replica_ids|
  }
}

module LiveByzRSL__Parameters_i {

  import opened Common__UpperBound_s
  datatype LParameters = LParameters(max_log_length: int, baseline_view_timeout_period: int, heartbeat_period: int, max_integer_val: UpperBound, max_batch_size: int, max_batch_delay: int)

  predicate WFLParameters(p: LParameters)
    decreases p
  {
    p.max_log_length > 0 &&
    p.baseline_view_timeout_period > 0 &&
    p.heartbeat_period > 0 &&
    (p.max_integer_val.UpperBoundFinite? ==>
      p.max_integer_val.n > p.max_log_length) &&
    p.max_batch_size > 0 &&
    p.max_batch_delay >= 0
  }
}

module Common__UpperBound_s {
  datatype UpperBound = UpperBoundFinite(n: int) | UpperBoundInfinite

  predicate LeqUpperBound(x: int, u: UpperBound)
    decreases x, u
  {
    match u
    case UpperBoundFinite(n) =>
      x <= n
    case UpperBoundInfinite() =>
      true
  }

  predicate LtUpperBound(x: int, u: UpperBound)
    decreases x, u
  {
    match u
    case UpperBoundFinite(n) =>
      x < n
    case UpperBoundInfinite() =>
      true
  }

  function UpperBoundedAddition(x: int, y: int, u: UpperBound): int
    decreases x, y, u
  {
    if LeqUpperBound(x + y, u) then
      x + y
    else
      u.n
  }
}

module LiveByzRSL__Proposer_i {

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__Broadcast_i

  import opened LiveByzRSL__Acceptor_i

  import opened LiveByzRSL__Election_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__CheckValSafety_i

  import opened Concrete_NodeIdentity_i

  import opened Common__UpperBound_s

  import opened Collections__CountMatches_i
  datatype IncompleteBatchTimer = IncompleteBatchTimerOn(when: int) | IncompleteBatchTimerOff

  datatype LProposer = LProposer(constants: LReplicaConstants, current_state: int, request_queue: seq<Request>, max_ballot_i_sent_1a: Ballot, next_operation_number_to_propose: int, received_1b_packets: seq<RslPacket>, highest_seqno_requested_by_client_this_view: map<NodeIdentity, int>, incomplete_batch_timer: IncompleteBatchTimer, election_state: ElectionState)

  function FindTheLowestTruncatePoint(S: seq<RslPacket>): OperationNumber
    requires LSeqOfMessage1b(S)
    decreases S
  {
    if |S| == 0 then
      0
    else
      ghost var opn: OperationNumber := FindTheLowestTruncatePoint(S[1..]); if opn > 0 && opn < S[0].msg.log_truncation_point then opn else S[0].msg.log_truncation_point
  }

  predicate LIsAfterLogTruncationPoint(opn: OperationNumber, S: seq<RslPacket>)
    decreases opn, S
  {
    forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in S} :: 
      p in S &&
      p.msg.RslMessage_1b? ==>
        p.msg.log_truncation_point <= opn
  }

  predicate LProposerCanNominateUsingOperationNumber(s: LProposer, log_truncation_point: OperationNumber, opn: OperationNumber)
    decreases s, log_truncation_point, opn
  {
    s.election_state.current_view == s.max_ballot_i_sent_1a &&
    s.current_state == 2 &&
    |s.received_1b_packets| >= LByzQuorumSize(s.constants.all.config) &&
    LSetOfMessage1bAboutBallot(s.received_1b_packets, s.max_ballot_i_sent_1a) &&
    LIsAfterLogTruncationPoint(opn, s.received_1b_packets) &&
    opn < UpperBoundedAddition(log_truncation_point, s.constants.all.params.max_log_length, s.constants.all.params.max_integer_val) &&
    opn >= 0 &&
    LtUpperBound(opn, s.constants.all.params.max_integer_val)
  }

  predicate LProposerInit(s: LProposer, c: LReplicaConstants)
    requires WellFormedLConfiguration(c.all.config)
    decreases s, c
  {
    s.constants == c &&
    s.current_state == 0 &&
    s.request_queue == [] &&
    s.max_ballot_i_sent_1a == Ballot(0, c.my_index) &&
    s.next_operation_number_to_propose == 0 &&
    s.received_1b_packets == [] &&
    s.highest_seqno_requested_by_client_this_view == map[] &&
    ElectionStateInit(s.election_state, c) &&
    s.incomplete_batch_timer == IncompleteBatchTimerOff()
  }

  predicate LProposerProcessRequest(s: LProposer, s': LProposer, packet: RslPacket)
    requires packet.msg.RslMessage_Request?
    decreases s, s', packet
  {
    ghost var val: Request := Request(packet.src, packet.msg.seqno_req, packet.msg.val);
    ElectionStateReflectReceivedRequest(s.election_state, s'.election_state, val) &&
    if s.current_state != 0 && (val.client !in s.highest_seqno_requested_by_client_this_view || val.seqno > s.highest_seqno_requested_by_client_this_view[val.client]) then s' == s.(election_state := s'.election_state, request_queue := s.request_queue + [val], highest_seqno_requested_by_client_this_view := s.highest_seqno_requested_by_client_this_view[val.client := val.seqno]) else s' == s.(election_state := s'.election_state)
  }

  predicate LProposerMaybeEnterNewViewAndSend1a(s: LProposer, s': LProposer, sent_packets: seq<RslPacket>)
    decreases s, s', sent_packets
  {
    if s.election_state.current_view.proposer_id == s.constants.my_index && BalLt(s.max_ballot_i_sent_1a, s.election_state.current_view) then
      s' == s.(current_state := 1, max_ballot_i_sent_1a := s.election_state.current_view, received_1b_packets := [], highest_seqno_requested_by_client_this_view := map[], request_queue := s.election_state.requests_received_prev_epochs + s.election_state.requests_received_this_epoch) &&
      LBroadcastToEveryone(s.constants.all.config, s.constants.my_index, RslMessage_1a(s.election_state.current_view), sent_packets)
    else
      s' == s && sent_packets == []
  }

  predicate LProposerProcess1b(s: LProposer, s': LProposer, p: RslPacket)
    requires p.msg.RslMessage_1b?
    requires p.src in s.constants.all.config.replica_ids
    requires p.msg.bal_1b == s.max_ballot_i_sent_1a
    requires s.current_state == 1
    requires forall other_packet: LPacket<NodeIdentity, RslMessage> {:trigger other_packet.src} {:trigger other_packet in s.received_1b_packets} :: other_packet in s.received_1b_packets ==> other_packet.src != p.src
    decreases s, s', p
  {
    s' == s.(received_1b_packets := s.received_1b_packets + [p])
  }

  predicate LProposerMaybeEnterPhase2(s: LProposer, s': LProposer, log_truncation_point: OperationNumber, sent_packets: seq<RslPacket>)
    decreases s, s', log_truncation_point, sent_packets
  {
    if |s.received_1b_packets| >= LByzQuorumSize(s.constants.all.config) && LSetOfMessage1bAboutBallot(s.received_1b_packets, s.max_ballot_i_sent_1a) && s.current_state == 1 then
      s' == s.(current_state := 2, next_operation_number_to_propose := log_truncation_point) &&
      LBroadcastToEveryone(s.constants.all.config, s.constants.my_index, RslMessage_StartingPhase2(s.max_ballot_i_sent_1a, log_truncation_point), sent_packets)
    else
      s' == s && sent_packets == []
  }

  predicate LProposerNominateNewValueAndSend1c(s: LProposer, s': LProposer, clock: int, log_truncation_point: OperationNumber, sent_packets: seq<RslPacket>)
    requires LProposerCanNominateUsingOperationNumber(s, log_truncation_point, s.next_operation_number_to_propose)
    requires LAllAcceptorsHadNoProposal(s.received_1b_packets, s.next_operation_number_to_propose)
    decreases s, s', clock, log_truncation_point, sent_packets
  {
    ghost var batchSize: int := if |s.request_queue| <= s.constants.all.params.max_batch_size || s.constants.all.params.max_batch_size < 0 then |s.request_queue| else s.constants.all.params.max_batch_size;
    ghost var v: seq<Request> := s.request_queue[..batchSize];
    ghost var opn: int := s.next_operation_number_to_propose;
    s' == s.(request_queue := s.request_queue[batchSize..], next_operation_number_to_propose := s.next_operation_number_to_propose + 1, incomplete_batch_timer := if |s.request_queue| > batchSize then IncompleteBatchTimerOn(UpperBoundedAddition(clock, s.constants.all.params.max_batch_delay, s.constants.all.params.max_integer_val)) else IncompleteBatchTimerOff()) &&
    LBroadcastToEveryone(s.constants.all.config, s.constants.my_index, RslMessage_1c(s.max_ballot_i_sent_1a, opn, v), sent_packets)
  }

  predicate LProposerNominateOldValueAndSend1c(s: LProposer, s': LProposer, log_truncation_point: OperationNumber, sent_packets: seq<RslPacket>)
    requires LProposerCanNominateUsingOperationNumber(s, log_truncation_point, s.next_operation_number_to_propose)
    requires !LAllAcceptorsHadNoProposal(s.received_1b_packets, s.next_operation_number_to_propose)
    decreases s, s', log_truncation_point, sent_packets
  {
    ghost var opn: int := s.next_operation_number_to_propose;
    ghost var byzq: int := LByzQuorumSize(s.constants.all.config);
    ghost var wq: int := LMinQuorumSize(s.constants.all.config);
    if exists p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in s.received_1b_packets} :: p in s.received_1b_packets && opn in p.msg.votes && LValIsSafeAt(p.msg.votes[opn].max_val, s.received_1b_packets, opn, byzq, wq) then
      ghost var p: LPacket<NodeIdentity, RslMessage> :| p in s.received_1b_packets && opn in p.msg.votes && LValIsSafeAt(p.msg.votes[opn].max_val, s.received_1b_packets, opn, byzq, wq);
      s' == s.(next_operation_number_to_propose := s.next_operation_number_to_propose + 1) &&
      LBroadcastToEveryone(s.constants.all.config, s.constants.my_index, RslMessage_1c(s.max_ballot_i_sent_1a, opn, p.msg.votes[opn].max_val), sent_packets)
    else
      s' == s && sent_packets == []
  }

  predicate LProposerMaybeNominateValueAndSend1c(s: LProposer, s': LProposer, clock: int, log_truncation_point: int, sent_packets: seq<RslPacket>)
    decreases s, s', clock, log_truncation_point, sent_packets
  {
    if !LProposerCanNominateUsingOperationNumber(s, log_truncation_point, s.next_operation_number_to_propose) then
      s' == s &&
      sent_packets == []
    else if !LAllAcceptorsHadNoProposal(s.received_1b_packets, s.next_operation_number_to_propose) then
      LProposerNominateOldValueAndSend1c(s, s', log_truncation_point, sent_packets)
    else if |s.request_queue| >= s.constants.all.params.max_batch_size || (|s.request_queue| > 0 && s.incomplete_batch_timer.IncompleteBatchTimerOn? && clock >= s.incomplete_batch_timer.when) then
      LProposerNominateNewValueAndSend1c(s, s', clock, log_truncation_point, sent_packets)
    else if |s.request_queue| > 0 && s.incomplete_batch_timer.IncompleteBatchTimerOff? then
      s' == s.(incomplete_batch_timer := IncompleteBatchTimerOn(UpperBoundedAddition(clock, s.constants.all.params.max_batch_delay, s.constants.all.params.max_integer_val))) &&
      sent_packets == []
    else
      s' == s && sent_packets == []
  }

  predicate LProposerProcessHeartbeat(s: LProposer, s': LProposer, p: RslPacket, clock: int)
    requires p.msg.RslMessage_Heartbeat?
    decreases s, s', p, clock
  {
    ElectionStateProcessHeartbeat(s.election_state, s'.election_state, p, clock) &&
    (if BalLt(s.election_state.current_view, s'.election_state.current_view) then s'.current_state == 0 && s'.request_queue == [] else s'.current_state == s.current_state && s'.request_queue == s.request_queue) &&
    s' == s.(election_state := s'.election_state, current_state := s'.current_state, request_queue := s'.request_queue)
  }

  predicate LProposerCheckForViewTimeout(s: LProposer, s': LProposer, clock: int)
    decreases s, s', clock
  {
    ElectionStateCheckForViewTimeout(s.election_state, s'.election_state, clock) &&
    s' == s.(election_state := s'.election_state)
  }

  predicate LProposerCheckForQuorumOfViewSuspicions(s: LProposer, s': LProposer, clock: int)
    decreases s, s', clock
  {
    ElectionStateCheckForQuorumOfViewSuspicions(s.election_state, s'.election_state, clock) &&
    (if BalLt(s.election_state.current_view, s'.election_state.current_view) then s'.current_state == 0 && s'.request_queue == [] else s'.current_state == s.current_state && s'.request_queue == s.request_queue) &&
    s' == s.(election_state := s'.election_state, current_state := s'.current_state, request_queue := s'.request_queue)
  }

  predicate LProposerResetViewTimerDueToExecution(s: LProposer, s': LProposer, val: RequestBatch)
    decreases s, s', val
  {
    ElectionStateReflectExecutedRequestBatch(s.election_state, s'.election_state, val) &&
    s' == s.(election_state := s'.election_state)
  }
}

module LiveByzRSL__Broadcast_i {

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Message_i

  import opened Environment_s
  predicate LBroadcastToEveryone(c: LConfiguration, myidx: int, m: RslMessage, sent_packets: seq<RslPacket>)
    decreases c, myidx, m, sent_packets
  {
    |sent_packets| == |c.replica_ids| &&
    0 <= myidx < |c.replica_ids| &&
    forall idx: int {:trigger sent_packets[idx]} {:trigger c.replica_ids[idx]} {:trigger LPacket(c.replica_ids[idx], c.replica_ids[myidx], m)} :: 
      0 <= idx < |sent_packets| ==>
        sent_packets[idx] == LPacket(c.replica_ids[idx], c.replica_ids[myidx], m)
  }
}

module LiveByzRSL__Election_i {

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__Configuration_i

  import opened Collections__Seqs_i

  import opened Common__UpperBound_s
  datatype ElectionState = ElectionState(constants: LReplicaConstants, current_view: Ballot, current_view_suspectors: set<int>, epoch_end_time: int, epoch_length: int, requests_received_this_epoch: seq<Request>, requests_received_prev_epochs: seq<Request>)

  function ComputeSuccessorView(b: Ballot, c: LConstants): Ballot
    decreases b, c
  {
    if b.proposer_id + 1 < |c.config.replica_ids| then
      Ballot(b.seqno, b.proposer_id + 1)
    else
      Ballot(b.seqno + 1, 0)
  }

  function BoundRequestSequence(s: seq<Request>, lengthBound: UpperBound): seq<Request>
    decreases s, lengthBound
  {
    if lengthBound.UpperBoundFinite? && 0 <= lengthBound.n < |s| then
      s[..lengthBound.n]
    else
      s
  }

  predicate RequestsMatch(r1: Request, r2: Request)
    decreases r1, r2
  {
    r1.Request? &&
    r2.Request? &&
    r1.client == r2.client &&
    r1.seqno == r2.seqno
  }

  predicate RequestSatisfiedBy(r1: Request, r2: Request)
    decreases r1, r2
  {
    r1.Request? &&
    r2.Request? &&
    r1.client == r2.client &&
    r1.seqno <= r2.seqno
  }

  function RemoveAllSatisfiedRequestsInSequence(s: seq<Request>, r: Request): seq<Request>
    decreases s, r
  {
    if |s| == 0 then
      []
    else if RequestSatisfiedBy(s[0], r) then
      RemoveAllSatisfiedRequestsInSequence(s[1..], r)
    else
      [s[0]] + RemoveAllSatisfiedRequestsInSequence(s[1..], r)
  }

  predicate CheckRequestValidInReqSeq(s: seq<Request>, r: Request)
    decreases s, r
  {
    exists i: Request {:trigger i.request} {:trigger RequestsMatch(i, r)} {:trigger i in s} :: 
      i in s &&
      RequestsMatch(i, r) &&
      i.request == r.request
  }

  predicate CheckRequestValid(s: ElectionState, r: Request)
    decreases s, r
  {
    CheckRequestValidInReqSeq(s.requests_received_this_epoch, r) || CheckRequestValidInReqSeq(s.requests_received_prev_epochs, r)
  }

  predicate ElectionStateInit(es: ElectionState, c: LReplicaConstants)
    requires |c.all.config.replica_ids| > 0
    decreases es, c
  {
    es.constants == c &&
    es.current_view == Ballot(1, 0) &&
    es.current_view_suspectors == {} &&
    es.epoch_end_time == 0 &&
    es.epoch_length == c.all.params.baseline_view_timeout_period &&
    es.requests_received_this_epoch == [] &&
    es.requests_received_prev_epochs == []
  }

  predicate ElectionStateProcessHeartbeat(es: ElectionState, es': ElectionState, p: RslPacket, clock: int)
    requires p.msg.RslMessage_Heartbeat?
    decreases es, es', p, clock
  {
    if p.src !in es.constants.all.config.replica_ids then
      es' == es
    else
      ghost var sender_index: int := GetReplicaIndex(p.src, es.constants.all.config); if p.msg.bal_heartbeat == es.current_view && p.msg.suspicious then es' == es.(current_view_suspectors := es.current_view_suspectors + {sender_index}) else if BalLt(es.current_view, p.msg.bal_heartbeat) then ghost var new_epoch_length: int := UpperBoundedAddition(es.epoch_length, es.epoch_length, es.constants.all.params.max_integer_val); es' == es.(current_view := p.msg.bal_heartbeat, current_view_suspectors := if p.msg.suspicious then {sender_index} else {}, epoch_length := new_epoch_length, epoch_end_time := UpperBoundedAddition(clock, new_epoch_length, es.constants.all.params.max_integer_val), requests_received_prev_epochs := BoundRequestSequence(es.requests_received_prev_epochs + es.requests_received_this_epoch, es.constants.all.params.max_integer_val), requests_received_this_epoch := []) else es' == es
  }

  predicate ElectionStateCheckForViewTimeout(es: ElectionState, es': ElectionState, clock: int)
    decreases es, es', clock
  {
    if clock < es.epoch_end_time then
      es' == es
    else if |es.requests_received_prev_epochs| == 0 then
      ghost var new_epoch_length: int := es.constants.all.params.baseline_view_timeout_period;
      es' == es.(epoch_length := new_epoch_length, epoch_end_time := UpperBoundedAddition(clock, new_epoch_length, es.constants.all.params.max_integer_val), requests_received_prev_epochs := es.requests_received_this_epoch, requests_received_this_epoch := [])
    else
      es' == es.(current_view_suspectors := es.current_view_suspectors + {es.constants.my_index}, epoch_end_time := UpperBoundedAddition(clock, es.epoch_length, es.constants.all.params.max_integer_val), requests_received_prev_epochs := BoundRequestSequence(es.requests_received_prev_epochs + es.requests_received_this_epoch, es.constants.all.params.max_integer_val), requests_received_this_epoch := [])
  }

  predicate ElectionStateCheckForQuorumOfViewSuspicions(es: ElectionState, es': ElectionState, clock: int)
    decreases es, es', clock
  {
    if |es.current_view_suspectors| < LMinQuorumSize(es.constants.all.config) || !LtUpperBound(es.current_view.seqno, es.constants.all.params.max_integer_val) then
      es' == es
    else
      ghost var new_epoch_length: int := UpperBoundedAddition(es.epoch_length, es.epoch_length, es.constants.all.params.max_integer_val); es' == es.(current_view := ComputeSuccessorView(es.current_view, es.constants.all), current_view_suspectors := {}, epoch_length := new_epoch_length, epoch_end_time := UpperBoundedAddition(clock, new_epoch_length, es.constants.all.params.max_integer_val), requests_received_prev_epochs := BoundRequestSequence(es.requests_received_prev_epochs + es.requests_received_this_epoch, es.constants.all.params.max_integer_val), requests_received_this_epoch := [])
  }

  predicate ElectionStateReflectReceivedRequest(es: ElectionState, es': ElectionState, req: Request)
    decreases es, es', req
  {
    if exists earlier_req: Request {:trigger RequestsMatch(earlier_req, req)} {:trigger earlier_req in es.requests_received_this_epoch} {:trigger earlier_req in es.requests_received_prev_epochs} :: (earlier_req in es.requests_received_prev_epochs || earlier_req in es.requests_received_this_epoch) && RequestsMatch(earlier_req, req) then
      es' == es
    else
      es' == es.(requests_received_this_epoch := BoundRequestSequence(es.requests_received_this_epoch + [req], es.constants.all.params.max_integer_val))
  }

  function RemoveExecutedRequestBatch(reqs: seq<Request>, batch: RequestBatch): seq<Request>
    decreases |batch|
  {
    if |batch| == 0 then
      reqs
    else
      RemoveExecutedRequestBatch(RemoveAllSatisfiedRequestsInSequence(reqs, batch[0]), batch[1..])
  }

  predicate ElectionStateReflectExecutedRequestBatch(es: ElectionState, es': ElectionState, batch: RequestBatch)
    decreases es, es', batch
  {
    es' == es.(requests_received_prev_epochs := RemoveExecutedRequestBatch(es.requests_received_prev_epochs, batch), requests_received_this_epoch := RemoveExecutedRequestBatch(es.requests_received_this_epoch, batch))
  }
}

module LiveByzRSL__Acceptor_i {

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__Broadcast_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__CheckValSafety_i

  import opened Collections__CountMatches_i

  import opened Environment_s

  import opened Common__UpperBound_s

  import opened Collections__Maps_i

  import opened Concrete_NodeIdentity_i
  datatype AcceptorTuple = AcceptorTuple(received_2av_packets: seq<RslPacket>)

  type Received2avs = map<OperationNumber, AcceptorTuple>

  datatype ValToBeSent2b = ValToBeSent2bKnown(v: RequestBatch, bal: Ballot) | ValToBeSent2bUnknown

  datatype LAcceptor = LAcceptor(constants: LReplicaConstants, max_bal: Ballot, votes: Votes, last_checkpointed_operation: seq<OperationNumber>, log_truncation_point: OperationNumber, received_1b_packets: seq<RslPacket>, received_2avs: Received2avs, opn_to_be_send_2b: OperationNumber, val_to_be_sent_2b: ValToBeSent2b)

  function CountMatchedValInReceived2avs(s: seq<RslPacket>, v: RequestBatch): int
    requires forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in s} :: p in s ==> p.msg.RslMessage_2av?
    decreases s, v
  {
    if |s| == 0 then
      0
    else
      CountMatchedValInReceived2avs(s[..|s| - 1], v) + if s[|s| - 1].msg.val_2av == v then 1 else 0
  }

  function CountMatchedInRequestBatches(s: seq<RequestBatch>, v: RequestBatch): int
    decreases s, v
  {
    if |s| == 0 then
      0
    else
      CountMatchedInRequestBatches(s[..|s| - 1], v) + if s[|s| - 1] == v then 1 else 0
  }

  predicate HasReceivedSame2avFromByzQuorum(r2avs: AcceptorTuple, n: int)
    requires forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in r2avs.received_2av_packets} :: p in r2avs.received_2av_packets ==> p.msg.RslMessage_2av?
    decreases r2avs, n
  {
    exists p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in r2avs.received_2av_packets} :: 
      p in r2avs.received_2av_packets &&
      CountMatchedValInReceived2avs(r2avs.received_2av_packets, p.msg.val_2av) >= n
  }

  predicate IsByzQuorumSendSame2av(vals: seq<RequestBatch>, n: int)
    decreases vals, n
  {
    exists v: RequestBatch {:trigger CountMatchedInRequestBatches(vals, v)} {:trigger v in vals} :: 
      v in vals &&
      CountMatchedInRequestBatches(vals, v) >= n
  }

  predicate HasReceived2avOfOpn(received_2avs: Received2avs, opn: OperationNumber)
    decreases received_2avs, opn
  {
    opn in received_2avs
  }

  predicate AcceptorTupleIsUniqueSeq(tup: AcceptorTuple)
    decreases tup
  {
    true &&
    forall i: int, j: int {:trigger tup.received_2av_packets[j], tup.received_2av_packets[i]} :: 
      (0 <= i < |tup.received_2av_packets| &&
      0 <= j < |tup.received_2av_packets| &&
      i != j ==>
        tup.received_2av_packets[i] != tup.received_2av_packets[j]) &&
      (0 <= i < |tup.received_2av_packets| &&
      0 <= j < |tup.received_2av_packets| &&
      i != j ==>
        tup.received_2av_packets[i].src != tup.received_2av_packets[j].src)
  }

  predicate Received2avSetCorrect(r2avs: AcceptorTuple, bal: Ballot, opn: OperationNumber, c: LConfiguration)
    decreases r2avs, bal, opn, c
  {
    |r2avs.received_2av_packets| <= |c.replica_ids| &&
    forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.src} {:trigger p.msg} {:trigger p in r2avs.received_2av_packets} :: 
      (p in r2avs.received_2av_packets ==>
        p.msg.RslMessage_2av?) &&
      (p in r2avs.received_2av_packets ==>
        p.msg.opn_2av == opn) &&
      (p in r2avs.received_2av_packets ==>
        p.msg.bal_2av == bal) &&
      (p in r2avs.received_2av_packets ==>
        p.src in c.replica_ids)
  }

  predicate AcceptorStateCorrect(r2avs: Received2avs, bal: Ballot, c: LConfiguration)
    decreases r2avs, bal, c
  {
    forall opn: int {:trigger r2avs[opn]} {:trigger opn in r2avs} :: 
      (opn in r2avs ==>
        Received2avSetCorrect(r2avs[opn], bal, opn, c)) &&
      (opn in r2avs ==>
        AcceptorTupleIsUniqueSeq(r2avs[opn]))
  }

  predicate IsLogTruncationPointValid(log_truncation_point: OperationNumber, last_checkpointed_operation: seq<OperationNumber>, config: LConfiguration)
    decreases log_truncation_point, last_checkpointed_operation, config
  {
    IsNthHighestValueInSequence(log_truncation_point, last_checkpointed_operation, LByzQuorumSize(config))
  }

  predicate RemoveVotesBeforeLogTruncationPoint(votes: Votes, votes': Votes, log_truncation_point: OperationNumber)
    decreases votes, votes', log_truncation_point
  {
    (forall opn: int {:trigger opn in votes} {:trigger opn in votes'} :: 
      opn in votes' <==> opn in votes && opn >= log_truncation_point) &&
    forall opn: int {:trigger votes[opn]} {:trigger votes'[opn]} {:trigger opn in votes'} :: 
      opn in votes' ==>
        votes'[opn] == votes[opn]
  }

  predicate LAddVoteAndRemoveOldOnes(votes: Votes, votes': Votes, new_opn: OperationNumber, new_vote: Vote, log_truncation_point: OperationNumber)
    decreases votes, votes', new_opn, new_vote, log_truncation_point
  {
    (forall opn: int {:trigger opn in votes.Keys + {new_opn}} {:trigger opn in votes'} :: 
      opn in votes' <==> opn in votes.Keys + {new_opn} && opn >= log_truncation_point) &&
    forall opn: int {:trigger votes[opn]} {:trigger votes'[opn]} {:trigger opn in votes'} :: 
      opn in votes' ==>
        votes'[opn] == if opn == new_opn then new_vote else votes[opn]
  }

  predicate LAcceptorInit(a: LAcceptor, c: LReplicaConstants)
    decreases a, c
  {
    a.constants == c &&
    a.max_bal == Ballot(0, 0) &&
    a.votes == map[] &&
    |a.last_checkpointed_operation| == |c.all.config.replica_ids| &&
    (forall idx: int {:trigger a.last_checkpointed_operation[idx]} :: 
      0 <= idx < |a.last_checkpointed_operation| ==>
        a.last_checkpointed_operation[idx] == 0) &&
    a.log_truncation_point == 0 &&
    a.received_2avs == map[] &&
    a.received_1b_packets == [] &&
    a.opn_to_be_send_2b == 0 &&
    a.val_to_be_sent_2b == ValToBeSent2bUnknown()
  }

  predicate LAcceptorMaybeEnterNewView(s: LAcceptor, s': LAcceptor)
    decreases s, s'
  {
    s' == s.(received_1b_packets := [])
  }

  predicate LAcceptorProcess1a(s: LAcceptor, s': LAcceptor, inp: RslPacket, sent_packets: seq<RslPacket>)
    requires inp.msg.RslMessage_1a?
    decreases s, s', inp, sent_packets
  {
    ghost var m: RslMessage := inp.msg;
    if inp.src in s.constants.all.config.replica_ids && BalLt(s.max_bal, m.bal_1a) && LReplicaConstantsValid(s.constants) then
      LBroadcastToEveryone(s.constants.all.config, s.constants.my_index, RslMessage_1b(m.bal_1a, s.log_truncation_point, s.votes), sent_packets) &&
      s' == s.(max_bal := m.bal_1a)
    else
      s' == s && sent_packets == []
  }

  predicate LAcceptorProcess1b(s: LAcceptor, s': LAcceptor, p: RslPacket)
    requires p.msg.RslMessage_1b?
    requires p.src in s.constants.all.config.replica_ids
    requires forall other_packet: LPacket<NodeIdentity, RslMessage> {:trigger other_packet.src} {:trigger other_packet in s.received_1b_packets} :: other_packet in s.received_1b_packets ==> other_packet.src != p.src
    decreases s, s', p
  {
    s' == s.(received_1b_packets := s.received_1b_packets + [p])
  }

  predicate LAcceptorProcess1c(s: LAcceptor, s': LAcceptor, inp: RslPacket, sent_packets: seq<RslPacket>)
    requires inp.msg.RslMessage_1c?
    requires inp.src in s.constants.all.config.replica_ids
    requires BalLeq(s.max_bal, inp.msg.bal_1c)
    requires LeqUpperBound(inp.msg.opn_1c, s.constants.all.params.max_integer_val)
    decreases s, s', inp, sent_packets
  {
    ghost var m: RslMessage := inp.msg;
    ghost var newLogTruncationPoint: int := if inp.msg.opn_1c - s.constants.all.params.max_log_length + 1 > s.log_truncation_point then inp.msg.opn_1c - s.constants.all.params.max_log_length + 1 else s.log_truncation_point;
    LBroadcastToEveryone(s.constants.all.config, s.constants.my_index, RslMessage_2av(m.bal_1c, m.opn_1c, m.val_1c), sent_packets) &&
    (if s.log_truncation_point <= inp.msg.opn_1c then true && LAddVoteAndRemoveOldOnes(s.votes, s'.votes, m.opn_1c, Vote(m.bal_1c, m.val_1c), newLogTruncationPoint) else s'.votes == s.votes) &&
    s' == s.(max_bal := m.bal_1c, log_truncation_point := newLogTruncationPoint, votes := s'.votes)
  }

  predicate LAcceptorProcess2av(s: LAcceptor, s': LAcceptor, inp: RslPacket)
    requires inp.msg.RslMessage_2av?
    decreases s, s', inp
  {
    ghost var m: RslMessage := inp.msg;
    ghost var opn: OperationNumber := m.opn_2av;
    if inp.src !in s.constants.all.config.replica_ids || BalLt(m.bal_2av, s.max_bal) then
      s' == s
    else if BalLt(s.max_bal, m.bal_2av) then
      ghost var tup': AcceptorTuple := AcceptorTuple([inp]);
      s' == s.(max_bal := m.bal_2av, received_2avs := map[opn := tup'])
    else if opn !in s.received_2avs then
      ghost var tup': AcceptorTuple := AcceptorTuple([inp]);
      s' == s.(received_2avs := s.received_2avs[opn := tup'])
    else if exists p: LPacket<NodeIdentity, RslMessage> {:trigger p.src} {:trigger p in s.received_2avs[opn].received_2av_packets} :: p in s.received_2avs[opn].received_2av_packets && p.src == inp.src then
      s' == s
    else
      ghost var tup: AcceptorTuple := s.received_2avs[opn]; ghost var tup': AcceptorTuple := tup.(received_2av_packets := tup.received_2av_packets + [inp]); s' == s.(received_2avs := s.received_2avs[opn := tup'])
  }

  predicate LAcceptorDecide2bVal(s: LAcceptor, s': LAcceptor, bal: Ballot, opn: OperationNumber, v: RequestBatch)
    requires s.opn_to_be_send_2b in s.received_2avs
    requires opn == s.opn_to_be_send_2b
    requires s.val_to_be_sent_2b.ValToBeSent2bUnknown?
    decreases s, s', bal, opn, v
  {
    true &&
    s' == s.(val_to_be_sent_2b := ValToBeSent2bKnown(v, bal))
  }

  predicate LAcceptorSent2b(s: LAcceptor, s': LAcceptor, sent_packets: seq<RslPacket>)
    requires s.val_to_be_sent_2b.ValToBeSent2bKnown?
    requires s.val_to_be_sent_2b.bal == s.max_bal
    decreases s, s', sent_packets
  {
    ghost var opn: OperationNumber := s.opn_to_be_send_2b;
    ghost var v: RequestBatch := s.val_to_be_sent_2b.v;
    ghost var bal: Ballot := s.val_to_be_sent_2b.bal;
    ghost var newLogTruncationPoint: int := if opn - s.constants.all.params.max_log_length + 1 > s.log_truncation_point then opn - s.constants.all.params.max_log_length + 1 else s.log_truncation_point;
    LBroadcastToEveryone(s.constants.all.config, s.constants.my_index, RslMessage_2b(bal, opn, v), sent_packets) &&
    (if s'.log_truncation_point <= opn then LAddVoteAndRemoveOldOnes(s.votes, s'.votes, opn, Vote(bal, v), newLogTruncationPoint) && s'.log_truncation_point == newLogTruncationPoint else s'.votes == s.votes && s'.log_truncation_point == s.log_truncation_point) &&
    s' == s.(opn_to_be_send_2b := s.opn_to_be_send_2b + 1, val_to_be_sent_2b := ValToBeSent2bUnknown(), votes := s'.votes, log_truncation_point := s'.log_truncation_point)
  }

  predicate LAcceptorForgetReceived2avs(s: LAcceptor, s': LAcceptor, opn: OperationNumber)
    decreases s, s', opn
  {
    if opn in s.received_2avs then
      s' == s.(received_2avs := RemoveElt(s.received_2avs, opn))
    else
      s' == s
  }

  predicate LAcceptorProcessHeartbeat(s: LAcceptor, s': LAcceptor, inp: RslPacket)
    requires inp.msg.RslMessage_Heartbeat?
    decreases s, s', inp
  {
    if inp.src in s.constants.all.config.replica_ids then
      ghost var sender_index: int := GetReplicaIndex(inp.src, s.constants.all.config);
      if 0 <= sender_index < |s.last_checkpointed_operation| && inp.msg.opn_ckpt > s.last_checkpointed_operation[sender_index] then
        s' == s.(last_checkpointed_operation := s.last_checkpointed_operation[sender_index := inp.msg.opn_ckpt])
      else
        s' == s
    else
      s' == s
  }

  predicate LAcceptorTruncateLog(s: LAcceptor, s': LAcceptor, opn: OperationNumber)
    decreases s, s', opn
  {
    if opn <= s.log_truncation_point then
      s' == s
    else
      RemoveVotesBeforeLogTruncationPoint(s.votes, s'.votes, opn) && s' == s.(log_truncation_point := opn, votes := s'.votes)
  }
}

module LiveByzRSL__CheckValSafety_i {

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__Broadcast_i

  import opened LiveByzRSL__Message_i

  import opened Concrete_NodeIdentity_i

  import opened Common__UpperBound_s

  import opened Collections__CountMatches_i
  function {:opaque} {:fuel 0, 0} Convert1bPacketsSeqToMsgSeq(S: seq<RslPacket>): seq<RslMessage>
    requires LSeqOfMessage1b(S)
    requires forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in S} :: p in S ==> p.msg.RslMessage_1b?
    ensures |S| == |Convert1bPacketsSeqToMsgSeq(S)|
    ensures forall m: RslMessage {:trigger m.RslMessage_1b?} {:trigger m in Convert1bPacketsSeqToMsgSeq(S)} :: m in Convert1bPacketsSeqToMsgSeq(S) ==> m.RslMessage_1b?
    decreases S
  {
    if |S| == 0 then
      []
    else
      [S[0].msg] + Convert1bPacketsSeqToMsgSeq(S[1..])
  }

  predicate LSeqOfMessage1b(S: seq<RslPacket>)
    decreases S
  {
    forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in S} :: 
      p in S ==>
        p.msg.RslMessage_1b?
  }

  predicate LSetOfMessage1bAboutBallot(S: seq<RslPacket>, b: Ballot)
    decreases S, b
  {
    LSeqOfMessage1b(S) &&
    forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in S} :: 
      p in S ==>
        p.msg.bal_1b == b
  }

  predicate LAllAcceptorsHadNoProposal(S: seq<RslPacket>, opn: OperationNumber)
    requires LSeqOfMessage1b(S)
    decreases S, opn
  {
    forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in S} :: 
      p in S ==>
        !(opn in p.msg.votes)
  }

  function CountInVotes(v: RequestBatch, c: Ballot, opn: OperationNumber, S: seq<RslPacket>): int
    requires forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in S} :: p in S ==> p.msg.RslMessage_1b?
    ensures CountInVotes(v, c, opn, S) > 0 ==> exists p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in S} :: p in S && opn in p.msg.votes && BalLeq(c, p.msg.votes[opn].max_value_bal)
    decreases v, c, opn, S
  {
    if |S| == 0 then
      0
    else
      CountInVotes(v, c, opn, S[1..]) + if opn in S[0].msg.votes && BalLeq(c, S[0].msg.votes[opn].max_value_bal) && S[0].msg.votes[opn].max_val == v then 1 else 0
  }

  predicate LSetOfMessage1b(S: seq<RslPacket>)
    decreases S
  {
    forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in S} :: 
      p in S ==>
        p.msg.RslMessage_1b?
  }

  predicate Lmax_balInS(c: Ballot, S: seq<RslPacket>, opn: OperationNumber)
    requires LSetOfMessage1b(S)
    decreases c, S, opn
  {
    forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in S} :: 
      p in S &&
      opn in p.msg.votes ==>
        BalLeq(p.msg.votes[opn].max_value_bal, c)
  }

  predicate LExistsBallotInS(v: RequestBatch, c: Ballot, S: seq<RslPacket>, opn: OperationNumber)
    requires LSetOfMessage1b(S)
    decreases v, c, S, opn
  {
    exists p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in S} :: 
      p in S &&
      opn in p.msg.votes &&
      p.msg.votes[opn].max_value_bal == c &&
      p.msg.votes[opn].max_val == v
  }

  predicate LValIsHighestNumberedProposalAtBallot(v: RequestBatch, c: Ballot, S: seq<RslPacket>, opn: OperationNumber)
    requires LSetOfMessage1b(S)
    decreases v, c, S, opn
  {
    Lmax_balInS(c, S, opn) &&
    LExistsBallotInS(v, c, S, opn)
  }

  predicate AllVotesWithLargerBalHasSameValue(v: RequestBatch, b: Ballot, p1bs: seq<RslPacket>, opn: OperationNumber)
    requires forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in p1bs} :: p in p1bs ==> p.msg.RslMessage_1b?
    decreases v, b, p1bs, opn
  {
    forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in p1bs} :: 
      p in p1bs &&
      opn in p.msg.votes &&
      BalLeq(b, p.msg.votes[opn].max_value_bal) ==>
        p.msg.votes[opn].max_val == v
  }

  predicate LValIsSafeAt(v: RequestBatch, p1bs: seq<RslPacket>, opn: OperationNumber, byzq: int, wq: int)
    requires forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in p1bs} :: p in p1bs ==> p.msg.RslMessage_1b?
    decreases v, p1bs, opn, byzq, wq
  {
    exists p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in p1bs} :: 
      p in p1bs &&
      opn in p.msg.votes &&
      CountInVotes(v, p.msg.votes[opn].max_value_bal, opn, p1bs) >= wq &&
      AllVotesWithLargerBalHasSameValue(v, p.msg.votes[opn].max_value_bal, p1bs, opn)
  }
}

module Collections__CountMatches_i {
  function method CountMatchesInSeq<T(!new)>(s: seq<T>, f: T --> bool): int
    requires forall x: T {:trigger f.requires(x)} :: f.requires(x)
    reads set _x0: T, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    decreases set _x0: T, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, s
  {
    if |s| == 0 then
      0
    else
      CountMatchesInSeq(s[1..], f) + if f(s[0]) then 1 else 0
  }

  function CountMatchesInMultiset<T(!new)>(m: multiset<T>, f: T --> bool): int
    requires forall x: T {:trigger f.requires(x)} :: f.requires(x)
    reads set _x0: T, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    decreases set _x0: T, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, m
  {
    if |m| == 0 then
      0
    else
      ghost var x: T :| x in m; CountMatchesInMultiset(m - multiset{x}, f) + if f(x) then 1 else 0
  }

  lemma /*{:_induction m, f}*/ Lemma_RemovingElementAffectsCount<T(!new)>(m: multiset<T>, f: T --> bool, x: T)
    requires forall u: T {:trigger f.requires(u)} :: f.requires(u)
    requires x in m
    ensures CountMatchesInMultiset(m, f) - CountMatchesInMultiset(m - multiset{x}, f) == if f(x) then 1 else 0
    decreases m
  {
  }

  lemma /*{:_induction s, m, f}*/ Lemma_MatchCountInSeqIsMatchCountInMultiset<T(!new)>(s: seq<T>, m: multiset<T>, f: T --> bool)
    requires forall x: T {:trigger f.requires(x)} :: f.requires(x)
    requires m == multiset(s)
    ensures CountMatchesInSeq(s, f) == CountMatchesInMultiset(m, f)
    decreases s, m
  {
  }

  predicate method IsNthHighestValueInSequence(v: int, s: seq<int>, n: int)
    decreases v, s, n
  {
    0 < n <= |s| &&
    v in s &&
    CountMatchesInSeq(s, (x: int) => x > v) < n &&
    CountMatchesInSeq(s, (x: int) => x >= v) >= n
  }

  predicate IsNthHighestValueInMultiset(v: int, m: multiset<int>, n: int)
    decreases v, m, n
  {
    0 < n <= |m| &&
    v in m &&
    CountMatchesInMultiset(m, (x: int) => x > v) < n &&
    CountMatchesInMultiset(m, (x: int) => x >= v) >= n
  }

  lemma Lemma_SequenceToMultisetPreservesIsNthHighestValue(v: int, s: seq<int>, m: multiset<int>, n: int)
    requires m == multiset(s)
    ensures IsNthHighestValueInSequence(v, s, n) <==> IsNthHighestValueInMultiset(v, m, n)
    decreases v, s, m, n
  {
  }

  lemma /*{:_induction s, f1, f2}*/ Lemma_CountMatchesInSeqSameForSameFunctions<T>(s: seq<T>, f1: T --> bool, f2: T --> bool)
    requires forall x: T {:trigger f1.requires(x)} :: f1.requires(x)
    requires forall x: T {:trigger f2.requires(x)} :: f2.requires(x)
    requires forall x: T {:trigger f2(x)} {:trigger f1(x)} :: f1(x) == f2(x)
    ensures CountMatchesInSeq(s, f1) == CountMatchesInSeq(s, f2)
    decreases s
  {
  }

  lemma /*{:_induction s, f}*/ Lemma_CountMatchesInSeqBounds<T>(s: seq<T>, f: T --> bool)
    requires forall x: T {:trigger f.requires(x)} :: f.requires(x)
    ensures 0 <= CountMatchesInSeq(s, f) <= |s|
    decreases s
  {
  }

  lemma /*{:_induction s, f}*/ Lemma_CountMatchesInSeqAll<T>(s: seq<T>, f: T --> bool)
    requires forall x: T {:trigger f.requires(x)} :: f.requires(x)
    requires forall x: T {:trigger f(x)} {:trigger x in s} :: x in s ==> f(x)
    ensures CountMatchesInSeq(s, f) == |s|
    decreases s
  {
  }

  lemma /*{:_induction s1, f1, s2, f2}*/ Lemma_CountMatchesInSeqCorrespondence<T1, T2>(s1: seq<T1>, f1: T1 --> bool, s2: seq<T2>, f2: T2 --> bool)
    requires forall x: T1 {:trigger f1.requires(x)} :: f1.requires(x)
    requires forall x: T2 {:trigger f2.requires(x)} :: f2.requires(x)
    requires |s1| == |s2|
    requires forall i: int {:trigger s2[i]} {:trigger s1[i]} :: 0 <= i < |s1| ==> f1(s1[i]) == f2(s2[i])
    ensures CountMatchesInSeq(s1, f1) == CountMatchesInSeq(s2, f2)
    decreases s1, s2
  {
  }

  function {:opaque} {:fuel 0, 0} EnumerateMatchesInSeq<T(!new)>(s: seq<T>, f: T --> bool): seq<T>
    requires forall x: T {:trigger f.requires(x)} :: f.requires(x)
    reads set _x0: T, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    ensures forall x: T {:trigger x in EnumerateMatchesInSeq(s, f)} {:trigger f(x)} {:trigger x in s} :: x in s && f(x) <==> x in EnumerateMatchesInSeq(s, f)
    ensures |EnumerateMatchesInSeq(s, f)| == CountMatchesInSeq(s, f)
    decreases set _x0: T, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, s
  {
    if |s| == 0 then
      []
    else if f(s[0]) then
      [s[0]] + EnumerateMatchesInSeq(s[1..], f)
    else
      EnumerateMatchesInSeq(s[1..], f)
  }

  function EnumerateIndicesOfMatchesInSeq_Helper<T(!new)>(s: seq<T>, f: T --> bool, offset: int): seq<int>
    requires forall x: T {:trigger f.requires(x)} :: f.requires(x)
    reads set _x0: T, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    ensures forall i: int {:trigger i in EnumerateIndicesOfMatchesInSeq_Helper(s, f, offset)} :: (i in EnumerateIndicesOfMatchesInSeq_Helper(s, f, offset) ==> offset <= i) && (i in EnumerateIndicesOfMatchesInSeq_Helper(s, f, offset) ==> i < offset + |s|)
    ensures forall i: int {:trigger s[i]} :: 0 <= i < |s| && f(s[i]) <==> i + offset in EnumerateIndicesOfMatchesInSeq_Helper(s, f, offset)
    ensures offset == 0 ==> forall i: int {:trigger i in EnumerateIndicesOfMatchesInSeq_Helper(s, f, offset)} {:trigger s[i]} :: 0 <= i < |s| && f(s[i]) <==> i in EnumerateIndicesOfMatchesInSeq_Helper(s, f, offset)
    ensures |EnumerateIndicesOfMatchesInSeq_Helper(s, f, offset)| == CountMatchesInSeq(s, f)
    decreases set _x0: T, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, s, offset
  {
    if |s| == 0 then
      []
    else if f(s[0]) then
      [offset] + EnumerateIndicesOfMatchesInSeq_Helper(s[1..], f, offset + 1)
    else
      EnumerateIndicesOfMatchesInSeq_Helper(s[1..], f, offset + 1)
  }

  function {:opaque} {:fuel 0, 0} EnumerateIndicesOfMatchesInSeq<T(!new)>(s: seq<T>, f: T --> bool): seq<int>
    requires forall x: T {:trigger f.requires(x)} :: f.requires(x)
    reads set _x0: T, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    ensures forall i: int {:trigger i in EnumerateIndicesOfMatchesInSeq(s, f)} {:trigger s[i]} :: 0 <= i < |s| && f(s[i]) <==> i in EnumerateIndicesOfMatchesInSeq(s, f)
    ensures |EnumerateIndicesOfMatchesInSeq(s, f)| == CountMatchesInSeq(s, f)
    decreases set _x0: T, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, s
  {
    EnumerateIndicesOfMatchesInSeq_Helper(s, f, 0)
  }

  function SetOfIndicesOfMatchesInSeq_Helper<T(!new)>(s: seq<T>, f: T --> bool, offset: int): set<int>
    requires forall x: T {:trigger f.requires(x)} :: f.requires(x)
    reads set _x0: T, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    ensures forall i: int {:trigger i in SetOfIndicesOfMatchesInSeq_Helper(s, f, offset)} :: (i in SetOfIndicesOfMatchesInSeq_Helper(s, f, offset) ==> offset <= i) && (i in SetOfIndicesOfMatchesInSeq_Helper(s, f, offset) ==> i < offset + |s|)
    ensures forall i: int {:trigger s[i]} :: 0 <= i < |s| && f(s[i]) <==> i + offset in SetOfIndicesOfMatchesInSeq_Helper(s, f, offset)
    ensures offset == 0 ==> forall i: int {:trigger i in SetOfIndicesOfMatchesInSeq_Helper(s, f, offset)} {:trigger s[i]} :: 0 <= i < |s| && f(s[i]) <==> i in SetOfIndicesOfMatchesInSeq_Helper(s, f, offset)
    ensures |SetOfIndicesOfMatchesInSeq_Helper(s, f, offset)| == CountMatchesInSeq(s, f)
    decreases set _x0: T, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, s, offset
  {
    if |s| == 0 then
      {}
    else if f(s[0]) then
      {offset} + SetOfIndicesOfMatchesInSeq_Helper(s[1..], f, offset + 1)
    else
      SetOfIndicesOfMatchesInSeq_Helper(s[1..], f, offset + 1)
  }

  function {:opaque} {:fuel 0, 0} SetOfIndicesOfMatchesInSeq<T(!new)>(s: seq<T>, f: T --> bool): set<int>
    requires forall x: T {:trigger f.requires(x)} :: f.requires(x)
    reads set _x0: T, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    ensures forall i: int {:trigger i in SetOfIndicesOfMatchesInSeq(s, f)} {:trigger s[i]} :: 0 <= i < |s| && f(s[i]) <==> i in SetOfIndicesOfMatchesInSeq(s, f)
    ensures |SetOfIndicesOfMatchesInSeq(s, f)| == CountMatchesInSeq(s, f)
    decreases set _x0: T, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, s
  {
    SetOfIndicesOfMatchesInSeq_Helper(s, f, 0)
  }
}

module Collections__Maps_i {
  predicate eq_map<A(!new), B>(x: map<A, B>, y: map<A, B>)
    ensures eq_map(x, y) ==> x == y
    decreases x, y
  {
    (forall a: A {:trigger a in y} {:trigger a in x} :: 
      a in x <==> a in y) &&
    forall a: A {:trigger y[a]} {:trigger x[a]} {:trigger a in x} :: 
      a in x ==>
        x[a] == y[a]
  }

  function method domain<U(!new), V>(m: map<U, V>): set<U>
    ensures forall i: U {:trigger i in m} {:trigger i in domain(m)} :: i in domain(m) <==> i in m
    decreases m
  {
    set s: U {:trigger s in m} | s in m
  }

  function union<U(!new), V>(m: map<U, V>, m': map<U, V>): map<U, V>
    requires m.Keys !! m'.Keys
    ensures forall i: U {:trigger i in m'} {:trigger i in m} {:trigger i in union(m, m')} :: i in union(m, m') <==> i in m || i in m'
    ensures forall i: U {:trigger m[i]} {:trigger union(m, m')[i]} {:trigger i in m} :: i in m ==> union(m, m')[i] == m[i]
    ensures forall i: U {:trigger m'[i]} {:trigger union(m, m')[i]} {:trigger i in m'} :: i in m' ==> union(m, m')[i] == m'[i]
    decreases m, m'
  {
    map i: U {:auto_trigger} {:trigger m'[i]} {:trigger m[i]} {:trigger i in m} {:trigger i in domain(m) + domain(m')} | i in domain(m) + domain(m') :: if i in m then m[i] else m'[i]
  }

  function method RemoveElt<U(!new), V(!new)>(m: map<U, V>, elt: U): map<U, V>
    requires elt in m
    ensures |RemoveElt(m, elt)| == |m| - 1
    ensures !(elt in RemoveElt(m, elt))
    ensures forall elt': U {:trigger elt' in m} {:trigger elt' in RemoveElt(m, elt)} :: elt' in RemoveElt(m, elt) <==> elt' in m && elt' != elt
    decreases |m|
  {
    var m': map<U, V> := map elt': U {:trigger m[elt']} {:trigger elt' in m} | elt' in m && elt' != elt :: m[elt'];
    lemma_map_remove_one(m, m', elt);
    m'
  }

  lemma lemma_non_empty_map_has_elements<S(!new), T(!new)>(m: map<S, T>)
    requires |m| > 0
    ensures exists x: S {:trigger x in m} :: x in m
    decreases m
  {
  }

  lemma lemma_MapSizeIsDomainSize<S(!new), T(!new)>(dom: set<S>, m: map<S, T>)
    requires dom == domain(m)
    ensures |m| == |dom|
    decreases dom, m
  {
  }

  lemma lemma_maps_decrease<S(!new), T(!new)>(before: map<S, T>, after: map<S, T>, item_removed: S)
    requires item_removed in before
    requires after == map s: S {:trigger before[s]} {:trigger s in before} | s in before && s != item_removed :: before[s]
    ensures |after| < |before|
    decreases before, after
  {
  }

  lemma lemma_map_remove_one<S(!new), T(!new)>(before: map<S, T>, after: map<S, T>, item_removed: S)
    requires item_removed in before
    requires after == map s: S {:trigger before[s]} {:trigger s in before} | s in before && s != item_removed :: before[s]
    ensures |after| + 1 == |before|
    decreases before, after
  {
  }

  lemma Lemma_map2equiv<K1, V>(f: map<K1, V>, g: map<K1, V>)
    requires forall k1: K1 {:trigger k1 in g} {:trigger k1 in f} :: k1 in f <==> k1 in g
    requires forall k1: K1 {:trigger g[k1]} {:trigger f[k1]} {:trigger k1 in f} :: k1 in f ==> f[k1] == g[k1]
    ensures f == g
    decreases f, g
  {
  }
}

module LiveByzRSL__Learner_i {

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__Executor_i

  import opened LiveByzRSL__Acceptor_i

  import opened Collections__Maps_i

  import opened Collections__CountMatches_i

  import opened Concrete_NodeIdentity_i
  datatype LearnerTuple = LearnerTuple(received_2bs: seq<RslPacket>)

  type LearnerState = map<OperationNumber, LearnerTuple>

  datatype LLearner = LLearner(constants: LReplicaConstants, max_ballot_seen: Ballot, unexecuted_learner_state: LearnerState)

  function CountMatchedValInReceived2bs(s: seq<RslPacket>, v: RequestBatch): int
    requires forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in s} :: p in s ==> p.msg.RslMessage_2b?
    decreases s, v
  {
    if |s| == 0 then
      0
    else
      CountMatchedValInReceived2bs(s[..|s| - 1], v) + if s[|s| - 1].msg.val_2b == v then 1 else 0
  }

  predicate IsWeakQuorumSendSame2b(vals: seq<RequestBatch>, n: int)
    decreases vals, n
  {
    exists v: RequestBatch {:trigger CountMatchedInRequestBatches(vals, v)} {:trigger v in vals} :: 
      v in vals &&
      CountMatchedInRequestBatches(vals, v) >= n
  }

  predicate HasReceivedSame2bFromWeakQuorum(tup: LearnerTuple, n: int)
    requires forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in tup.received_2bs} :: p in tup.received_2bs ==> p.msg.RslMessage_2b?
    decreases tup, n
  {
    exists p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in tup.received_2bs} :: 
      p in tup.received_2bs &&
      CountMatchedValInReceived2bs(tup.received_2bs, p.msg.val_2b) >= n
  }

  predicate LearnerTupleIsUniqueSeq(tup: LearnerTuple)
    decreases tup
  {
    true &&
    forall i: int, j: int {:trigger tup.received_2bs[j], tup.received_2bs[i]} :: 
      (0 <= i < |tup.received_2bs| &&
      0 <= j < |tup.received_2bs| &&
      i != j ==>
        tup.received_2bs[i] != tup.received_2bs[j]) &&
      (0 <= i < |tup.received_2bs| &&
      0 <= j < |tup.received_2bs| &&
      i != j ==>
        tup.received_2bs[i].src != tup.received_2bs[j].src)
  }

  predicate LearnerTupleCorrect(tup: LearnerTuple, bal: Ballot, opn: OperationNumber, c: LConfiguration)
    decreases tup, bal, opn, c
  {
    |tup.received_2bs| <= |c.replica_ids| &&
    forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.src} {:trigger p.msg} {:trigger p in tup.received_2bs} :: 
      (p in tup.received_2bs ==>
        p.msg.RslMessage_2b?) &&
      (p in tup.received_2bs ==>
        p.msg.opn_2b == opn) &&
      (p in tup.received_2bs ==>
        p.msg.bal_2b == bal) &&
      (p in tup.received_2bs ==>
        p.src in c.replica_ids)
  }

  predicate LearnerStateCorrect(ls: LearnerState, bal: Ballot, c: LConfiguration)
    decreases ls, bal, c
  {
    forall opn: int {:trigger ls[opn]} {:trigger opn in ls} :: 
      (opn in ls ==>
        LearnerTupleCorrect(ls[opn], bal, opn, c)) &&
      (opn in ls ==>
        LearnerTupleIsUniqueSeq(ls[opn]))
  }

  predicate LLearnerInit(l: LLearner, c: LReplicaConstants)
    decreases l, c
  {
    l.constants == c &&
    l.max_ballot_seen == Ballot(0, 0) &&
    l.unexecuted_learner_state == map[]
  }

  predicate LLearnerProcess2b(s: LLearner, s': LLearner, packet: RslPacket)
    requires packet.msg.RslMessage_2b?
    decreases s, s', packet
  {
    ghost var m: RslMessage := packet.msg;
    ghost var opn: OperationNumber := m.opn_2b;
    if packet.src !in s.constants.all.config.replica_ids || BalLt(m.bal_2b, s.max_ballot_seen) then
      s' == s
    else if BalLt(s.max_ballot_seen, m.bal_2b) then
      ghost var tup': LearnerTuple := LearnerTuple([packet]);
      s' == s.(max_ballot_seen := m.bal_2b, unexecuted_learner_state := map[opn := tup'])
    else if opn !in s.unexecuted_learner_state then
      ghost var tup': LearnerTuple := LearnerTuple([packet]);
      s' == s.(unexecuted_learner_state := s.unexecuted_learner_state[opn := tup'])
    else if exists p: LPacket<NodeIdentity, RslMessage> {:trigger p.src} {:trigger p in s.unexecuted_learner_state[opn].received_2bs} :: p in s.unexecuted_learner_state[opn].received_2bs && p.src == packet.src then
      s' == s
    else
      ghost var tup: LearnerTuple := s.unexecuted_learner_state[opn]; ghost var tup': LearnerTuple := tup.(received_2bs := tup.received_2bs + [packet]); s' == s.(unexecuted_learner_state := s.unexecuted_learner_state[opn := tup'])
  }

  predicate LLearnerForgetDecision(s: LLearner, s': LLearner, opn: OperationNumber)
    decreases s, s', opn
  {
    if opn in s.unexecuted_learner_state then
      s' == s.(unexecuted_learner_state := RemoveElt(s.unexecuted_learner_state, opn))
    else
      s' == s
  }

  predicate LLearnerForgetOperationsBefore(s: LLearner, s': LLearner, ops_complete: OperationNumber)
    decreases s, s', ops_complete
  {
    s' == s.(unexecuted_learner_state := map op: int {:trigger s.unexecuted_learner_state[op]} {:trigger op in s.unexecuted_learner_state} | op in s.unexecuted_learner_state && op >= ops_complete :: s.unexecuted_learner_state[op])
  }
}

module LiveByzRSL__Executor_i {

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__StateMachine_i

  import opened LiveByzRSL__Broadcast_i

  import opened AppStateMachine_i

  import opened Collections__Maps_i

  import opened Concrete_NodeIdentity_i

  import opened Environment_s

  import opened Common__UpperBound_s
  datatype OutstandingOperation = OutstandingOpKnown(v: RequestBatch, bal: Ballot) | OutstandingOpUnknown

  datatype LExecutor = LExecutor(constants: LReplicaConstants, app: AppState, ops_complete: int, max_bal_reflected: Ballot, next_op_to_execute: OutstandingOperation, reply_cache: ReplyCache)

  predicate LExecutorInit(s: LExecutor, c: LReplicaConstants)
    decreases s, c
  {
    s.constants == c &&
    s.app == AppInitialize() &&
    s.ops_complete == 0 &&
    s.max_bal_reflected == Ballot(0, 0) &&
    s.next_op_to_execute == OutstandingOpUnknown() &&
    s.reply_cache == map[]
  }

  predicate LExecutorGetDecision(s: LExecutor, s': LExecutor, bal: Ballot, opn: OperationNumber, v: RequestBatch)
    requires opn == s.ops_complete
    requires s.next_op_to_execute.OutstandingOpUnknown?
    decreases s, s', bal, opn, v
  {
    s' == s.(next_op_to_execute := OutstandingOpKnown(v, bal))
  }

  function GetPacketsFromReplies(me: NodeIdentity, requests: seq<Request>, replies: seq<Reply>): seq<RslPacket>
    requires |requests| == |replies|
    requires forall r: Reply {:trigger r.Reply?} {:trigger r in replies} :: r in replies ==> r.Reply?
    ensures forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p.src} {:trigger p in GetPacketsFromReplies(me, requests, replies)} :: (p in GetPacketsFromReplies(me, requests, replies) ==> p.src == me) && (p in GetPacketsFromReplies(me, requests, replies) ==> p.msg.RslMessage_Reply?)
    decreases me, requests, replies
  {
    if |requests| == 0 then
      []
    else
      [LPacket(requests[0].client, me, RslMessage_Reply(requests[0].seqno, replies[0].reply))] + GetPacketsFromReplies(me, requests[1..], replies[1..])
  }

  lemma /*{:_induction me, requests, replies}*/ lemma_SizeOfGetPacketsFromReplies(me: NodeIdentity, requests: seq<Request>, replies: seq<Reply>, packets: seq<RslPacket>)
    requires |requests| == |replies|
    requires forall r: Reply {:trigger r.Reply?} {:trigger r in replies} :: r in replies ==> r.Reply?
    requires packets == GetPacketsFromReplies(me, requests, replies)
    ensures |packets| == |requests|
    decreases |requests|
  {
  }

  lemma /*{:_induction me, requests, replies}*/ lemma_SpecificPacketInGetPacketsFromReplies(me: NodeIdentity, requests: seq<Request>, replies: seq<Reply>, packets: seq<RslPacket>, batch_idx: int)
    requires |requests| == |replies|
    requires forall r: Reply {:trigger r.Reply?} {:trigger r in replies} :: r in replies ==> r.Reply?
    requires 0 <= batch_idx < |requests|
    requires packets == GetPacketsFromReplies(me, requests, replies)
    ensures |packets| == |requests|
    ensures packets[batch_idx] == LPacket(requests[batch_idx].client, me, RslMessage_Reply(requests[batch_idx].seqno, replies[batch_idx].reply))
    decreases |requests|
  {
  }

  function LClientsInReplies(replies: seq<Reply>): ReplyCache
    ensures ghost var m: ReplyCache := LClientsInReplies(replies); (forall c: EndPoint {:trigger m[c]} {:trigger c in m} :: c in m ==> m[c].client == c) && forall c: EndPoint {:trigger m[c]} {:trigger c in m} :: c in m ==> exists req_idx: int {:trigger replies[req_idx]} :: 0 <= req_idx < |replies| && replies[req_idx].client == c && m[c] == replies[req_idx]
    decreases replies
  {
    if |replies| == 0 then
      map[]
    else
      LClientsInReplies(replies[1..])[replies[0].client := replies[0]]
  }

  predicate UpdateNewCache(c: ReplyCache, c': ReplyCache, replies: seq<Reply>)
    decreases c, c', replies
  {
    ghost var nc: ReplyCache := LClientsInReplies(replies);
    (forall client: EndPoint {:trigger c[client]} {:trigger c'[client]} {:trigger client in c} {:trigger client in c'} :: 
      client in c' ==>
        (client in c && c'[client] == c[client]) || exists req_idx: int {:trigger replies[req_idx]} :: 0 <= req_idx < |replies| && replies[req_idx].client == client && c'[client] == replies[req_idx]) &&
    (forall client: EndPoint {:trigger client in c} {:trigger client in nc} {:trigger client in c'} :: 
      client in c' <==> client in nc || client in c) &&
    (forall client: EndPoint {:trigger nc[client]} {:trigger c[client]} {:trigger client in c} {:trigger c'[client]} {:trigger client in c'} :: 
      client in c' ==>
        c'[client] == if client in c then c[client] else nc[client]) &&
    forall client: EndPoint {:trigger nc[client]} {:trigger c[client]} {:trigger c'[client]} {:trigger client in c'} {:trigger client in c} {:trigger client in nc} :: 
      (client in nc || client in c ==>
        client in c') &&
      (client in nc || client in c ==>
        c'[client] == if client in c then c[client] else nc[client])
  }

  predicate LExecutorExecute(s: LExecutor, s': LExecutor, sent_packets: seq<RslPacket>)
    requires s.next_op_to_execute.OutstandingOpKnown?
    requires LtUpperBound(s.ops_complete, s.constants.all.params.max_integer_val)
    requires LReplicaConstantsValid(s.constants)
    decreases s, s', sent_packets
  {
    ghost var batch: RequestBatch := s.next_op_to_execute.v;
    ghost var temp: (seq<AppState>, seq<Reply>) := HandleRequestBatch(s.app, batch);
    ghost var new_state: uint64 := temp.0[|temp.0| - 1];
    ghost var replies: seq<Reply> := temp.1;
    ghost var clients: ReplyCache := LClientsInReplies(replies);
    s'.constants == s.constants &&
    s'.app == new_state &&
    s'.ops_complete == s.ops_complete + 1 &&
    s'.max_bal_reflected == (if BalLeq(s.max_bal_reflected, s.next_op_to_execute.bal) then s.next_op_to_execute.bal else s.max_bal_reflected) &&
    s'.next_op_to_execute == OutstandingOpUnknown() &&
    UpdateNewCache(s.reply_cache, s'.reply_cache, replies) &&
    sent_packets == GetPacketsFromReplies(s.constants.all.config.replica_ids[s.constants.my_index], batch, replies)
  }

  predicate LExecutorProcessStartingPhase2(s: LExecutor, s': LExecutor, inp: RslPacket, sent_packets: seq<RslPacket>)
    requires inp.msg.RslMessage_StartingPhase2?
    decreases s, s', inp, sent_packets
  {
    if inp.src in s.constants.all.config.replica_ids && inp.msg.logTruncationPoint_2 > s.ops_complete then
      s' == s &&
      sent_packets == []
    else
      s' == s && sent_packets == []
  }

  predicate LExecutorProcessRequest(s: LExecutor, inp: RslPacket, sent_packets: seq<RslPacket>)
    requires inp.msg.RslMessage_Request?
    requires inp.src in s.reply_cache
    requires s.reply_cache[inp.src].Reply?
    requires inp.msg.seqno_req <= s.reply_cache[inp.src].seqno
    decreases s, inp, sent_packets
  {
    if inp.msg.seqno_req == s.reply_cache[inp.src].seqno && LReplicaConstantsValid(s.constants) then
      ghost var r: Reply := s.reply_cache[inp.src];
      sent_packets == [LPacket(r.client, s.constants.all.config.replica_ids[s.constants.my_index], RslMessage_Reply(r.seqno, r.reply))]
    else
      sent_packets == []
  }
}

module LiveByzRSL__StateMachine_i {

  import opened AppStateMachine_i

  import opened LiveByzRSL__Types_i
  function HandleRequest(state: AppState, request: Request): (AppState, Reply)
    decreases state, request
  {
    var (new_state: AppState, reply: AppMessage) := AppHandleRequest(state, request.request);
    (new_state, Reply(request.client, request.seqno, reply))
  }

  function {:opaque} {:fuel 0, 0} HandleRequestBatchHidden(state: AppState, batch: RequestBatch): (seq<AppState>, seq<Reply>)
    ensures var (states: seq<AppState>, replies: seq<Reply>) := HandleRequestBatchHidden(state, batch); |states| == |batch| + 1 && |replies| == |batch| && forall i: int {:trigger replies[i]} :: 0 <= i < |batch| ==> replies[i].Reply?
    decreases |batch|
  {
    if |batch| == 0 then
      ([state], [])
    else
      var (restStates: seq<AppState>, restReplies: seq<Reply>) := HandleRequestBatchHidden(state, batch[..|batch| - 1]); var (new_state: AppState, reply: AppMessage) := AppHandleRequest(restStates[|restStates| - 1], batch[|batch| - 1].request); (restStates + [new_state], restReplies + [Reply(batch[|batch| - 1].client, batch[|batch| - 1].seqno, reply)])
  }

  lemma {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ /*{:_induction state, batch}*/ lemma_HandleRequestBatchHidden(state: AppState, batch: RequestBatch, states: seq<AppState>, replies: seq<Reply>)
    requires (states, replies) == HandleRequestBatchHidden(state, batch)
    ensures states[0] == state && |states| == |batch| + 1 && |replies| == |batch| && (forall i: int {:trigger replies[i]} :: 0 <= i < |batch| ==> replies[i].Reply?) && (forall i: int, _t#0: int {:trigger batch[i], states[_t#0]} {:trigger states[i], states[_t#0]} {:trigger replies[i], states[_t#0]} | _t#0 == i + 1 :: 0 <= i && i < |batch| ==> (states[_t#0], replies[i].reply) == AppHandleRequest(states[i], batch[i].request)) && forall i: int {:trigger batch[i]} {:trigger replies[i]} :: (0 <= i < |batch| ==> replies[i].client == batch[i].client) && (0 <= i < |batch| ==> replies[i].seqno == batch[i].seqno)
    decreases |batch|
  {
  }

  lemma lemma_HandleBatchRequestSizes(state: AppState, batch: RequestBatch, states: seq<AppState>, replies: seq<Reply>)
    requires (states, replies) == HandleRequestBatch(state, batch)
    ensures states[0] == state
    ensures |states| == |batch| + 1
    ensures |replies| == |batch|
    decreases state, batch, states, replies
  {
  }

  lemma lemma_HandleBatchRequestProperties(state: AppState, batch: RequestBatch, states: seq<AppState>, replies: seq<Reply>, i: int)
    requires (states, replies) == HandleRequestBatch(state, batch)
    requires 0 <= i < |batch|
    ensures states[0] == state
    ensures |states| == |batch| + 1
    ensures |replies| == |batch|
    ensures replies[i].Reply?
    ensures var (s: AppState, r: AppMessage) := AppHandleRequest(states[i], batch[i].request); s == states[i + 1] && r == replies[i].reply
    ensures replies[i].client == batch[i].client
    ensures replies[i].seqno == batch[i].seqno
    decreases state, batch, states, replies, i
  {
  }

  lemma lemma_HandleRequestBatchTriggerHappy(state: AppState, batch: RequestBatch, states: seq<AppState>, replies: seq<Reply>)
    requires (states, replies) == HandleRequestBatch(state, batch)
    ensures states[0] == state && |states| == |batch| + 1 && |replies| == |batch| && (forall i: int {:trigger replies[i]} :: 0 <= i < |batch| ==> replies[i].Reply?) && (forall i: int, _t#0: int {:trigger batch[i], states[_t#0]} {:trigger states[i], states[_t#0]} {:trigger replies[i], states[_t#0]} | _t#0 == i + 1 :: 0 <= i && i < |batch| ==> (states[_t#0], replies[i].reply) == AppHandleRequest(states[i], batch[i].request)) && forall i: int {:trigger batch[i]} {:trigger replies[i]} :: (0 <= i < |batch| ==> replies[i].client == batch[i].client) && (0 <= i < |batch| ==> replies[i].seqno == batch[i].seqno)
    decreases state, batch, states, replies
  {
  }

  function HandleRequestBatch(state: AppState, batch: RequestBatch): (seq<AppState>, seq<Reply>)
    ensures var (states: seq<AppState>, replies: seq<Reply>) := HandleRequestBatch(state, batch); states[0] == state && |states| == |batch| + 1 && |replies| == |batch| && (forall i: int {:trigger replies[i]} :: 0 <= i < |batch| ==> replies[i].Reply?) && (forall i: int, _t#0: int {:trigger batch[i], states[_t#0]} {:trigger states[i], states[_t#0]} {:trigger replies[i], states[_t#0]} | _t#0 == i + 1 :: 0 <= i && i < |batch| ==> (states[_t#0], replies[i].reply) == AppHandleRequest(states[i], batch[i].request)) && forall i: int {:trigger batch[i]} {:trigger replies[i]} :: (0 <= i < |batch| ==> replies[i].client == batch[i].client) && (0 <= i < |batch| ==> replies[i].seqno == batch[i].seqno)
    decreases state, batch
  {
    var (states: seq<AppState>, replies: seq<Reply>) := HandleRequestBatchHidden(state, batch);
    lemma_HandleRequestBatchHidden(state, batch, states, replies);
    (states, replies)
  }
}

module LiveByzRSL__ReplicaModel_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened LiveByzRSL__AcceptorModel_i

  import opened LiveByzRSL__AppInterface_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__CTypes_i

  import opened LiveByzRSL__ElectionModel_i

  import opened LiveByzRSL__ExecutorModel_i

  import opened LiveByzRSL__LearnerModel_i

  import opened LiveByzRSL__CheckValSafetyImpl_i

  import opened LiveByzRSL__PacketParsing_i

  import opened LiveByzRSL__Proposer_i

  import opened LiveByzRSL__Learner_i

  import opened LiveByzRSL__Acceptor_i

  import opened LiveByzRSL__ProposerModel_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__ConstantsState_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__Election_i

  import opened LiveByzRSL__CheckValSafety_i

  import opened LiveByzRSL__Environment_i

  import opened Logic__Option_i

  import opened LiveByzRSL__CClockReading_i

  import opened LiveByzRSL__CConfiguration_i

  import opened Common__UpperBound_i

  import opened Impl__LiveByzRSL__Broadcast_i

  import opened LiveByzRSL__Configuration_i

  import opened Common__Util_i

  import opened Common__UdpClient_i

  import opened GenericRefinement_i

  import opened Collections__CountMatches_i

  import opened Collections__Multisets_s

  import opened Collections__Seqs_i
  datatype CReplica = CReplica(constants: CReplicaConstants, nextHeartbeatTime: int, proposer: CProposer, acceptor: CAcceptor, learner: CLearner, executor: CExecutor)

  predicate CReplicaIsValid(s: CReplica)
    decreases s
  {
    CReplicaIsAbstractable(s) &&
    CReplicaConstantsIsValid(s.constants) &&
    CProposerIsValid(s.proposer) &&
    CAcceptorIsValid(s.acceptor) &&
    CLearnerIsValid(s.learner) &&
    CExecutorIsValid(s.executor) &&
    ConstantsStayConstant(AbstractifyCReplicaToLReplica(s), s)
  }

  predicate CReplicaIsAbstractable(s: CReplica)
    decreases s
  {
    CReplicaConstantsIsAbstractable(s.constants) &&
    CProposerIsValid(s.proposer) &&
    CAcceptorIsAbstractable(s.acceptor) &&
    CLearnerIsAbstractable(s.learner) &&
    CExecutorIsAbstractable(s.executor)
  }

  function AbstractifyCReplicaToLReplica(s: CReplica): LReplica
    requires CReplicaIsAbstractable(s)
    decreases s
  {
    LReplica(AbstractifyCReplicaConstantsToLReplicaConstants(s.constants), s.nextHeartbeatTime, AbstractifyCProposerToLProposer(s.proposer), AbstractifyCAcceptorToLAcceptor(s.acceptor), AbstractifyCLearnerToLLearner(s.learner), AbstractifyCExecutorToLExecutor(s.executor))
  }

  function method CReplicaInit(c: CReplicaConstants): CReplica
    requires CReplicaConstantsIsValid(c)
    ensures var r: CReplica := CReplicaInit(c); CReplicaIsValid(r) && LReplicaInit(AbstractifyCReplicaToLReplica(r), AbstractifyCReplicaConstantsToLReplicaConstants(c))
    decreases c
  {
    var t1: CReplicaConstants := c;
    var t2: int := 0;
    var t3: CProposer := CProposerInit(c);
    var t4: CAcceptor := CAcceptorInit(c);
    var t5: CLearner := CLearnerInit(c);
    var t6: CExecutor := CExecutorInit(c);
    CReplica(t1, t2, t3, t4, t5, t6)
  }

  function method CReplicaNextProcessInvalid(s: CReplica, received_packet: CPacket): (CReplica, OutboundPackets)
    requires CReplicaIsValid(s)
    requires CPacketIsValid(received_packet)
    requires received_packet.msg.CMessage_Invalid?
    ensures var (s': CReplica, non_empty_sequential_sent_packets: OutboundPackets) := CReplicaNextProcessInvalid(s, received_packet); CReplicaIsValid(s') && OutboundPacketsIsValid(non_empty_sequential_sent_packets) && LReplicaNextProcessInvalid(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyCPacketToRslPacket(received_packet), AbstractifyOutboundCPacketsToSeqOfRslPackets(non_empty_sequential_sent_packets))
    decreases s, received_packet
  {
    var t1: CReplica := s;
    var t2: OutboundPackets := PacketSequence([]);
    (t1, t2)
  }

  function method CReplicaNextProcessRequest(s: CReplica, received_packet: CPacket): (CReplica, OutboundPackets)
    requires CReplicaIsValid(s)
    requires CPacketIsValid(received_packet)
    requires received_packet.msg.CMessage_Request?
    ensures var (s': CReplica, sequential_sent_packets: OutboundPackets) := CReplicaNextProcessRequest(s, received_packet); CReplicaIsValid(s') && Replica_Common_Postconditions(AbstractifyCReplicaToLReplica(s), s', received_packet, sequential_sent_packets) && OutboundPacketsIsValid(sequential_sent_packets) && LReplicaNextProcessRequest(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyCPacketToRslPacket(received_packet), AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets))
    decreases s, received_packet
  {
    var t1: (CReplica, OutboundPackets) := if received_packet.src in s.executor.reply_cache && s.executor.reply_cache[received_packet.src].CReply? && received_packet.msg.seqno_req <= s.executor.reply_cache[received_packet.src].seqno then var t1: OutboundPackets := CExecutorProcessRequest(s.executor, received_packet); var t2: CReplica := s; (t2, t1) else var t1: CProposer := CProposerProcessRequest(s.proposer, received_packet); var t2: OutboundPackets := PacketSequence([]); var t3: CReplica := s.(proposer := t1); (t3, t2);
    (t1.0, t1.1)
  }

  function method CReplicaNextProcess1a(s: CReplica, received_packet: CPacket): (CReplica, OutboundPackets)
    requires CReplicaIsValid(s)
    requires CPacketIsValid(received_packet)
    requires received_packet.msg.CMessage_1a?
    ensures var (s': CReplica, sequential_sent_packets: OutboundPackets) := CReplicaNextProcess1a(s, received_packet); CReplicaIsValid(s') && Replica_Common_Postconditions(AbstractifyCReplicaToLReplica(s), s', received_packet, sequential_sent_packets) && OutboundPacketsIsValid(sequential_sent_packets) && LReplicaNextProcess1a(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyCPacketToRslPacket(received_packet), AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets))
    decreases s, received_packet
  {
    var t1: (CAcceptor, OutboundPackets) := CAcceptorProcess1a(s.acceptor, received_packet);
    var t2: CReplica := s.(acceptor := t1.0);
    (t2, t1.1)
  }

  function method CReplicaNextProcess1b(s: CReplica, received_packet: CPacket): (CReplica, OutboundPackets)
    requires CReplicaIsValid(s)
    requires CPacketIsValid(received_packet)
    requires received_packet.msg.CMessage_1b?
    ensures var (s': CReplica, sent_packets: OutboundPackets) := CReplicaNextProcess1b(s, received_packet); CReplicaIsValid(s') && Replica_Common_Postconditions(AbstractifyCReplicaToLReplica(s), s', received_packet, sent_packets) && OutboundPacketsIsValid(sent_packets) && LReplicaNextProcess1b(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyCPacketToRslPacket(received_packet), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets))
    decreases s, received_packet
  {
    var t1: (CReplica, OutboundPackets) := if received_packet.src in s.proposer.constants.all.config.replica_ids && received_packet.msg.bal_1b == s.proposer.max_ballot_i_sent_1a && s.proposer.current_state == 1 && forall other_packet: CPacket {:trigger other_packet.src} {:trigger other_packet in s.proposer.received_1b_packets} :: other_packet in s.proposer.received_1b_packets ==> other_packet.src != received_packet.src then var t1: CProposer := CProposerProcess1b(s.proposer, received_packet); var t2: CAcceptor := CAcceptorTruncateLog(s.acceptor, received_packet.msg.log_truncation_point); var t3: OutboundPackets := PacketSequence([]); var t4: CReplica := s.(proposer := t1, acceptor := t2); (t4, t3) else var t1: (CReplica, OutboundPackets) := if received_packet.src in s.acceptor.constants.all.config.replica_ids && forall other_packet: CPacket {:trigger other_packet.src} {:trigger other_packet in s.acceptor.received_1b_packets} :: other_packet in s.acceptor.received_1b_packets ==> other_packet.src != received_packet.src then var t1: CAcceptor := CAcceptorProcess1b(s.acceptor, received_packet); var t2: CReplica := s.(acceptor := t1); var t3: OutboundPackets := PacketSequence([]); (t2, t3) else var t1: CReplica := s; var t2: OutboundPackets := PacketSequence([]); (t1, t2); (t1.0, t1.1);
    (t1.0, t1.1)
  }

  function method CReplicaNextProcessStartingPhase2(s: CReplica, received_packet: CPacket): (CReplica, OutboundPackets)
    requires CReplicaIsValid(s)
    requires CPacketIsValid(received_packet)
    requires received_packet.msg.CMessage_StartingPhase2?
    ensures var (s': CReplica, sequential_sent_packets: OutboundPackets) := CReplicaNextProcessStartingPhase2(s, received_packet); CReplicaIsValid(s') && Replica_Common_Postconditions(AbstractifyCReplicaToLReplica(s), s', received_packet, sequential_sent_packets) && OutboundPacketsIsValid(sequential_sent_packets) && LReplicaNextProcessStartingPhase2(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyCPacketToRslPacket(received_packet), AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets))
    decreases s, received_packet
  {
    var t1: (CExecutor, OutboundPackets) := CExecutorProcessStartingPhase2(s.executor, received_packet);
    var t2: CReplica := s.(executor := t1.0);
    (t2, t1.1)
  }

  function method CReplicaNextProcess2av(s: CReplica, received_packet: CPacket): (CReplica, OutboundPackets)
    requires CReplicaIsValid(s)
    requires CPacketIsValid(received_packet)
    requires received_packet.msg.CMessage_2av?
    ensures var (s': CReplica, sent_packets: OutboundPackets) := CReplicaNextProcess2av(s, received_packet); CReplicaIsValid(s') && Replica_Common_Postconditions(AbstractifyCReplicaToLReplica(s), s', received_packet, sent_packets) && OutboundPacketsIsValid(sent_packets) && LReplicaNextProcess2av(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyCPacketToRslPacket(received_packet), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets))
    decreases s, received_packet
  {
    var t1: (OutboundPackets, CReplica) := var opn: COperationNumber := received_packet.msg.opn_2av; var t1: (CReplica, OutboundPackets) := var src: EndPoint := received_packet.src; var t1: (OutboundPackets, CReplica) := var op_sendable: bool := s.acceptor.opn_to_be_send_2b < opn || (s.acceptor.opn_to_be_send_2b == opn && s.acceptor.val_to_be_sent_2b.CValToBeSent2bUnknown?); var t1: (CReplica, OutboundPackets) := if op_sendable && src in s.acceptor.constants.all.config.replica_ids then var t1: CAcceptor := CAcceptorProcess2av(s.acceptor, received_packet); var t2: CReplica := s.(acceptor := t1); var t3: OutboundPackets := Broadcast(CBroadcastNop); (t2, t3) else var t1: CReplica := s; var t2: OutboundPackets := Broadcast(CBroadcastNop); (t1, t2); (t1.1, t1.0); (t1.1, t1.0); (t1.1, t1.0);
    (t1.1, t1.0)
  }

  function method CReplicaNextSpontaneousMaybeSend2b(s: CReplica): (CReplica, OutboundPackets)
    requires CReplicaIsValid(s)
    ensures var (s': CReplica, sent_packets: OutboundPackets) := CReplicaNextSpontaneousMaybeSend2b(s); CReplicaIsValid(s') && Replica_Common_Postconditions_NoPacket(AbstractifyCReplicaToLReplica(s), s', sent_packets) && OutboundPacketsIsValid(sent_packets) && LReplicaNextSpontaneousMaybeSend2b(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets))
    decreases s
  {
    var t1: (CReplica, OutboundPackets) := if s.acceptor.val_to_be_sent_2b.CValToBeSent2bKnown? && s.acceptor.val_to_be_sent_2b.bal == s.acceptor.max_bal then var t1: (CAcceptor, OutboundPackets) := CAcceptorSent2b(s.acceptor); var t2: CReplica := s.(acceptor := t1.0); (t2, t1.1) else var t1: CReplica := s; var t2: OutboundPackets := Broadcast(CBroadcastNop); (t1, t2);
    (t1.0, t1.1)
  }

  function method CReplicaNextProcess2b(s: CReplica, received_packet: CPacket): (CReplica, OutboundPackets)
    requires CReplicaIsValid(s)
    requires CPacketIsValid(received_packet)
    requires received_packet.msg.CMessage_2b?
    ensures var (s': CReplica, sequential_sent_packets: OutboundPackets) := CReplicaNextProcess2b(s, received_packet); CReplicaIsValid(s') && Replica_Common_Postconditions(AbstractifyCReplicaToLReplica(s), s', received_packet, sequential_sent_packets) && OutboundPacketsIsValid(sequential_sent_packets) && LReplicaNextProcess2b(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyCPacketToRslPacket(received_packet), AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets))
    decreases s, received_packet
  {
    var t1: (CReplica, OutboundPackets) := var opn: COperationNumber := received_packet.msg.opn_2b; var t1: (CReplica, OutboundPackets) := var op_learnable: bool := s.executor.ops_complete < opn || (s.executor.ops_complete == opn && s.executor.next_op_to_execute.COutstandingOpUnknown?); var t1: (CReplica, OutboundPackets) := if op_learnable then var t1: CLearner := CLearnerProcess2b(s.learner, received_packet); var t2: OutboundPackets := PacketSequence([]); var t3: CReplica := s.(learner := t1); (t3, t2) else var t1: CReplica := s; var t2: OutboundPackets := PacketSequence([]); (t1, t2); (t1.0, t1.1); (t1.0, t1.1);
    (t1.0, t1.1)
  }

  function method CReplicaNextProcessReply(s: CReplica, received_packet: CPacket): (CReplica, OutboundPackets)
    requires CReplicaIsValid(s)
    requires CPacketIsValid(received_packet)
    requires received_packet.msg.CMessage_Reply?
    ensures var (s': CReplica, sequential_sent_packets: OutboundPackets) := CReplicaNextProcessReply(s, received_packet); CReplicaIsValid(s') && Replica_Common_Postconditions(AbstractifyCReplicaToLReplica(s), s', received_packet, sequential_sent_packets) && OutboundPacketsIsValid(sequential_sent_packets) && LReplicaNextProcessReply(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyCPacketToRslPacket(received_packet), AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets))
    decreases s, received_packet
  {
    var t1: OutboundPackets := PacketSequence([]);
    var t2: CReplica := s;
    (t2, t1)
  }

  function method CReplicaNextProcessHeartbeat(s: CReplica, received_packet: CPacket, clock: int): (CReplica, OutboundPackets)
    requires CReplicaIsValid(s)
    requires CPacketIsValid(received_packet)
    requires received_packet.msg.CMessage_Heartbeat?
    ensures var (s': CReplica, sequential_sent_packets: OutboundPackets) := CReplicaNextProcessHeartbeat(s, received_packet, clock); CReplicaIsValid(s') && Replica_Common_Postconditions(AbstractifyCReplicaToLReplica(s), s', received_packet, sequential_sent_packets) && OutboundPacketsIsValid(sequential_sent_packets) && LReplicaNextProcessHeartbeat(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyCPacketToRslPacket(received_packet), clock, AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets))
    decreases s, received_packet, clock
  {
    var t1: CProposer := CProposerProcessHeartbeat(s.proposer, received_packet, clock);
    var t2: CAcceptor := CAcceptorProcessHeartbeat(s.acceptor, received_packet);
    var t3: OutboundPackets := PacketSequence([]);
    var t4: CReplica := s.(proposer := t1, acceptor := t2);
    (t4, t3)
  }

  function method CReplicaNextSpontaneousMaybeEnterNewViewAndSend1a(s: CReplica): (CReplica, OutboundPackets)
    requires CReplicaIsValid(s)
    ensures var (s': CReplica, sent_packets: OutboundPackets) := CReplicaNextSpontaneousMaybeEnterNewViewAndSend1a(s); CReplicaIsValid(s') && Replica_Common_Postconditions_NoPacket(AbstractifyCReplicaToLReplica(s), s', sent_packets) && OutboundPacketsIsValid(sent_packets) && LReplicaNextSpontaneousMaybeEnterNewViewAndSend1a(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets))
    decreases s
  {
    var t1: (CProposer, OutboundPackets) := CProposerMaybeEnterNewViewAndSend1a(s.proposer);
    var t2: CAcceptor := CAcceptorMaybeEnterNewView(s.acceptor);
    var t3: CReplica := s.(proposer := t1.0, acceptor := t2);
    (t3, t1.1)
  }

  function method CReplicaNextSpontaneousMaybeEnterPhase2(s: CReplica): (CReplica, OutboundPackets)
    requires CReplicaIsValid(s)
    ensures var (s': CReplica, sequential_sent_packets: OutboundPackets) := CReplicaNextSpontaneousMaybeEnterPhase2(s); CReplicaIsValid(s') && Replica_Common_Postconditions_NoPacket(AbstractifyCReplicaToLReplica(s), s', sequential_sent_packets) && OutboundPacketsIsValid(sequential_sent_packets) && LReplicaNextSpontaneousMaybeEnterPhase2(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets))
    decreases s
  {
    var t1: (CProposer, OutboundPackets) := CProposerMaybeEnterPhase2(s.proposer, s.acceptor.log_truncation_point);
    var t2: CReplica := s.(proposer := t1.0);
    (t2, t1.1)
  }

  function method CReplicaNextSpontaneousMaybeExecute(s: CReplica): (CReplica, OutboundPackets)
    requires CReplicaIsValid(s)
    ensures var (s': CReplica, sent_packets: OutboundPackets) := CReplicaNextSpontaneousMaybeExecute(s); CReplicaIsValid(s') && Replica_Common_Postconditions_NoPacket(AbstractifyCReplicaToLReplica(s), s', sent_packets) && OutboundPacketsIsValid(sent_packets) && LReplicaNextSpontaneousMaybeExecute(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets))
    decreases s
  {
    var t1: (CReplica, OutboundPackets) := if s.executor.next_op_to_execute.COutstandingOpKnown? && CLtUpperBound(s.executor.ops_complete, s.executor.constants.all.params.max_integer_val) && CReplicaConstantsValid(s.executor.constants) then var t1: (CReplica, OutboundPackets) := var v: CRequestBatch := s.executor.next_op_to_execute.v; var t1: CProposer := CProposerResetViewTimerDueToExecution(s.proposer, v); var t2: CLearner := CLearnerForgetDecision(s.learner, s.executor.ops_complete); var t3: CAcceptor := CAcceptorForgetReceived2avs(s.acceptor, s.executor.ops_complete); var t4: (CExecutor, OutboundPackets) := CExecutorExecute(s.executor); var t5: CReplica := s.(acceptor := t3, proposer := t1, learner := t2, executor := t4.0); (t5, t4.1); (t1.0, t1.1) else var t1: CReplica := s; var t2: OutboundPackets := PacketSequence([]); (t1, t2);
    (t1.0, t1.1)
  }

  function method CReplicaNextReadClockMaybeSendHeartbeat(s: CReplica, clock: CClockReading): (CReplica, OutboundPackets)
    requires CReplicaIsValid(s)
    ensures var (s': CReplica, sequential_sent_packets: OutboundPackets) := CReplicaNextReadClockMaybeSendHeartbeat(s, clock); CReplicaIsValid(s') && Replica_Common_Postconditions_NoPacket(AbstractifyCReplicaToLReplica(s), s', sequential_sent_packets) && OutboundPacketsIsValid(sequential_sent_packets) && LReplicaNextReadClockMaybeSendHeartbeat(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyCClockReadingToClockReading(clock), AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets))
    decreases s, clock
  {
    var t1: (CReplica, OutboundPackets) := if clock.t < s.nextHeartbeatTime then var t1: CReplica := s; var t2: OutboundPackets := PacketSequence([]); (t1, t2) else var t1: int := UpperBoundedAdditionImpl(clock.t, s.constants.all.params.heartbeat_period, s.constants.all.params.max_integer_val); var t2: OutboundPackets := Broadcast(BuildBroadcastToEveryone(s.constants.all.config, s.constants.my_index, CMessage_Heartbeat(s.proposer.election_state.current_view, s.constants.my_index in s.proposer.election_state.current_view_suspectors, s.executor.ops_complete))); var t3: CReplica := s.(nextHeartbeatTime := t1); (t3, t2);
    (t1.0, t1.1)
  }

  function method CReplicaNextReadClockCheckForViewTimeout(s: CReplica, clock: CClockReading): (CReplica, OutboundPackets)
    requires CReplicaIsValid(s)
    ensures var (s': CReplica, sequential_sent_packets: OutboundPackets) := CReplicaNextReadClockCheckForViewTimeout(s, clock); CReplicaIsValid(s') && Replica_Common_Postconditions_NoPacket(AbstractifyCReplicaToLReplica(s), s', sequential_sent_packets) && OutboundPacketsIsValid(sequential_sent_packets) && LReplicaNextReadClockCheckForViewTimeout(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyCClockReadingToClockReading(clock), AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets))
    decreases s, clock
  {
    var t1: CProposer := CProposerCheckForViewTimeout(s.proposer, clock.t);
    var t2: OutboundPackets := PacketSequence([]);
    var t3: CReplica := s.(proposer := t1);
    (t3, t2)
  }

  function method CReplicaNextReadClockCheckForQuorumOfViewSuspicions(s: CReplica, clock: CClockReading): (CReplica, OutboundPackets)
    requires CReplicaIsValid(s)
    ensures var (s': CReplica, sequential_sent_packets: OutboundPackets) := CReplicaNextReadClockCheckForQuorumOfViewSuspicions(s, clock); CReplicaIsValid(s') && Replica_Common_Postconditions_NoPacket(AbstractifyCReplicaToLReplica(s), s', sequential_sent_packets) && OutboundPacketsIsValid(sequential_sent_packets) && LReplicaNextReadClockCheckForQuorumOfViewSuspicions(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyCClockReadingToClockReading(clock), AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets))
    decreases s, clock
  {
    var t1: CProposer := CProposerCheckForQuorumOfViewSuspicions(s.proposer, clock.t);
    var t2: OutboundPackets := PacketSequence([]);
    var t3: CReplica := s.(proposer := t1);
    (t3, t2)
  }

  method {:opaque} CReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(s: CReplica) returns (s': CReplica, sequential_sent_packets: OutboundPackets)
    requires CReplicaIsValid(s)
    ensures CReplicaIsValid(s') && Replica_Common_Postconditions_NoPacket(AbstractifyCReplicaToLReplica(s), s', sequential_sent_packets) && OutboundPacketsIsValid(sequential_sent_packets) && LReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets))
    decreases s
  {
    if exists opn: int {:trigger CIsLogTruncationPointValid(opn, s.acceptor.last_checkpointed_operation, s.constants.all.config)} {:trigger opn in s.acceptor.last_checkpointed_operation} :: opn in s.acceptor.last_checkpointed_operation && opn > s.acceptor.log_truncation_point && CIsLogTruncationPointValid(opn, s.acceptor.last_checkpointed_operation, s.constants.all.config) {
      var opn :| opn > s.acceptor.log_truncation_point && CIsLogTruncationPointValid(opn, s.acceptor.last_checkpointed_operation, s.constants.all.config);
      var newAcceptor := CAcceptorTruncateLog(s.acceptor, opn);
      s' := s.(acceptor := newAcceptor);
      sequential_sent_packets := Broadcast(CBroadcastNop);
      lemma_CReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(s, s', sequential_sent_packets);
      assert LReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets));
    } else if exists opn: int {:trigger CIsLogTruncationPointValid(opn, s.acceptor.last_checkpointed_operation, s.constants.all.config)} {:trigger opn in s.acceptor.last_checkpointed_operation} :: opn in s.acceptor.last_checkpointed_operation && opn <= s.acceptor.log_truncation_point && CIsLogTruncationPointValid(opn, s.acceptor.last_checkpointed_operation, s.constants.all.config) {
      s' := s;
      sequential_sent_packets := Broadcast(CBroadcastNop);
      lemma_CReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(s, s', sequential_sent_packets);
      assert LReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets));
    } else {
      assert !exists opn: int {:trigger CIsLogTruncationPointValid(opn, s.acceptor.last_checkpointed_operation, s.constants.all.config)} {:trigger opn in s.acceptor.last_checkpointed_operation} :: opn in s.acceptor.last_checkpointed_operation && CIsLogTruncationPointValid(opn, s.acceptor.last_checkpointed_operation, s.constants.all.config);
      s' := s;
      sequential_sent_packets := Broadcast(CBroadcastNop);
      lemma_CReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(s, s', sequential_sent_packets);
      assert LReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets));
    }
  }

  lemma {:axiom} lemma_CReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(s: CReplica, s': CReplica, sequential_sent_packets: OutboundPackets)
    requires CReplicaIsValid(s)
    ensures CReplicaIsValid(s') && Replica_Common_Postconditions_NoPacket(AbstractifyCReplicaToLReplica(s), s', sequential_sent_packets) && OutboundPacketsIsValid(sequential_sent_packets) && LReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets))
    decreases s, s', sequential_sent_packets

  lemma {:axiom} lemma_CReplicaNextProcess1c1(b1: bool, b2: bool)
    ensures b1 == b2
    decreases b1, b2

  method CReplicaNextProcess1c(s: CReplica, received_packet: CPacket)
      returns (s': CReplica, out: OutboundPackets)
    requires CReplicaIsValid(s)
    requires CPacketIsValid(received_packet)
    requires received_packet.msg.CMessage_1c?
    ensures CReplicaIsValid(s') && Replica_Common_Postconditions(AbstractifyCReplicaToLReplica(s), s', received_packet, out) && OutboundPacketsIsValid(out) && LReplicaNextProcess1c(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyCPacketToRslPacket(received_packet), AbstractifyOutboundCPacketsToSeqOfRslPackets(out))
    decreases s, received_packet
  {
    ghost var ls := AbstractifyCReplicaToLReplica(s);
    ghost var linp := AbstractifyCPacketToRslPacket(received_packet);
    var m := received_packet.msg;
    var packets_1b := s.acceptor.received_1b_packets;
    var byzq := CByzQuorumSize(s.constants.all.config);
    var wq := CMinQuorumSize(s.constants.all.config);
    var req_is_valid_from_client := true;
    ghost var lm := linp.msg;
    ghost var lreq_is_valid_from_client := forall req: Request {:trigger CheckRequestValid(ls.proposer.election_state, req)} {:trigger req in lm.val_1c} :: req in lm.val_1c ==> CheckRequestValid(ls.proposer.election_state, req);
    lemma_CReplicaNextProcess1c1(lreq_is_valid_from_client, req_is_valid_from_client);
    var req_is_safe := if s.proposer.current_state == 2 then true else if CSeqOfMessage1b(packets_1b) then CAllAcceptorsHadNoProposal(packets_1b, m.opn_1c) || CValIsSafeAt(m.val_1c, packets_1b, m.opn_1c, byzq, wq) else false;
    if received_packet.src in s.acceptor.constants.all.config.replica_ids && req_is_valid_from_client && req_is_safe && CBalLeq(s.acceptor.max_bal, m.bal_1c) && CLeqUpperBound(m.opn_1c, s.acceptor.constants.all.params.max_integer_val) {
      var (newAcceptor, outs) := CAcceptorProcess1c(s.acceptor, received_packet);
      s' := s.(acceptor := newAcceptor);
      out := outs;
    } else {
      s' := s;
      out := Broadcast(CBroadcastNop);
    }
  }

  lemma lemma_Msg2avs(r2avs: CAcceptorTuple)
    requires CAcceptorTupleIsValid(r2avs)
    requires forall p: CPacket {:trigger p.msg} {:trigger p in r2avs.received_2av_packets} :: p in r2avs.received_2av_packets ==> p.msg.CMessage_2av?
    ensures forall p: CPacket {:trigger p.msg} {:trigger p in r2avs.received_2av_packets} :: p in r2avs.received_2av_packets ==> CRequestBatchIsValid(p.msg.val_2av)
    decreases r2avs
  {
  }

  lemma /*{:_induction s}*/ lemma_AbstractifyPacketSeq(s: seq<CPacket>, ls: seq<RslPacket>)
    requires forall p: CPacket {:trigger CPacketIsAbstractable(p)} {:trigger p in s} :: p in s ==> CPacketIsAbstractable(p)
    requires ls == AbstractifySeq(s, AbstractifyCPacketToRslPacket)
    ensures forall p: CPacket {:trigger AbstractifyCPacketToRslPacket(p)} {:trigger p in s} :: p in s ==> AbstractifyCPacketToRslPacket(p) in ls
    decreases s, ls
  {
  }

  method CReplicaNextSpontaneousMaybeDecide2bVal(s: CReplica) returns (s': CReplica, sent_packets: OutboundPackets)
    requires CReplicaIsValid(s)
    ensures CReplicaIsValid(s') && Replica_Common_Postconditions_NoPacket(AbstractifyCReplicaToLReplica(s), s', sent_packets) && s.constants == s'.constants && OutboundPacketsIsValid(sent_packets) && LReplicaNextSpontaneousMaybeDecide2bVal(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets))
    decreases s
  {
    ghost var ls := AbstractifyCReplicaToLReplica(s);
    ghost var lopn := ls.acceptor.opn_to_be_send_2b;
    ghost var lquorum := LByzQuorumSize(ls.acceptor.constants.all.config);
    var opn := s.acceptor.opn_to_be_send_2b;
    var quorum := CByzQuorumSize(s.acceptor.constants.all.config);
    if s.acceptor.val_to_be_sent_2b.CValToBeSent2bUnknown? && opn in s.acceptor.received_2avs && |s.acceptor.received_2avs[opn].received_2av_packets| >= quorum && CAcceptorStateCorrect(s.acceptor.received_2avs, s.acceptor.max_bal, s.constants.all.config) && CHasReceivedSame2avFromByzQuorum(s.acceptor.received_2avs[opn], quorum) {
      var p2avs := s.acceptor.received_2avs[opn];
      lemma_Msg2avs(p2avs);
      assert forall p: CPacket {:trigger p.msg} {:trigger p in p2avs.received_2av_packets} :: p in p2avs.received_2av_packets ==> CRequestBatchIsValid(p.msg.val_2av);
      var p :| p in p2avs.received_2av_packets && CCountMatchedValInReceived2avs(p2avs.received_2av_packets, p.msg.val_2av) >= quorum;
      assert AbstractifySeq(s.acceptor.received_2avs[opn].received_2av_packets, AbstractifyCPacketToRslPacket) == ls.acceptor.received_2avs[lopn].received_2av_packets;
      lemma_AbstractifyPacketSeq(s.acceptor.received_2avs[opn].received_2av_packets, ls.acceptor.received_2avs[lopn].received_2av_packets);
      assert forall pkt: CPacket {:trigger AbstractifyCPacketToRslPacket(pkt)} {:trigger pkt in s.acceptor.received_2avs[opn].received_2av_packets} :: pkt in s.acceptor.received_2avs[opn].received_2av_packets ==> AbstractifyCPacketToRslPacket(pkt) in ls.acceptor.received_2avs[lopn].received_2av_packets;
      var newAcceptor := CAcceptorDecide2bVal(s.acceptor, s.acceptor.max_bal, opn, p.msg.val_2av);
      s' := s.(acceptor := newAcceptor);
      sent_packets := Broadcast(CBroadcastNop);
    } else {
      s' := s;
      sent_packets := Broadcast(CBroadcastNop);
    }
    assert AbstractifyCReplicaConstantsToLReplicaConstants(s'.constants) == ls.constants;
    assert ConstantsStayConstant_Replica(AbstractifyCReplicaToLReplica(s), s');
    assert OutboundPacketsHasCorrectSrc(sent_packets, s'.constants.all.config.replica_ids[s'.constants.my_index]);
    assert CReplicaConstantsIsValid(s'.constants);
    assert CReplicaIsAbstractable(s');
    assert CReplicaIsValid(s');
    assert OutboundPacketsIsValid(sent_packets);
    assert OutboundPacketsIsAbstractable(sent_packets);
  }

  lemma lemma_Msg2bs(r2bs: CLearnerTuple)
    requires CLearnerTupleIsValid(r2bs)
    requires forall p: CPacket {:trigger p.msg} {:trigger p in r2bs.received_2bs} :: p in r2bs.received_2bs ==> p.msg.CMessage_2b?
    ensures forall p: CPacket {:trigger p.msg} {:trigger p in r2bs.received_2bs} :: p in r2bs.received_2bs ==> CRequestBatchIsValid(p.msg.val_2b)
    decreases r2bs
  {
  }

  method {:opaque} CReplicaNextSpontaneousMaybeMakeDecision(s: CReplica) returns (s': CReplica, sent_packets: OutboundPackets)
    requires CReplicaIsValid(s)
    ensures CReplicaIsValid(s') && Replica_Common_Postconditions_NoPacket(AbstractifyCReplicaToLReplica(s), s', sent_packets) && s.constants == s'.constants && OutboundPacketsIsValid(sent_packets) && LReplicaNextSpontaneousMaybeMakeDecision(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets))
    decreases s
  {
    ghost var ls := AbstractifyCReplicaToLReplica(s);
    ghost var lopn := ls.executor.ops_complete;
    ghost var lquorum := LMinQuorumSize(ls.acceptor.constants.all.config);
    var opn := s.executor.ops_complete;
    var quorum := CMinQuorumSize(s.acceptor.constants.all.config);
    if s.executor.next_op_to_execute.COutstandingOpUnknown? && opn in s.learner.unexecuted_learner_state && CLearnerStateCorrect(s.learner.unexecuted_learner_state, s.learner.max_ballot_seen, s.constants.all.config) && |s.learner.unexecuted_learner_state[opn].received_2bs| >= quorum && CHasReceivedSame2bFromWeakQuorum(s.learner.unexecuted_learner_state[opn], quorum) {
      var p2bs := s.learner.unexecuted_learner_state[opn];
      lemma_Msg2bs(p2bs);
      var p :| p in s.learner.unexecuted_learner_state[opn].received_2bs && CCountMatchedValInReceived2bs(s.learner.unexecuted_learner_state[opn].received_2bs, p.msg.val_2b) >= quorum;
      assert AbstractifySeq(s.learner.unexecuted_learner_state[opn].received_2bs, AbstractifyCPacketToRslPacket) == ls.learner.unexecuted_learner_state[lopn].received_2bs;
      lemma_AbstractifyPacketSeq(s.learner.unexecuted_learner_state[opn].received_2bs, ls.learner.unexecuted_learner_state[lopn].received_2bs);
      assert forall pkt: CPacket {:trigger AbstractifyCPacketToRslPacket(pkt)} {:trigger pkt in s.learner.unexecuted_learner_state[opn].received_2bs} :: pkt in s.learner.unexecuted_learner_state[opn].received_2bs ==> AbstractifyCPacketToRslPacket(pkt) in ls.learner.unexecuted_learner_state[lopn].received_2bs;
      var newExecutor := CExecutorGetDecision(s.executor, s.learner.max_ballot_seen, opn, p.msg.val_2b);
      s' := s.(executor := newExecutor);
      sent_packets := Broadcast(CBroadcastNop);
    } else {
      s' := s;
      sent_packets := Broadcast(CBroadcastNop);
    }
    assert ConstantsStayConstant_Replica(AbstractifyCReplicaToLReplica(s), s');
    assert OutboundPacketsHasCorrectSrc(sent_packets, s'.constants.all.config.replica_ids[s'.constants.my_index]);
    assert CReplicaConstantsIsValid(s'.constants);
    assert CReplicaIsAbstractable(s');
    assert CReplicaIsValid(s');
    assert OutboundPacketsIsValid(sent_packets);
    assert OutboundPacketsIsAbstractable(sent_packets);
  }

  method CReplicaNextReadClockMaybeNominateValueAndSend1c(s: CReplica, clock: CClockReading)
      returns (s': CReplica, sequential_sent_packets: OutboundPackets)
    requires CReplicaIsValid(s)
    ensures CReplicaIsValid(s') && Replica_Common_Postconditions_NoPacket(AbstractifyCReplicaToLReplica(s), s', sequential_sent_packets) && OutboundPacketsIsValid(sequential_sent_packets) && LReplicaNextReadClockMaybeNominateValueAndSend1c(AbstractifyCReplicaToLReplica(s), AbstractifyCReplicaToLReplica(s'), AbstractifyCClockReadingToClockReading(clock), AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets))
    decreases s, clock
  {
    var newProposer, packets := CProposerMaybeNominateValueAndSend1c(s.proposer, clock.t, s.acceptor.log_truncation_point);
    s' := s.(proposer := newProposer);
    sequential_sent_packets := packets;
  }

  predicate ConstantsStayConstant(replica: LReplica, replica': CReplica)
    decreases replica, replica'
  {
    replica.constants == replica.proposer.constants &&
    replica.constants == replica.acceptor.constants &&
    replica.constants == replica.learner.constants &&
    replica.constants == replica.executor.constants &&
    replica'.constants == replica'.proposer.constants &&
    replica'.constants == replica'.acceptor.constants &&
    replica'.constants == replica'.learner.constants &&
    replica'.constants == replica'.executor.constants
  }

  predicate ConstantsStayConstant_Replica(replica: LReplica, replica': CReplica)
    requires CReplicaConstantsIsAbstractable(replica'.constants)
    decreases replica, replica'
  {
    AbstractifyCReplicaConstantsToLReplicaConstants(replica'.constants) == replica.constants &&
    replica.constants == replica.proposer.constants &&
    replica.constants == replica.acceptor.constants &&
    replica.constants == replica.learner.constants &&
    replica.constants == replica.executor.constants &&
    replica'.constants == replica'.proposer.constants &&
    replica'.constants == replica'.acceptor.constants &&
    replica'.constants == replica'.learner.constants &&
    replica'.constants == replica'.executor.constants
  }

  predicate Replica_Common_Postconditions(replica: LReplica, replica': CReplica, inp: CPacket, packets_sent: OutboundPackets)
    decreases replica, replica', inp, packets_sent
  {
    CReplicaConstantsIsValid(replica'.constants) &&
    CPacketIsSendable(inp) &&
    CReplicaIsAbstractable(replica') &&
    ConstantsStayConstant_Replica(replica, replica') &&
    CReplicaIsValid(replica') &&
    OutboundPacketsIsValid(packets_sent) &&
    OutboundPacketsHasCorrectSrc(packets_sent, replica'.constants.all.config.replica_ids[replica'.constants.my_index]) &&
    OutboundPacketsIsAbstractable(packets_sent)
  }

  predicate Replica_Common_Postconditions_NoPacket(replica: LReplica, replica': CReplica, packets_sent: OutboundPackets)
    decreases replica, replica', packets_sent
  {
    CReplicaConstantsIsValid(replica'.constants) &&
    CReplicaIsAbstractable(replica') &&
    ConstantsStayConstant_Replica(replica, replica') &&
    CReplicaIsValid(replica') &&
    OutboundPacketsIsValid(packets_sent) &&
    OutboundPacketsHasCorrectSrc(packets_sent, replica'.constants.all.config.replica_ids[replica'.constants.my_index]) &&
    OutboundPacketsIsAbstractable(packets_sent)
  }
}

module LiveByzRSL__ConstantsState_i {

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__CConfiguration_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__ParametersState_i

  import opened Native__NativeTypes_s

  import opened Native__Io_s
  datatype CConstants = CConstants(config: CConfiguration, params: CParameters)

  datatype CReplicaConstants = CReplicaConstants(my_index: int, all: CConstants)

  predicate CConstantsIsValid(s: CConstants)
    decreases s
  {
    CConstantsIsAbstractable(s) &&
    CConfigurationIsValid(s.config) &&
    CParametersIsValid(s.params)
  }

  predicate CConstantsIsAbstractable(s: CConstants)
    decreases s
  {
    CConfigurationIsAbstractable(s.config) &&
    CParametersIsAbstractable(s.params)
  }

  function AbstractifyCConstantsToLConstants(s: CConstants): LConstants
    requires CConstantsIsAbstractable(s)
    decreases s
  {
    LConstants(AbstractifyCConfigurationToLConfiguration(s.config), AbstractifyCParametersToLParameters(s.params))
  }

  predicate CReplicaConstantsIsValid(s: CReplicaConstants)
    decreases s
  {
    CReplicaConstantsIsAbstractable(s) &&
    CConstantsIsValid(s.all) &&
    0 <= s.my_index < |s.all.config.replica_ids|
  }

  predicate CReplicaConstantsIsAbstractable(s: CReplicaConstants)
    decreases s
  {
    CConstantsIsAbstractable(s.all)
  }

  function AbstractifyCReplicaConstantsToLReplicaConstants(s: CReplicaConstants): LReplicaConstants
    requires CReplicaConstantsIsAbstractable(s)
    decreases s
  {
    LReplicaConstants(s.my_index, AbstractifyCConstantsToLConstants(s.all))
  }

  function method CReplicaConstantsValid(c: CReplicaConstants): bool
    requires CReplicaConstantsIsValid(c)
    ensures CReplicaConstantsValid(c) == LReplicaConstantsValid(AbstractifyCReplicaConstantsToLReplicaConstants(c))
    decreases c
  {
    0 <= c.my_index &&
    c.my_index < |c.all.config.replica_ids|
  }

  method InitReplicaConstantsState(endPoint: EndPoint, config: CConfiguration) returns (rc: CReplicaConstants)
    requires CConfigurationIsValid(config)
    requires endPoint in config.replica_ids
    ensures CReplicaConstantsIsValid(rc)
    ensures rc.all.config.replica_ids[rc.my_index] == endPoint
    ensures rc.all.config == config
    ensures rc.all.params.max_log_length > 0
    ensures rc.all.params.max_log_length < 10000
    ensures rc.all.params == StaticParams()
    decreases endPoint, config
  {
    var params := StaticParams();
    var constants := CConstants(config, params);
    var index := CGetReplicaIndex(endPoint, config);
    rc := CReplicaConstants(index, constants);
  }
}

module LiveByzRSL__CConfiguration_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__ParametersState_i

  import opened Common__NodeIdentity_i

  import opened Common__SeqIsUniqueDef_i

  import opened Common__UdpClient_i

  import opened Collections__Seqs_i

  import opened GenericRefinement_i
  datatype CConfiguration = CConfiguration(replica_ids: seq<EndPoint>)

  predicate CConfigurationIsValid(s: CConfiguration)
    decreases s
  {
    CConfigurationIsAbstractable(s) &&
    (forall i: EndPoint {:trigger EndPointIsValid(i)} {:trigger i in s.replica_ids} :: 
      i in s.replica_ids ==>
        EndPointIsValid(i)) &&
    SeqIsValid(s.replica_ids, EndPointIsValid) &&
    0 < |s.replica_ids| < 18446744073709551615 &&
    (forall i: int, j: int {:trigger CReplicasDistinct(s.replica_ids, i, j)} :: 
      CReplicasDistinct(s.replica_ids, i, j)) &&
    (forall i: int, j: int {:trigger s.replica_ids[j], s.replica_ids[i]} :: 
      0 <= i < |s.replica_ids| &&
      0 <= j < |s.replica_ids| &&
      s.replica_ids[i] == s.replica_ids[j] ==>
        i == j) &&
    LMinQuorumSize(AbstractifyCConfigurationToLConfiguration(s)) <= |s.replica_ids|
  }

  predicate CConfigurationIsAbstractable(s: CConfiguration)
    decreases s
  {
    (forall i: EndPoint {:trigger EndPointIsAbstractable(i)} {:trigger i.EndPoint?} {:trigger i in s.replica_ids} :: 
      (i in s.replica_ids ==>
        i.EndPoint?) &&
      (i in s.replica_ids ==>
        EndPointIsAbstractable(i))) &&
    SeqIsUnique(s.replica_ids)
  }

  function AbstractifyCConfigurationToLConfiguration(s: CConfiguration): LConfiguration
    requires CConfigurationIsAbstractable(s)
    decreases s
  {
    LConfiguration({}, AbstractifySeq(s.replica_ids, AbstractifyEndPointToNodeIdentity))
  }

  function method CMinQuorumSize(c: CConfiguration): int
    requires CConfigurationIsValid(c)
    ensures var lr: int := LMinQuorumSize(AbstractifyCConfigurationToLConfiguration(c)); var cr: int := CMinQuorumSize(c); cr == lr
    decreases c
  {
    |c.replica_ids| / 2 + 1
  }

  function method CByzQuorumSize(c: CConfiguration): int
    requires CConfigurationIsValid(c)
    ensures var lr: int := LByzQuorumSize(AbstractifyCConfigurationToLConfiguration(c)); var cr: int := CByzQuorumSize(c); cr == lr
    decreases c
  {
    2 * |c.replica_ids| / 3 + 1
  }

  function method CReplicasDistinct(replica_ids: seq<EndPoint>, i: int, j: int): bool
    requires forall i: EndPoint {:trigger EndPointIsValid(i)} {:trigger i in replica_ids} :: i in replica_ids ==> EndPointIsValid(i)
    ensures CReplicasDistinct(replica_ids, i, j) == ReplicasDistinct(AbstractifySeq(replica_ids, AbstractifyEndPointToNodeIdentity), i, j)
    decreases replica_ids, i, j
  {
    0 <= i &&
    i < |replica_ids| &&
    0 <= j &&
    j < |replica_ids| &&
    replica_ids[i] == replica_ids[j] ==>
      i == j
  }

  function method CReplicasIsUnique(replica_ids: seq<EndPoint>): bool
    requires forall i: EndPoint {:trigger EndPointIsValid(i)} {:trigger i in replica_ids} :: i in replica_ids ==> EndPointIsValid(i)
    ensures var lr: bool := ReplicasIsUnique(AbstractifySeq(replica_ids, AbstractifyEndPointToNodeIdentity)); var cr: bool := CReplicasIsUnique(replica_ids); cr == lr
    decreases replica_ids
  {
    forall i: int, j: int {:trigger replica_ids[j], replica_ids[i]} :: 
      0 <= i &&
      i < |replica_ids| &&
      0 <= j &&
      j < |replica_ids| &&
      replica_ids[i] == replica_ids[j] ==>
        i == j
  }

  function method CIsReplicaIndex(idx: int, id: EndPoint, c: CConfiguration): bool
    requires EndPointIsValid(id)
    requires CConfigurationIsValid(c)
    ensures var lr: bool := IsReplicaIndex(idx, AbstractifyEndPointToNodeIdentity(id), AbstractifyCConfigurationToLConfiguration(c)); var cr: bool := CIsReplicaIndex(idx, id, c); cr == lr
    decreases idx, id, c
  {
    0 <= idx &&
    idx < |c.replica_ids| &&
    c.replica_ids[idx] == id
  }

  function method CGetReplicaIndex(id: EndPoint, c: CConfiguration): int
    requires EndPointIsValid(id)
    requires CConfigurationIsValid(c)
    requires id in c.replica_ids
    ensures var idx: int := CGetReplicaIndex(id, c); CIsReplicaIndex(idx, id, c)
    ensures var lr: int := GetReplicaIndex(AbstractifyEndPointToNodeIdentity(id), AbstractifyCConfigurationToLConfiguration(c)); var cr: int := CGetReplicaIndex(id, c); cr == lr
    decreases id, c
  {
    FindIndexInSeq(c.replica_ids, id)
  }

  predicate ReplicaIndexValid(idx: int, c: CConfiguration)
    decreases idx, c
  {
    true &&
    0 <= idx < |c.replica_ids|
  }
}

module Common__NodeIdentity_i {

  import opened Native__NativeTypes_s

  import opened Native__Io_s

  import opened Common__Util_i

  import opened Common__UdpClient_i

  import opened Common__SeqIsUniqueDef_i

  import opened Common__SeqIsUnique_i

  import opened Concrete_NodeIdentity_i

  import opened GenericRefinement_i

  import opened Collections__Sets_i

  import opened Math__power2_s

  import opened Math__power2_i
  function {:opaque} {:fuel 0, 0} AbstractifySeqOfUint64sToSeqOfInts(s: seq<uint64>): seq<int>
    ensures |AbstractifySeqOfUint64sToSeqOfInts(s)| == |s|
    ensures forall i: int {:trigger AbstractifySeqOfUint64sToSeqOfInts(s)[i]} {:trigger s[i]} :: 0 <= i < |s| ==> s[i] as int == AbstractifySeqOfUint64sToSeqOfInts(s)[i]
    decreases s
  {
    MapSeqToSeq(s, uint64_to_int)
  }

  function {:opaque} {:fuel 0, 0} AbstractifySeqOfUint64sToSetOfInts(s: seq<uint64>): set<int>
    requires SeqIsUnique(s)
    ensures forall x: uint64 {:trigger x in s} :: x in s ==> x as int in AbstractifySeqOfUint64sToSetOfInts(s)
    decreases s
  {
    ghost var unique_set: set<uint64> := UniqueSeqToSet(s);
    set i: uint64 {:trigger i in unique_set} | i in unique_set :: i as int
  }

  lemma lemma_AbstractifySeqOfUint64sToSetOfInts_properties(s: seq<uint64>)
    requires SeqIsUnique(s)
    ensures |AbstractifySeqOfUint64sToSetOfInts(s)| == |s|
    ensures forall i: uint64 {:auto_trigger} {:trigger i in s} :: i in s <==> i as int in AbstractifySeqOfUint64sToSetOfInts(s)
    decreases s
  {
  }

  lemma lemma_AbstractifySeqOfUint64sToSetOfInts_append(original_seq: seq<uint64>, new_index: uint64)
    requires SeqIsUnique(original_seq)
    ensures ghost var r_original_set: set<int> := AbstractifySeqOfUint64sToSetOfInts(original_seq); AbstractifySeqOfUint64sToSetOfInts(AppendToUniqueSeqMaybe(original_seq, new_index)) == r_original_set + {new_index as int}
    decreases original_seq, new_index
  {
  }

  predicate EndPointIsValid(endpoint: EndPoint)
    decreases endpoint
  {
    EndPointIsAbstractable(endpoint)
  }

  predicate EndPointIsAbstractable(endpoint: EndPoint)
    decreases endpoint
  {
    EndPointIsValidIPV4(endpoint)
  }

  function AbstractifyEndPointToNodeIdentity(endpoint: EndPoint): NodeIdentity
    decreases endpoint
  {
    endpoint
  }

  predicate Uint64IsAbstractableToNodeIdentity(id: uint64)
    decreases id
  {
    EndPointUint64Representation(id)
  }

  predicate SeqOfEndPointsIsAbstractable(endPoints: seq<EndPoint>)
    decreases endPoints
  {
    forall e: EndPoint {:trigger EndPointIsValidIPV4(e)} {:trigger e in endPoints} :: 
      e in endPoints ==>
        EndPointIsValidIPV4(e)
  }

  predicate SetOfEndPointsIsAbstractable(endPoints: set<EndPoint>)
    decreases endPoints
  {
    forall e: EndPoint {:trigger EndPointIsAbstractable(e)} {:trigger e in endPoints} :: 
      e in endPoints ==>
        EndPointIsAbstractable(e)
  }

  function {:opaque} {:fuel 0, 0} AbstractifyEndPointsToNodeIdentities(endPoints: seq<EndPoint>): seq<NodeIdentity>
    requires forall e: EndPoint {:trigger EndPointIsValidIPV4(e)} {:trigger e in endPoints} :: e in endPoints ==> EndPointIsValidIPV4(e)
    ensures |AbstractifyEndPointsToNodeIdentities(endPoints)| == |endPoints|
    ensures forall i: int {:trigger AbstractifyEndPointsToNodeIdentities(endPoints)[i]} {:trigger endPoints[i]} :: 0 <= i < |endPoints| ==> AbstractifyEndPointToNodeIdentity(endPoints[i]) == AbstractifyEndPointsToNodeIdentities(endPoints)[i]
    decreases endPoints
  {
    if |endPoints| == 0 then
      []
    else
      [AbstractifyEndPointToNodeIdentity(endPoints[0])] + AbstractifyEndPointsToNodeIdentities(endPoints[1..])
  }

  function AbstractifyEndPointsToNodeIdentitiesSet(endPoints: set<EndPoint>): set<NodeIdentity>
    requires forall e: EndPoint {:trigger EndPointIsAbstractable(e)} {:trigger e in endPoints} :: e in endPoints ==> EndPointIsAbstractable(e)
    decreases endPoints
  {
    ghost var ss: set<NodeIdentity> := set s: EndPoint {:trigger AbstractifyEndPointToNodeIdentity(s)} {:trigger s in endPoints} | s in endPoints :: AbstractifyEndPointToNodeIdentity(s);
    ss
  }

  predicate EndPointSeqRepresentation(s: seq<byte>)
    decreases s
  {
    |s| == 8 &&
    s[0] == 0 &&
    s[1] == 0
  }

  predicate EndPointUint64Representation(u: uint64)
    decreases u
  {
    u <= 281474976710655
  }

  lemma EndPointRepresentations()
    ensures forall u: uint64 {:trigger Uint64ToSeqByte(u)} {:trigger EndPointUint64Representation(u)} :: EndPointUint64Representation(u) ==> EndPointSeqRepresentation(Uint64ToSeqByte(u))
  {
  }

  function method {:opaque} {:fuel 0, 0} ConvertEndPointToSeqByte(e: EndPoint): seq<byte>
    requires EndPointIsValidIPV4(e)
    ensures EndPointSeqRepresentation(ConvertEndPointToSeqByte(e))
    decreases e
  {
    [0, 0] + e.addr + Uint16ToSeqByte(e.port)
  }

  function method {:opaque} {:fuel 0, 0} ConvertSeqByteToEndPoint(s: seq<byte>): EndPoint
    requires EndPointSeqRepresentation(s)
    ensures EndPointIsValidIPV4(ConvertSeqByteToEndPoint(s))
    decreases s
  {
    EndPoint(s[2 .. 6], SeqByteToUint16(s[6..]))
  }

  lemma {:timeLimitMultiplier 3} /*{:_timeLimit 30}*/ EndPointSeqRepresentations()
    ensures forall s: seq<byte> {:trigger ConvertSeqByteToEndPoint(s)} {:trigger EndPointSeqRepresentation(s)} :: EndPointSeqRepresentation(s) ==> ConvertEndPointToSeqByte(ConvertSeqByteToEndPoint(s)) == s
    ensures forall e: EndPoint {:trigger ConvertEndPointToSeqByte(e)} {:trigger EndPointIsValidIPV4(e)} :: EndPointIsValidIPV4(e) ==> ConvertSeqByteToEndPoint(ConvertEndPointToSeqByte(e)) == e
  {
  }

  function method {:opaque} {:fuel 0, 0} ConvertEndPointToUint64(e: EndPoint): uint64
    requires EndPointIsValidIPV4(e)
    ensures EndPointUint64Representation(ConvertEndPointToUint64(e))
    decreases e
  {
    SeqByteToUint64(ConvertEndPointToSeqByte(e))
  }

  function method {:opaque} {:fuel 0, 0} ConvertUint64ToEndPoint(u: uint64): EndPoint
    requires EndPointUint64Representation(u)
    ensures EndPointIsValidIPV4(ConvertUint64ToEndPoint(u))
    decreases u
  {
    EndPointRepresentations();
    ConvertSeqByteToEndPoint(Uint64ToSeqByte(u))
  }

  lemma lemma_ConvertUint64ToNodeIdentity_injective_forall()
    ensures forall u1: uint64, u2: uint64 {:trigger AbstractifyUint64ToNodeIdentity(u2), AbstractifyUint64ToNodeIdentity(u1)} {:trigger AbstractifyUint64ToNodeIdentity(u2), EndPointUint64Representation(u1)} {:trigger AbstractifyUint64ToNodeIdentity(u1), EndPointUint64Representation(u2)} {:trigger EndPointUint64Representation(u2), EndPointUint64Representation(u1)} :: EndPointUint64Representation(u1) && EndPointUint64Representation(u2) && AbstractifyUint64ToNodeIdentity(u1) == AbstractifyUint64ToNodeIdentity(u2) ==> u1 == u2
  {
  }

  lemma Uint64EndPointRelationships()
    ensures forall u: uint64 {:trigger ConvertUint64ToEndPoint(u)} {:trigger EndPointUint64Representation(u)} :: (EndPointUint64Representation(u) ==> EndPointIsValidIPV4(ConvertUint64ToEndPoint(u))) && (EndPointUint64Representation(u) ==> ConvertEndPointToUint64(ConvertUint64ToEndPoint(u)) == u)
    ensures forall e: EndPoint {:trigger ConvertEndPointToUint64(e)} {:trigger EndPointIsValidIPV4(e)} :: EndPointIsValidIPV4(e) ==> ConvertUint64ToEndPoint(ConvertEndPointToUint64(e)) == e
  {
  }

  lemma lemma_Uint64EndPointRelationships()
    ensures forall u: uint64 {:trigger ConvertEndPointToUint64(ConvertUint64ToEndPoint(u))} :: (EndPointUint64Representation(u) ==> EndPointIsValidIPV4(ConvertUint64ToEndPoint(u))) && (EndPointUint64Representation(u) ==> ConvertEndPointToUint64(ConvertUint64ToEndPoint(u)) == u)
    ensures forall e: EndPoint {:trigger ConvertUint64ToEndPoint(ConvertEndPointToUint64(e))} :: EndPointIsValidIPV4(e) ==> ConvertUint64ToEndPoint(ConvertEndPointToUint64(e)) == e
  {
  }

  function AbstractifyUint64ToNodeIdentity(u: uint64): NodeIdentity
    requires EndPointUint64Representation(u)
    decreases u
  {
    reveal ConvertUint64ToEndPoint();
    AbstractifyEndPointToNodeIdentity(ConvertUint64ToEndPoint(u))
  }

  lemma lemma_ConvertUint64ToNodeIdentity_injective(u1: uint64, u2: uint64)
    requires EndPointUint64Representation(u1) && EndPointUint64Representation(u2)
    requires AbstractifyUint64ToNodeIdentity(u1) == AbstractifyUint64ToNodeIdentity(u2)
    ensures u1 == u2
    decreases u1, u2
  {
  }

  lemma lemma_AbstractifyEndPointToNodeIdentity_injective(e1: EndPoint, e2: EndPoint)
    requires EndPointIsValidIPV4(e1) && EndPointIsValidIPV4(e2)
    requires AbstractifyEndPointToNodeIdentity(e1) == AbstractifyEndPointToNodeIdentity(e2)
    ensures e1 == e2
    decreases e1, e2
  {
  }

  lemma lemma_AbstractifyEndPointToNodeIdentity_injective_forall()
    ensures forall e1: EndPoint, e2: EndPoint {:trigger AbstractifyEndPointToNodeIdentity(e1), AbstractifyEndPointToNodeIdentity(e2)} :: EndPointIsValidIPV4(e1) && EndPointIsValidIPV4(e2) && AbstractifyEndPointToNodeIdentity(e1) == AbstractifyEndPointToNodeIdentity(e2) ==> e1 == e2
  {
  }

  lemma lemma_seqs_set_cardinality_EndPoint(Q: seq<EndPoint>, S: set<EndPoint>)
    requires SeqIsUnique(Q)
    requires S == set e: EndPoint {:trigger e in Q} | e in Q
    ensures |Q| == |S|
    decreases |Q|
  {
  }

  lemma lemma_sets_cardinality_EndPoint(S: set<EndPoint>, T: set<NodeIdentity>)
    requires forall e: EndPoint {:trigger EndPointIsValidIPV4(e)} {:trigger e in S} :: e in S ==> EndPointIsValidIPV4(e)
    requires T == set e: EndPoint {:trigger AbstractifyEndPointToNodeIdentity(e)} {:trigger e in S} | e in S :: AbstractifyEndPointToNodeIdentity(e)
    ensures |S| == |T|
    decreases |S|
  {
  }

  lemma /*{:_induction endpoints}*/ lemma_AbstractifyEndPointsToNodeIdentities_properties(endpoints: seq<EndPoint>)
    requires SeqIsUnique(endpoints)
    requires SeqOfEndPointsIsAbstractable(endpoints)
    ensures |AbstractifyEndPointsToNodeIdentities(endpoints)| == |endpoints|
    ensures forall e: EndPoint {:trigger AbstractifyEndPointToNodeIdentity(e)} {:trigger e in endpoints} :: e in endpoints ==> AbstractifyEndPointToNodeIdentity(e) in AbstractifyEndPointsToNodeIdentities(endpoints)
    ensures forall e: EndPoint {:trigger AbstractifyEndPointToNodeIdentity(e)} {:trigger e in endpoints} {:trigger EndPointIsValidIPV4(e)} :: EndPointIsValidIPV4(e) ==> (e in endpoints <==> AbstractifyEndPointToNodeIdentity(e) in AbstractifyEndPointsToNodeIdentities(endpoints))
    decreases endpoints
  {
  }

  lemma /*{:_induction s1, s2}*/ lemma_AbstractifyEndPointsToNodeIdentities_injective_elements(s1: seq<EndPoint>, s2: seq<EndPoint>)
    requires forall e: EndPoint {:trigger EndPointIsValidIPV4(e)} {:trigger e in s1} :: e in s1 ==> EndPointIsValidIPV4(e)
    requires forall e: EndPoint {:trigger EndPointIsValidIPV4(e)} {:trigger e in s2} :: e in s2 ==> EndPointIsValidIPV4(e)
    requires AbstractifyEndPointsToNodeIdentities(s1) == AbstractifyEndPointsToNodeIdentities(s2)
    ensures forall e: EndPoint {:trigger e in s2} {:trigger e in s1} :: e in s1 <==> e in s2
    decreases s1, s2
  {
  }

  lemma /*{:_induction s1, s2}*/ lemma_AbstractifyEndPointsToNodeIdentities_injective(s1: seq<EndPoint>, s2: seq<EndPoint>)
    requires forall e: EndPoint {:trigger EndPointIsValidIPV4(e)} {:trigger e in s1} :: e in s1 ==> EndPointIsValidIPV4(e)
    requires forall e: EndPoint {:trigger EndPointIsValidIPV4(e)} {:trigger e in s2} :: e in s2 ==> EndPointIsValidIPV4(e)
    requires AbstractifyEndPointsToNodeIdentities(s1) == AbstractifyEndPointsToNodeIdentities(s2)
    ensures s1 == s2
    decreases s1, s2
  {
  }

  predicate NodeIdentityIsRefinable(id: NodeIdentity)
    decreases id
  {
    exists ep: EndPoint {:trigger AbstractifyEndPointToNodeIdentity(ep)} {:trigger EndPointIsValidIPV4(ep)} :: 
      EndPointIsValidIPV4(ep) &&
      AbstractifyEndPointToNodeIdentity(ep) == id
  }

  function {:opaque} {:fuel 0, 0} AbstractifyNodeIdentityToEndPoint(id: NodeIdentity): EndPoint
    ensures NodeIdentityIsRefinable(id) ==> EndPointIsValidIPV4(AbstractifyNodeIdentityToEndPoint(id))
    ensures NodeIdentityIsRefinable(id) ==> AbstractifyEndPointToNodeIdentity(AbstractifyNodeIdentityToEndPoint(id)) == id
    decreases id
  {
    if NodeIdentityIsRefinable(id) then
      ghost var ep: EndPoint :| EndPointIsValidIPV4(ep) && AbstractifyEndPointToNodeIdentity(ep) == id;
      ep
    else
      ghost var e: EndPoint :| true; e
  }
}

module Common__Util_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened Native__NativeTypes_i

  import opened Math__power2_s

  import opened Math__power2_i

  import opened Math__div_i
  function method ShouldPrintProfilingInfo(): bool
  {
    false
  }

  function method ShouldPrintProgress(): bool
  {
    false
  }

  method seqToArray_slow<A(0)>(s: seq<A>) returns (a: array<A>)
    ensures a[..] == s
    decreases s
  {
    var len := |s|;
    a := new A[len];
    var i := 0;
    while i < len
      invariant 0 <= i <= len
      invariant a[..i] == s[..i]
      decreases len - i
    {
      a[i] := s[i];
      i := i + 1;
    }
  }

  method seqIntoArrayOpt<A>(s: seq<A>, a: array<A>)
    requires |s| == a.Length
    requires |s| < 18446744073709551616
    modifies a
    ensures a[..] == s
    decreases s, a
  {
    var i: uint64 := 0;
    while i < |s| as uint64
      invariant 0 <= i as int <= a.Length
      invariant a[..] == s[0 .. i] + old(a[i..])
      decreases |s| as uint64 as int - i as int
    {
      a[i] := s[i];
      i := i + 1;
    }
  }

  method seqToArrayOpt<A(0)>(s: seq<A>) returns (a: array<A>)
    requires |s| < 18446744073709551616
    ensures a[..] == s
    ensures fresh(a)
    decreases s
  {
    a := new A[|s| as uint64];
    seqIntoArrayOpt(s, a);
  }

  method seqIntoArrayChar(s: seq<char>, a: array<char>)
    requires |s| == a.Length
    requires |s| < 18446744073709551616
    modifies a
    ensures a[..] == s
    decreases s, a
  {
    var i: uint64 := 0;
    while i < |s| as uint64
      invariant 0 <= i as int <= a.Length
      invariant a[..] == s[0 .. i] + old(a[i..])
      decreases |s| as uint64 as int - i as int
    {
      a[i] := s[i];
      i := i + 1;
    }
  }

  method RecordTimingSeq(name: seq<char>, start: uint64, end: uint64)
    requires 0 < |name| < 18446744073709551616
    decreases name, start, end
  {
    if ShouldPrintProfilingInfo() {
      var name_array := new char[|name|];
      seqIntoArrayChar(name, name_array);
      var time: uint64;
      if start <= end {
        time := end - start;
      } else {
        time := 18446744073709551615;
      }
      Time.RecordTiming(name_array, time);
    }
  }

  function BEByteSeqToInt(bytes: seq<byte>): int
    decreases |bytes|
  {
    if bytes == [] then
      0
    else
      BEByteSeqToInt(bytes[..|bytes| - 1]) * 256 + bytes[|bytes| - 1] as int
  }

  lemma /*{:_induction bytes}*/ lemma_BEByteSeqToInt_bound(bytes: seq<byte>)
    ensures 0 <= BEByteSeqToInt(bytes)
    ensures BEByteSeqToInt(bytes) < power2(8 * |bytes|)
    decreases bytes
  {
  }

  lemma /*{:_induction bs}*/ lemma_BEByteSeqToUint64_properties(bs: seq<byte>)
    requires |bs| == Uint64Size() as int
    ensures ghost var ret: uint64 := bs[0] as uint64 * 256 * 256 * 256 * 4294967296 + bs[1] as uint64 * 256 * 256 * 4294967296 + bs[2] as uint64 * 256 * 4294967296 + bs[3] as uint64 * 4294967296 + bs[4] as uint64 * 256 * 256 * 256 + bs[5] as uint64 * 256 * 256 + bs[6] as uint64 * 256 + bs[7] as uint64; ret as int == BEByteSeqToInt(bs)
    decreases bs
  {
  }

  function method SeqByteToUint64(bs: seq<byte>): uint64
    requires |bs| == Uint64Size() as int
    ensures 0 <= BEByteSeqToInt(bs) < 18446744073709551616
    ensures SeqByteToUint64(bs) == BEByteSeqToInt(bs) as uint64
    decreases bs
  {
    lemma_2toX();
    lemma_BEByteSeqToUint64_properties(bs);
    bs[0] as uint64 * 256 * 256 * 256 * 4294967296 + bs[1] as uint64 * 256 * 256 * 4294967296 + bs[2] as uint64 * 256 * 4294967296 + bs[3] as uint64 * 4294967296 + bs[4] as uint64 * 256 * 256 * 256 + bs[5] as uint64 * 256 * 256 + bs[6] as uint64 * 256 + bs[7] as uint64
  }

  function BEUintToSeqByte(v: int, width: int): seq<byte>
    ensures width >= 0 && v >= 0 ==> |BEUintToSeqByte(v, width)| == width
    decreases v, width
  {
    if width > 0 && v >= 0 then
      BEUintToSeqByte(v / 256, width - 1) + [(v % 256) as byte]
    else
      []
  }

  lemma /*{:_induction bytes, val, width}*/ lemma_BEUintToSeqByte_invertability(bytes: seq<byte>, val: int, width: nat)
    requires bytes == BEUintToSeqByte(val, width)
    requires 0 <= val < power2(8 * width)
    requires |bytes| == width
    ensures BEByteSeqToInt(bytes) == val
    decreases bytes, val, width
  {
  }

  lemma /*{:_induction bytes, val, width}*/ lemma_BEByteSeqToInt_invertability(bytes: seq<byte>, val: int, width: nat)
    requires BEByteSeqToInt(bytes) == val
    requires 0 <= val < power2(8 * width)
    requires |bytes| == width
    ensures bytes == BEUintToSeqByte(val, width)
    decreases bytes, val, width
  {
  }

  lemma lemma_BEByteSeqToInt_BEUintToSeqByte_invertability()
    ensures forall bytes: seq<byte>, width: nat {:trigger BEUintToSeqByte(BEByteSeqToInt(bytes), width)} :: |bytes| == width ==> bytes == BEUintToSeqByte(BEByteSeqToInt(bytes), width)
    ensures forall width: nat, val: int {:trigger BEUintToSeqByte(val, width)} :: 0 <= val < power2(8 * width) ==> val == BEByteSeqToInt(BEUintToSeqByte(val, width))
  {
  }

  function method Uint64ToSeqByte(u: uint64): seq<byte>
    ensures Uint64ToSeqByte(u) == BEUintToSeqByte(u as int, 8)
    decreases u
  {
    ghost var pv: int := 256;
    var bs: seq<byte> := [(u / 72057594037927936) as byte, (u / 281474976710656 % 256) as byte, (u / 1099511627776 % 256) as byte, (u / 4294967296 % 256) as byte, (u / 16777216 % 256) as byte, (u / 65536 % 256) as byte, (u / 256 % 256) as byte, (u % 256) as byte];
    lemma_2toX();
    var u_int: int := u as int;
    calc {
      BEUintToSeqByte(u_int, 8);
      BEUintToSeqByte(u_int / 256, 7) + [(u_int % 256) as byte];
      BEUintToSeqByte(u_int / 256 / 256, 6) + [(u_int / 256 % 256) as byte] + [(u_int % 256) as byte];
      {
        lemma_div_denominator(u_int as int, 256, 256);
      }
      BEUintToSeqByte(u_int / 65536, 6) + [(u_int / 256 % 256) as byte] + [(u_int % 256) as byte];
      {
        lemma_div_denominator(u_int as int, 65536, 256);
      }
      BEUintToSeqByte(u_int / 16777216, 5) + [(u_int / 65536 % 256) as byte] + [(u_int / 256 % 256) as byte] + [(u_int % 256) as byte];
      {
        lemma_div_denominator(u_int as int, 16777216, 256);
      }
      BEUintToSeqByte(u_int / 4294967296, 4) + [(u_int / 16777216 % 256) as byte] + [(u_int / 65536 % 256) as byte] + [(u_int / 256 % 256) as byte] + [(u_int % 256) as byte];
      {
        lemma_div_denominator(u_int as int, 4294967296, 256);
      }
      BEUintToSeqByte(u_int / 1099511627776, 3) + [(u_int / 4294967296 % 256) as byte] + [(u_int / 16777216 % 256) as byte] + [(u_int / 65536 % 256) as byte] + [(u_int / 256 % 256) as byte] + [(u_int % 256) as byte];
      {
        lemma_div_denominator(u_int as int, 1099511627776, 256);
      }
      BEUintToSeqByte(u_int / 281474976710656, 2) + [(u_int / 1099511627776 % 256) as byte] + [(u_int / 4294967296 % 256) as byte] + [(u_int / 16777216 % 256) as byte] + [(u_int / 65536 % 256) as byte] + [(u_int / 256 % 256) as byte] + [(u_int % 256) as byte];
      {
        lemma_div_denominator(u_int as int, 281474976710656, 256);
      }
      BEUintToSeqByte(u_int / 72057594037927936, 1) + [(u_int / 281474976710656 % 256) as byte] + [(u_int / 1099511627776 % 256) as byte] + [(u_int / 4294967296 % 256) as byte] + [(u_int / 16777216 % 256) as byte] + [(u_int / 65536 % 256) as byte] + [(u_int / 256 % 256) as byte] + [(u_int % 256) as byte];
      {
        lemma_div_denominator(u_int as int, 72057594037927936, 256);
      }
      BEUintToSeqByte(u_int / 18446744073709551616, 0) + [(u_int / 72057594037927936 % 256) as byte] + [(u_int / 281474976710656 % 256) as byte] + [(u_int / 1099511627776 % 256) as byte] + [(u_int / 4294967296 % 256) as byte] + [(u_int / 16777216 % 256) as byte] + [(u_int / 65536 % 256) as byte] + [(u_int / 256 % 256) as byte] + [(u_int % 256) as byte];
    }
    bs
  }

  function method SeqByteToUint16(bs: seq<byte>): uint16
    requires |bs| == Uint16Size() as int
    ensures 0 <= BEByteSeqToInt(bs) < 18446744073709551616
    ensures BEByteSeqToInt(bs) < 65536
    ensures SeqByteToUint16(bs) == BEByteSeqToInt(bs) as uint16
    decreases bs
  {
    lemma_2toX();
    lemma_BEByteSeqToInt_bound(bs);
    bs[0] as uint16 * 256 + bs[1] as uint16
  }

  function method Uint16ToSeqByte(u: uint16): seq<byte>
    ensures Uint16ToSeqByte(u) == BEUintToSeqByte(u as int, 2)
    decreases u
  {
    ghost var pv: int := 256;
    var s: seq<byte> := [(u / 256 % 256) as byte, (u % 256) as byte];
    lemma_2toX();
    var u_int: int := u as int;
    calc {
      BEUintToSeqByte(u_int, 2);
      BEUintToSeqByte(u_int / 256, 1) + [(u_int % 256) as byte];
      BEUintToSeqByte(u_int / 256 / 256, 0) + [(u_int / 256 % 256) as byte] + [(u_int % 256) as byte];
      {
        lemma_div_denominator(u_int as int, 256, 256);
      }
      BEUintToSeqByte(u_int / 65536, 0) + [(u_int / 256 % 256) as byte] + [(u_int % 256) as byte];
    }
    s
  }
}

module Native__NativeTypes_i {

  import opened Native__NativeTypes_s
  function method Uint64Size(): uint64
  {
    8
  }

  function method Uint32Size(): uint64
  {
    4
  }

  function method Uint16Size(): uint64
  {
    2
  }
}

module Math__power2_i {

  import opened Math__power2_s

  import opened Math__power_s

  import opened Math__power_i

  import opened Math__div_nonlinear_i

  import opened Math__div_i

  import opened Math__mul_auto_i

  import opened Math__mul_i
  lemma lemma_power2_is_power_2_general()
    ensures forall x: nat {:trigger power(2, x)} {:trigger power2(x)} :: power2(x) == power(2, x)
  {
  }

  lemma /*{:_induction x}*/ lemma_power2_is_power_2(x: nat)
    ensures power2(x) == power(2, x)
    decreases x
  {
  }

  lemma lemma_power2_auto()
    ensures power2(0) == 1
    ensures power2(1) == 2
    ensures forall x: nat, y: nat {:trigger power2(x + y)} :: power2(x + y) == power2(x) * power2(y)
    ensures forall x: nat, y: nat {:trigger power2(x - y)} :: x >= y ==> power2(x - y) * power2(y) == power2(x)
    ensures forall x: nat, y: nat {:trigger x * y} :: y == 2 ==> x * y == x + x
  {
  }

  lemma /*{:_induction e1, e2}*/ lemma_power2_strictly_increases(e1: int, e2: int)
    requires 0 <= e1 < e2
    ensures power2(e1) < power2(e2)
    decreases e1, e2
  {
  }

  lemma /*{:_induction e1, e2}*/ lemma_power2_increases(e1: int, e2: int)
    requires 0 <= e1 <= e2
    ensures power2(e1) <= power2(e2)
    decreases e1, e2
  {
  }

  lemma /*{:_induction e1, e2}*/ lemma_power2_strictly_increases_converse(e1: int, e2: int)
    requires 0 <= e1
    requires 0 < e2
    requires power2(e1) < power2(e2)
    ensures e1 < e2
    decreases e1, e2
  {
  }

  lemma /*{:_induction e1, e2}*/ lemma_power2_increases_converse(e1: int, e2: int)
    requires 0 < e1
    requires 0 < e2
    requires power2(e1) <= power2(e2)
    ensures e1 <= e2
    decreases e1, e2
  {
  }

  lemma /*{:_induction e1, e2}*/ lemma_power2_adds(e1: nat, e2: nat)
    ensures power2(e1 + e2) == power2(e1) * power2(e2)
    decreases e2
  {
  }

  lemma /*{:_induction x, y}*/ lemma_power2_div_is_sub(x: int, y: int)
    requires 0 <= x <= y
    ensures power2(y - x) == power2(y) / power2(x) >= 0
    decreases x, y
  {
  }

  lemma lemma_2toX32()
    ensures power2(0) == 1
    ensures power2(1) == 2
    ensures power2(2) == 4
    ensures power2(3) == 8
    ensures power2(4) == 16
    ensures power2(5) == 32
    ensures power2(6) == 64
    ensures power2(7) == 128
    ensures power2(8) == 256
    ensures power2(9) == 512
    ensures power2(10) == 1024
    ensures power2(11) == 2048
    ensures power2(12) == 4096
    ensures power2(13) == 8192
    ensures power2(14) == 16384
    ensures power2(15) == 32768
    ensures power2(16) == 65536
    ensures power2(17) == 131072
    ensures power2(18) == 262144
    ensures power2(19) == 524288
    ensures power2(20) == 1048576
    ensures power2(21) == 2097152
    ensures power2(22) == 4194304
    ensures power2(23) == 8388608
    ensures power2(24) == 16777216
    ensures power2(25) == 33554432
    ensures power2(26) == 67108864
    ensures power2(27) == 134217728
    ensures power2(28) == 268435456
    ensures power2(29) == 536870912
    ensures power2(30) == 1073741824
    ensures power2(31) == 2147483648
    ensures power2(32) == 4294967296
  {
  }

  lemma lemma_2toX()
    ensures power2(64) == 18446744073709551616
    ensures power2(60) == 1152921504606846976
    ensures power2(32) == 4294967296
    ensures power2(24) == 16777216
    ensures power2(19) == 524288
    ensures power2(16) == 65536
    ensures power2(8) == 256
  {
  }

  lemma /*{:_induction n}*/ lemma_power2_add8(n: int)
    requires n >= 0
    ensures power2(n + 1) == 2 * power2(n)
    ensures power2(n + 2) == 4 * power2(n)
    ensures power2(n + 3) == 8 * power2(n)
    ensures power2(n + 4) == 16 * power2(n)
    ensures power2(n + 5) == 32 * power2(n)
    ensures power2(n + 6) == 64 * power2(n)
    ensures power2(n + 7) == 128 * power2(n)
    ensures power2(n + 8) == 256 * power2(n)
    decreases n
  {
  }

  lemma lemma_2to32()
    ensures power2(32) == 4294967296
    ensures power2(24) == 16777216
    ensures power2(19) == 524288
    ensures power2(16) == 65536
    ensures power2(8) == 256
    ensures power2(0) == 1
  {
  }

  lemma lemma_2to64()
    ensures power2(64) == 18446744073709551616
    ensures power2(60) == 1152921504606846976
  {
  }

  lemma lemma_power2_0_is_1()
    ensures power2(0) == 1
  {
  }

  lemma lemma_power2_1_is_2()
    ensures power2(1) == 2
  {
  }

  lemma /*{:_induction a, b}*/ lemma_bit_count_is_unique(x: int, a: int, b: int)
    requires 0 < a
    requires 0 < b
    requires power2(a - 1) <= x < power2(a)
    requires power2(b - 1) <= x < power2(b)
    ensures a == b
    decreases x, a, b
  {
  }

  lemma /*{:_induction x, y, z}*/ lemma_pull_out_powers_of_2(x: nat, y: nat, z: nat)
    ensures 0 <= x * y
    ensures 0 <= y * z
    ensures power(power2(x * y), z) == power(power2(x), y * z)
    decreases x, y, z
  {
  }

  lemma lemma_rebase_powers_of_2()
    ensures forall n: nat, e: nat {:trigger power(power2(n), e)} :: 0 <= n * e && power(power2(n), e) == power2(n * e)
  {
  }

  lemma /*{:_induction c}*/ lemma_mask_div_2(c: nat)
    requires 0 < c
    ensures (power2(c) - 1) / 2 == power2(c - 1) - 1
    decreases c
  {
  }

  lemma /*{:_induction p, s}*/ lemma_power2_division_inequality(x: nat, p: nat, s: nat)
    requires s <= p
    requires x < power2(p)
    ensures x / power2(s) < power2(p - s)
    decreases x, p, s
  {
  }

  lemma /*{:_induction a, b}*/ lemma_power2_unfolding(a: nat, b: nat)
    ensures 0 <= a * b
    ensures power(power2(a), b) == power2(a * b)
    decreases a, b
  {
  }

  function {:opaque} {:fuel 0, 0} NatNumBits(n: nat): nat
    ensures NatNumBits(n) >= 0
    decreases n
  {
    if n == 0 then
      0
    else
      1 + NatNumBits(n / 2)
  }

  lemma /*{:_induction c, n}*/ lemma_Power2BoundIsNatNumBits(c: nat, n: nat)
    ensures (c > 0 ==> power2(c - 1) <= n) && n < power2(c) <==> c == NatNumBits(n)
    decreases c, n
  {
  }
}

module Math__power2_s {
  function {:opaque} {:fuel 0, 0} power2(exp: nat): nat
    ensures power2(exp) > 0
    decreases exp
  {
    if exp == 0 then
      1
    else
      2 * power2(exp - 1)
  }

  lemma lemma_power2_32()
    ensures power2(8) == 256
    ensures power2(16) == 65536
    ensures power2(24) == 16777216
    ensures power2(32) == 4294967296
  {
  }
}

module Math__power_s {
  function {:opaque} {:fuel 0, 0} power(b: int, e: nat): int
    decreases e
  {
    if e == 0 then
      1
    else
      b * power(b, e - 1)
  }
}

module Math__power_i {

  import opened Math__power_s

  import opened Math__mul_i

  import opened Math__mul_auto_i
  lemma /*{:_induction b}*/ lemma_power_0(b: int)
    ensures power(b, 0) == 1
    decreases b
  {
  }

  lemma /*{:_induction b}*/ lemma_power_1(b: int)
    ensures power(b, 1) == b
    decreases b
  {
  }

  lemma /*{:_induction e}*/ lemma_0_power(e: nat)
    requires e > 0
    ensures power(0, e) == 0
    decreases e
  {
  }

  lemma /*{:_induction e}*/ lemma_1_power(e: nat)
    ensures power(1, e) == 1
    decreases e
  {
  }

  lemma /*{:_induction b, e1, e2}*/ lemma_power_adds(b: int, e1: nat, e2: nat)
    ensures power(b, e1) * power(b, e2) == power(b, e1 + e2)
    decreases e1
  {
  }

  lemma /*{:_induction a, b, c}*/ lemma_power_multiplies(a: int, b: nat, c: nat)
    ensures 0 <= b * c
    ensures power(a, b * c) == power(power(a, b), c)
    decreases c
  {
  }

  lemma /*{:_induction a, b, e}*/ lemma_power_distributes(a: int, b: int, e: nat)
    ensures power(a * b, e) == power(a, e) * power(b, e)
    decreases e
  {
  }

  lemma lemma_power_auto()
    ensures forall x: int {:trigger power(x, 0)} :: power(x, 0) == 1
    ensures forall x: int {:trigger power(x, 1)} :: power(x, 1) == x
    ensures forall x: int, y: int {:trigger power(x, y)} :: y == 0 ==> power(x, y) == 1
    ensures forall x: int, y: int {:trigger power(x, y)} :: y == 1 ==> power(x, y) == x
    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 0 < y ==> x <= x * y
    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 1 < y ==> x < x * y
    ensures forall x: int, y: nat, z: nat {:trigger power(x, y + z)} :: power(x, y + z) == power(x, y) * power(x, z)
    ensures forall x: int, y: nat, z: nat {:trigger power(x, y - z)} :: y >= z ==> power(x, y - z) * power(x, z) == power(x, y)
    ensures forall x: int, y: int, z: nat {:trigger power(x * y, z)} :: power(x * y, z) == power(x, z) * power(y, z)
  {
  }

  lemma /*{:_induction b, e}*/ lemma_power_positive(b: int, e: nat)
    requires 0 < b
    ensures 0 < power(b, e)
    decreases b, e
  {
  }

  lemma /*{:_induction b, e1, e2}*/ lemma_power_increases(b: nat, e1: nat, e2: nat)
    requires 0 < b
    requires e1 <= e2
    ensures power(b, e1) <= power(b, e2)
    decreases b, e1, e2
  {
  }

  lemma /*{:_induction b, e1, e2}*/ lemma_power_strictly_increases(b: nat, e1: nat, e2: nat)
    requires 1 < b
    requires e1 < e2
    ensures power(b, e1) < power(b, e2)
    decreases b, e1, e2
  {
  }

  lemma /*{:_induction x}*/ lemma_square_is_power_2(x: nat)
    ensures power(x, 2) == x * x
    decreases x
  {
  }
}

module Math__div_i {

  import opened Math__power_s

  import opened Math__power_i

  import opened Math__mod_auto_i

  import opened Math__mul_auto_i

  import opened Math__mul_nonlinear_i

  import opened Math__mul_i

  import opened Math__div_def_i

  import opened Math__div_nonlinear_i

  import opened Math__div_auto_i
  lemma lemma_div_by_one_is_identity(x: int)
    decreases x
  {
  }

  lemma lemma_div_basics(x: int)
    ensures x != 0 ==> 0 / x == 0
    ensures x / 1 == x
    ensures x != 0 ==> x / x == 1
    decreases x
  {
  }

  lemma lemma_small_div_converse()
    ensures forall x: int, d: int {:trigger x / d} :: 0 <= x && 0 < d && x / d == 0 ==> x < d
  {
  }

  lemma lemma_div_is_ordered_by_denominator(x: int, y: int, z: int)
    requires x >= 0
    requires 1 <= y <= z
    ensures x / y >= x / z
    decreases x
  {
  }

  lemma lemma_div_is_strictly_ordered_by_denominator(x: int, d: int)
    requires 0 < x
    requires 1 < d
    ensures x / d < x
    decreases x
  {
  }

  lemma lemma_dividing_sums(a: int, b: int, d: int, R: int)
    requires 0 < d
    requires R == a % d + b % d - (a + b) % d
    ensures d * (a + b) / d - R == d * a / d + d * b / d
    decreases a, b, d, R
  {
  }

  lemma lemma_div_pos_is_pos(x: int, divisor: int)
    requires 0 <= x
    requires 0 < divisor
    ensures x / divisor >= 0
    decreases x, divisor
  {
  }

  lemma lemma_div_basics_forall()
    ensures forall x: int {:trigger 0 / x} :: x != 0 ==> 0 / x == 0
    ensures forall x: int {:trigger x / 1} :: x / 1 == x
    ensures forall x: int, y: int {:trigger x / y} :: x >= 0 && y > 0 ==> x / y >= 0
    ensures forall x: int, y: int {:trigger x / y} :: x >= 0 && y > 0 ==> x / y <= x
  {
  }

  lemma lemma_div_neg_neg(x: int, d: int)
    requires d > 0
    ensures x / d == -((-x + d - 1) / d)
    decreases x, d
  {
  }

  lemma lemma_mod_2(x: int)
    decreases x
  {
  }

  lemma lemma_mod2_plus(x: int)
    decreases x
  {
  }

  lemma lemma_mod2_plus2(x: int)
    decreases x
  {
  }

  lemma lemma_mod32(x: int)
    decreases x
  {
  }

  lemma lemma_mod_remainder_neg_specific(x: int, m: int)
    decreases x, m
  {
  }

  lemma lemma_mod_remainder_neg()
  {
  }

  lemma lemma_mod_remainder_pos_specific(x: int, m: int)
    decreases x, m
  {
  }

  lemma lemma_mod_remainder_pos()
  {
  }

  lemma lemma_mod_remainder_specific(x: int, m: int)
    decreases x, m
  {
  }

  lemma lemma_mod_remainder()
  {
  }

  lemma lemma_mod_basics()
    ensures forall m: int {:trigger m % m} :: m > 0 ==> m % m == 0
    ensures forall x: int, m: int {:trigger x % m % m} :: m > 0 ==> x % m % m == x % m
  {
  }

  lemma lemma_mod_properties()
    ensures forall m: int {:trigger m % m} :: m > 0 ==> m % m == 0
    ensures forall x: int, m: int {:trigger x % m % m} :: m > 0 ==> x % m % m == x % m
    ensures forall x: int, m: int {:trigger x % m} :: (m > 0 ==> 0 <= x % m) && (m > 0 ==> x % m < m)
  {
  }

  lemma lemma_mod_decreases(x: nat, d: nat)
    requires 0 < d
    ensures x % d <= x
    decreases x, d
  {
  }

  lemma lemma_mod_add_multiples_vanish(b: int, m: int)
    requires 0 < m
    ensures (m + b) % m == b % m
    decreases b, m
  {
  }

  lemma lemma_mod_sub_multiples_vanish(b: int, m: int)
    requires 0 < m
    ensures (-m + b) % m == b % m
    decreases b, m
  {
  }

  lemma lemma_mod_multiples_vanish(a: int, b: int, m: int)
    requires 0 < m
    ensures (m * a + b) % m == b % m
    decreases if a > 0 then a else -a
  {
  }

  lemma lemma_add_mod_noop(x: int, y: int, m: int)
    requires 0 < m
    ensures (x % m + y % m) % m == (x + y) % m
    decreases x, y, m
  {
  }

  lemma lemma_add_mod_noop_right(x: int, y: int, m: int)
    requires 0 < m
    ensures (x + y % m) % m == (x + y) % m
    decreases x, y, m
  {
  }

  lemma lemma_mod_equivalence(x: int, y: int, m: int)
    requires 0 < m
    ensures x % m == y % m <==> (x - y) % m == 0
    decreases x, y, m
  {
  }

  lemma lemma_sub_mod_noop(x: int, y: int, m: int)
    requires 0 < m
    ensures (x % m - y % m) % m == (x - y) % m
    decreases x, y, m
  {
  }

  lemma lemma_sub_mod_noop_right(x: int, y: int, m: int)
    requires 0 < m
    ensures (x - y % m) % m == (x - y) % m
    decreases x, y, m
  {
  }

  lemma lemma_mod_adds(a: int, b: int, d: int)
    requires 0 < d
    ensures a % d + b % d == (a + b) % d + d * (a % d + b % d) / d
    ensures a % d + b % d < d ==> a % d + b % d == (a + b) % d
    decreases a, b, d
  {
  }

  lemma {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ lemma_mod_neg_neg(x: int, d: int)
    requires d > 0
    ensures x % d == x * (1 - d) % d
    decreases x, d
  {
  }

  lemma {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ lemma_fundamental_div_mod_converse(x: int, d: int, q: int, r: int)
    requires d != 0
    requires 0 <= r < d
    requires x == q * d + r
    ensures q == x / d
    ensures r == x % d
    decreases x, d, q, r
  {
  }

  lemma lemma_mod_pos_bound(x: int, m: int)
    requires 0 <= x
    requires 0 < m
    ensures 0 <= x % m < m
    decreases x
  {
  }

  lemma lemma_mul_mod_noop_left(x: int, y: int, m: int)
    requires 0 < m
    ensures x % m * y % m == x * y % m
    decreases x, y, m
  {
  }

  lemma lemma_mul_mod_noop_right(x: int, y: int, m: int)
    requires 0 < m
    ensures x * y % m % m == x * y % m
    decreases x, y, m
  {
  }

  lemma lemma_mul_mod_noop_general(x: int, y: int, m: int)
    requires 0 < m
    ensures x % m * y % m == x * y % m
    ensures x * y % m % m == x * y % m
    ensures x % m * y % m % m == x * y % m
    decreases x, y, m
  {
  }

  lemma lemma_mul_mod_noop(x: int, y: int, m: int)
    requires 0 < m
    ensures x % m * y % m % m == x * y % m
    decreases x, y, m
  {
  }

  lemma /*{:_induction b, e, m}*/ lemma_power_mod_noop(b: int, e: nat, m: int)
    requires 0 < m
    ensures power(b % m, e) % m == power(b, e) % m
    decreases e
  {
  }

  lemma lemma_mod_subtraction(x: nat, s: nat, d: nat)
    requires 0 < d
    requires 0 <= s <= x % d
    ensures x % d - s % d == (x - s) % d
    decreases x, s, d
  {
  }

  lemma lemma_mod_ordering(x: nat, k: nat, d: nat)
    requires 1 < d
    requires 0 < k
    ensures 0 < d * k
    ensures x % d <= x % (d * k)
    decreases x, k, d
  {
  }

  lemma lemma_mod_multiples_basic(x: int, m: int)
    requires m > 0
    ensures x * m % m == 0
    decreases x, m
  {
  }

  lemma lemma_div_plus_one(x: int, d: int)
    requires d > 0
    ensures 1 + x / d == (d + x) / d
    decreases x, d
  {
  }

  lemma lemma_div_minus_one(x: int, d: int)
    requires d > 0
    ensures -1 + x / d == (-d + x) / d
    decreases x, d
  {
  }

  lemma lemma_mod_mod(x: int, a: int, b: int)
    requires 0 < a
    requires 0 < b
    ensures 0 < a * b
    ensures x % (a * b) % a == x % a
    decreases x, a, b
  {
  }

  lemma lemma_div_is_div_recursive(x: int, d: int)
    requires d > 0
    ensures my_div_recursive(x, d) == x / d
    decreases x, d
  {
  }

  lemma lemma_div_is_div_recursive_forall()
    ensures forall x: int, d: int {:trigger my_div_recursive(x, d)} :: d > 0 ==> my_div_recursive(x, d) == x / d
  {
  }

  lemma /*{:_induction x, m}*/ lemma_mod_is_mod_recursive(x: int, m: int)
    requires m > 0
    ensures my_mod_recursive(x, m) == x % m
    decreases if x < 0 then -x + m else x
  {
  }

  lemma lemma_mod_is_mod_recursive_forall()
    ensures forall x: int, d: int {:trigger my_mod_recursive(x, d)} :: d > 0 ==> my_mod_recursive(x, d) == x % d
  {
  }

  lemma lemma_basic_div(d: int)
    requires d > 0
    ensures forall x: int {:trigger x / d} :: 0 <= x < d ==> x / d == 0
    decreases d
  {
  }

  lemma lemma_div_is_ordered(x: int, y: int, z: int)
    requires x <= y
    requires z > 0
    ensures x / z <= y / z
    decreases x, y, z
  {
  }

  lemma lemma_div_decreases(x: int, d: int)
    requires 0 < x
    requires 1 < d
    ensures x / d < x
    decreases x, d
  {
  }

  lemma lemma_div_nonincreasing(x: int, d: int)
    requires 0 <= x
    requires 0 < d
    ensures x / d <= x
    decreases x, d
  {
  }

  lemma lemma_breakdown(a: int, b: int, c: int)
    requires 0 <= a
    requires 0 < b
    requires 0 < c
    ensures 0 < b * c
    ensures a % (b * c) == b * a / b % c + a % b
    decreases a, b, c
  {
  }

  lemma lemma_remainder_upper(x: int, divisor: int)
    requires 0 <= x
    requires 0 < divisor
    ensures x - divisor < x / divisor * divisor
    decreases x, divisor
  {
  }

  lemma lemma_remainder_lower(x: int, divisor: int)
    requires 0 <= x
    requires 0 < divisor
    ensures x >= x / divisor * divisor
    decreases x, divisor
  {
  }

  lemma lemma_remainder(x: int, divisor: int)
    requires 0 <= x
    requires 0 < divisor
    ensures 0 <= x - x / divisor * divisor < divisor
    decreases x, divisor
  {
  }

  lemma lemma_div_denominator(x: int, c: nat, d: nat)
    requires 0 <= x
    requires 0 < c
    requires 0 < d
    ensures c * d != 0
    ensures x / c / d == x / (c * d)
    decreases x, c, d
  {
  }

  lemma lemma_mul_hoist_inequality(x: int, y: int, z: int)
    requires 0 <= x
    requires 0 < z
    ensures x * y / z <= x * y / z
    decreases x, y, z
  {
  }

  lemma lemma_indistinguishable_quotients(a: int, b: int, d: int)
    requires 0 < d
    requires 0 <= a - a % d <= b < a + d - a % d
    ensures a / d == b / d
    decreases a, b, d
  {
  }

  lemma lemma_truncate_middle(x: int, b: int, c: int)
    requires 0 <= x
    requires 0 < b
    requires 0 < c
    ensures 0 < b * c
    ensures b * x % (b * c) == b * x % c
    decreases x, b, c
  {
  }

  lemma lemma_div_multiples_vanish_quotient(x: int, a: int, d: int)
    requires 0 < x
    requires 0 <= a
    requires 0 < d
    ensures 0 < x * d
    ensures a / d == x * a / (x * d)
    decreases x, a, d
  {
  }

  lemma lemma_round_down(a: int, r: int, d: int)
    requires 0 < d
    requires a % d == 0
    requires 0 <= r < d
    ensures a == d * (a + r) / d
    decreases a, r, d
  {
  }

  lemma lemma_div_multiples_vanish_fancy(x: int, b: int, d: int)
    requires 0 < d
    requires 0 <= b < d
    ensures (d * x + b) / d == x
    decreases x, b, d
  {
  }

  lemma lemma_div_multiples_vanish(x: int, d: int)
    requires 0 < d
    ensures d * x / d == x
    decreases x, d
  {
  }

  lemma lemma_div_by_multiple(b: int, d: int)
    requires 0 <= b
    requires 0 < d
    ensures b * d / d == b
    decreases b, d
  {
  }

  lemma lemma_div_by_multiple_is_strongly_ordered(x: int, y: int, m: int, z: int)
    requires x < y
    requires y == m * z
    requires z > 0
    ensures x / z < y / z
    decreases x, y, m, z
  {
  }

  lemma lemma_multiply_divide_le(a: int, b: int, c: int)
    requires 0 < b
    requires a <= b * c
    ensures a / b <= c
    decreases a, b, c
  {
  }

  lemma lemma_multiply_divide_lt(a: int, b: int, c: int)
    requires 0 < b
    requires a < b * c
    ensures a / b < c
    decreases a, b, c
  {
  }

  lemma lemma_hoist_over_denominator(x: int, j: int, d: nat)
    requires 0 < d
    ensures x / d + j == (x + j * d) / d
    decreases x, j, d
  {
  }

  lemma lemma_part_bound1(a: int, b: int, c: int)
    requires 0 <= a
    requires 0 < b
    requires 0 < c
    ensures 0 < b * c
    ensures b * a / b % (b * c) <= b * (c - 1)
    decreases a, b, c
  {
  }

  lemma lemma_part_bound2(a: int, b: int, c: int)
    requires 0 <= a
    requires 0 < b
    requires 0 < c
    ensures 0 < b * c
    ensures a % b % (b * c) < b
    decreases a, b, c
  {
  }

  lemma lemma_mod_breakdown(a: int, b: int, c: int)
    requires 0 <= a
    requires 0 < b
    requires 0 < c
    ensures 0 < b * c
    ensures a % (b * c) == b * a / b % c + a % b
    decreases a, b, c
  {
  }

  lemma lemma_div_denominator_forall()
    ensures forall c: nat, d: nat {:trigger c * d} :: 0 < c && 0 < d ==> c * d != 0
    ensures forall x: int, c: nat, d: nat {:trigger x / c / d} :: 0 <= x && 0 < c && 0 < d ==> x / c / d == x / (c * d)
  {
  }
}

module Math__div_def_i {
  function div(x: int, d: int): int
    requires d != 0
    decreases x, d
  {
    x / d
  }

  function mod(x: int, d: int): int
    requires d != 0
    decreases x, d
  {
    x % d
  }

  function div_recursive(x: int, d: int): int
    requires d != 0
    decreases x, d
  {
    INTERNAL_div_recursive(x, d)
  }

  function mod_recursive(x: int, d: int): int
    requires d > 0
    decreases x, d
  {
    INTERNAL_mod_recursive(x, d)
  }

  function mod_boogie(x: int, y: int): int
    requires y != 0
    decreases x, y
  {
    x % y
  }

  function div_boogie(x: int, y: int): int
    requires y != 0
    decreases x, y
  {
    x / y
  }

  function my_div_recursive(x: int, d: int): int
    requires d != 0
    decreases x, d
  {
    if d > 0 then
      my_div_pos(x, d)
    else
      -1 * my_div_pos(x, -1 * d)
  }

  function my_div_pos(x: int, d: int): int
    requires d > 0
    decreases if x < 0 then d - x else x
  {
    if x < 0 then
      -1 + my_div_pos(x + d, d)
    else if x < d then
      0
    else
      1 + my_div_pos(x - d, d)
  }

  function my_mod_recursive(x: int, m: int): int
    requires m > 0
    decreases if x < 0 then m - x else x
  {
    if x < 0 then
      my_mod_recursive(m + x, m)
    else if x < m then
      x
    else
      my_mod_recursive(x - m, m)
  }

  function INTERNAL_mod_recursive(x: int, m: int): int
    requires m > 0
    decreases x, m
  {
    my_mod_recursive(x, m)
  }

  function INTERNAL_div_recursive(x: int, d: int): int
    requires d != 0
    decreases x, d
  {
    my_div_recursive(x, d)
  }
}

module Math__div_auto_i {

  import opened Math__mod_auto_i

  import opened Math__mod_auto_proofs_i

  import opened Math__div_auto_proofs_i
  predicate DivAuto(n: int)
    requires n > 0
    decreases n
  {
    ModAuto(n) &&
    n / n == -(-n / n) == 1 &&
    (forall x: int {:trigger x / n} :: 
      0 <= x < n <==> x / n == 0) &&
    (forall x: int, y: int {:trigger (x + y) / n} :: 
      ghost var z: int := x % n + y % n; (0 <= z < n && (x + y) / n == x / n + y / n) || (n <= z < n + n && (x + y) / n == x / n + y / n + 1)) &&
    forall x: int, y: int {:trigger (x - y) / n} :: 
      ghost var z: int := x % n - y % n; (0 <= z < n && (x - y) / n == x / n - y / n) || (-n <= z < 0 && (x - y) / n == x / n - y / n - 1)
  }

  lemma lemma_div_auto(n: int)
    requires n > 0
    ensures DivAuto(n)
    decreases n
  {
  }

  predicate TDivAutoLe(x: int, y: int)
    decreases x, y
  {
    x <= y
  }

  lemma lemma_div_auto_induction(n: int, x: int, f: int -> bool)
    requires n > 0
    requires DivAuto(n) ==> (forall i: int {:trigger TDivAutoLe(0, i)} :: TDivAutoLe(0, i) && i < n ==> f(i)) && (forall i: int {:trigger TDivAutoLe(0, i)} :: TDivAutoLe(0, i) && f(i) ==> f(i + n)) && forall i: int {:trigger TDivAutoLe(i + 1, n)} :: TDivAutoLe(i + 1, n) && f(i) ==> f(i - n)
    ensures DivAuto(n)
    ensures f(x)
    decreases n, x
  {
  }

  lemma lemma_div_auto_induction_forall(n: int, f: int -> bool)
    requires n > 0
    requires DivAuto(n) ==> (forall i: int {:trigger TDivAutoLe(0, i)} :: TDivAutoLe(0, i) && i < n ==> f(i)) && (forall i: int {:trigger TDivAutoLe(0, i)} :: TDivAutoLe(0, i) && f(i) ==> f(i + n)) && forall i: int {:trigger TDivAutoLe(i + 1, n)} :: TDivAutoLe(i + 1, n) && f(i) ==> f(i - n)
    ensures DivAuto(n)
    ensures forall i: int {:trigger f(i)} :: f(i)
    decreases n
  {
  }
}

module Math__div_auto_proofs_i {

  import opened Math__mod_auto_i

  import opened Math__mod_auto_proofs_i

  import opened Math__div_nonlinear_i
  lemma lemma_div_auto_basics(n: int)
    requires n > 0
    ensures n / n == -(-n / n) == 1
    ensures forall x: int {:trigger x / n} :: 0 <= x < n <==> x / n == 0
    ensures forall x: int {:trigger (x + n) / n} :: (x + n) / n == x / n + 1
    ensures forall x: int {:trigger (x - n) / n} :: (x - n) / n == x / n - 1
    decreases n
  {
  }
}

module Common__UdpClient_i {

  import opened Native__Io_s
  function Workaround_CastHostEnvironmentToObject(env: HostEnvironment): object
    decreases env
  {
    env
  }

  function Workaround_CastOkStateToObject(okState: OkState): object
    decreases okState
  {
    okState
  }

  function Workaround_CastNowStateToObject(nowState: NowState): object
    decreases nowState
  {
    nowState
  }

  function Workaround_CastUdpStateToObject(udpState: UdpState): object
    decreases udpState
  {
    udpState
  }

  function Workaround_CastIPEndPointToObject(ip: IPEndPoint): object
    decreases ip
  {
    ip
  }

  function Workaround_CastUdpClientToObject(udpc: UdpClient?): object?
    decreases udpc
  {
    udpc
  }

  function HostEnvironmentDefaultFrame(env: HostEnvironment): set<object>
    reads env, {env.now}, {env.ok}, {env.udp}, {env}
    decreases {env.now} + {env.ok} + {env.udp} + {env} + {env}, env
  {
    {Workaround_CastOkStateToObject(env.ok), Workaround_CastNowStateToObject(env.now), Workaround_CastUdpStateToObject(env.udp)}
  }

  function UdpClientRepr(udpc: UdpClient?): set<object?>
    reads udpc, if udpc != null then HostEnvironmentDefaultFrame.reads(udpc.env) else {}
    decreases (if udpc != null then HostEnvironmentDefaultFrame.reads(udpc.env) else {}) + {udpc}, udpc
  {
    {Workaround_CastUdpClientToObject(udpc)} + if udpc != null then HostEnvironmentDefaultFrame(udpc.env) else {}
  }

  predicate HostEnvironmentIsValid(env: HostEnvironment)
    reads env, env.Valid.reads(), env.ok.ok.reads()
    decreases env.Valid.reads() + env.ok.ok.reads() + {env}, env
  {
    env.Valid() &&
    env.ok.ok()
  }

  predicate UdpClientOk(udpc: UdpClient?)
    reads udpc, if udpc != null then HostEnvironmentDefaultFrame.reads(udpc.env) else {}
    decreases (if udpc != null then HostEnvironmentDefaultFrame.reads(udpc.env) else {}) + {udpc}, udpc
  {
    udpc != null &&
    udpc.env.ok.ok()
  }

  function method EndPointIsValidIPV4(endPoint: EndPoint): bool
    decreases endPoint
  {
    |endPoint.addr| == 4 &&
    0 <= endPoint.port <= 65535
  }

  predicate UdpClientIsValid(udpc: UdpClient?)
    reads UdpClientRepr(udpc), if udpc != null then HostEnvironmentIsValid.reads(udpc.env) else {}
    decreases UdpClientRepr(udpc) + if udpc != null then HostEnvironmentIsValid.reads(udpc.env) else {}, udpc
  {
    udpc != null &&
    udpc.IsOpen() &&
    HostEnvironmentIsValid(udpc.env) &&
    EndPointIsValidIPV4(udpc.LocalEndPoint())
  }

  predicate EndPointsAreValidIPV4(eps: seq<EndPoint>)
    decreases eps
  {
    forall i: int {:trigger eps[i]} :: 
      0 <= i < |eps| ==>
        EndPointIsValidIPV4(eps[i])
  }
}

module Common__SeqIsUnique_i {

  import opened Common__SeqIsUniqueDef_i

  import opened Native__NativeTypes_i
  function UniqueSeqToSet<X>(xs: seq<X>): set<X>
    requires SeqIsUnique(xs)
    ensures forall x: X {:trigger x in UniqueSeqToSet(xs)} {:trigger x in xs} :: x in xs ==> x in UniqueSeqToSet(xs)
    decreases xs
  {
    set x: X {:trigger x in xs} | x in xs
  }

  function {:timeLimitMultiplier 3} {:opaque} {:fuel 0, 0} /*{:_timeLimit 30}*/ SetToUniqueSeq<X(!new)>(s: set<X>): seq<X>
    ensures forall x: X {:trigger x in s} {:trigger x in SetToUniqueSeq(s)} :: x in SetToUniqueSeq(s) <==> x in s
    ensures SeqIsUnique(SetToUniqueSeq(s))
    ensures |SetToUniqueSeq(s)| == |s|
    decreases s
  {
    if s == {} then
      ghost var xs: seq<X> := [];
      calc ==> {
        true;
        {
          reveal SeqIsUnique();
        }
        SeqIsUnique(xs);
      }
      xs
    else
      ghost var x: X :| x in s; ghost var s': set<X> := s - {x}; ghost var xs': seq<X> := SetToUniqueSeq(s'); calc ==> {
    true;
    {
      reveal SeqIsUnique();
    }
    SeqIsUnique(xs' + [x]);
  } xs' + [x]
  }

  function Subsequence<X(!new)>(xs: seq<X>, f: X -> bool): seq<X>
    requires forall x: X {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)
    reads set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    ensures forall x: X {:trigger f(x)} {:trigger x in xs} {:trigger x in Subsequence(xs, f)} :: x in Subsequence(xs, f) <==> x in xs && f(x)
    decreases set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, xs
  {
    ghost var s: set<X> := set x: X {:trigger f(x)} {:trigger x in xs} | x in xs && f(x);
    SetToUniqueSeq(s)
  }

  method SeqToSetConstruct<X>(xs: seq<X>) returns (s: set<X>)
    ensures forall x: X {:trigger x in xs} {:trigger x in s} :: x in s <==> x in xs
    ensures SeqIsUnique(xs) ==> |s| == |xs| && s == UniqueSeqToSet(xs)
    decreases xs
  {
    reveal SeqIsUnique();
    s := {};
    var i := 0;
    while i < |xs|
      invariant 0 <= i <= |xs|
      invariant forall x: X {:trigger x in xs[..i]} {:trigger x in s} :: x in s <==> x in xs[..i]
      invariant SeqIsUnique(xs[..i]) ==> |s| == i
      decreases |xs| - i
    {
      s := s + {xs[i]};
      i := i + 1;
    }
  }

  method {:timeLimitMultiplier 5} /*{:_timeLimit 50}*/ SetToUniqueSeqConstruct<X(0)>(s: set<X>) returns (xs: seq<X>)
    ensures SeqIsUnique(xs)
    ensures UniqueSeqToSet(xs) == s
    ensures forall x: X {:trigger x in s} {:trigger x in xs} :: x in xs <==> x in s
    ensures |xs| == |s|
    decreases s
  {
    var arr := new X[|s|];
    var s1 := s;
    ghost var s2 := {};
    ghost var i := 0;
    forall
      ensures SeqIsUnique(arr[..i])
    {
      reveal SeqIsUnique();
    }
    while |s1| != 0
      invariant 0 <= i <= |s|
      invariant s1 + s2 == s
      invariant s1 !! s2
      invariant |s1| == |s| - i
      invariant |s2| == i
      invariant SeqIsUnique(arr[..i])
      invariant forall x: X {:trigger x in s2} {:trigger x in arr[..i]} :: x in arr[..i] <==> x in s2
      decreases if |s1| <= 0 then 0 - |s1| else |s1| - 0
    {
      reveal SeqIsUnique();
      ghost var old_seq := arr[..i];
      var x :| x in s1;
      assert x !in old_seq;
      assert forall y: X {:trigger y in s2} {:trigger y in old_seq} :: y in s2 + {x} ==> y in old_seq + [x];
      arr[|s| - |s1|] := x;
      s1 := s1 - {x};
      s2 := s2 + {x};
      i := i + 1;
      assert arr[..i] == old_seq + [x];
    }
    xs := arr[..];
    assert xs == arr[..i];
  }

  method SubsequenceConstruct<X(==,0)>(xs: seq<X>, f: X -> bool) returns (xs': seq<X>)
    requires forall x: X {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)
    ensures forall x: X {:trigger x in xs} {:trigger x in xs'} :: x in xs' <==> x in xs && f(x)
    ensures SeqIsUnique(xs) ==> SeqIsUnique(xs')
    decreases xs
  {
    reveal SeqIsUnique();
    var arr := new X[|xs|];
    var i := 0;
    var j := 0;
    while i < |xs|
      invariant 0 <= i <= |xs|
      invariant 0 <= j <= i
      invariant forall x: X {:trigger x in xs[..i]} {:trigger x in arr[..j]} :: x in arr[..j] <==> x in xs[..i] && f(x)
      invariant SeqIsUnique(xs) ==> SeqIsUnique(arr[..j])
      decreases |xs| - i
    {
      ghost var old_xs := xs[..i];
      ghost var old_xs' := arr[..j];
      if f(xs[i]) {
        if SeqIsUnique(xs) {
          reveal SeqIsUnique();
          assert forall k: int {:trigger xs[k]} :: 0 <= k < i ==> xs[k] != xs[i];
          assert forall k: int {:trigger xs[..i][k]} :: 0 <= k < i ==> xs[..i][k] != xs[i];
          assert xs[i] !in arr[..j];
        }
        arr[j] := xs[i];
        j := j + 1;
        assert arr[..j] == old_xs' + [xs[i]];
      }
      i := i + 1;
      assert xs[..i] == old_xs + [xs[i - 1]];
    }
    xs' := arr[..j];
  }

  method UniqueSubsequenceConstruct<X(==,0)>(xs: seq<X>, f: X -> bool) returns (xs': seq<X>)
    requires forall x: X {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)
    ensures forall x: X {:trigger x in xs} {:trigger x in xs'} :: x in xs' <==> x in xs && f(x)
    ensures SeqIsUnique(xs')
    decreases xs
  {
    var s := set x: X {:trigger f(x)} {:trigger x in xs} | x in xs && f(x);
    xs' := SetToUniqueSeqConstruct(s);
  }

  lemma EstablishAppendToUniqueSeq<X>(xs: seq<X>, x: X, xs': seq<X>)
    requires SeqIsUnique(xs)
    requires x !in xs
    requires xs' == xs + [x]
    ensures SeqIsUnique(xs')
    ensures x in xs'
    decreases xs, xs'
  {
  }

  function method AppendToUniqueSeq<X>(xs: seq<X>, x: X): seq<X>
    requires SeqIsUnique(xs)
    requires x !in xs
    ensures SeqIsUnique(AppendToUniqueSeq(xs, x))
    ensures x in AppendToUniqueSeq(xs, x)
    decreases xs
  {
    reveal SeqIsUnique();
    var xs': seq<X> := xs + [x];
    EstablishAppendToUniqueSeq(xs, x, xs');
    xs'
  }

  function method AppendToUniqueSeqMaybe<X(==)>(xs: seq<X>, x: X): seq<X>
    requires SeqIsUnique(xs)
    ensures SeqIsUnique(AppendToUniqueSeqMaybe(xs, x))
    ensures x in AppendToUniqueSeqMaybe(xs, x)
    decreases xs
  {
    reveal SeqIsUnique();
    if x in xs then
      xs
    else
      var xs': seq<X> := xs + [x]; EstablishAppendToUniqueSeq(xs, x, xs'); xs'
  }

  lemma lemma_UniqueSeq_SubSeqsUnique<X>(whole: seq<X>, left: seq<X>, right: seq<X>)
    requires SeqIsUnique(whole)
    requires whole == left + right
    ensures SeqIsUnique(left)
    ensures SeqIsUnique(right)
    decreases whole, left, right
  {
  }

  lemma lemma_seqs_set_cardinality<T>(Q: seq<T>, S: set<T>)
    requires SeqIsUnique(Q)
    requires S == UniqueSeqToSet(Q)
    ensures |Q| == |S|
    decreases Q, S
  {
  }

  lemma lemma_seqs_set_membership<T>(Q: seq<T>, S: set<T>)
    requires SeqIsUnique(Q)
    requires S == UniqueSeqToSet(Q)
    ensures forall i: T {:trigger i in S} {:trigger i in Q} :: i in Q <==> i in S
    decreases Q, S
  {
  }
}

module Common__SeqIsUniqueDef_i {
  predicate {:opaque} {:fuel 0, 0} SeqIsUnique<X>(xs: seq<X>)
    decreases xs
  {
    forall i: int, j: int {:trigger xs[j], xs[i]} :: 
      0 <= i < |xs| &&
      0 <= j < |xs| &&
      xs[i] == xs[j] ==>
        i == j
  }
}

module GenericRefinement_i {

  import opened Native__NativeTypes_s

  import opened Collections__Maps_i

  import opened Collections__Sets_i

  import opened Logic__Option_i
  function uint64_to_int(u: uint64): int
    decreases u
  {
    u as int
  }

  function int_to_int(u: int): int
    decreases u
  {
    u as int
  }

  function nat_to_nat(n: nat): nat
    decreases n
  {
    n
  }

  predicate OptionalIsAbstractable<CT(!new), T>(ov: Option<CT>, refine_func: CT ~> T)
    reads set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in refine_func.reads(_x0)} | _obj in refine_func.reads(_x0) :: _obj
    decreases set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in refine_func.reads(_x0)} | _obj in refine_func.reads(_x0) :: _obj, ov
  {
    match ov
    case Some(v) =>
      refine_func.requires(v)
    case None() =>
      true
  }

  function AbstractifyOptional<CT(!new), T>(ov: Option<CT>, refine_func: CT ~> T): Option<T>
    requires OptionalIsAbstractable(ov, refine_func)
    reads set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in refine_func.reads(_x0)} | _obj in refine_func.reads(_x0) :: _obj
    decreases set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in refine_func.reads(_x0)} | _obj in refine_func.reads(_x0) :: _obj, ov
  {
    match ov {
      case Some(v) =>
        Some(refine_func(v))
      case None() =>
        None()
    }
  }

  function {:opaque} {:fuel 0, 0} MapSeqToSeq<T(!new), U>(s: seq<T>, refine_func: T ~> U): seq<U>
    requires forall i: T {:trigger refine_func.reads(i)} :: refine_func.reads(i) == {}
    requires forall i: int {:trigger s[i]} :: 0 <= i < |s| ==> refine_func.requires(s[i])
    reads set _x0: T, _obj: object? /*{:_reads}*/ {:trigger _obj in refine_func.reads(_x0)} | _obj in refine_func.reads(_x0) :: _obj
    ensures |MapSeqToSeq(s, refine_func)| == |s|
    ensures forall i: int {:trigger MapSeqToSeq(s, refine_func)[i]} {:trigger s[i]} :: 0 <= i < |s| ==> refine_func(s[i]) == MapSeqToSeq(s, refine_func)[i]
    decreases set _x0: T, _obj: object? /*{:_reads}*/ {:trigger _obj in refine_func.reads(_x0)} | _obj in refine_func.reads(_x0) :: _obj, s
  {
    if |s| == 0 then
      []
    else
      [refine_func(s[0])] + MapSeqToSeq(s[1..], refine_func)
  }

  predicate IsInjective<CT(!new), T(!new)>(f: CT ~> T)
    reads set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    decreases set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
  {
    forall i: CT, j: CT {:trigger f(j), f(i)} {:trigger f(j), f.requires(i)} {:trigger f(i), f.requires(j)} {:trigger f.requires(j), f.requires(i)} :: 
      f.requires(i) &&
      f.requires(j) &&
      f(i) == f(j) ==>
        i == j
  }

  predicate SeqIsAbstractable<T(!new), CT(!new)>(s: seq<CT>, RefineValue: CT ~> T)
    reads set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in RefineValue.reads(_x0)} | _obj in RefineValue.reads(_x0) :: _obj
    decreases set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in RefineValue.reads(_x0)} | _obj in RefineValue.reads(_x0) :: _obj, s
  {
    forall i: CT {:trigger RefineValue.requires(i)} {:trigger i in s} :: 
      i in s ==>
        RefineValue.requires(i)
  }

  function NoChange<T(!new)>(v: T): T
  {
    v
  }

  predicate MapIsValid<CKT(!new), CVT(!new)>(m: map<CKT, CVT>, ValidateKey: CKT ~> bool, ValidateValue: CVT ~> bool)
    reads set _x0: CKT, _obj: object? /*{:_reads}*/ {:trigger _obj in ValidateKey.reads(_x0)} | _obj in ValidateKey.reads(_x0) :: _obj, set _x0: CVT, _obj: object? /*{:_reads}*/ {:trigger _obj in ValidateValue.reads(_x0)} | _obj in ValidateValue.reads(_x0) :: _obj
    decreases (set _x0: CKT, _obj: object? /*{:_reads}*/ {:trigger _obj in ValidateKey.reads(_x0)} | _obj in ValidateKey.reads(_x0) :: _obj) + set _x0: CVT, _obj: object? /*{:_reads}*/ {:trigger _obj in ValidateValue.reads(_x0)} | _obj in ValidateValue.reads(_x0) :: _obj, m
  {
    forall k: CKT {:trigger m[k]} {:trigger ValidateKey(k)} {:trigger ValidateKey.requires(k)} {:trigger k in m} :: 
      (k in m ==>
        ValidateKey.requires(k)) &&
      (k in m ==>
        ValidateKey(k)) &&
      (k in m ==>
        ValidateValue.requires(m[k])) &&
      (k in m ==>
        ValidateValue(m[k]))
  }

  predicate SeqIsValid<CT(!new)>(s: seq<CT>, ValidateValue: CT ~> bool)
    reads set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in ValidateValue.reads(_x0)} | _obj in ValidateValue.reads(_x0) :: _obj
    decreases set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in ValidateValue.reads(_x0)} | _obj in ValidateValue.reads(_x0) :: _obj, s
  {
    forall i: CT {:trigger ValidateValue(i)} {:trigger ValidateValue.requires(i)} {:trigger i in s} :: 
      (i in s ==>
        ValidateValue.requires(i)) &&
      (i in s ==>
        ValidateValue(i))
  }

  function AbstractifySeq<T(!new), CT(!new)>(s: seq<CT>, RefineValue: CT ~> T): seq<T>
    requires SeqIsAbstractable(s, RefineValue)
    reads set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in RefineValue.reads(_x0)} | _obj in RefineValue.reads(_x0) :: _obj
    ensures ghost var cs: seq<T> := AbstractifySeq(s, RefineValue); |cs| == |s| && (forall i: int {:trigger s[i]} {:trigger cs[i]} :: 0 <= i < |s| ==> cs[i] == RefineValue(s[i])) && forall i: T {:trigger i in cs} :: i in cs ==> exists x: CT {:trigger RefineValue(x)} {:trigger x in s} :: x in s && i == RefineValue(x)
    decreases set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in RefineValue.reads(_x0)} | _obj in RefineValue.reads(_x0) :: _obj, s
  {
    ghost var cs: seq<T> := if |s| == 0 then [] else [RefineValue(s[0])] + AbstractifySeq(s[1..], RefineValue);
    assert forall i: T {:trigger i in cs} :: i in cs ==> exists x: CT {:trigger RefineValue(x)} {:trigger x in s} :: x in s && i == RefineValue(x);
    cs
  }

  lemma /*{:_induction s1, s2, RefineValue}*/ lemma_seq_concat<T(!new), CT(!new)>(s1: seq<CT>, s2: seq<CT>, RefineValue: CT ~> T)
    requires SeqIsAbstractable(s1, RefineValue)
    requires SeqIsAbstractable(s2, RefineValue)
    ensures AbstractifySeq(s1, RefineValue) + AbstractifySeq(s2, RefineValue) == AbstractifySeq(s1 + s2, RefineValue)
    ensures SeqIsAbstractable(s1 + s2, RefineValue)
    decreases s1, s2
  {
  }

  lemma /*{:_induction s, RefineValue}*/ lemma_seq_sub<T(!new), CT(!new)>(s: seq<CT>, RefineValue: CT ~> T, l: int, r: int)
    requires SeqIsAbstractable(s, RefineValue)
    requires 0 <= l <= r <= |s|
    ensures AbstractifySeq(s[l .. r], RefineValue) == AbstractifySeq(s, RefineValue)[l .. r]
    decreases s, l, r
  {
  }

  predicate SetIsInjective<T(!new), CT(!new)>(s: set<CT>, f: CT ~> T)
    requires SetIsAbstractable(s, f)
    reads set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    decreases set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, s
  {
    forall i: CT, j: CT {:trigger f(j), f(i)} {:trigger f(j), f.requires(i)} {:trigger f(j), i in s} {:trigger f(i), f.requires(j)} {:trigger f(i), j in s} {:trigger f.requires(j), f.requires(i)} {:trigger f.requires(j), i in s} {:trigger f.requires(i), j in s} {:trigger j in s, i in s} :: 
      i in s &&
      j in s &&
      f.requires(i) &&
      f.requires(j) &&
      f(i) == f(j) ==>
        i == j
  }

  predicate SetIsAbstractable<T(!new), CT(!new)>(s: set<CT>, RefineValue: CT ~> T)
    reads set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in RefineValue.reads(_x0)} | _obj in RefineValue.reads(_x0) :: _obj
    decreases set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in RefineValue.reads(_x0)} | _obj in RefineValue.reads(_x0) :: _obj, s
  {
    forall k: CT {:trigger RefineValue.requires(k)} {:trigger k in s} :: 
      k in s ==>
        RefineValue.requires(k)
  }

  function AbstractifySet<T(!new), CT(!new)>(s: set<CT>, RefineValue: CT ~> T): set<T>
    requires SetIsAbstractable(s, RefineValue)
    requires forall x: CT, y: CT {:trigger RefineValue(y), RefineValue(x)} {:trigger RefineValue(y), x in s} {:trigger RefineValue(x), y in s} {:trigger y in s, x in s} :: x in s && y in s && RefineValue(x) == RefineValue(y) ==> x == y
    reads set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in RefineValue.reads(_x0)} | _obj in RefineValue.reads(_x0) :: _obj
    ensures ghost var ss: set<T> := AbstractifySet(s, RefineValue); (forall k: CT {:trigger RefineValue(k)} {:trigger k in s} :: k in s ==> RefineValue(k) in ss) && |ss| == |s|
    decreases set _x0: CT, _obj: object? /*{:_reads}*/ {:trigger _obj in RefineValue.reads(_x0)} | _obj in RefineValue.reads(_x0) :: _obj, s
  {
    ghost var ss: set<T> := set i: CT {:trigger RefineValue(i)} {:trigger i in s} | i in s :: RefineValue(i);
    lemma_AbstractifySet_SizeUnchange(s, ss, RefineValue);
    ss
  }

  lemma lemma_AbstractifySet_SizeUnchange<T(!new), CT(!new)>(s: set<CT>, ss: set<T>, f: CT ~> T)
    requires forall x: CT {:trigger f.requires(x)} {:trigger x in s} :: x in s ==> f.requires(x)
    requires forall x: CT, y: CT {:trigger f(y), f(x)} {:trigger f(y), x in s} {:trigger f(x), y in s} {:trigger y in s, x in s} :: x in s && y in s && f(x) == f(y) ==> x == y
    requires forall x: CT {:trigger f(x)} {:trigger x in s} :: x in s ==> f(x) in ss
    requires forall y: T {:trigger y in ss} :: y in ss <==> exists x: CT {:trigger f(x)} {:trigger x in s} :: x in s && y == f(x)
    ensures |s| == |ss|
    decreases s, ss
  {
  }

  predicate MapIsAbstractable<KT(!new), VT, CKT(!new), CVT(!new)>(m: map<CKT, CVT>, RefineKey: CKT ~> KT, RefineValue: CVT ~> VT, ReverseKey: KT ~> CKT)
    reads set _x0: CKT, _obj: object? /*{:_reads}*/ {:trigger _obj in RefineKey.reads(_x0)} | _obj in RefineKey.reads(_x0) :: _obj, set _x0: CVT, _obj: object? /*{:_reads}*/ {:trigger _obj in RefineValue.reads(_x0)} | _obj in RefineValue.reads(_x0) :: _obj, set _x0: KT, _obj: object? /*{:_reads}*/ {:trigger _obj in ReverseKey.reads(_x0)} | _obj in ReverseKey.reads(_x0) :: _obj
    decreases (set _x0: CKT, _obj: object? /*{:_reads}*/ {:trigger _obj in RefineKey.reads(_x0)} | _obj in RefineKey.reads(_x0) :: _obj) + (set _x0: CVT, _obj: object? /*{:_reads}*/ {:trigger _obj in RefineValue.reads(_x0)} | _obj in RefineValue.reads(_x0) :: _obj) + set _x0: KT, _obj: object? /*{:_reads}*/ {:trigger _obj in ReverseKey.reads(_x0)} | _obj in ReverseKey.reads(_x0) :: _obj, m
  {
    (forall ck: CKT {:trigger m[ck]} {:trigger RefineKey.requires(ck)} {:trigger ck in m} :: 
      (ck in m ==>
        RefineKey.requires(ck)) &&
      (ck in m ==>
        RefineValue.requires(m[ck]))) &&
    forall ck: CKT {:trigger RefineKey(ck)} {:trigger ck in m} :: 
      (ck in m ==>
        ReverseKey.requires(RefineKey(ck))) &&
      (ck in m ==>
        ReverseKey(RefineKey(ck)) == ck)
  }

  function {:opaque} {:fuel 0, 0} AbstractifyMap<CKT(!new), CVT(!new), KT(!new), VT>(m: map<CKT, CVT>, RefineKey: CKT ~> KT, RefineValue: CVT ~> VT, ReverseKey: KT ~> CKT): map<KT, VT>
    requires forall ck: CKT {:trigger m[ck]} {:trigger RefineKey.requires(ck)} {:trigger ck in m} :: (ck in m ==> RefineKey.requires(ck)) && (ck in m ==> RefineValue.requires(m[ck]))
    requires forall ck: CKT {:trigger RefineKey(ck)} {:trigger ck in m} :: (ck in m ==> ReverseKey.requires(RefineKey(ck))) && (ck in m ==> ReverseKey(RefineKey(ck)) == ck)
    reads set _x0: CKT, _obj: object? /*{:_reads}*/ {:trigger _obj in RefineKey.reads(_x0)} | _obj in RefineKey.reads(_x0) :: _obj, set _x0: CVT, _obj: object? /*{:_reads}*/ {:trigger _obj in RefineValue.reads(_x0)} | _obj in RefineValue.reads(_x0) :: _obj, set _x0: KT, _obj: object? /*{:_reads}*/ {:trigger _obj in ReverseKey.reads(_x0)} | _obj in ReverseKey.reads(_x0) :: _obj
    ensures ghost var rm: map<KT, VT> := AbstractifyMap(m, RefineKey, RefineValue, ReverseKey); (forall ck: CKT {:trigger RefineKey(ck)} {:trigger RefineKey.requires(ck)} {:trigger ck in m} :: (ck in m ==> RefineKey.requires(ck)) && (ck in m ==> RefineKey(ck) in rm)) && (forall ck: CKT {:trigger m[ck]} {:trigger RefineKey(ck)} {:trigger ck in m} :: ck in m ==> rm[RefineKey(ck)] == RefineValue(m[ck])) && forall k: KT {:trigger k in rm} :: k in rm ==> exists ck: CKT {:trigger RefineKey(ck)} {:trigger ck in m} :: ck in m && RefineKey(ck) == k
    decreases (set _x0: CKT, _obj: object? /*{:_reads}*/ {:trigger _obj in RefineKey.reads(_x0)} | _obj in RefineKey.reads(_x0) :: _obj) + (set _x0: CVT, _obj: object? /*{:_reads}*/ {:trigger _obj in RefineValue.reads(_x0)} | _obj in RefineValue.reads(_x0) :: _obj) + set _x0: KT, _obj: object? /*{:_reads}*/ {:trigger _obj in ReverseKey.reads(_x0)} | _obj in ReverseKey.reads(_x0) :: _obj, m
  {
    map k: KT {:trigger m[ReverseKey(k)]} | k in set ck: CKT {:trigger RefineKey(ck)} {:trigger ck in m} | ck in m :: RefineKey(ck) :: RefineValue(m[ReverseKey(k)])
  }

  lemma Lemma_AbstractifyMap_basic_properties<CKT, CVT, KT, VT>(m: map<CKT, CVT>, RefineKey: CKT ~> KT, RefineValue: CVT ~> VT, ReverseKey: KT ~> CKT)
    requires MapIsAbstractable(m, RefineKey, RefineValue, ReverseKey)
    requires forall ck1: CKT, ck2: CKT {:trigger RefineKey(ck2), RefineKey(ck1)} {:trigger RefineKey(ck2), RefineKey.requires(ck1)} {:trigger RefineKey(ck1), RefineKey.requires(ck2)} {:trigger RefineKey.requires(ck2), RefineKey.requires(ck1)} :: RefineKey.requires(ck1) && RefineKey.requires(ck2) && RefineKey(ck1) == RefineKey(ck2) ==> ck1 == ck2
    ensures m == map[] ==> AbstractifyMap(m, RefineKey, RefineValue, ReverseKey) == map[]
    ensures forall ck: CKT {:trigger m[ck]} {:trigger RefineKey(ck)} {:trigger ck in m} :: ck in m ==> AbstractifyMap(m, RefineKey, RefineValue, ReverseKey)[RefineKey(ck)] == RefineValue(m[ck])
    ensures forall ck: CKT {:trigger RefineKey(ck)} {:trigger RefineKey.requires(ck)} {:trigger ck in m} :: ck in m <==> RefineKey.requires(ck) && RefineKey(ck) in AbstractifyMap(m, RefineKey, RefineValue, ReverseKey)
    ensures forall ck: CKT {:trigger m[ck]} {:trigger RefineKey(ck)} {:trigger ck in m} :: ck in m ==> AbstractifyMap(m, RefineKey, RefineValue, ReverseKey)[RefineKey(ck)] == RefineValue(m[ck])
    decreases m
  {
  }

  lemma Lemma_AbstractifyMap_preimage<KT(!new), VT(!new), CKT(!new), CVT(!new)>(cm: map<CKT, CVT>, RefineKey: CKT ~> KT, RefineValue: CVT ~> VT, ReverseKey: KT ~> CKT)
    requires MapIsAbstractable(cm, RefineKey, RefineValue, ReverseKey)
    requires forall ck1: CKT, ck2: CKT {:trigger RefineKey(ck2), RefineKey(ck1)} {:trigger RefineKey(ck2), RefineKey.requires(ck1)} {:trigger RefineKey(ck1), RefineKey.requires(ck2)} {:trigger RefineKey.requires(ck2), RefineKey.requires(ck1)} :: RefineKey.requires(ck1) && RefineKey.requires(ck2) && RefineKey(ck1) == RefineKey(ck2) ==> ck1 == ck2
    ensures ghost var rm: map<KT, VT> := AbstractifyMap(cm, RefineKey, RefineValue, ReverseKey); forall k: KT {:trigger k in rm} :: k in rm ==> exists ck: CKT {:trigger RefineKey(ck)} {:trigger ck in cm} :: ck in cm && RefineKey(ck) == k
    decreases cm
  {
  }

  lemma Lemma_AbstractifyMap_append<KT(!new), VT(!new), CKT(!new), CVT(!new)>(cm: map<CKT, CVT>, RefineKey: CKT ~> KT, RefineValue: CVT ~> VT, ReverseKey: KT ~> CKT, ck: CKT, cval: CVT)
    requires MapIsAbstractable(cm, RefineKey, RefineValue, ReverseKey)
    requires forall ck1: CKT, ck2: CKT {:trigger RefineKey(ck2), RefineKey(ck1)} {:trigger RefineKey(ck2), RefineKey.requires(ck1)} {:trigger RefineKey(ck1), RefineKey.requires(ck2)} {:trigger RefineKey.requires(ck2), RefineKey.requires(ck1)} :: RefineKey.requires(ck1) && RefineKey.requires(ck2) && RefineKey(ck1) == RefineKey(ck2) ==> ck1 == ck2
    requires RefineKey.requires(ck)
    requires RefineValue.requires(cval)
    requires ReverseKey.requires(RefineKey(ck)) && ReverseKey(RefineKey(ck)) == ck
    ensures ghost var rm: map<KT, VT> := AbstractifyMap(cm, RefineKey, RefineValue, ReverseKey); ghost var rm': map<KT, VT> := AbstractifyMap(cm[ck := cval], RefineKey, RefineValue, ReverseKey); rm' == AbstractifyMap(cm, RefineKey, RefineValue, ReverseKey)[RefineKey(ck) := RefineValue(cval)]
    decreases cm
  {
  }

  lemma Lemma_AbstractifyMap_remove<KT(!new), VT(!new), CKT(!new), CVT(!new)>(cm: map<CKT, CVT>, RefineKey: CKT ~> KT, RefineValue: CVT ~> VT, ReverseKey: KT ~> CKT, ck: CKT)
    requires MapIsAbstractable(cm, RefineKey, RefineValue, ReverseKey)
    requires forall ck1: CKT, ck2: CKT {:trigger RefineKey(ck2), RefineKey(ck1)} {:trigger RefineKey(ck2), RefineKey.requires(ck1)} {:trigger RefineKey(ck1), RefineKey.requires(ck2)} {:trigger RefineKey.requires(ck2), RefineKey.requires(ck1)} :: RefineKey.requires(ck1) && RefineKey.requires(ck2) && RefineKey(ck1) == RefineKey(ck2) ==> ck1 == ck2
    requires RefineKey.requires(ck)
    requires ReverseKey.requires(RefineKey(ck)) && ReverseKey(RefineKey(ck)) == ck
    requires ck in cm
    ensures ghost var rm: map<KT, VT> := AbstractifyMap(cm, RefineKey, RefineValue, ReverseKey); ghost var rm': map<KT, VT> := AbstractifyMap(RemoveElt(cm, ck), RefineKey, RefineValue, ReverseKey); RefineKey(ck) in rm && rm' == RemoveElt(rm, RefineKey(ck))
    decreases cm
  {
  }

  lemma lemma_AbstractifyMap_properties<CKT(!new), CVT(!new), KT(!new), VT(!new)>(cm: map<CKT, CVT>, RefineKey: CKT ~> KT, RefineValue: CVT ~> VT, ReverseKey: KT ~> CKT)
    requires MapIsAbstractable(cm, RefineKey, RefineValue, ReverseKey)
    requires forall ck1: CKT, ck2: CKT {:trigger RefineKey(ck2), RefineKey(ck1)} {:trigger RefineKey(ck2), RefineKey.requires(ck1)} {:trigger RefineKey(ck1), RefineKey.requires(ck2)} {:trigger RefineKey.requires(ck2), RefineKey.requires(ck1)} :: RefineKey.requires(ck1) && RefineKey.requires(ck2) && RefineKey(ck1) == RefineKey(ck2) ==> ck1 == ck2
    ensures cm == map[] ==> AbstractifyMap(cm, RefineKey, RefineValue, ReverseKey) == map[]
    ensures forall ck: CKT {:trigger RefineKey(ck)} {:trigger RefineKey.requires(ck)} {:trigger ck in cm} :: ck in cm <==> RefineKey.requires(ck) && RefineKey(ck) in AbstractifyMap(cm, RefineKey, RefineValue, ReverseKey)
    ensures forall ck: CKT {:trigger cm[ck]} {:trigger RefineKey(ck)} {:trigger ck in cm} :: ck in cm ==> AbstractifyMap(cm, RefineKey, RefineValue, ReverseKey)[RefineKey(ck)] == RefineValue(cm[ck])
    ensures forall ck: CKT {:trigger RefineKey(ck)} {:trigger RefineKey.requires(ck)} {:trigger ck in cm} :: ck !in cm && RefineKey.requires(ck) ==> RefineKey(ck) !in AbstractifyMap(cm, RefineKey, RefineValue, ReverseKey)
    ensures ghost var rm: map<KT, VT> := AbstractifyMap(cm, RefineKey, RefineValue, ReverseKey); forall k: KT {:trigger k in rm} :: k in rm ==> exists ck: CKT {:trigger RefineKey(ck)} {:trigger ck in cm} :: ck in cm && RefineKey(ck) == k
    ensures forall ck: CKT, cval: CVT {:trigger cm[ck := cval]} {:trigger RefineKey(ck), RefineValue(cval)} :: RefineKey.requires(ck) && RefineValue.requires(cval) && ReverseKey.requires(RefineKey(ck)) && ReverseKey(RefineKey(ck)) == ck ==> ghost var rm: map<KT, VT> := AbstractifyMap(cm, RefineKey, RefineValue, ReverseKey); ghost var rm': map<KT, VT> := AbstractifyMap(cm[ck := cval], RefineKey, RefineValue, ReverseKey); rm' == AbstractifyMap(cm, RefineKey, RefineValue, ReverseKey)[RefineKey(ck) := RefineValue(cval)]
    ensures forall ck: CKT {:trigger RemoveElt(AbstractifyMap(cm, RefineKey, RefineValue, ReverseKey), RefineKey(ck))} :: RefineKey.requires(ck) && ReverseKey.requires(RefineKey(ck)) && ReverseKey(RefineKey(ck)) == ck && ck in cm ==> ghost var rm: map<KT, VT> := AbstractifyMap(cm, RefineKey, RefineValue, ReverseKey); ghost var rm': map<KT, VT> := AbstractifyMap(RemoveElt(cm, ck), RefineKey, RefineValue, ReverseKey); rm' == RemoveElt(rm, RefineKey(ck))
    decreases cm
  {
  }
}

module Logic__Option_i {
  datatype Option<T> = Some(v: T) | None
}

module LiveByzRSL__PacketParsing_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened Collections__Maps_i

  import opened LiveByzRSL__AppInterface_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__CTypes_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__Types_i

  import opened Common__GenericMarshalling_i

  import opened Common__NodeIdentity_i

  import opened Common__UdpClient_i

  import opened Common__Util_i

  import opened Environment_s

  import opened Math__mul_i

  import opened Math__mul_nonlinear_i
  function method EndPoint_grammar(): G
  {
    GUint64
  }

  function method CRequest_grammar(): G
  {
    GTuple([EndPoint_grammar(), GUint64, CAppMessage_grammar()])
  }

  function method CRequestBatch_grammar(): G
  {
    GArray(CRequest_grammar())
  }

  function method CReply_grammar(): G
  {
    GTuple([EndPoint_grammar(), GUint64, CAppMessage_grammar()])
  }

  function method CBallot_grammar(): G
  {
    GTuple([GUint64, GUint64])
  }

  function method COperationNumber_grammar(): G
  {
    GUint64
  }

  function method CVote_grammar(): G
  {
    GTuple([CBallot_grammar(), CRequestBatch_grammar()])
  }

  function method CMap_grammar(key: G, val: G): G
    decreases key, val
  {
    GArray(GTuple([key, val]))
  }

  function method CVotes_grammar(): G
  {
    GArray(GTuple([COperationNumber_grammar(), CVote_grammar()]))
  }

  function method CReplyCache_grammar(): G
  {
    GArray(GTuple([EndPoint_grammar(), CReply_grammar()]))
  }

  function method CMessage_Request_grammar(): G
  {
    GTuple([GUint64, CAppMessage_grammar()])
  }

  function method CMessage_1a_grammar(): G
  {
    CBallot_grammar()
  }

  function method CMessage_1b_grammar(): G
  {
    GTuple([CBallot_grammar(), COperationNumber_grammar(), CVotes_grammar()])
  }

  function method CMessage_1c_grammar(): G
  {
    GTuple([CBallot_grammar(), COperationNumber_grammar(), CRequestBatch_grammar()])
  }

  function method CMessage_2av_grammar(): G
  {
    GTuple([CBallot_grammar(), COperationNumber_grammar(), CRequestBatch_grammar()])
  }

  function method CMessage_2b_grammar(): G
  {
    GTuple([CBallot_grammar(), COperationNumber_grammar(), CRequestBatch_grammar()])
  }

  function method CMessage_Heartbeat_grammar(): G
  {
    GTuple([CBallot_grammar(), GUint64, COperationNumber_grammar()])
  }

  function method CMessage_Reply_grammar(): G
  {
    GTuple([GUint64, CAppMessage_grammar()])
  }

  function method CMessage_StartingPhase2_grammar(): G
  {
    GTuple([CBallot_grammar(), COperationNumber_grammar()])
  }

  function method CMessage_grammar(): G
  {
    GTaggedUnion([CMessage_Request_grammar(), CMessage_1a_grammar(), CMessage_1b_grammar(), CMessage_1c_grammar(), CMessage_2av_grammar(), CMessage_2b_grammar(), CMessage_Heartbeat_grammar(), CMessage_Reply_grammar(), CMessage_StartingPhase2_grammar()])
  }

  predicate NetPacketBound(data: seq<byte>)
    decreases data
  {
    |data| < MaxPacketSize()
  }

  predicate CRequestBatchIs64Bit(batch: CRequestBatch)
    decreases batch
  {
    |batch| < 18446744073709551616
  }

  predicate CVoteIs64Bit(vote: CVote)
    decreases vote
  {
    CRequestBatchIs64Bit(vote.max_val)
  }

  predicate CVotesIs64Bit(votes: CVotes)
    decreases votes
  {
    |votes| < 18446744073709551616 &&
    forall opn: int {:trigger votes[opn]} {:trigger opn in votes} :: 
      opn in votes ==>
        CVoteIs64Bit(votes[opn])
  }

  predicate CReplyCacheIs64Bit(rc: CReplyCache)
    decreases rc
  {
    |rc| < 18446744073709551616
  }

  predicate CMessageIs64Bit(msg: CMessage)
    decreases msg
  {
    match msg
    case CMessage_Invalid() =>
      true
    case CMessage_Request(seqno, val) =>
      true
    case CMessage_1a(bal) =>
      true
    case CMessage_1b(bal, log_truncation_point, votes) =>
      CVotesIs64Bit(votes)
    case CMessage_1c(bal, opn, batch) =>
      CRequestBatchIs64Bit(batch)
    case CMessage_2av(bal, opn, batch) =>
      CRequestBatchIs64Bit(batch)
    case CMessage_2b(bal, opn, batch) =>
      CRequestBatchIs64Bit(batch)
    case CMessage_Heartbeat(bal, suspicious, opn) =>
      true
    case CMessage_Reply(seqno, reply) =>
      true
    case CMessage_StartingPhase2(bal, log_truncation_point) =>
      true
  }

  function method parse_EndPoint(val: V): EndPoint
    requires ValInGrammar(val, EndPoint_grammar())
    ensures EndPointIsAbstractable(parse_EndPoint(val))
    decreases val
  {
    if val.u <= 281474976710655 then
      ConvertUint64ToEndPoint(val.u)
    else
      EndPoint([0, 0, 0, 0], 0)
  }

  function method parse_Request(val: V): CRequest
    requires ValInGrammar(val, CRequest_grammar())
    ensures CRequestIsAbstractable(parse_Request(val))
    decreases val
  {
    assert ValInGrammar(val.t[0], CRequest_grammar().t[0]);
    assert ValInGrammar(val.t[1], CRequest_grammar().t[1]);
    assert ValInGrammar(val.t[2], CRequest_grammar().t[2]);
    var ep: EndPoint := parse_EndPoint(val.t[0]);
    CRequest(ep, val.t[1].u as int, parse_AppMessage(val.t[2]))
  }

  function parse_RequestBatch(val: V): CRequestBatch
    requires ValInGrammar(val, CRequestBatch_grammar())
    ensures |parse_RequestBatch(val)| == |val.a|
    ensures forall i: int {:trigger val.a[i]} {:trigger parse_RequestBatch(val)[i]} :: 0 <= i < |parse_RequestBatch(val)| ==> parse_RequestBatch(val)[i] == parse_Request(val.a[i])
    ensures CRequestBatchIsAbstractable(parse_RequestBatch(val))
    ensures ValidVal(val) ==> CRequestBatchIs64Bit(parse_RequestBatch(val))
    decreases |val.a|
  {
    if |val.a| == 0 then
      []
    else
      ghost var req: CRequest := parse_Request(val.a[0]); ghost var restVal: V := VArray(val.a[1..]); ghost var rest: CRequestBatch := parse_RequestBatch(restVal); [req] + rest
  }

  method Parse_RequestBatch(val: V) returns (batch: CRequestBatch)
    requires ValInGrammar(val, CRequestBatch_grammar())
    requires ValidVal(val)
    ensures |batch| == |val.a|
    ensures CRequestBatchIs64Bit(batch)
    ensures forall i: int {:trigger val.a[i]} {:trigger batch[i]} :: 0 <= i < |batch| ==> batch[i] == parse_Request(val.a[i])
    ensures batch == parse_RequestBatch(val)
    ensures CRequestBatchIsAbstractable(batch)
    decreases val
  {
    var batchArr := new CRequest[|val.a| as uint64];
    var i: uint64 := 0;
    while i < |val.a| as uint64
      invariant 0 <= i as int <= |val.a|
      invariant forall j: int {:trigger val.a[j]} {:trigger batchArr[j]} :: 0 <= j < i as int ==> batchArr[j] == parse_Request(val.a[j])
      decreases |val.a| as uint64 as int - i as int
    {
      var req := parse_Request(val.a[i]);
      batchArr[i] := req;
      i := i + 1;
    }
    batch := batchArr[..];
  }

  function method parse_Reply(val: V): CReply
    requires ValInGrammar(val, CReply_grammar())
    ensures CReplyIsAbstractable(parse_Reply(val))
    decreases val
  {
    assert ValInGrammar(val.t[0], CReply_grammar().t[0]);
    assert ValInGrammar(val.t[1], CReply_grammar().t[1]);
    assert ValInGrammar(val.t[2], CReply_grammar().t[2]);
    var ep: EndPoint := parse_EndPoint(val.t[0]);
    CReply(ep, val.t[1].u as int, parse_AppMessage(val.t[2]))
  }

  function method parse_Ballot(val: V): CBallot
    requires ValInGrammar(val, CBallot_grammar())
    ensures CBallotIsAbstractable(parse_Ballot(val))
    decreases val
  {
    assert ValInGrammar(val.t[0], CBallot_grammar().t[0]);
    assert ValInGrammar(val.t[1], CBallot_grammar().t[1]);
    CBallot(val.t[0].u as int, val.t[1].u as int)
  }

  function method parse_OperationNumber(val: V): COperationNumber
    requires ValInGrammar(val, COperationNumber_grammar())
    decreases val
  {
    val.u as int
  }

  function parse_Vote(val: V): CVote
    requires ValInGrammar(val, CVote_grammar())
    ensures CVoteIsAbstractable(parse_Vote(val))
    ensures ValidVal(val) ==> CVoteIs64Bit(parse_Vote(val))
    decreases val
  {
    CVote(parse_Ballot(val.t[0]), parse_RequestBatch(val.t[1]))
  }

  method Parse_Vote(val: V) returns (vote: CVote)
    requires ValInGrammar(val, CVote_grammar())
    requires ValidVal(val)
    ensures parse_Vote(val) == vote
    ensures CVoteIs64Bit(vote)
    decreases val
  {
    var batch := Parse_RequestBatch(val.t[1]);
    vote := CVote(parse_Ballot(val.t[0]), batch);
  }

  function parse_Votes(val: V): CVotes
    requires ValInGrammar(val, CVotes_grammar())
    ensures CVotesIsAbstractable(parse_Votes(val))
    ensures |parse_Votes(val)| <= |val.a|
    ensures ValidVal(val) ==> CVotesIs64Bit(parse_Votes(val))
    decreases |val.a|
  {
    if |val.a| == 0 then
      map[]
    else
      ghost var tuple: V := val.a[0]; assert ValInGrammar(tuple, CVotes_grammar().elt); assert ValInGrammar(tuple.t[0], CVotes_grammar().elt.t[0]); assert ValInGrammar(tuple.t[1], CVotes_grammar().elt.t[1]); ghost var op: COperationNumber := parse_OperationNumber(tuple.t[0]); ghost var vote: CVote := parse_Vote(tuple.t[1]); ghost var others: CVotes := parse_Votes(VArray(val.a[1..])); calc {
    ValidVal(val);
  ==>
    {
      assert val.a[0] in val.a;
    }
    ValidVal(val.a[0]);
  ==>
    ValidVal(tuple);
  ==>
    {
      assert tuple.t[1] in tuple.t;
    }
    ValidVal(tuple.t[1]);
  ==>
    CVoteIs64Bit(vote);
  } ghost var m: map<COperationNumber, CVote> := others[op := vote]; m
  }

  method Parse_Votes(val: V) returns (votes: CVotes)
    requires ValInGrammar(val, CVotes_grammar())
    requires ValidVal(val)
    ensures CVotesIsAbstractable(votes)
    ensures CVotesIs64Bit(votes)
    ensures votes == parse_Votes(val)
    decreases |val.a|
  {
    if |val.a| as uint64 == 0 {
      votes := map[];
    } else {
      var tuple := val.a[0];
      assert ValInGrammar(tuple, CVotes_grammar().elt);
      assert ValInGrammar(tuple.t[0], CVotes_grammar().elt.t[0]);
      assert ValInGrammar(tuple.t[1], CVotes_grammar().elt.t[1]);
      calc ==> {
        ValidVal(val);
        ValidVal(tuple);
        ValidVal(tuple.t[1]);
      }
      var op := parse_OperationNumber(tuple.t[0]);
      var vote := Parse_Vote(tuple.t[1]);
      var others := Parse_Votes(VArray(val.a[1..]));
      var m := others[op := vote];
      votes := m;
    }
  }

  function method parse_ReplyCache(val: V): CReplyCache
    requires ValInGrammar(val, CReplyCache_grammar())
    ensures CReplyCacheIsAbstractable(parse_ReplyCache(val))
    ensures |parse_ReplyCache(val)| <= |val.a|
    ensures ValidVal(val) ==> CReplyCacheIs64Bit(parse_ReplyCache(val))
    decreases |val.a|
  {
    if |val.a| == 0 then
      map[]
    else
      var tuple: V := val.a[0]; assert ValInGrammar(tuple, CReplyCache_grammar().elt); assert ValInGrammar(tuple.t[0], CReplyCache_grammar().elt.t[0]); assert ValInGrammar(tuple.t[1], CReplyCache_grammar().elt.t[1]); var e: EndPoint := parse_EndPoint(tuple.t[0]); var reply: CReply := parse_Reply(tuple.t[1]); var others: CReplyCache := parse_ReplyCache(VArray(val.a[1..])); var m: map<EndPoint, CReply> := others[e := reply]; assert forall e': EndPoint {:trigger EndPointIsValidIPV4(e')} {:trigger e' in m} :: e' in m ==> EndPointIsValidIPV4(e'); assert forall e': EndPoint {:trigger m[e']} {:trigger e' in m} :: e' in m ==> CReplyIsAbstractable(m[e']); m
  }

  function method parse_Message_Request(val: V): CMessage
    requires ValInGrammar(val, CMessage_Request_grammar())
    ensures CMessageIsAbstractable(parse_Message_Request(val))
    ensures ValidVal(val) ==> CMessageIs64Bit(parse_Message_Request(val))
    decreases val
  {
    assert ValInGrammar(val.t[0], CMessage_Request_grammar().t[0]);
    assert ValInGrammar(val.t[1], CMessage_Request_grammar().t[1]);
    CMessage_Request(val.t[0].u as int, parse_AppMessage(val.t[1]))
  }

  function method parse_Message_1a(val: V): CMessage
    requires ValInGrammar(val, CMessage_1a_grammar())
    ensures CMessageIsAbstractable(parse_Message_1a(val))
    ensures ValidVal(val) ==> CMessageIs64Bit(parse_Message_1a(val))
    decreases val
  {
    CMessage_1a(parse_Ballot(val))
  }

  function parse_Message_1b(val: V): CMessage
    requires ValInGrammar(val, CMessage_1b_grammar())
    ensures CMessageIsAbstractable(parse_Message_1b(val))
    ensures ValidVal(val) ==> CMessageIs64Bit(parse_Message_1b(val))
    decreases val
  {
    CMessage_1b(parse_Ballot(val.t[0]), parse_OperationNumber(val.t[1]), parse_Votes(val.t[2]))
  }

  method Parse_Message_1b(val: V) returns (msg: CMessage)
    requires ValInGrammar(val, CMessage_1b_grammar())
    requires ValidVal(val)
    ensures msg == parse_Message_1b(val)
    ensures CMessageIsAbstractable(msg)
    ensures CMessageIs64Bit(msg)
    decreases val
  {
    var votes := Parse_Votes(val.t[2]);
    msg := CMessage_1b(parse_Ballot(val.t[0]), parse_OperationNumber(val.t[1]), votes);
  }

  function parse_Message_1c(val: V): CMessage
    requires ValInGrammar(val, CMessage_1c_grammar())
    ensures CMessageIsAbstractable(parse_Message_1c(val))
    ensures ValidVal(val) ==> CMessageIs64Bit(parse_Message_1c(val))
    decreases val
  {
    CMessage_1c(parse_Ballot(val.t[0]), parse_OperationNumber(val.t[1]), parse_RequestBatch(val.t[2]))
  }

  method Parse_Message_1c(val: V) returns (msg: CMessage)
    requires ValInGrammar(val, CMessage_1c_grammar())
    requires ValidVal(val)
    ensures msg == parse_Message_1c(val)
    ensures CMessageIsAbstractable(msg)
    ensures CMessageIs64Bit(msg)
    decreases val
  {
    var batch := Parse_RequestBatch(val.t[2]);
    msg := CMessage_1c(parse_Ballot(val.t[0]), parse_OperationNumber(val.t[1]), batch);
  }

  function parse_Message_2av(val: V): CMessage
    requires ValInGrammar(val, CMessage_2av_grammar())
    ensures CMessageIsAbstractable(parse_Message_2av(val))
    ensures ValidVal(val) ==> CMessageIs64Bit(parse_Message_2av(val))
    decreases val
  {
    CMessage_2av(parse_Ballot(val.t[0]), parse_OperationNumber(val.t[1]), parse_RequestBatch(val.t[2]))
  }

  method Parse_Message_2av(val: V) returns (msg: CMessage)
    requires ValInGrammar(val, CMessage_2av_grammar())
    requires ValidVal(val)
    ensures msg == parse_Message_2av(val)
    ensures CMessageIsAbstractable(msg)
    ensures CMessageIs64Bit(msg)
    decreases val
  {
    var batch := Parse_RequestBatch(val.t[2]);
    msg := CMessage_2av(parse_Ballot(val.t[0]), parse_OperationNumber(val.t[1]), batch);
  }

  function parse_Message_2b(val: V): CMessage
    requires ValInGrammar(val, CMessage_2b_grammar())
    ensures ValidVal(val) ==> CMessageIs64Bit(parse_Message_2b(val))
    decreases val
  {
    CMessage_2b(parse_Ballot(val.t[0]), parse_OperationNumber(val.t[1]), parse_RequestBatch(val.t[2]))
  }

  method Parse_Message_2b(val: V) returns (msg: CMessage)
    requires ValInGrammar(val, CMessage_2b_grammar())
    requires ValidVal(val)
    ensures msg == parse_Message_2b(val)
    ensures CMessageIsAbstractable(msg)
    ensures CMessageIs64Bit(msg)
    decreases val
  {
    var batch := Parse_RequestBatch(val.t[2]);
    msg := CMessage_2b(parse_Ballot(val.t[0]), parse_OperationNumber(val.t[1]), batch);
  }

  function method parse_Message_Heartbeat(val: V): CMessage
    requires ValInGrammar(val, CMessage_Heartbeat_grammar())
    ensures CMessageIsAbstractable(parse_Message_Heartbeat(val))
    ensures ValidVal(val) ==> CMessageIs64Bit(parse_Message_Heartbeat(val))
    decreases val
  {
    assert ValInGrammar(val.t[1], CMessage_Heartbeat_grammar().t[1]);
    CMessage_Heartbeat(parse_Ballot(val.t[0]), val.t[1].u != 0, parse_OperationNumber(val.t[2]))
  }

  function method parse_Message_Reply(val: V): CMessage
    requires ValInGrammar(val, CMessage_Reply_grammar())
    ensures CMessageIsAbstractable(parse_Message_Reply(val))
    ensures ValidVal(val) ==> CMessageIs64Bit(parse_Message_Reply(val))
    decreases val
  {
    assert ValInGrammar(val.t[0], CMessage_Reply_grammar().t[0]);
    assert ValInGrammar(val.t[1], CMessage_Reply_grammar().t[1]);
    CMessage_Reply(val.t[0].u as int, parse_AppMessage(val.t[1]))
  }

  function method parse_Message_StartingPhase2(val: V): CMessage
    requires ValInGrammar(val, CMessage_StartingPhase2_grammar())
    ensures CMessageIsAbstractable(parse_Message_StartingPhase2(val))
    ensures ValidVal(val) ==> CMessageIs64Bit(parse_Message_StartingPhase2(val))
    decreases val
  {
    CMessage_StartingPhase2(parse_Ballot(val.t[0]), parse_OperationNumber(val.t[1]))
  }

  function parse_Message(val: V): CMessage
    requires ValInGrammar(val, CMessage_grammar())
    ensures CMessageIsAbstractable(parse_Message(val))
    ensures ValidVal(val) ==> CMessageIs64Bit(parse_Message(val))
    decreases val
  {
    if val.c == 0 then
      parse_Message_Request(val.val)
    else if val.c == 1 then
      parse_Message_1a(val.val)
    else if val.c == 2 then
      parse_Message_1b(val.val)
    else if val.c == 3 then
      parse_Message_1c(val.val)
    else if val.c == 4 then
      parse_Message_2av(val.val)
    else if val.c == 5 then
      parse_Message_2b(val.val)
    else if val.c == 6 then
      parse_Message_Heartbeat(val.val)
    else if val.c == 7 then
      parse_Message_Reply(val.val)
    else if val.c == 8 then
      parse_Message_StartingPhase2(val.val)
    else
      assert false; parse_Message_Request(val)
  }

  method Parse_Message(val: V) returns (msg: CMessage)
    requires ValInGrammar(val, CMessage_grammar())
    requires ValidVal(val)
    ensures msg == parse_Message(val)
    ensures !msg.CMessage_Invalid?
    ensures CMessageIsAbstractable(msg)
    ensures CMessageIs64Bit(msg)
    decreases val
  {
    if val.c == 0 {
      msg := parse_Message_Request(val.val);
    } else if val.c == 1 {
      msg := parse_Message_1a(val.val);
    } else if val.c == 2 {
      msg := Parse_Message_1b(val.val);
    } else if val.c == 3 {
      msg := Parse_Message_1c(val.val);
    } else if val.c == 4 {
      msg := Parse_Message_2av(val.val);
    } else if val.c == 5 {
      msg := Parse_Message_2b(val.val);
    } else if val.c == 6 {
      msg := parse_Message_Heartbeat(val.val);
    } else if val.c == 7 {
      msg := parse_Message_Reply(val.val);
    } else if val.c == 8 {
      msg := parse_Message_StartingPhase2(val.val);
    } else {
      assert false;
      msg := parse_Message_Request(val);
    }
  }

  function PaxosDemarshallData(data: seq<byte>): CMessage
    ensures CMessageIsAbstractable(PaxosDemarshallData(data))
    decreases data
  {
    if Demarshallable(data, CMessage_grammar()) then
      ghost var val: V := DemarshallFunc(data, CMessage_grammar());
      parse_Message(val)
    else
      CMessage_Invalid()
  }

  method PaxosDemarshallDataMethod(data: array<byte>, msg_grammar: G) returns (msg: CMessage)
    requires data.Length < 18446744073709551616
    requires msg_grammar == CMessage_grammar()
    requires ValidGrammar(msg_grammar)
    ensures CMessageIsAbstractable(msg)
    ensures if Demarshallable(data[..], msg_grammar) then msg == PaxosDemarshallData(data[..]) else msg.CMessage_Invalid?
    ensures CMessageIs64Bit(msg)
    decreases data, msg_grammar
  {
    var success, val := Demarshall(data, msg_grammar);
    if success {
      assert ValInGrammar(val, msg_grammar);
      msg := Parse_Message(val);
      assert !msg.CMessage_Invalid?;
    } else {
      msg := CMessage_Invalid();
    }
  }

  function Marshallable_1c(msg: CMessage): bool
    decreases msg
  {
    msg.CMessage_1c? &&
    CRequestBatchIsValid(msg.val_1c)
  }

  function Marshallable_2av(msg: CMessage): bool
    decreases msg
  {
    msg.CMessage_2av? &&
    CRequestBatchIsValid(msg.val_2av)
  }

  function Marshallable_2b(msg: CMessage): bool
    decreases msg
  {
    msg.CMessage_2b? &&
    CRequestBatchIsValid(msg.val_2b)
  }

  function Marshallable(msg: CMessage): bool
    decreases msg
  {
    !msg.CMessage_Invalid? &&
    (msg.CMessage_Request? ==>
      CAppMessageIsValid(msg.val)) &&
    (msg.CMessage_1a? ==>
      true) &&
    (msg.CMessage_1b? ==>
      CVotesIsValid(msg.votes)) &&
    (msg.CMessage_1c? ==>
      Marshallable_1c(msg)) &&
    (msg.CMessage_2av? ==>
      Marshallable_2av(msg)) &&
    (msg.CMessage_2b? ==>
      Marshallable_2b(msg)) &&
    (msg.CMessage_Heartbeat? ==>
      true) &&
    (msg.CMessage_Reply? ==>
      CAppMessageIsValid(msg.reply)) &&
    (msg.CMessage_StartingPhase2? ==>
      true)
  }

  function CMessageIsMarshallable(msg: CMessage): bool
    decreases msg
  {
    Marshallable(msg)
  }

  method DetermineIfValidVote(vote: CVote) returns (b: bool)
    requires CVoteIsAbstractable(vote)
    requires CVoteIs64Bit(vote)
    ensures b == CVoteIsValid(vote)
    decreases vote
  {
    if |vote.max_val| > RequestBatchSizeLimit() {
      print ""Cvote's RequestBatch exceeds size limit\n"";
      lemma_RequestQueue_len(vote.max_val);
      return;
    }
    b := |vote.max_val| as uint64 <= RequestBatchSizeLimit() as uint64;
  }

  lemma {:axiom} lemma_vote_len(votes: CVotes)
    ensures |votes| < max_votes_len()
    decreases votes

  method DetermineIfValidVotes(votes: CVotes) returns (b: bool)
    requires CVotesIsAbstractable(votes)
    requires CVotesIs64Bit(votes)
    ensures b == CVotesIsValid(votes)
    decreases votes
  {
    b := |votes| as uint64 < max_votes_len() as uint64;
    if !b {
      print ""votes exceeds the max length"";
      lemma_vote_len(votes);
      return;
    }
    var keys := domain(votes);
    lemma_MapSizeIsDomainSize(keys, votes);
    while |keys| > 0
      invariant |keys| < max_votes_len()
      invariant forall opn: int {:trigger opn in votes} {:trigger opn in keys} :: opn in keys ==> opn in votes
      invariant forall opn: int {:trigger votes[opn]} {:trigger opn in keys} {:trigger opn in votes} :: opn in votes ==> opn in keys || CVoteIsValid(votes[opn])
      decreases |keys|
    {
      var opn :| opn in keys;
      keys := keys - {opn};
      b := DetermineIfValidVote(votes[opn]);
      if !b {
        return;
      }
    }
  }

  method DetermineIfValidRequestBatch(c: CRequestBatch) returns (b: bool)
    requires CRequestBatchIsAbstractable(c)
    requires CRequestBatchIs64Bit(c)
    ensures b == CRequestBatchIsValid(c)
    decreases c
  {
    var n := |c| as uint64;
    b := n <= RequestBatchSizeLimit() as uint64;
    if !b {
      print ""RequestBatch exceeds size limit.\n"";
      lemma_RequestQueue_len(c);
      return;
    }
    var pos: uint64 := 0;
    while pos < n
      invariant 0 <= pos <= n
      invariant forall i: uint64 {:trigger c[i]} :: 0 <= i < pos ==> CRequestIsValid(c[i])
      decreases n as int - pos as int
    {
      var a := c[pos];
      if !CAppMessageIsValid(a.request) || !EndPointIsValidIPV4(a.client) {
        assert !CRequestIsValid(a);
        assert !CRequestBatchIsValid(c);
        b := false;
        return;
      }
      pos := pos + 1;
    }
    b := true;
  }

  method DetermineIfValidReplyCache(m: CReplyCache) returns (b: bool)
    requires CReplyCacheIsAbstractable(m)
    requires CReplyCacheIs64Bit(m)
    ensures b == CReplyCacheIsValid(m)
    decreases m
  {
    b := |m| as uint64 < 256;
    if !b {
      print ""ReplyCache exceeds size limit\n"";
      lemma_ReplyCacheLen(m);
      return;
    }
    assert CReplyCacheIsAbstractable(m);
    forall e: EndPoint | e in m
      ensures CReplyIsValid(m[e])
    {
      assert EndPointIsValidIPV4(e);
      assert CReplyIsAbstractable(m[e]);
    }
  }

  method DetermineIfMessageMarshallable(msg: CMessage) returns (b: bool)
    requires CMessageIsAbstractable(msg)
    requires CMessageIs64Bit(msg)
    ensures b == Marshallable(msg)
    decreases msg
  {
    if msg.CMessage_Invalid? {
      b := false;
    } else if msg.CMessage_Request? {
      b := CAppMessageIsValid(msg.val);
    } else if msg.CMessage_1a? {
      b := true;
    } else if msg.CMessage_1b? {
      b := DetermineIfValidVotes(msg.votes);
    } else if msg.CMessage_1c? {
      if |msg.val_1c| > RequestBatchSizeLimit() {
        print ""1c msg RequestBatch exceeds size limit\n"";
        lemma_RequestQueue_len(msg.val_1c);
        return;
      }
      b := |msg.val_1c| as uint64 <= RequestBatchSizeLimit() as uint64;
    } else if msg.CMessage_2av? {
      if |msg.val_2av| > RequestBatchSizeLimit() {
        print ""2av msg RequestBatch exceeds size limit\n"";
        lemma_RequestQueue_len(msg.val_2av);
        return;
      }
      b := |msg.val_2av| as uint64 <= RequestBatchSizeLimit() as uint64;
    } else if msg.CMessage_2b? {
      if |msg.val_2b| > RequestBatchSizeLimit() {
        print ""2b msg RequestBatch exceeds size limit\n"";
        lemma_RequestQueue_len(msg.val_2b);
        return;
      }
      b := |msg.val_2b| as uint64 <= RequestBatchSizeLimit() as uint64;
    } else if msg.CMessage_Heartbeat? {
      b := true;
    } else if msg.CMessage_Reply? {
      b := CAppMessageIsValid(msg.reply);
    } else if msg.CMessage_StartingPhase2? {
      b := true;
    } else {
      assert false;
    }
  }

  method MarshallEndPoint(c: EndPoint) returns (val: V)
    requires EndPointIsValidIPV4(c)
    ensures ValInGrammar(val, EndPoint_grammar())
    ensures ValidVal(val)
    ensures parse_EndPoint(val) == c
    decreases c
  {
    val := VUint64(ConvertEndPointToUint64(c));
    lemma_Uint64EndPointRelationships();
  }

  predicate method RequestInRange(c: CRequest)
    decreases c
  {
    true &&
    Uint64InRange(c.seqno)
  }

  method MarshallRequest(c: CRequest) returns (val: V)
    requires CRequestIsValid(c)
    ensures ValInGrammar(val, CRequest_grammar())
    ensures ValidVal(val)
    ensures parse_Request(val) == c
    decreases c
  {
    var marshalled_app_message := MarshallCAppMessage(c.request);
    var marshalled_ep := MarshallEndPoint(c.client);
    var seqno := 0;
    if 0 <= c.seqno < 18446744073709551616 {
      seqno := c.seqno as uint64;
    } else {
      seqno := 18446744073709551615;
      print ""Marshall CRequest seqno overflow\n"";
    }
    val := VTuple([marshalled_ep, VUint64(seqno), marshalled_app_message]);
    assert ValInGrammar(val.t[0], CRequest_grammar().t[0]);
    assert ValInGrammar(val.t[1], CRequest_grammar().t[1]);
    assert ValInGrammar(val.t[2], CRequest_grammar().t[2]);
    calc {
      ValidVal(val);
      ValidVal(val.t[0]) &&
      ValidVal(val.t[1]) &&
      ValidVal(val.t[2]);
    }
    lemma_parserequest(c, val);
  }

  lemma {:axiom} lemma_parserequest(c: CRequest, val: V)
    requires CRequestIsValid(c)
    ensures ValInGrammar(val, CRequest_grammar())
    ensures ValidVal(val)
    ensures parse_Request(val) == c
    decreases c, val

  method MarshallRequestBatch(c: CRequestBatch) returns (val: V)
    requires CRequestBatchIsValid(c)
    ensures ValInGrammar(val, CRequestBatch_grammar())
    ensures ValidVal(val)
    ensures parse_RequestBatch(val) == c
    decreases c
  {
    if |c| > RequestBatchSizeLimit() {
      print ""RequestBatch exceeds size limit\n"";
      lemma_RequestQueue_len(c);
      return;
    }
    var reqs := new V[|c| as uint64];
    var i: uint64 := 0;
    while i < |c| as uint64
      invariant 0 <= i as int <= |c|
      invariant forall j: uint64 {:trigger reqs[j]} :: 0 <= j < i ==> ValInGrammar(reqs[j], CRequest_grammar())
      invariant forall j: uint64 {:trigger reqs[j]} :: 0 <= j < i ==> ValidVal(reqs[j])
      invariant forall j: uint64 {:trigger c[j]} {:trigger reqs[j]} :: 0 <= j < i ==> parse_Request(reqs[j]) == c[j]
      decreases |c| as uint64 as int - i as int
    {
      var single := MarshallRequest(c[i]);
      assert ValInGrammar(single, CRequest_grammar());
      reqs[i] := single;
      i := i + 1;
    }
    val := VArray(reqs[..]);
  }

  predicate method ReplyInRange(c: CReply)
    decreases c
  {
    true &&
    Uint64InRange(c.seqno)
  }

  method MarshallReply(c: CReply) returns (val: V)
    requires CReplyIsValid(c)
    ensures ValInGrammar(val, CReply_grammar())
    ensures ValidVal(val)
    ensures ReplyInRange(c) ==> parse_Reply(val) == c
    decreases c
  {
    var marshalled_app_message := MarshallCAppMessage(c.reply);
    var marshalled_ep := MarshallEndPoint(c.client);
    var seqno := 0;
    if 0 <= c.seqno < 18446744073709551616 {
      seqno := c.seqno as uint64;
    } else {
      seqno := 18446744073709551615;
      print ""Marshall CReply seqno overflow\n"";
    }
    val := VTuple([marshalled_ep, VUint64(seqno), marshalled_app_message]);
    assert ValInGrammar(val.t[0], CReply_grammar().t[0]);
    assert ValInGrammar(val.t[1], CReply_grammar().t[1]);
    assert ValInGrammar(val.t[2], CReply_grammar().t[2]);
    calc {
      ValidVal(val);
      ValidVal(val.t[0]) &&
      ValidVal(val.t[1]) &&
      ValidVal(val.t[2]);
    }
  }

  predicate method BallotInRange(c: CBallot)
    decreases c
  {
    Uint64InRange(c.seqno) &&
    Uint64InRange(c.proposer_id)
  }

  method MarshallBallot(c: CBallot) returns (val: V)
    ensures ValInGrammar(val, CBallot_grammar())
    ensures ValidVal(val)
    ensures BallotInRange(c) ==> parse_Ballot(val) == c
    decreases c
  {
    var seqno := 0;
    if 0 <= c.seqno < 18446744073709551616 {
      seqno := c.seqno as uint64;
    } else {
      seqno := 18446744073709551615;
      print ""Marshall CBallot seqno overflow\n"";
    }
    var id := 0;
    if 0 <= c.proposer_id < 18446744073709551616 {
      id := c.proposer_id as uint64;
    } else {
      id := 18446744073709551615;
      print ""Marshall CBallot seqno overflow\n"";
    }
    val := VTuple([VUint64(seqno), VUint64(id)]);
    assert 0 <= c.seqno < 18446744073709551616 && 0 <= c.proposer_id < 18446744073709551616 ==> parse_Ballot(val) == c;
  }

  method MarshallOperationNumber(c: COperationNumber) returns (val: V)
    ensures Uint64InRange(c) ==> ValInGrammar(val, COperationNumber_grammar())
    ensures Uint64InRange(c) ==> ValidVal(val)
    ensures Uint64InRange(c) ==> parse_OperationNumber(val) == c
    decreases c
  {
    var opn := 0;
    if 0 <= c < 18446744073709551616 {
      opn := c as uint64;
    } else {
      opn := 18446744073709551615;
      print ""Marshall CRequest seqno overflow\n"";
    }
    val := VUint64(opn);
  }

  predicate method VoteInRange(c: CVote)
    decreases c
  {
    true &&
    BallotInRange(c.max_value_bal)
  }

  method MarshallVote(c: CVote) returns (val: V)
    requires CVoteIsValid(c)
    ensures ValInGrammar(val, CVote_grammar())
    ensures ValidVal(val)
    decreases c
  {
    var bal := MarshallBallot(c.max_value_bal);
    var v := MarshallRequestBatch(c.max_val);
    val := VTuple([bal, v]);
  }

  predicate method Uint64InRange(i: int)
    decreases i
  {
    0 <= i < 18446744073709551615
  }

  predicate method VotesInRange(c: CVotes)
    decreases c
  {
    true &&
    forall i: int {:trigger c[i]} {:trigger Uint64InRange(i)} {:trigger i in c} :: 
      (i in c ==>
        Uint64InRange(i)) &&
      (i in c ==>
        VoteInRange(c[i])) &&
      (i in c ==>
        |c[i].max_val| <= RequestBatchSizeLimit())
  }

  method {:timeLimitMultiplier 3} /*{:_timeLimit 30}*/ MarshallVotes(c: CVotes) returns (val: V)
    requires CVotesIsValid(c)
    ensures VotesInRange(c) ==> ValInGrammar(val, CVotes_grammar())
    ensures VotesInRange(c) ==> |val.a| == |c|
    ensures VotesInRange(c) ==> ValidVal(val)
    ensures VotesInRange(c) ==> parse_Votes(val) == c
    ensures VotesInRange(c) ==> SeqSum(val.a) <= |c| * (8 + 8 + 8 + 8 + (16 + max_val_len()) * RequestBatchSizeLimit())
    decreases |c|
  {
    if VotesInRange(c) {
      if |c| == 0 {
        val := VArray([]);
        reveal SeqSum();
      } else {
        var b := |c| < max_votes_len();
        if !b {
          print ""votes exceeds the max length"";
          lemma_vote_len(c);
          return;
        }
        lemma_non_empty_map_has_elements(c);
        var op :| op in c;
        var marshalled_op := MarshallOperationNumber(op);
        var marshalled_vote := MarshallVote(c[op]);
        var remainder := RemoveElt(c, op);
        var marshalled_remainder := MarshallVotes(remainder);
        assert VotesInRange(c) ==> parse_Votes(marshalled_remainder) == remainder;
        val := VArray([VTuple([marshalled_op, marshalled_vote])] + marshalled_remainder.a);
        ghost var tuple := val.a[0];
        ghost var rest := val.a[1..];
        assert ValInGrammar(tuple, CVotes_grammar().elt);
        assert ValInGrammar(tuple.t[0], CVotes_grammar().elt.t[0]);
        assert ValInGrammar(tuple.t[1], CVotes_grammar().elt.t[1]);
        ghost var op' := parse_OperationNumber(tuple.t[0]);
        ghost var vote' := parse_Vote(tuple.t[1]);
        ghost var others' := parse_Votes(VArray(val.a[1..]));
        ghost var m' := others'[op' := vote'];
        assert op' == op;
        lemma_MarshallVotes(c, val);
        calc {
          SeqSum(val.a);
          {
            reveal SeqSum();
          }
          SizeOfV(val.a[0]) + SeqSum(val.a[1..]);
        <=
          SizeOfV(val.a[0]) + |remainder| * (8 + 8 + 8 + 8 + (16 + max_val_len()) * RequestBatchSizeLimit());
          {
            lemma_SeqSum2(val.a[0]);
          }
          SizeOfV(val.a[0].t[0]) + SizeOfV(val.a[0].t[1]) + |remainder| * (8 + 8 + 8 + 8 + (16 + max_val_len()) * RequestBatchSizeLimit());
        <=
          {
            lemma_VoteValValid(c[op], val.a[0].t[1]);
            lemma_VoteBound(c[op], val.a[0].t[1]);
          }
          8 + 8 + 8 + 8 + (16 + max_val_len()) * |val.a[0].t[1].t[1].a| + |remainder| * (8 + 8 + 8 + 8 + (16 + max_val_len()) * RequestBatchSizeLimit());
        <=
          {
            assert |val.a[0].t[1].t[1].a| <= RequestBatchSizeLimit();
            lemma_mul_upper_bound(16 + max_val_len(), 16 + max_val_len(), |val.a[0].t[1].t[1].a|, RequestBatchSizeLimit());
          }
          8 + 8 + 8 + 8 + (16 + max_val_len()) * RequestBatchSizeLimit() + |remainder| * (8 + 8 + 8 + 8 + (16 + max_val_len()) * RequestBatchSizeLimit());
          1 * (8 + 8 + 8 + 8 + (16 + max_val_len()) * RequestBatchSizeLimit()) + |remainder| * (8 + 8 + 8 + 8 + (16 + max_val_len()) * RequestBatchSizeLimit());
          {
            lemma_mul_is_distributive(8 + 8 + 8 + 8 + (16 + max_val_len()) * RequestBatchSizeLimit(), 1, |remainder|);
          }
          (1 + |remainder|) * (8 + 8 + 8 + 8 + (16 + max_val_len()) * RequestBatchSizeLimit());
          |c| * (8 + 8 + 8 + 8 + (16 + max_val_len()) * RequestBatchSizeLimit());
        }
      }
    } else {
      print ""Marshall CVotes overflow\n"";
    }
  }

  lemma {:axiom} lemma_MarshallVotes(c: CVotes, val: V)
    requires CVotesIsValid(c)
    ensures VotesInRange(c) ==> ValInGrammar(val, CVotes_grammar())
    ensures VotesInRange(c) ==> |val.a| == |c|
    ensures VotesInRange(c) ==> ValidVal(val)
    ensures VotesInRange(c) ==> parse_Votes(val) == c
    decreases c, val

  predicate method MsgRequestInRange(c: CMessage)
    requires c.CMessage_Request?
    decreases c
  {
    true &&
    Uint64InRange(c.seqno_req)
  }

  method MarshallMessage_Request(c: CMessage) returns (val: V)
    requires c.CMessage_Request?
    requires Marshallable(c)
    ensures ValInGrammar(val, CMessage_Request_grammar())
    ensures ValidVal(val)
    ensures MsgRequestInRange(c) ==> parse_Message_Request(val) == c
    decreases c
  {
    var v := MarshallCAppMessage(c.val);
    var seqno: uint64 := 0;
    if MsgRequestInRange(c) {
      seqno := c.seqno_req as uint64;
    }
    val := VTuple([VUint64(seqno), v]);
    assert MsgRequestInRange(c) ==> parse_Message_Request(val) == c;
  }

  predicate method Msg1aInRange(c: CMessage)
    requires c.CMessage_1a?
    decreases c
  {
    true &&
    BallotInRange(c.bal_1a)
  }

  method MarshallMessage_1a(c: CMessage) returns (val: V)
    requires c.CMessage_1a?
    requires Marshallable(c)
    ensures ValInGrammar(val, CMessage_1a_grammar())
    ensures ValidVal(val)
    ensures Uint64InRange(c.bal_1a.seqno) && Uint64InRange(c.bal_1a.proposer_id) ==> parse_Message_1a(val) == c
    decreases c
  {
    val := MarshallBallot(c.bal_1a);
  }

  predicate method Msg1bInRange(c: CMessage)
    requires c.CMessage_1b?
    decreases c
  {
    BallotInRange(c.bal_1b) &&
    Uint64InRange(c.log_truncation_point) &&
    VotesInRange(c.votes)
  }

  method MarshallMessage_1b(c: CMessage) returns (val: V)
    requires c.CMessage_1b?
    requires Marshallable(c)
    ensures Msg1bInRange(c) ==> ValInGrammar(val, CMessage_1b_grammar())
    ensures Msg1bInRange(c) ==> ValidVal(val)
    ensures Msg1bInRange(c) ==> parse_Message_1b(val) == c
    ensures Msg1bInRange(c) ==> 0 <= SizeOfV(val) < MaxPacketSize() - 8
    decreases c
  {
    if Msg1bInRange(c) {
      var bal := MarshallBallot(c.bal_1b);
      var log_truncation_point := MarshallOperationNumber(c.log_truncation_point);
      var votes := MarshallVotes(c.votes);
      var b := |c.votes| < max_votes_len();
      if !b {
        print ""votes exceeds the max length"";
        lemma_vote_len(c.votes);
        return;
      }
      lemma_vote_len(c.votes);
      val := VTuple([bal, log_truncation_point, votes]);
      lemma_SeqSum3(val);
      assert ValInGrammar(val.t[0], CBallot_grammar());
      lemma_BallotBound(c.bal_1b, val.t[0]);
      assert ValInGrammar(val.t[1], COperationNumber_grammar());
      assert ValInGrammar(val.t[2], CVotes_grammar());
      calc {
        SizeOfV(val);
        16 + 8 + SizeOfV(val.t[2]);
      <=
        16 + 8 + 8 + |c.votes| * (8 + 8 + 8 + 8 + (16 + max_val_len()) * RequestBatchSizeLimit());
        32 + |c.votes| * (32 + (16 + 64) * RequestBatchSizeLimit());
        32 + |c.votes| * 80032;
      <
        {
          lemma_mul_strict_inequality(|c.votes|, max_votes_len(), 80032);
        }
        32 + max_votes_len() * 80032;
      <
        MaxPacketSize() - 8;
      }
    } else {
      print ""Marshall 1b overflow\n"";
    }
  }

  predicate method Msg1cInRange(c: CMessage)
    requires c.CMessage_1c?
    decreases c
  {
    BallotInRange(c.bal_1c) &&
    Uint64InRange(c.opn_1c)
  }

  method MarshallMessage_1c(c: CMessage) returns (val: V)
    requires c.CMessage_1c?
    requires Marshallable_1c(c)
    ensures Msg1cInRange(c) ==> ValInGrammar(val, CMessage_1c_grammar())
    ensures Msg1cInRange(c) ==> ValidVal(val)
    ensures Msg1cInRange(c) ==> parse_Message_1c(val) == c
    decreases c
  {
    if Msg1cInRange(c) {
      var bal := MarshallBallot(c.bal_1c);
      var op := MarshallOperationNumber(c.opn_1c);
      var v := MarshallRequestBatch(c.val_1c);
      val := VTuple([bal, op, v]);
      assert forall u: V {:trigger ValidVal(u)} {:trigger u in val.t} :: u in val.t ==> ValidVal(u);
      assert ValInGrammar(bal, CMessage_1c_grammar().t[0]);
      assert ValInGrammar(op, CMessage_1c_grammar().t[1]);
      assert ValInGrammar(v, CMessage_1c_grammar().t[2]);
      assert ValInGrammar(val, CMessage_1c_grammar());
      assert ValidVal(val);
    } else {
      print ""Marshall 1c overflow\n"";
    }
  }

  predicate method Msg2avInRange(c: CMessage)
    requires c.CMessage_2av?
    decreases c
  {
    BallotInRange(c.bal_2av) &&
    Uint64InRange(c.opn_2av)
  }

  method MarshallMessage_2av(c: CMessage) returns (val: V)
    requires c.CMessage_2av?
    requires Marshallable_2av(c)
    ensures Msg2avInRange(c) ==> ValInGrammar(val, CMessage_2av_grammar())
    ensures Msg2avInRange(c) ==> ValidVal(val)
    ensures Msg2avInRange(c) ==> parse_Message_2av(val) == c
    decreases c
  {
    if Msg2avInRange(c) {
      var bal := MarshallBallot(c.bal_2av);
      var op := MarshallOperationNumber(c.opn_2av);
      var v := MarshallRequestBatch(c.val_2av);
      val := VTuple([bal, op, v]);
      assert forall u: V {:trigger ValidVal(u)} {:trigger u in val.t} :: u in val.t ==> ValidVal(u);
      assert ValInGrammar(bal, CMessage_2av_grammar().t[0]);
      assert ValInGrammar(op, CMessage_2av_grammar().t[1]);
      assert ValInGrammar(v, CMessage_2av_grammar().t[2]);
      assert ValInGrammar(val, CMessage_2av_grammar());
      assert ValidVal(val);
    } else {
      print ""Marshall 2av overflow\n"";
    }
  }

  predicate method Msg2bInRange(c: CMessage)
    requires c.CMessage_2b?
    decreases c
  {
    BallotInRange(c.bal_2b) &&
    Uint64InRange(c.opn_2b)
  }

  method MarshallMessage_2b(c: CMessage) returns (val: V)
    requires c.CMessage_2b?
    requires Marshallable_2b(c)
    ensures Msg2bInRange(c) ==> ValInGrammar(val, CMessage_2b_grammar())
    ensures Msg2bInRange(c) ==> ValidVal(val)
    ensures Msg2bInRange(c) ==> parse_Message_2b(val) == c
    decreases c
  {
    if Msg2bInRange(c) {
      var bal := MarshallBallot(c.bal_2b);
      var op := MarshallOperationNumber(c.opn_2b);
      var v := MarshallRequestBatch(c.val_2b);
      val := VTuple([bal, op, v]);
      assert ValInGrammar(bal, CBallot_grammar());
      assert ValInGrammar(op, COperationNumber_grammar());
      assert ValInGrammar(v, CRequestBatch_grammar());
      assert ValInGrammar(val, CMessage_2b_grammar());
    } else {
      print ""Marshall 2b overflow\n"";
    }
  }

  predicate method MsgHeartBeatInRange(c: CMessage)
    requires c.CMessage_Heartbeat?
    decreases c
  {
    BallotInRange(c.bal_heartbeat) &&
    Uint64InRange(c.opn_ckpt)
  }

  method MarshallMessage_Heartbeat(c: CMessage) returns (val: V)
    requires c.CMessage_Heartbeat?
    requires Marshallable(c)
    ensures MsgHeartBeatInRange(c) ==> ValInGrammar(val, CMessage_Heartbeat_grammar())
    ensures MsgHeartBeatInRange(c) ==> ValidVal(val)
    ensures MsgHeartBeatInRange(c) ==> parse_Message_Heartbeat(val) == c
    decreases c
  {
    if MsgHeartBeatInRange(c) {
      var ballot := MarshallBallot(c.bal_heartbeat);
      var op := MarshallOperationNumber(c.opn_ckpt);
      val := VTuple([ballot, VUint64(if c.suspicious then 1 else 0), op]);
      assert parse_Message_Heartbeat(val) == c;
    } else {
      print ""Marshall heartbeat overflow\n"";
    }
  }

  predicate method MsgReplyInRange(c: CMessage)
    requires c.CMessage_Reply?
    decreases c
  {
    true &&
    Uint64InRange(c.seqno_reply)
  }

  method MarshallMessage_Reply(c: CMessage) returns (val: V)
    requires c.CMessage_Reply?
    requires Marshallable(c)
    ensures MsgReplyInRange(c) ==> ValInGrammar(val, CMessage_Reply_grammar())
    ensures MsgReplyInRange(c) ==> ValidVal(val)
    ensures MsgReplyInRange(c) ==> parse_Message_Reply(val) == c
    decreases c
  {
    if MsgReplyInRange(c) {
      var app_val := MarshallCAppMessage(c.reply);
      var seqno: uint64 := 0;
      if MsgReplyInRange(c) {
        seqno := c.seqno_reply as uint64;
      }
      val := VTuple([VUint64(seqno), app_val]);
      assert parse_Message_Reply(val) == c;
    } else {
      print ""Marshall reply overflow\n"";
    }
  }

  predicate method ReplyCacheInRange(c: CReplyCache)
    decreases c
  {
    true &&
    forall i: EndPoint {:trigger c[i]} {:trigger i in c} :: 
      i in c ==>
        ReplyInRange(c[i])
  }

  lemma {:axiom} lemma_ReplyCacheLen(cache: CReplyCache)
    ensures |cache| < max_reply_cache_size()
    decreases cache

  method MarshallReplyCache(c: CReplyCache) returns (val: V)
    requires CReplyCacheIsValid(c)
    ensures ReplyCacheInRange(c) ==> ValInGrammar(val, CReplyCache_grammar())
    ensures ReplyCacheInRange(c) ==> |val.a| == |c|
    ensures ReplyCacheInRange(c) ==> ValidVal(val)
    ensures ReplyCacheInRange(c) ==> parse_ReplyCache(val) == c
    ensures ReplyCacheInRange(c) ==> SeqSum(val.a) <= |c| * (8 + 8 + 8 + 24 + max_val_len())
    decreases |c|
  {
    if ReplyCacheInRange(c) {
      if |c| == 0 {
        val := VArray([]);
        reveal SeqSum();
      } else {
        var b := |c| < max_reply_cache_size();
        if !b {
          print ""Reply cache exceeds size limit.\n"";
          lemma_ReplyCacheLen(c);
          return;
        }
        var ep :| ep in c;
        var marshalled_ep := MarshallEndPoint(ep);
        var marshalled_reply := MarshallReply(c[ep]);
        var remainder := RemoveElt(c, ep);
        assert forall e: EndPoint {:trigger remainder[e]} {:trigger e in remainder} :: e in remainder ==> CReplyIsValid(remainder[e]);
        var marshalled_remainder := MarshallReplyCache(remainder);
        assert parse_ReplyCache(marshalled_remainder) == remainder;
        val := VArray([VTuple([marshalled_ep, marshalled_reply])] + marshalled_remainder.a);
        ghost var tuple := val.a[0];
        ghost var rest := val.a[1..];
        assert ValInGrammar(tuple, CReplyCache_grammar().elt);
        assert ValInGrammar(tuple.t[0], CReplyCache_grammar().elt.t[0]);
        assert ValInGrammar(tuple.t[1], CReplyCache_grammar().elt.t[1]);
        ghost var ep' := parse_EndPoint(tuple.t[0]);
        ghost var reply' := parse_Reply(tuple.t[1]);
        ghost var others' := parse_ReplyCache(VArray(val.a[1..]));
        ghost var m' := others'[ep' := reply'];
        assert ep' == ep;
        assert reply' == c[ep];
        assert others' == remainder;
        assert m' == c;
        calc {
          SeqSum(val.a);
          {
            reveal SeqSum();
          }
          SizeOfV(val.a[0]) + SeqSum(val.a[1..]);
        <=
          SizeOfV(val.a[0]) + |remainder| * (8 + 8 + 8 + 24 + max_val_len());
          SizeOfV(val.a[0]) + |remainder| * (8 + 8 + 8 + 24 + max_val_len());
          {
            lemma_SeqSum2(val.a[0]);
          }
          SizeOfV(val.a[0].t[0]) + SizeOfV(val.a[0].t[1]) + |remainder| * (8 + 8 + 8 + 24 + max_val_len());
        <
          {
            lemma_ReplyValValid(c[ep], val.a[0].t[1]);
            lemma_ReplyBound(c[ep], val.a[0].t[1]);
          }
          8 + 8 + 8 + 24 + max_val_len() + |remainder| * (8 + 8 + 8 + 24 + max_val_len());
          1 * (8 + 8 + 8 + 24 + max_val_len()) + |remainder| * (8 + 8 + 8 + 24 + max_val_len());
          {
            lemma_mul_is_distributive(8 + 8 + 8 + 24 + max_val_len(), 1, |remainder|);
          }
          (1 + |remainder|) * (8 + 8 + 8 + 24 + max_val_len());
          |c| * (8 + 8 + 8 + 24 + max_val_len());
        }
      }
    } else {
      print ""Marshall replycache overflow\n"";
    }
  }

  lemma /*{:_induction val}*/ lemma_ReplyValValid(c: CReply, val: V)
    requires ValInGrammar(val, CReply_grammar())
    requires CReplyIsValid(c)
    requires parse_Reply(val) == c
    ensures ValidVal(val)
    decreases c, val
  {
  }

  lemma /*{:_induction val}*/ lemma_ReplyBound(c: CReply, val: V)
    requires ValInGrammar(val, CReply_grammar())
    requires CReplyIsValid(c)
    requires parse_Reply(val) == c
    ensures SizeOfV(val) < 24 + max_val_len()
    decreases c, val
  {
  }

  lemma /*{:_induction val}*/ lemma_SeqSum4(val: V)
    requires val.VTuple?
    requires |val.t| == 4
    ensures SizeOfV(val) == SizeOfV(val.t[0]) + SizeOfV(val.t[1]) + SizeOfV(val.t[2]) + SizeOfV(val.t[3])
    decreases val
  {
  }

  predicate method MsgStartPhase2InRange(c: CMessage)
    requires c.CMessage_StartingPhase2?
    decreases c
  {
    BallotInRange(c.bal_2) &&
    Uint64InRange(c.logTruncationPoint_2)
  }

  method MarshallMessage_StartingPhase2(c: CMessage) returns (val: V)
    requires c.CMessage_StartingPhase2?
    requires Marshallable(c)
    ensures MsgStartPhase2InRange(c) ==> ValInGrammar(val, CMessage_StartingPhase2_grammar())
    ensures MsgStartPhase2InRange(c) ==> ValidVal(val)
    ensures MsgStartPhase2InRange(c) ==> parse_Message_StartingPhase2(val) == c
    decreases c
  {
    if MsgStartPhase2InRange(c) {
      var bal := MarshallBallot(c.bal_2);
      var op := MarshallOperationNumber(c.logTruncationPoint_2);
      val := VTuple([bal, op]);
    } else {
      print ""Marshall startphase2 overflow\n"";
    }
  }

  predicate method MsgInRange(c: CMessage)
    decreases c
  {
    if c.CMessage_Request? then
      MsgRequestInRange(c)
    else if c.CMessage_1a? then
      Msg1aInRange(c)
    else if c.CMessage_1b? then
      Msg1bInRange(c)
    else if c.CMessage_1c? then
      Msg1cInRange(c)
    else if c.CMessage_2av? then
      Msg2avInRange(c)
    else if c.CMessage_2b? then
      Msg2bInRange(c)
    else if c.CMessage_Heartbeat? then
      MsgHeartBeatInRange(c)
    else if c.CMessage_Reply? then
      MsgReplyInRange(c)
    else if c.CMessage_StartingPhase2? then
      MsgStartPhase2InRange(c)
    else
      true
  }

  method {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ MarshallMessage(c: CMessage) returns (val: V)
    requires Marshallable(c)
    ensures MsgInRange(c) ==> ValInGrammar(val, CMessage_grammar())
    ensures MsgInRange(c) ==> ValidVal(val)
    ensures MsgInRange(c) ==> parse_Message(val) == c
    ensures MsgInRange(c) ==> c.CMessage_1b? ==> 0 <= SizeOfV(val) < MaxPacketSize()
    decreases c
  {
    if MsgInRange(c) {
      assert !c.CMessage_Invalid?;
      if c.CMessage_Request? {
        var msg := MarshallMessage_Request(c);
        val := VCase(0, msg);
      } else if c.CMessage_1a? {
        var msg := MarshallMessage_1a(c);
        val := VCase(1, msg);
      } else if c.CMessage_1b? {
        var msg := MarshallMessage_1b(c);
        val := VCase(2, msg);
      } else if c.CMessage_1c? {
        var msg := MarshallMessage_1c(c);
        val := VCase(3, msg);
      } else if c.CMessage_2av? {
        var msg := MarshallMessage_2av(c);
        val := VCase(4, msg);
      } else if c.CMessage_2b? {
        var msg := MarshallMessage_2b(c);
        val := VCase(5, msg);
      } else if c.CMessage_Heartbeat? {
        var msg := MarshallMessage_Heartbeat(c);
        val := VCase(6, msg);
      } else if c.CMessage_Reply? {
        var msg := MarshallMessage_Reply(c);
        val := VCase(7, msg);
        assert CMessage_grammar().cases[7] == CMessage_Reply_grammar();
      } else if c.CMessage_StartingPhase2? {
        var msg := MarshallMessage_StartingPhase2(c);
        val := VCase(8, msg);
      }
    }
  }

  lemma /*{:_induction val}*/ lemma_SeqSum2(val: V)
    requires val.VTuple?
    requires |val.t| == 2
    ensures SizeOfV(val) == SizeOfV(val.t[0]) + SizeOfV(val.t[1])
    decreases val
  {
  }

  lemma /*{:_induction val}*/ lemma_SeqSum3(val: V)
    requires val.VTuple?
    requires |val.t| == 3
    ensures SizeOfV(val) == SizeOfV(val.t[0]) + SizeOfV(val.t[1]) + SizeOfV(val.t[2])
    decreases val
  {
  }

  lemma {:axiom} lemma_SeqSum5(val: V)
    requires val.VTuple?
    requires |val.t| == 5
    ensures SizeOfV(val) == SizeOfV(val.t[0]) + SizeOfV(val.t[1]) + SizeOfV(val.t[2]) + SizeOfV(val.t[3]) + SizeOfV(val.t[4])
    decreases val

  lemma {:axiom} lemma_SeqSum7(val: V)
    requires val.VTuple?
    requires |val.t| == 7
    ensures SizeOfV(val) == SizeOfV(val.t[0]) + SizeOfV(val.t[1]) + SizeOfV(val.t[2]) + SizeOfV(val.t[3]) + SizeOfV(val.t[4]) + SizeOfV(val.t[5]) + SizeOfV(val.t[6])
    decreases val

  lemma /*{:_induction val}*/ lemma_BallotBound(c: CBallot, val: V)
    requires ValInGrammar(val, CBallot_grammar())
    requires ValidVal(val)
    requires parse_Ballot(val) == c
    ensures SizeOfV(val) == 16
    decreases c, val
  {
  }

  lemma /*{:_induction val}*/ lemma_CRequestBound(c: CRequest, val: V)
    requires ValInGrammar(val, CRequest_grammar())
    requires CRequestIsValid(c)
    requires parse_Request(val) == c
    ensures SizeOfV(val) < 16 + max_val_len()
    decreases c, val
  {
  }

  lemma {:axiom} lemma_CRequestBoundSize(c: CRequest, val: V)
    requires ValInGrammar(val, CRequest_grammar())
    requires CRequestIsValid(c)
    requires parse_Request(val) == c
    ensures SizeOfV(val) < 16 + max_val_len()
    decreases c, val

  lemma /*{:_induction val}*/ lemma_CRequestBatchBound(c: CRequestBatch, val: V)
    requires ValInGrammar(val, CRequestBatch_grammar())
    requires CRequestBatchIsValid(c)
    requires parse_RequestBatch(val) == c
    ensures SeqSum(val.a) <= (16 + max_val_len()) * |val.a|
    decreases |c|
  {
  }

  lemma {:axiom} lemma_MsgMarshallable(m: CMessage)
    ensures Marshallable(m)
    decreases m

  lemma {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ /*{:_induction val}*/ lemma_VoteValValid(c: CVote, val: V)
    requires ValInGrammar(val, CVote_grammar())
    requires CVoteIsValid(c)
    requires parse_Vote(val) == c
    ensures ValidVal(val)
    decreases c, val
  {
  }

  lemma /*{:_induction val}*/ lemma_VoteBound(c: CVote, val: V)
    requires ValInGrammar(val, CVote_grammar())
    requires ValInGrammar(val.t[1], CRequestBatch_grammar())
    requires ValidVal(val)
    requires CVoteIsValid(c)
    requires parse_Vote(val) == c
    ensures SizeOfV(val) <= 8 + 8 + 8 + (16 + max_val_len()) * |val.t[1].a|
    decreases c, val
  {
  }

  lemma {:axiom} lemma_RequestQueue_len(s: seq<CRequest>)
    ensures |s| <= RequestBatchSizeLimit()
    decreases s

  lemma /*{:_induction val}*/ lemma_MarshallableBound(c: CMessage, val: V)
    requires Marshallable(c)
    requires ValInGrammar(val, CMessage_grammar())
    requires ValidVal(val)
    requires parse_Message(val) == c
    decreases c, val
  {
  }

  function AbstractifyBufferToRslPacket(src: EndPoint, dst: EndPoint, data: seq<byte>): RslPacket
    requires EndPointIsValidIPV4(src)
    requires EndPointIsValidIPV4(dst)
    decreases src, dst, data
  {
    LPacket(AbstractifyEndPointToNodeIdentity(dst), AbstractifyEndPointToNodeIdentity(src), AbstractifyCMessageToRslMessage(PaxosDemarshallData(data)))
  }

  predicate BufferRefinementAgreesWithMessageRefinement(msg: CMessage, marshalled: seq<byte>)
    requires CMessageIsAbstractable(msg)
    requires CMessageIsAbstractable(msg)
    decreases msg, marshalled
  {
    forall src: EndPoint, dst: EndPoint {:trigger AbstractifyEndPointToNodeIdentity(src), AbstractifyEndPointToNodeIdentity(dst)} {:trigger AbstractifyEndPointToNodeIdentity(src), EndPointIsValidIPV4(dst)} {:trigger AbstractifyEndPointToNodeIdentity(dst), EndPointIsValidIPV4(src)} {:trigger AbstractifyBufferToRslPacket(src, dst, marshalled)} {:trigger EndPointIsValidIPV4(dst), EndPointIsValidIPV4(src)} :: 
      EndPointIsValidIPV4(src) &&
      EndPointIsValidIPV4(dst) ==>
        AbstractifyBufferToRslPacket(src, dst, marshalled) == LPacket(AbstractifyEndPointToNodeIdentity(dst), AbstractifyEndPointToNodeIdentity(src), AbstractifyCMessageToRslMessage(msg))
  }

  function AbstractifyNetPacketToRslPacket(net: UdpPacket): RslPacket
    requires NetPacketIsAbstractable(net)
    decreases net
  {
    AbstractifyBufferToRslPacket(net.src, net.dst, net.msg)
  }

  predicate NetPacketIsAbstractable(net: UdpPacket)
    decreases net
  {
    EndPointIsValidIPV4(net.src) &&
    EndPointIsValidIPV4(net.dst)
  }

  predicate NetPacketsIsAbstractable(netps: set<UdpPacket>)
    decreases netps
  {
    forall p: UdpPacket {:trigger NetPacketIsAbstractable(p)} {:trigger p in netps} :: 
      p in netps ==>
        NetPacketIsAbstractable(p)
  }

  lemma lemma_CMessageGrammarValid()
    ensures ValidGrammar(CMessage_grammar())
  {
  }

  method PaxosMarshall(msg: CMessage) returns (data: array<byte>)
    requires CMessageIsAbstractable(msg)
    requires Marshallable(msg)
    ensures fresh(data)
    ensures NetPacketBound(data[..])
    ensures Marshallable(PaxosDemarshallData(data[..]))
    ensures BufferRefinementAgreesWithMessageRefinement(msg, data[..])
    decreases msg
  {
    var val := MarshallMessage(msg);
    lemma_PaxosMarshall(msg, val);
    lemma_MarshallableBound(msg, val);
    lemma_CMessageGrammarValid();
    data := Marshall(val, CMessage_grammar());
    assert !msg.CMessage_Invalid?;
    if msg.CMessage_Request? {
    } else if msg.CMessage_1a? {
    } else if msg.CMessage_1b? {
    } else if msg.CMessage_1c? {
    } else if msg.CMessage_2av? {
    } else if msg.CMessage_2b? {
    } else if msg.CMessage_Heartbeat? {
    } else if msg.CMessage_Reply? {
    } else if msg.CMessage_StartingPhase2? {
    }
    forall src: EndPoint, dst: EndPoint | EndPointIsValidIPV4(src) && EndPointIsValidIPV4(dst)
      ensures AbstractifyBufferToRslPacket(src, dst, data[..]) == LPacket(AbstractifyEndPointToNodeIdentity(dst), AbstractifyEndPointToNodeIdentity(src), AbstractifyCMessageToRslMessage(msg))
    {
      calc {
        AbstractifyBufferToRslPacket(src, dst, data[..]);
        LPacket(AbstractifyEndPointToNodeIdentity(dst), AbstractifyEndPointToNodeIdentity(src), AbstractifyCMessageToRslMessage(PaxosDemarshallData(data[..])));
        LPacket(AbstractifyEndPointToNodeIdentity(dst), AbstractifyEndPointToNodeIdentity(src), AbstractifyCMessageToRslMessage(PaxosDemarshallData(data[..])));
        LPacket(AbstractifyEndPointToNodeIdentity(dst), AbstractifyEndPointToNodeIdentity(src), AbstractifyCMessageToRslMessage(msg));
      }
    }
    lemma_PaxosMarshall2(msg, data);
  }

  lemma {:axiom} lemma_PaxosMarshall(c: CMessage, val: V)
    ensures Marshallable(c)
    ensures ValInGrammar(val, CMessage_grammar())
    ensures ValidVal(val)
    ensures parse_Message(val) == c
    ensures 0 <= SizeOfV(val) < 18446744073709551616
    decreases c, val

  lemma {:axiom} lemma_PaxosMarshall2(c: CMessage, data: array<byte>)
    requires CMessageIsAbstractable(c)
    requires Marshallable(c)
    ensures NetPacketBound(data[..])
    ensures Marshallable(PaxosDemarshallData(data[..]))
    ensures BufferRefinementAgreesWithMessageRefinement(c, data[..])
    decreases c, data

  predicate CPacketIsSendable(cpacket: CPacket)
    decreases cpacket
  {
    CMessageIsMarshallable(cpacket.msg) &&
    CPacketIsAbstractable(cpacket) &&
    EndPointIsValidIPV4(cpacket.src)
  }

  predicate CBroadcastIsValid(broadcast: CBroadcast)
    decreases broadcast
  {
    CBroadcastIsAbstractable(broadcast) &&
    (broadcast.CBroadcast? ==>
      Marshallable(broadcast.msg) &&
      0 <= |broadcast.dsts| < 18446744073709551615)
  }

  predicate OutboundPacketsIsValid(out: OutboundPackets)
    decreases out
  {
    OutboundPacketsIsAbstractable(out) &&
    match out case Broadcast(broadcast) => CBroadcastIsValid(broadcast) case OutboundPacket(p) => p.Some? ==> CPacketIsSendable(p.v) case PacketSequence(s) => forall p: CPacket {:trigger CPacketIsSendable(p)} {:trigger p in s} :: p in s ==> CPacketIsSendable(p)
  }

  function AbstractifyUdpPacketToRslPacket(udp: UdpPacket): RslPacket
    requires UdpPacketIsAbstractable(udp)
    decreases udp
  {
    AbstractifyBufferToRslPacket(udp.src, udp.dst, udp.msg)
  }

  predicate UdpPacketIsAbstractable(udp: UdpPacket)
    decreases udp
  {
    EndPointIsValidIPV4(udp.src) &&
    EndPointIsValidIPV4(udp.dst)
  }

  predicate UdpPacketsIsAbstractable(udpps: set<UdpPacket>)
    decreases udpps
  {
    forall p: UdpPacket {:trigger UdpPacketIsAbstractable(p)} {:trigger p in udpps} :: 
      p in udpps ==>
        UdpPacketIsAbstractable(p)
  }

  predicate UdpPacketBound(data: seq<byte>)
    decreases data
  {
    |data| < MaxPacketSize()
  }
}

module Common__GenericMarshalling_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened Native__NativeTypes_i

  import opened Collections__Maps_i

  import opened Collections__Seqs_i

  import opened Logic__Option_i

  import opened Common__Util_i

  import opened Common__MarshallInt_i

  import opened Math__power2_i
  datatype G = GUint64 | GArray(elt: G) | GTuple(t: seq<G>) | GByteArray | GTaggedUnion(cases: seq<G>)

  datatype V = VUint64(u: uint64) | VArray(a: seq<V>) | VTuple(t: seq<V>) | VByteArray(b: seq<byte>) | VCase(c: uint64, val: V)

  datatype ContentsTraceStep = ContentsTraceStep(data: seq<byte>, val: Option<V>)

  predicate ValInGrammar(val: V, grammar: G)
    decreases val, grammar
  {
    match val
    case VUint64(_) =>
      grammar.GUint64?
    case VArray(a) =>
      grammar.GArray? &&
      forall v: V {:trigger ValInGrammar(v, grammar.elt)} {:trigger v in a} :: 
        v in a ==>
          ValInGrammar(v, grammar.elt)
    case VTuple(t) =>
      grammar.GTuple? &&
      |t| == |grammar.t| &&
      forall i: int {:trigger grammar.t[i]} {:trigger t[i]} :: 
        0 <= i < |t| ==>
          ValInGrammar(t[i], grammar.t[i])
    case VByteArray(b) =>
      grammar.GByteArray?
    case VCase(c, v) =>
      grammar.GTaggedUnion? &&
      c as int < |grammar.cases| &&
      ValInGrammar(v, grammar.cases[c])
  }

  predicate ValidGrammar(grammar: G)
    decreases grammar
  {
    match grammar
    case GUint64() =>
      true
    case GArray(elt) =>
      ValidGrammar(elt)
    case GTuple(t) =>
      |t| < 18446744073709551616 &&
      forall g: G {:trigger ValidGrammar(g)} {:trigger g in t} :: 
        g in t ==>
          ValidGrammar(g)
    case GByteArray() =>
      true
    case GTaggedUnion(cases) =>
      |cases| < 18446744073709551616 &&
      forall g: G {:trigger ValidGrammar(g)} {:trigger g in cases} :: 
        g in cases ==>
          ValidGrammar(g)
  }

  predicate ValidVal(val: V)
    decreases val
  {
    match val
    case VUint64(_) =>
      true
    case VArray(a) =>
      |a| < 18446744073709551616 &&
      forall v: V {:trigger ValidVal(v)} {:trigger v in a} :: 
        v in a ==>
          ValidVal(v)
    case VTuple(t) =>
      |t| < 18446744073709551616 &&
      forall v: V {:trigger ValidVal(v)} {:trigger v in t} :: 
        v in t ==>
          ValidVal(v)
    case VByteArray(b) =>
      |b| < 18446744073709551616
    case VCase(c, v) =>
      ValidVal(v)
  }

  function {:opaque} {:fuel 0, 0} SeqSum(t: seq<V>): int
    ensures SeqSum(t) >= 0
    decreases t
  {
    if |t| == 0 then
      0
    else
      SizeOfV(t[0]) + SeqSum(t[1..])
  }

  function SizeOfV(val: V): int
    ensures SizeOfV(val) >= 0
    decreases val
  {
    match val
    case VUint64(_) =>
      8
    case VArray(a) =>
      8 + SeqSum(a)
    case VTuple(t) =>
      SeqSum(t)
    case VByteArray(b) =>
      8 + |b|
    case VCase(c, v) =>
      8 + SizeOfV(v)
  }

  predicate Trigger(i: int)
    decreases i
  {
    true
  }

  function method parse_Uint64(data: seq<byte>): (Option<V>, seq<byte>)
    requires |data| < 18446744073709551616
    decreases data
  {
    if |data| as uint64 >= Uint64Size() then
      (Some(VUint64(SeqByteToUint64(data[..Uint64Size()]))), data[Uint64Size()..])
    else
      (None, [])
  }

  method ParseUint64(data: array<byte>, index: uint64)
      returns (success: bool, v: V, rest_index: uint64)
    requires index as int <= data.Length
    requires data.Length < 18446744073709551616
    ensures rest_index as int <= data.Length
    ensures var (v': Option<V>, rest': seq<byte>) := parse_Uint64(data[index..]); var v_opt: Option<V> := if success then Some(v) else None(); v_opt == v' && data[rest_index..] == rest'
    decreases data, index
  {
    lemma_2toX();
    if data.Length as uint64 >= 8 && index <= data.Length as uint64 - 8 {
      var result := data[index as int] as uint64 * 72057594037927936 + data[index as int + 1] as uint64 * 281474976710656 + data[index as int + 2] as uint64 * 1099511627776 + data[index as int + 3] as uint64 * 4294967296 + data[index as int + 4] as uint64 * 16777216 + data[index as int + 5] as uint64 * 65536 + data[index as int + 6] as uint64 * 256 + data[index as int + 7] as uint64;
      success := true;
      v := VUint64(result);
      rest_index := index + Uint64Size();
    } else {
      success := false;
      rest_index := data.Length as uint64;
    }
  }

  function method {:opaque} {:fuel 0, 0} parse_Array_contents(data: seq<byte>, eltType: G, len: uint64): (Option<seq<V>>, seq<byte>)
    requires |data| < 18446744073709551616
    requires ValidGrammar(eltType)
    ensures var (opt_seq: Option<seq<V>>, rest: seq<byte>) := parse_Array_contents(data, eltType, len); |rest| <= |data| && (opt_seq.Some? ==> forall i: int {:trigger opt_seq.v[i]} :: 0 <= i < |opt_seq.v| ==> ValInGrammar(opt_seq.v[i], eltType))
    decreases eltType, 1, len
  {
    if len == 0 then
      (Some([]), data)
    else
      var (val: Option<V>, rest1: seq<byte>) := parse_Val(data, eltType); var (others: Option<seq<V>>, rest2: seq<byte>) := parse_Array_contents(rest1, eltType, len - 1); if !val.None? && !others.None? then (Some([val.v] + others.v), rest2) else (None, [])
  }

  lemma /*{:_induction data, eltType, len}*/ lemma_ArrayContents_helper(data: seq<byte>, eltType: G, len: uint64, v: seq<V>, trace: seq<ContentsTraceStep>)
    requires |data| < 18446744073709551616
    requires ValidGrammar(eltType)
    requires |trace| == len as int + 1
    requires |v| == len as int
    requires forall j: int {:trigger trace[j]} :: 0 <= j < |trace| ==> |trace[j].data| < 18446744073709551616
    requires trace[0].data == data
    requires (forall j: int, _t#0: int {:trigger trace[_t#0], trace[j]} | _t#0 == j - 1 :: 0 < j && j < len as int + 1 ==> trace[j].val == parse_Val(trace[_t#0].data, eltType).0) && forall j: int, _t#0: int {:trigger trace[_t#0], trace[j]} | _t#0 == j - 1 :: 0 < j && j < len as int + 1 ==> trace[j].data == parse_Val(trace[_t#0].data, eltType).1
    requires forall j: int {:trigger trace[j]} :: 0 < j < |trace| ==> trace[j].val.Some?
    requires forall j: int {:trigger trace[j]} :: 0 < j < |trace| ==> v[j - 1] == trace[j].val.v
    ensures var (v': Option<seq<V>>, rest': seq<byte>) := parse_Array_contents(data, eltType, len); ghost var v_opt: Option<seq<V>> := Some(v); v_opt == v' && trace[|trace| - 1].data == rest'
    decreases len
  {
  }

  lemma /*{:_induction data, eltType, len}*/ lemma_ArrayContents_helper_bailout(data: seq<byte>, eltType: G, len: uint64, trace: seq<ContentsTraceStep>)
    requires |data| < 18446744073709551616
    requires ValidGrammar(eltType)
    requires 1 < |trace| <= len as int + 1
    requires forall j: int {:trigger trace[j]} :: 0 <= j < |trace| ==> |trace[j].data| < 18446744073709551616
    requires trace[0].data == data
    requires (forall j: int, _t#0: int {:trigger trace[_t#0], trace[j]} | _t#0 == j - 1 :: 0 < j && j < |trace| ==> trace[j].val == parse_Val(trace[_t#0].data, eltType).0) && forall j: int, _t#0: int {:trigger trace[_t#0], trace[j]} | _t#0 == j - 1 :: 0 < j && j < |trace| ==> trace[j].data == parse_Val(trace[_t#0].data, eltType).1
    requires forall j: int {:trigger trace[j]} :: 0 < j < |trace| - 1 ==> trace[j].val.Some?
    requires trace[|trace| - 1].val.None?
    ensures var (v': Option<seq<V>>, rest': seq<byte>) := parse_Array_contents(data, eltType, len); v'.None? && rest' == []
    decreases len
  {
  }

  method {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ ParseArrayContents(data: array<byte>, index: uint64, eltType: G, len: uint64)
      returns (success: bool, v: seq<V>, rest_index: uint64)
    requires index as int <= data.Length
    requires data.Length < 18446744073709551616
    requires ValidGrammar(eltType)
    ensures rest_index as int <= data.Length
    ensures var (v': Option<seq<V>>, rest': seq<byte>) := parse_Array_contents(data[index..], eltType, len); var v_opt: Option<seq<V>> := if success then Some(v) else None(); v_opt == v' && data[rest_index..] == rest'
    ensures success ==> ValidVal(VArray(v))
    decreases eltType, 1, len
  {
    reveal parse_Array_contents();
    var vArr := new V[len];
    ghost var g_v := [];
    success := true;
    var i: uint64 := 0;
    var next_val_index: uint64 := index;
    ghost var trace := [ContentsTraceStep(data[index..], None())];
    while i < len
      invariant 0 <= i <= len
      invariant index <= next_val_index <= data.Length as uint64
      invariant |trace| == i as int + 1
      invariant |g_v| == i as int
      invariant vArr[..i] == g_v
      invariant trace[0].data == data[index..]
      invariant forall j: int {:trigger trace[j]} :: 0 <= j < i as int + 1 ==> |trace[j].data| < 18446744073709551616
      invariant trace[i].data == data[next_val_index..]
      invariant forall j: uint64 {:trigger trace[j]} :: 0 < j <= i ==> trace[j].val.Some?
      invariant forall j: uint64 {:trigger trace[j]} :: 0 < j <= i ==> g_v[j - 1] == trace[j].val.v
      invariant (forall j: int, _t#0: int {:trigger trace[_t#0], trace[j]} | _t#0 == j - 1 :: 0 < j && j < i as int + 1 ==> trace[j].val == parse_Val(trace[_t#0].data, eltType).0) && forall j: int, _t#0: int {:trigger trace[_t#0], trace[j]} | _t#0 == j - 1 :: 0 < j && j < i as int + 1 ==> trace[j].data == parse_Val(trace[_t#0].data, eltType).1
      invariant ValidVal(VArray(vArr[..i]))
      decreases len as int - i as int
    {
      var some1, val, rest1 := ParseVal(data, next_val_index, eltType);
      ghost var step := ContentsTraceStep(data[rest1..], if some1 then Some(val) else None());
      ghost var old_trace := trace;
      trace := trace + [step];
      if !some1 {
        success := false;
        rest_index := data.Length as uint64;
        lemma_ArrayContents_helper_bailout(data[index..], eltType, len, trace);
        return;
      }
      g_v := g_v + [val];
      vArr[i] := val;
      next_val_index := rest1;
      i := i + 1;
    }
    success := true;
    rest_index := next_val_index;
    v := vArr[..];
    lemma_ArrayContents_helper(data[index..], eltType, len, v, trace);
  }

  function method parse_Array(data: seq<byte>, eltType: G): (Option<V>, seq<byte>)
    requires ValidGrammar(eltType)
    requires |data| < 18446744073709551616
    ensures var (opt_val: Option<V>, rest: seq<byte>) := parse_Array(data, eltType); |rest| <= |data| && (opt_val.Some? ==> ValInGrammar(opt_val.v, GArray(eltType)))
    decreases eltType
  {
    var (len: Option<V>, rest: seq<byte>) := parse_Uint64(data);
    if !len.None? then
      var (contents: Option<seq<V>>, remainder: seq<byte>) := parse_Array_contents(rest, eltType, len.v.u);
      if !contents.None? then
        (Some(VArray(contents.v)), remainder)
      else
        (None, [])
    else
      (None, [])
  }

  method ParseArray(data: array<byte>, index: uint64, eltType: G)
      returns (success: bool, v: V, rest_index: uint64)
    requires index as int <= data.Length
    requires data.Length < 18446744073709551616
    requires ValidGrammar(eltType)
    ensures rest_index as int <= data.Length
    ensures var (v': Option<V>, rest': seq<byte>) := parse_Array(data[index..], eltType); var v_opt: Option<V> := if success then Some(v) else None(); v_opt == v' && data[rest_index..] == rest'
    ensures success ==> ValidVal(v)
    decreases eltType
  {
    var some1, len, rest := ParseUint64(data, index);
    if some1 {
      var some2, contents, remainder := ParseArrayContents(data, rest, eltType, len.u);
      if some2 {
        success := true;
        v := VArray(contents);
        rest_index := remainder;
      } else {
        success := false;
        rest_index := data.Length as uint64;
      }
    } else {
      success := false;
      rest_index := data.Length as uint64;
    }
  }

  function method {:opaque} {:fuel 0, 0} parse_Tuple_contents(data: seq<byte>, eltTypes: seq<G>): (Option<seq<V>>, seq<byte>)
    requires |data| < 18446744073709551616
    requires |eltTypes| < 18446744073709551616
    requires forall elt: G {:trigger ValidGrammar(elt)} {:trigger elt in eltTypes} :: elt in eltTypes ==> ValidGrammar(elt)
    ensures var (opt_val: Option<seq<V>>, rest: seq<byte>) := parse_Tuple_contents(data, eltTypes); |rest| <= |data| && (opt_val.Some? ==> |opt_val.v| == |eltTypes| && forall i: int {:trigger eltTypes[i]} {:trigger opt_val.v[i]} :: 0 <= i < |opt_val.v| ==> ValInGrammar(opt_val.v[i], eltTypes[i]))
    decreases eltTypes, 0
  {
    if eltTypes == [] then
      (Some([]), data)
    else
      var (val: Option<V>, rest1: seq<byte>) := parse_Val(data, eltTypes[0]); assert |rest1| <= |data|; var (contents: Option<seq<V>>, rest2: seq<byte>) := parse_Tuple_contents(rest1, eltTypes[1..]); if !val.None? && !contents.None? then (Some([val.v] + contents.v), rest2) else (None, [])
  }

  lemma /*{:_induction data, eltTypes}*/ lemma_TupleContents_helper(data: seq<byte>, eltTypes: seq<G>, v: seq<V>, trace: seq<ContentsTraceStep>)
    requires |data| < 18446744073709551616
    requires |eltTypes| < 18446744073709551616
    requires forall elt: G {:trigger ValidGrammar(elt)} {:trigger elt in eltTypes} :: elt in eltTypes ==> ValidGrammar(elt)
    requires |trace| == |eltTypes| + 1
    requires |v| == |eltTypes| as int
    requires forall j: int {:trigger trace[j]} :: 0 <= j < |trace| ==> |trace[j].data| < 18446744073709551616
    requires trace[0].data == data
    requires (forall j: int, _t#0: int {:trigger eltTypes[_t#0], trace[j]} {:trigger trace[_t#0], trace[j]} | _t#0 == j - 1 :: 0 < j && j < |eltTypes| as int + 1 ==> trace[j].val == parse_Val(trace[_t#0].data, eltTypes[_t#0]).0) && forall j: int, _t#0: int {:trigger eltTypes[_t#0], trace[j]} {:trigger trace[_t#0], trace[j]} | _t#0 == j - 1 :: 0 < j && j < |eltTypes| as int + 1 ==> trace[j].data == parse_Val(trace[_t#0].data, eltTypes[_t#0]).1
    requires forall j: int {:trigger trace[j]} :: 0 < j < |trace| ==> trace[j].val.Some?
    requires forall j: int {:trigger trace[j]} :: 0 < j < |trace| ==> v[j - 1] == trace[j].val.v
    ensures var (v': Option<seq<V>>, rest': seq<byte>) := parse_Tuple_contents(data, eltTypes); ghost var v_opt: Option<seq<V>> := Some(v); v_opt == v' && trace[|trace| - 1].data == rest'
    decreases |eltTypes|
  {
  }

  lemma /*{:_induction data, eltTypes}*/ lemma_TupleContents_helper_bailout(data: seq<byte>, eltTypes: seq<G>, trace: seq<ContentsTraceStep>)
    requires |data| < 18446744073709551616
    requires |eltTypes| < 18446744073709551616
    requires forall elt: G {:trigger ValidGrammar(elt)} {:trigger elt in eltTypes} :: elt in eltTypes ==> ValidGrammar(elt)
    requires 1 < |trace| <= |eltTypes| as int + 1
    requires forall j: int {:trigger trace[j]} :: 0 <= j < |trace| ==> |trace[j].data| < 18446744073709551616
    requires trace[0].data == data
    requires (forall j: int, _t#0: int {:trigger eltTypes[_t#0], trace[j]} {:trigger trace[_t#0], trace[j]} | _t#0 == j - 1 :: 0 < j && j < |trace| ==> trace[j].val == parse_Val(trace[_t#0].data, eltTypes[_t#0]).0) && forall j: int, _t#0: int {:trigger eltTypes[_t#0], trace[j]} {:trigger trace[_t#0], trace[j]} | _t#0 == j - 1 :: 0 < j && j < |trace| ==> trace[j].data == parse_Val(trace[_t#0].data, eltTypes[_t#0]).1
    requires forall j: int {:trigger trace[j]} :: 0 < j < |trace| - 1 ==> trace[j].val.Some?
    requires trace[|trace| - 1].val.None?
    ensures var (v': Option<seq<V>>, rest': seq<byte>) := parse_Tuple_contents(data, eltTypes); v'.None? && rest' == []
    decreases |eltTypes|
  {
  }

  method {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ ParseTupleContents(data: array<byte>, index: uint64, eltTypes: seq<G>)
      returns (success: bool, v: seq<V>, rest_index: uint64)
    requires index as int <= data.Length
    requires data.Length < 18446744073709551616
    requires |eltTypes| < 18446744073709551616
    requires forall elt: G {:trigger ValidGrammar(elt)} {:trigger elt in eltTypes} :: elt in eltTypes ==> ValidGrammar(elt)
    ensures rest_index as int <= data.Length
    ensures var (v': Option<seq<V>>, rest': seq<byte>) := parse_Tuple_contents(data[index..], eltTypes); var v_opt: Option<seq<V>> := if success then Some(v) else None(); v_opt == v' && data[rest_index..] == rest'
    ensures success ==> ValidVal(VTuple(v))
    decreases eltTypes, 0
  {
    reveal parse_Tuple_contents();
    var vArr := new V[|eltTypes|];
    ghost var g_v := [];
    success := true;
    var i: int := 0;
    var next_val_index: uint64 := index;
    ghost var trace := [ContentsTraceStep(data[index..], None())];
    while i < |eltTypes|
      invariant 0 <= i <= |eltTypes|
      invariant index <= next_val_index <= data.Length as uint64
      invariant |trace| == i + 1
      invariant |g_v| == i
      invariant vArr[..i] == g_v
      invariant trace[0].data == data[index..]
      invariant forall j: int {:trigger trace[j]} :: 0 <= j < i + 1 ==> |trace[j].data| < 18446744073709551616
      invariant trace[i].data == data[next_val_index..]
      invariant forall j: int {:trigger trace[j]} :: 0 < j <= i ==> trace[j].val.Some?
      invariant forall j: int {:trigger trace[j]} :: 0 < j <= i ==> g_v[j - 1] == trace[j].val.v
      invariant (forall j: int, _t#0: int {:trigger eltTypes[_t#0], trace[j]} {:trigger trace[_t#0], trace[j]} | _t#0 == j - 1 :: 0 < j && j < i + 1 ==> trace[j].val == parse_Val(trace[_t#0].data, eltTypes[_t#0]).0) && forall j: int, _t#0: int {:trigger eltTypes[_t#0], trace[j]} {:trigger trace[_t#0], trace[j]} | _t#0 == j - 1 :: 0 < j && j < i + 1 ==> trace[j].data == parse_Val(trace[_t#0].data, eltTypes[_t#0]).1
      invariant ValidVal(VTuple(vArr[..i]))
      decreases |eltTypes| - i
    {
      var some1, val, rest1 := ParseVal(data, next_val_index, eltTypes[i]);
      ghost var step := ContentsTraceStep(data[rest1..], if some1 then Some(val) else None());
      ghost var old_trace := trace;
      trace := trace + [step];
      if !some1 {
        success := false;
        rest_index := data.Length as uint64;
        lemma_TupleContents_helper_bailout(data[index..], eltTypes, trace);
        return;
      }
      g_v := g_v + [val];
      vArr[i] := val;
      next_val_index := rest1;
      i := i + 1;
    }
    success := true;
    rest_index := next_val_index;
    v := vArr[..];
    lemma_TupleContents_helper(data[index..], eltTypes, v, trace);
  }

  function method parse_Tuple(data: seq<byte>, eltTypes: seq<G>): (Option<V>, seq<byte>)
    requires |data| < 18446744073709551616
    requires |eltTypes| < 18446744073709551616
    requires forall elt: G {:trigger ValidGrammar(elt)} {:trigger elt in eltTypes} :: elt in eltTypes ==> ValidGrammar(elt)
    ensures var (opt_val: Option<V>, rest: seq<byte>) := parse_Tuple(data, eltTypes); |rest| <= |data| && (opt_val.Some? ==> ValInGrammar(opt_val.v, GTuple(eltTypes)))
    decreases eltTypes, 1
  {
    var (contents: Option<seq<V>>, rest: seq<byte>) := parse_Tuple_contents(data, eltTypes);
    if !contents.None? then
      (Some(VTuple(contents.v)), rest)
    else
      (None, [])
  }

  method ParseTuple(data: array<byte>, index: uint64, eltTypes: seq<G>)
      returns (success: bool, v: V, rest_index: uint64)
    requires index as int <= data.Length
    requires data.Length < 18446744073709551616
    requires |eltTypes| < 18446744073709551616
    requires forall elt: G {:trigger ValidGrammar(elt)} {:trigger elt in eltTypes} :: elt in eltTypes ==> ValidGrammar(elt)
    ensures rest_index as int <= data.Length
    ensures var (v': Option<V>, rest': seq<byte>) := parse_Tuple(data[index..], eltTypes); var v_opt: Option<V> := if success then Some(v) else None(); v_opt == v' && data[rest_index..] == rest'
    ensures success ==> ValidVal(v)
    decreases eltTypes, 1
  {
    var some, contents, rest := ParseTupleContents(data, index, eltTypes);
    if some {
      success := true;
      v := VTuple(contents);
      rest_index := rest;
    } else {
      success := false;
      rest_index := data.Length as uint64;
    }
  }

  function method parse_ByteArray(data: seq<byte>): (Option<V>, seq<byte>)
    requires |data| < 18446744073709551616
    decreases data
  {
    var (len: Option<V>, rest: seq<byte>) := parse_Uint64(data);
    if !len.None? && len.v.u <= |rest| as uint64 then
      (Some(VByteArray(rest[0 .. len.v.u])), rest[len.v.u..])
    else
      (None, [])
  }

  method ParseByteArray(data: array<byte>, index: uint64)
      returns (success: bool, v: V, rest_index: uint64)
    requires index as int <= data.Length
    requires data.Length < 18446744073709551616
    ensures rest_index as int <= data.Length
    ensures var (v': Option<V>, rest': seq<byte>) := parse_ByteArray(data[index..]); var v_opt: Option<V> := if success then Some(v) else None(); v_opt == v' && data[rest_index..] == rest'
    decreases data, index
  {
    var some, len, rest := ParseUint64(data, index);
    if some && len.u <= data.Length as uint64 - rest {
      var rest_seq := data[rest..];
      assert len.u <= |rest_seq| as uint64;
      calc {
        rest_seq[0 .. len.u];
        data[rest .. rest + len.u];
      }
      success := true;
      v := VByteArray(data[rest .. rest + len.u]);
      rest_index := rest + len.u;
    } else {
      success := false;
      rest_index := data.Length as uint64;
    }
  }

  function method parse_Case(data: seq<byte>, cases: seq<G>): (Option<V>, seq<byte>)
    requires |data| < 18446744073709551616
    requires |cases| < 18446744073709551616
    requires forall elt: G {:trigger ValidGrammar(elt)} {:trigger elt in cases} :: elt in cases ==> ValidGrammar(elt)
    ensures var (opt_val: Option<V>, rest: seq<byte>) := parse_Case(data, cases); |rest| <= |data| && (opt_val.Some? ==> ValInGrammar(opt_val.v, GTaggedUnion(cases)))
    decreases cases
  {
    var (caseID: Option<V>, rest1: seq<byte>) := parse_Uint64(data);
    if !caseID.None? && caseID.v.u < |cases| as uint64 then
      var (val: Option<V>, rest2: seq<byte>) := parse_Val(rest1, cases[caseID.v.u]);
      if !val.None? then
        (Some(VCase(caseID.v.u, val.v)), rest2)
      else
        (None, [])
    else
      (None, [])
  }

  method ParseCase(data: array<byte>, index: uint64, cases: seq<G>)
      returns (success: bool, v: V, rest_index: uint64)
    requires index as int <= data.Length
    requires data.Length < 18446744073709551616
    requires |cases| < 18446744073709551616
    requires forall elt: G {:trigger ValidGrammar(elt)} {:trigger elt in cases} :: elt in cases ==> ValidGrammar(elt)
    ensures rest_index as int <= data.Length
    ensures var (v': Option<V>, rest': seq<byte>) := parse_Case(data[index..], cases); var v_opt: Option<V> := if success then Some(v) else None(); v_opt == v' && data[rest_index..] == rest'
    ensures success ==> ValidVal(v)
    decreases cases
  {
    var some1, caseID, rest1 := ParseUint64(data, index);
    if some1 && caseID.u < |cases| as uint64 {
      var some2, val, rest2 := ParseVal(data, rest1, cases[caseID.u]);
      if some2 {
        success := true;
        v := VCase(caseID.u, val);
        rest_index := rest2;
      } else {
        success := false;
        rest_index := data.Length as uint64;
      }
    } else {
      success := false;
      rest_index := data.Length as uint64;
    }
  }

  function method {:opaque} {:fuel 0, 0} parse_Val(data: seq<byte>, grammar: G): (Option<V>, seq<byte>)
    requires |data| < 18446744073709551616
    requires ValidGrammar(grammar)
    ensures var (val: Option<V>, rest: seq<byte>) := parse_Val(data, grammar); |rest| <= |data| && (!val.None? ==> ValInGrammar(val.v, grammar))
    decreases grammar, 0
  {
    match grammar
    case GUint64() =>
      parse_Uint64(data)
    case GArray(elt) =>
      parse_Array(data, elt)
    case GTuple(t) =>
      parse_Tuple(data, t)
    case GByteArray() =>
      parse_ByteArray(data)
    case GTaggedUnion(cases) =>
      parse_Case(data, cases)
  }

  method ParseVal(data: array<byte>, index: uint64, grammar: G)
      returns (success: bool, v: V, rest_index: uint64)
    requires index as int <= data.Length
    requires data.Length < 18446744073709551616
    requires ValidGrammar(grammar)
    ensures rest_index as int <= data.Length
    ensures var (v': Option<V>, rest': seq<byte>) := parse_Val(data[index..], grammar); var v_opt: Option<V> := if success then Some(v) else None(); v_opt == v' && data[rest_index..] == rest'
    ensures success ==> ValidVal(v)
    decreases grammar, 0
  {
    reveal parse_Val();
    match grammar {
      case {:split false} GUint64() =>
        success, v, rest_index := ParseUint64(data, index);
      case {:split false} GArray(elt) =>
        success, v, rest_index := ParseArray(data, index, elt);
      case {:split false} GTuple(t) =>
        success, v, rest_index := ParseTuple(data, index, t);
      case {:split false} GByteArray() =>
        success, v, rest_index := ParseByteArray(data, index);
      case {:split false} GTaggedUnion(cases) =>
        success, v, rest_index := ParseCase(data, index, cases);
    }
  }

  predicate Demarshallable(data: seq<byte>, grammar: G)
    decreases data, grammar
  {
    |data| < 18446744073709551616 &&
    ValidGrammar(grammar) &&
    !parse_Val(data, grammar).0.None? &&
    ValidVal(parse_Val(data, grammar).0.v) &&
    parse_Val(data, grammar).1 == []
  }

  function DemarshallFunc(data: seq<byte>, grammar: G): V
    requires Demarshallable(data, grammar)
    ensures var (val: Option<V>, rest: seq<byte>) := parse_Val(data, grammar); !val.None? && ValInGrammar(val.v, grammar)
    decreases grammar, 0
  {
    parse_Val(data, grammar).0.v
  }

  method Demarshall(data: array<byte>, grammar: G)
      returns (success: bool, v: V)
    requires data.Length < 18446744073709551616
    requires ValidGrammar(grammar)
    ensures success == Demarshallable(data[..], grammar)
    ensures success ==> v == DemarshallFunc(data[..], grammar)
    decreases data, grammar
  {
    var rest: uint64;
    success, v, rest := ParseVal(data, 0, grammar);
    if success && rest == data.Length as uint64 {
      assert v == parse_Val(data[..], grammar).0.v;
      assert Demarshallable(data[..], grammar);
      assert v == DemarshallFunc(data[..], grammar);
    } else {
      success := false;
      assert !Demarshallable(data[..], grammar);
    }
  }

  lemma /*{:_induction v, grammar}*/ lemma_parse_Val_view_ByteArray(data: seq<byte>, v: V, grammar: G, index: int)
    requires |data| < 18446744073709551616
    requires ValInGrammar(v, grammar)
    requires ValidGrammar(grammar)
    requires grammar.GByteArray?
    requires 0 <= index <= |data|
    requires 0 <= index + SizeOfV(v) <= |data|
    ensures forall bound: int {:trigger data[index .. bound]} {:trigger Trigger(bound)} :: Trigger(bound) ==> index + SizeOfV(v) <= bound <= |data| ==> (parse_ByteArray(data[index .. bound]).0 == Some(v) <==> parse_ByteArray(data[index .. index + SizeOfV(v)]).0 == Some(v))
    ensures forall bound: int {:trigger data[index .. bound]} :: index + SizeOfV(v) <= bound <= |data| ==> parse_ByteArray(data[index .. bound]).0 == Some(v) ==> parse_ByteArray(data[index .. bound]).1 == data[index + SizeOfV(v) .. bound]
    decreases data, v, grammar, index
  {
  }

  lemma /*{:_induction s, v}*/ lemma_SeqSum_prefix(s: seq<V>, v: V)
    ensures SeqSum(s + [v]) == SeqSum(s) + SizeOfV(v)
    decreases s, v
  {
  }

  lemma /*{:_induction s}*/ lemma_SeqSum_bound(s: seq<V>, bound: int)
    requires SeqSum(s) < bound
    ensures forall v: V {:trigger SizeOfV(v)} {:trigger v in s} :: v in s ==> SizeOfV(v) < bound
    decreases s, bound
  {
  }

  lemma /*{:_induction s, prefix}*/ lemma_SeqSum_bound_prefix(s: seq<V>, prefix: seq<V>, index: int)
    requires 0 <= index <= |s|
    requires prefix == s[..index]
    ensures SeqSum(prefix) <= SeqSum(s)
    decreases s, prefix, index
  {
  }

  lemma /*{:_induction data, eltType, len}*/ lemma_parse_Array_contents_len(data: seq<byte>, eltType: G, len: uint64)
    requires |data| < 18446744073709551616
    requires ValidGrammar(eltType)
    requires len >= 0
    requires !parse_Array_contents(data, eltType, len).0.None?
    ensures len as int == |parse_Array_contents(data, eltType, len).0.v|
    decreases len
  {
  }

  lemma /*{:_induction vs, grammar, len}*/ lemma_parse_Val_view_Array_contents(data: seq<byte>, vs: seq<V>, grammar: G, index: int, bound: int, len: uint64)
    requires |data| < 18446744073709551616
    requires forall v: V {:trigger ValInGrammar(v, grammar)} {:trigger v in vs} :: v in vs ==> ValInGrammar(v, grammar)
    requires ValidGrammar(grammar)
    requires len as int == |vs|
    requires 0 <= index <= |data|
    requires 0 <= index + SeqSum(vs) <= |data|
    requires index + SeqSum(vs) <= bound <= |data|
    ensures parse_Array_contents(data[index .. bound], grammar, len).0 == Some(vs) <==> parse_Array_contents(data[index .. index + SeqSum(vs)], grammar, len).0 == Some(vs)
    ensures parse_Array_contents(data[index .. bound], grammar, len).0 == Some(vs) ==> parse_Array_contents(data[index .. bound], grammar, len).1 == data[index + SeqSum(vs) .. bound]
    decreases grammar, 1, len
  {
  }

  lemma /*{:_induction v, grammar}*/ lemma_parse_Val_view_Array(data: seq<byte>, v: V, grammar: G, index: int, bound: int)
    requires |data| < 18446744073709551616
    requires ValInGrammar(v, grammar)
    requires ValidGrammar(grammar)
    requires grammar.GArray?
    requires 0 <= index <= |data|
    requires 0 <= index + SizeOfV(v) <= |data|
    requires index + SizeOfV(v) <= bound <= |data|
    ensures parse_Array(data[index .. bound], grammar.elt).0 == Some(v) <==> parse_Array(data[index .. index + SizeOfV(v)], grammar.elt).0 == Some(v)
    ensures parse_Array(data[index .. bound], grammar.elt).0 == Some(v) ==> parse_Array(data[index .. bound], grammar.elt).1 == data[index + SizeOfV(v) .. bound]
    decreases grammar, -1
  {
  }

  lemma /*{:_induction vs, grammar}*/ lemma_parse_Val_view_Tuple_contents(data: seq<byte>, vs: seq<V>, grammar: seq<G>, index: int, bound: int)
    requires |data| < 18446744073709551616
    requires |vs| == |grammar|
    requires forall i: int {:trigger grammar[i]} {:trigger vs[i]} :: 0 <= i < |vs| ==> ValInGrammar(vs[i], grammar[i])
    requires |grammar| < 18446744073709551616
    requires forall g: G {:trigger ValidGrammar(g)} {:trigger g in grammar} :: g in grammar ==> ValidGrammar(g)
    requires 0 <= index <= |data|
    requires 0 <= index + SeqSum(vs) <= |data|
    requires index + SeqSum(vs) <= bound <= |data|
    ensures parse_Tuple_contents(data[index .. bound], grammar).0 == Some(vs) <==> parse_Tuple_contents(data[index .. index + SeqSum(vs)], grammar).0 == Some(vs)
    ensures parse_Tuple_contents(data[index .. bound], grammar).0 == Some(vs) ==> parse_Tuple_contents(data[index .. bound], grammar).1 == data[index + SeqSum(vs) .. bound]
    decreases grammar, -1, vs
  {
  }

  lemma /*{:_induction v, grammar}*/ lemma_parse_Val_view_Tuple(data: seq<byte>, v: V, grammar: seq<G>, index: int, bound: int)
    requires |data| < 18446744073709551616
    requires v.VTuple?
    requires |v.t| == |grammar|
    requires forall i: int {:trigger grammar[i]} {:trigger v.t[i]} :: 0 <= i < |v.t| ==> ValInGrammar(v.t[i], grammar[i])
    requires |grammar| < 18446744073709551616
    requires forall g: G {:trigger ValidGrammar(g)} {:trigger g in grammar} :: g in grammar ==> ValidGrammar(g)
    requires 0 <= index <= |data|
    requires 0 <= index + SizeOfV(v) <= |data|
    requires index + SizeOfV(v) <= bound <= |data|
    ensures parse_Tuple(data[index .. bound], grammar).0 == Some(v) <==> parse_Tuple(data[index .. index + SizeOfV(v)], grammar).0 == Some(v)
    ensures parse_Tuple(data[index .. bound], grammar).0 == Some(v) ==> parse_Tuple(data[index .. bound], grammar).1 == data[index + SizeOfV(v) .. bound]
    decreases grammar, -1, v
  {
  }

  lemma /*{:_induction v, grammar}*/ lemma_parse_Val_view_Union(data: seq<byte>, v: V, grammar: G, index: int, bound: int)
    requires |data| < 18446744073709551616
    requires ValInGrammar(v, grammar)
    requires ValidGrammar(grammar)
    requires grammar.GTaggedUnion?
    requires 0 <= index <= |data|
    requires 0 <= index + SizeOfV(v) <= |data|
    requires index + SizeOfV(v) <= bound <= |data|
    ensures parse_Case(data[index .. bound], grammar.cases).0 == Some(v) <==> parse_Case(data[index .. index + SizeOfV(v)], grammar.cases).0 == Some(v)
    ensures parse_Case(data[index .. bound], grammar.cases).0 == Some(v) ==> parse_Case(data[index .. bound], grammar.cases).1 == data[index + SizeOfV(v) .. bound]
    decreases grammar, -1
  {
  }

  lemma /*{:_induction v, grammar}*/ lemma_parse_Val_view(data: seq<byte>, v: V, grammar: G, index: int)
    requires |data| < 18446744073709551616
    requires ValInGrammar(v, grammar)
    requires ValidGrammar(grammar)
    requires 0 <= index <= |data|
    requires 0 <= index + SizeOfV(v) <= |data|
    ensures forall bound: int {:trigger data[index .. bound]} :: index + SizeOfV(v) <= bound <= |data| ==> (parse_Val(data[index .. bound], grammar).0 == Some(v) <==> parse_Val(data[index .. index + SizeOfV(v)], grammar).0 == Some(v))
    ensures forall bound: int {:trigger data[index .. bound]} :: index + SizeOfV(v) <= bound <= |data| ==> parse_Val(data[index .. bound], grammar).0 == Some(v) ==> parse_Val(data[index .. bound], grammar).1 == data[index + SizeOfV(v) .. bound]
    decreases grammar, 0
  {
  }

  lemma /*{:_induction v, grammar}*/ lemma_parse_Val_view_specific(data: seq<byte>, v: V, grammar: G, index: int, bound: int)
    requires |data| < 18446744073709551616
    requires ValInGrammar(v, grammar)
    requires ValidGrammar(grammar)
    requires 0 <= index <= |data|
    requires 0 <= index + SizeOfV(v) <= |data|
    requires index + SizeOfV(v) <= bound <= |data|
    requires parse_Val(data[index .. index + SizeOfV(v)], grammar).0 == Some(v)
    ensures parse_Val(data[index .. bound], grammar).0 == Some(v)
    ensures parse_Val(data[index .. bound], grammar).1 == data[index + SizeOfV(v) .. bound]
    decreases grammar, 0
  {
  }

  lemma /*{:_induction v, grammar}*/ lemma_parse_Val_view_specific_size(data: seq<byte>, v: V, grammar: G, index: int, bound: int)
    requires |data| < 18446744073709551616
    requires ValInGrammar(v, grammar)
    requires ValidGrammar(grammar)
    requires 0 <= index <= |data|
    requires 0 <= index + SizeOfV(v) <= |data|
    requires index + SizeOfV(v) <= bound <= |data|
    requires parse_Val(data[index .. bound], grammar).0 == Some(v)
    ensures parse_Val(data[index .. index + SizeOfV(v)], grammar).0 == Some(v)
    ensures parse_Val(data[index .. bound], grammar).1 == data[index + SizeOfV(v) .. bound]
    decreases grammar, 0
  {
  }

  method ComputeSeqSum(s: seq<V>) returns (size: uint64)
    requires |s| < 18446744073709551616
    requires 0 <= SeqSum(s) < 18446744073709551616
    requires forall v: V {:trigger ValidVal(v)} {:trigger v in s} :: v in s ==> ValidVal(v)
    ensures size as int == SeqSum(s)
    decreases s
  {
    reveal SeqSum();
    if |s| as uint64 == 0 {
      size := 0;
    } else {
      var v_size := ComputeSizeOf(s[0]);
      var rest_size := ComputeSeqSum(s[1..]);
      size := v_size + rest_size;
    }
  }

  method ComputeSizeOf(val: V) returns (size: uint64)
    requires 0 <= SizeOfV(val) < 18446744073709551616
    requires ValidVal(val)
    ensures size as int == SizeOfV(val)
    decreases val
  {
    match val
    case {:split false} VUint64(_) =>
      size := 8;
    case {:split false} VArray(a) =>
      var v := ComputeSeqSum(a);
      if v == 0 {
        size := 8;
      } else {
        size := 8 + v;
      }
    case {:split false} VTuple(t) =>
      size := ComputeSeqSum(t);
    case {:split false} VByteArray(b) =>
      size := 8 + |b| as uint64;
    case {:split false} VCase(c, v) =>
      var vs := ComputeSizeOf(v);
      size := 8 + vs;
  }

  method MarshallUint64(n: uint64, data: array<byte>, index: uint64)
    requires index as int + Uint64Size() as int <= data.Length
    requires 0 <= index as int + Uint64Size() as int < 18446744073709551616
    requires data.Length < 18446744073709551616
    modifies data
    ensures SeqByteToUint64(data[index .. index + Uint64Size()]) == n
    ensures !parse_Uint64(data[index .. index + Uint64Size()]).0.None?
    ensures !parse_Uint64(data[index..]).0.None?
    ensures var tuple: (Option<V>, seq<byte>) := parse_Uint64(data[index .. index + Uint64Size()]); tuple.0.v.u == n && tuple.1 == []
    ensures var tuple: (Option<V>, seq<byte>) := parse_Uint64(data[index..]); tuple.0.v.u == n && tuple.1 == data[index + Uint64Size()..]
    ensures data[0 .. index] == old(data[0 .. index])
    ensures data[index + Uint64Size()..] == old(data[index + Uint64Size()..])
    ensures forall i: uint64 {:trigger old(data[i])} {:trigger data[i]} :: 0 <= i < index ==> data[i] == old(data[i])
    ensures forall i: int {:trigger old(data[i])} {:trigger data[i]} :: index as int + Uint64Size() as int <= i < data.Length ==> data[i] == old(data[i])
    decreases n, data, index
  {
    MarshallUint64_guts(n, data, index);
    var tuple := parse_Uint64(data[index..]);
  }

  lemma /*{:_induction contents, eltType, marshalled_bytes, trace}*/ lemma_marshall_array_contents(contents: seq<V>, eltType: G, marshalled_bytes: seq<byte>, trace: seq<seq<byte>>)
    requires forall v: V {:trigger ValInGrammar(v, eltType)} {:trigger v in contents} :: v in contents ==> ValInGrammar(v, eltType)
    requires forall v: V {:trigger ValidVal(v)} {:trigger v in contents} :: v in contents ==> ValidVal(v)
    requires ValidGrammar(eltType)
    requires |marshalled_bytes| < 18446744073709551616
    requires |contents| < 18446744073709551616
    requires |contents| == |trace|
    requires |marshalled_bytes| == SeqSum(contents)
    requires marshalled_bytes == SeqCatRev(trace)
    requires forall j: int {:trigger trace[j]} {:trigger contents[j]} :: (0 <= j < |trace| ==> SizeOfV(contents[j]) == |trace[j]|) && (0 <= j < |trace| ==> |trace[j]| < 18446744073709551616)
    requires forall j: int {:trigger contents[j]} {:trigger trace[j]} :: 0 <= j < |trace| ==> var (val: Option<V>, rest: seq<byte>) := parse_Val(trace[j], eltType); val.Some? && val.v == contents[j]
    ensures parse_Array_contents(marshalled_bytes, eltType, |contents| as uint64).0.Some?
    ensures parse_Array_contents(marshalled_bytes, eltType, |contents| as uint64).0.v == contents
    decreases contents, eltType, marshalled_bytes, trace
  {
  }

  method {:timeLimitMultiplier 4} /*{:_timeLimit 40}*/ MarshallArrayContents(contents: seq<V>, eltType: G, data: array<byte>, index: uint64)
      returns (size: uint64)
    requires forall v: V {:trigger ValInGrammar(v, eltType)} {:trigger v in contents} :: v in contents ==> ValInGrammar(v, eltType)
    requires forall v: V {:trigger ValidVal(v)} {:trigger v in contents} :: v in contents ==> ValidVal(v)
    requires ValidGrammar(eltType)
    requires index as int + SeqSum(contents) <= data.Length
    requires 0 <= index as int + SeqSum(contents) < 18446744073709551616
    requires data.Length < 18446744073709551616
    requires |contents| < 18446744073709551616
    modifies data
    ensures parse_Array_contents(data[index .. index as int + SeqSum(contents)], eltType, |contents| as uint64).0.Some?
    ensures parse_Array_contents(data[index .. index as int + SeqSum(contents)], eltType, |contents| as uint64).0.v == contents
    ensures forall i: uint64 {:trigger old(data[i])} {:trigger data[i]} :: 0 <= i < index ==> data[i] == old(data[i])
    ensures forall i: int {:trigger old(data[i])} {:trigger data[i]} :: index as int + SeqSum(contents) <= i < data.Length ==> data[i] == old(data[i])
    ensures size as int == SeqSum(contents)
    decreases eltType, 1, |contents|
  {
    var i: int := 0;
    var cur_index := index;
    reveal SeqSum();
    reveal parse_Array_contents();
    ghost var trace := [];
    ghost var marshalled_bytes := [];
    while i < |contents|
      invariant 0 <= i <= |contents|
      invariant 0 <= index as int <= index as int + SeqSum(contents[..i]) <= data.Length
      invariant cur_index as int == index as int + SeqSum(contents[..i])
      invariant forall j: uint64 {:trigger old(data[j])} {:trigger data[j]} :: 0 <= j < index ==> data[j] == old(data[j])
      invariant forall j: int {:trigger old(data[j])} {:trigger data[j]} :: index as int + SeqSum(contents) <= j < data.Length ==> data[j] == old(data[j])
      invariant marshalled_bytes == data[index .. cur_index]
      invariant marshalled_bytes == SeqCatRev(trace)
      invariant |trace| == i
      invariant forall j: int {:trigger trace[j]} {:trigger contents[j]} :: (0 <= j < |trace| ==> SizeOfV(contents[j]) == |trace[j]|) && (0 <= j < |trace| ==> |trace[j]| < 18446744073709551616)
      invariant forall j: int {:trigger contents[j]} {:trigger trace[j]} :: 0 <= j < |trace| ==> var (val: Option<V>, rest: seq<byte>) := parse_Val(trace[j], eltType); val.Some? && val.v == contents[j]
      decreases |contents| - i
    {
      lemma_SeqSum_bound(contents, 18446744073709551616);
      calc <= {
        cur_index as int + SizeOfV(contents[i]);
        index as int + SeqSum(contents[..i]) + SizeOfV(contents[i]);
        {
          lemma_SeqSum_prefix(contents[..i], contents[i]);
          assert contents[..i] + [contents[i]] == contents[..i + 1];
        }
        index as int + SeqSum(contents[..i + 1]);
        {
          lemma_SeqSum_bound_prefix(contents, contents[..i + 1], i + 1);
        }
        index as int + SeqSum(contents);
      }
      var item_size := MarshallVal(contents[i], eltType, data, cur_index);
      ghost var fresh_bytes := data[cur_index .. cur_index + item_size];
      marshalled_bytes := marshalled_bytes + fresh_bytes;
      forall
        ensures var (val: Option<V>, rest: seq<byte>) := parse_Val(fresh_bytes, eltType); val.Some? && val.v == contents[i]
      {
        assert SizeOfV(contents[i]) <= |fresh_bytes|;
        lemma_parse_Val_view(fresh_bytes, contents[i], eltType, 0);
      }
      ghost var old_trace := trace;
      trace := trace + [fresh_bytes];
      ghost var old_cur_index := cur_index;
      cur_index := cur_index + item_size;
      i := i + 1;
      calc <= {
        index as int + SeqSum(contents[..i]);
        calc {
          SeqSum(contents[..i]);
        <=
          {
            lemma_SeqSum_bound_prefix(contents, contents[..i], i);
          }
          SeqSum(contents);
        }
        index as int + SeqSum(contents);
        data.Length;
      }
      assert {:split_here} true;
      assert marshalled_bytes == data[index .. cur_index];
      calc {
        cur_index as int;
        old_cur_index as int + SizeOfV(contents[i - 1]);
        index as int + SeqSum(contents[..i - 1]) + SizeOfV(contents[i - 1]);
        {
          lemma_SeqSum_prefix(contents[..i - 1], contents[i - 1]);
          assert contents[..i - 1] + [contents[i - 1]] == contents[..i];
        }
        index as int + SeqSum(contents[..i]);
      }
      assert cur_index as int == index as int + SeqSum(contents[..i]);
      assert marshalled_bytes == data[index .. cur_index];
    }
    assert contents[..i] == contents;
    assert cur_index as int == index as int + SeqSum(contents);
    assert marshalled_bytes == data[index .. index as int + SeqSum(contents)];
    lemma_marshall_array_contents(contents, eltType, marshalled_bytes, trace);
    size := cur_index - index;
  }

  method MarshallArray(val: V, grammar: G, data: array<byte>, index: uint64)
      returns (size: uint64)
    requires val.VArray?
    requires ValInGrammar(val, grammar)
    requires ValidGrammar(grammar)
    requires ValidVal(val)
    requires index as int + SizeOfV(val) <= data.Length
    requires 0 <= index as int + SizeOfV(val) < 18446744073709551616
    requires data.Length < 18446744073709551616
    modifies data
    ensures parse_Val(data[index .. index as int + SizeOfV(val)], grammar).0.Some? && parse_Val(data[index .. index as int + SizeOfV(val)], grammar).0.v == val
    ensures forall i: uint64 {:trigger old(data[i])} {:trigger data[i]} :: 0 <= i < index ==> data[i] == old(data[i])
    ensures forall i: int {:trigger old(data[i])} {:trigger data[i]} :: index as int + SizeOfV(val) <= i < data.Length ==> data[i] == old(data[i])
    ensures size as int == SizeOfV(val)
    decreases grammar, -1
  {
    reveal parse_Val();
    MarshallUint64(|val.a| as uint64, data, index);
    ghost var tuple := parse_Uint64(data[index .. index as int + SizeOfV(val)]);
    ghost var len := tuple.0;
    ghost var rest := tuple.1;
    assert !len.None?;
    var contents_size := MarshallArrayContents(val.a, grammar.elt, data, index + Uint64Size());
    tuple := parse_Uint64(data[index .. index as int + SizeOfV(val)]);
    assert {:split_here} true;
    len := tuple.0;
    rest := tuple.1;
    assert !len.None?;
    ghost var contents_tuple := parse_Array_contents(rest, grammar.elt, len.v.u);
    ghost var contents := contents_tuple.0;
    ghost var remainder := contents_tuple.1;
    assert !contents.None?;
    size := 8 + contents_size;
  }

  lemma /*{:_induction contents, eltTypes, marshalled_bytes, trace}*/ lemma_marshall_tuple_contents(contents: seq<V>, eltTypes: seq<G>, marshalled_bytes: seq<byte>, trace: seq<seq<byte>>)
    requires |contents| == |eltTypes|
    requires forall i: int {:trigger eltTypes[i]} {:trigger contents[i]} :: 0 <= i < |contents| ==> ValInGrammar(contents[i], eltTypes[i])
    requires forall g: G {:trigger ValidGrammar(g)} {:trigger g in eltTypes} :: g in eltTypes ==> ValidGrammar(g)
    requires |eltTypes| < 18446744073709551616
    requires forall i: int {:trigger contents[i]} :: 0 <= i < |contents| ==> ValidVal(contents[i])
    requires |marshalled_bytes| < 18446744073709551616
    requires |contents| < 18446744073709551616
    requires |contents| == |trace|
    requires |marshalled_bytes| == SeqSum(contents)
    requires marshalled_bytes == SeqCatRev(trace)
    requires forall j: int {:trigger trace[j]} {:trigger contents[j]} :: (0 <= j < |trace| ==> SizeOfV(contents[j]) == |trace[j]|) && (0 <= j < |trace| ==> |trace[j]| < 18446744073709551616)
    requires forall j: int {:trigger contents[j]} {:trigger eltTypes[j]} {:trigger trace[j]} :: 0 <= j < |trace| ==> var (val: Option<V>, rest: seq<byte>) := parse_Val(trace[j], eltTypes[j]); val.Some? && val.v == contents[j]
    ensures parse_Tuple_contents(marshalled_bytes, eltTypes).0.Some?
    ensures parse_Tuple_contents(marshalled_bytes, eltTypes).0.v == contents
    decreases contents, eltTypes, marshalled_bytes, trace
  {
  }

  method {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ MarshallTupleContents(contents: seq<V>, eltTypes: seq<G>, data: array<byte>, index: uint64)
      returns (size: uint64)
    requires |contents| == |eltTypes|
    requires forall i: int {:trigger eltTypes[i]} {:trigger contents[i]} :: 0 <= i < |contents| ==> ValInGrammar(contents[i], eltTypes[i])
    requires forall g: G {:trigger ValidGrammar(g)} {:trigger g in eltTypes} :: g in eltTypes ==> ValidGrammar(g)
    requires |eltTypes| < 18446744073709551616
    requires forall i: int {:trigger contents[i]} :: 0 <= i < |contents| ==> ValidVal(contents[i])
    requires index as int + SeqSum(contents) <= data.Length
    requires 0 <= index as int + SeqSum(contents) < 18446744073709551616
    requires data.Length < 18446744073709551616
    requires |contents| < 18446744073709551616
    modifies data
    ensures parse_Tuple_contents(data[index .. index as int + SeqSum(contents)], eltTypes).0.Some?
    ensures parse_Tuple_contents(data[index .. index as int + SeqSum(contents)], eltTypes).0.v == contents
    ensures forall i: uint64 {:trigger old(data[i])} {:trigger data[i]} :: 0 <= i < index ==> data[i] == old(data[i])
    ensures forall i: int {:trigger old(data[i])} {:trigger data[i]} :: index as int + SeqSum(contents) <= i < data.Length ==> data[i] == old(data[i])
    ensures size as int == SeqSum(contents)
    decreases eltTypes, 1, |contents|
  {
    var i: int := 0;
    var cur_index := index;
    reveal SeqSum();
    reveal parse_Tuple_contents();
    ghost var trace := [];
    ghost var marshalled_bytes := [];
    while i < |contents|
      invariant 0 <= i <= |contents|
      invariant 0 <= index as int <= index as int + SeqSum(contents[..i]) <= data.Length
      invariant cur_index as int == index as int + SeqSum(contents[..i])
      invariant forall j: uint64 {:trigger old(data[j])} {:trigger data[j]} :: 0 <= j < index ==> data[j] == old(data[j])
      invariant forall j: int {:trigger old(data[j])} {:trigger data[j]} :: index as int + SeqSum(contents) <= j < data.Length ==> data[j] == old(data[j])
      invariant marshalled_bytes == data[index .. cur_index]
      invariant marshalled_bytes == SeqCatRev(trace)
      invariant |trace| == i
      invariant forall j: int {:trigger trace[j]} {:trigger contents[j]} :: (0 <= j < |trace| ==> SizeOfV(contents[j]) == |trace[j]|) && (0 <= j < |trace| ==> |trace[j]| < 18446744073709551616)
      invariant forall j: int {:trigger contents[j]} {:trigger eltTypes[j]} {:trigger trace[j]} :: 0 <= j < |trace| ==> var (val: Option<V>, rest: seq<byte>) := parse_Val(trace[j], eltTypes[j]); val.Some? && val.v == contents[j]
      decreases |contents| - i
    {
      lemma_SeqSum_bound(contents, 18446744073709551616);
      ghost var old_marshalled_bytes := marshalled_bytes;
      ghost var old_data := data[index .. cur_index];
      assert old_marshalled_bytes == old_data;
      calc <= {
        cur_index as int + SizeOfV(contents[i]);
        index as int + SeqSum(contents[..i]) + SizeOfV(contents[i]);
        {
          lemma_SeqSum_prefix(contents[..i], contents[i]);
          assert contents[..i] + [contents[i]] == contents[..i + 1];
        }
        index as int + SeqSum(contents[..i + 1]);
        {
          lemma_SeqSum_bound_prefix(contents, contents[..i + 1], i + 1);
        }
        index as int + SeqSum(contents);
      }
      var item_size := MarshallVal(contents[i], eltTypes[i], data, cur_index);
      ghost var fresh_bytes := data[cur_index .. cur_index + item_size];
      marshalled_bytes := marshalled_bytes + fresh_bytes;
      forall
        ensures var (val: Option<V>, rest: seq<byte>) := parse_Val(fresh_bytes, eltTypes[i]); val.Some? && val.v == contents[i]
      {
        assert SizeOfV(contents[i]) <= |fresh_bytes|;
        lemma_parse_Val_view(fresh_bytes, contents[i], eltTypes[i], 0);
      }
      ghost var old_trace := trace;
      trace := trace + [fresh_bytes];
      ghost var old_cur_index := cur_index;
      cur_index := cur_index + item_size;
      i := i + 1;
      assert {:split_here} true;
      calc {
        marshalled_bytes;
        old_marshalled_bytes + fresh_bytes;
        old_data + fresh_bytes;
        data[index .. old_cur_index] + fresh_bytes;
        data[index .. old_cur_index] + data[old_cur_index .. cur_index];
        data[index .. cur_index];
      }
      calc <= {
        index as int + SeqSum(contents[..i]);
        calc {
          SeqSum(contents[..i]);
        <=
          {
            lemma_SeqSum_bound_prefix(contents, contents[..i], i);
          }
          SeqSum(contents);
        }
        index as int + SeqSum(contents);
        data.Length;
      }
      calc {
        cur_index as int;
        old_cur_index as int + SizeOfV(contents[i - 1]);
        index as int + SeqSum(contents[..i - 1]) + SizeOfV(contents[i - 1]);
        {
          lemma_SeqSum_prefix(contents[..i - 1], contents[i - 1]);
          assert contents[..i - 1] + [contents[i - 1]] == contents[..i];
        }
        index as int + SeqSum(contents[..i]);
      }
      assert cur_index as int == index as int + SeqSum(contents[..i]);
    }
    assert contents[..i] == contents;
    assert cur_index as int == index as int + SeqSum(contents);
    assert marshalled_bytes == data[index .. index as int + SeqSum(contents)];
    lemma_marshall_tuple_contents(contents, eltTypes, marshalled_bytes, trace);
    size := cur_index - index;
  }

  method MarshallTuple(val: V, grammar: G, data: array<byte>, index: uint64)
      returns (size: uint64)
    requires val.VTuple?
    requires ValidVal(val)
    requires ValidGrammar(grammar)
    requires ValInGrammar(val, grammar)
    requires index as int + SizeOfV(val) <= data.Length
    requires 0 <= index as int + SizeOfV(val) < 18446744073709551616
    requires data.Length < 18446744073709551616
    modifies data
    ensures parse_Val(data[index .. index as int + SizeOfV(val)], grammar).0.Some? && parse_Val(data[index .. index as int + SizeOfV(val)], grammar).0.v == val
    ensures forall i: uint64 {:trigger old(data[i])} {:trigger data[i]} :: 0 <= i < index ==> data[i] == old(data[i])
    ensures forall i: int {:trigger old(data[i])} {:trigger data[i]} :: index as int + SizeOfV(val) <= i < data.Length ==> data[i] == old(data[i])
    ensures size as int == SizeOfV(val)
    decreases grammar, -1
  {
    size := MarshallTupleContents(val.t, grammar.t, data, index);
    calc {
      parse_Val(data[index .. index as int + SizeOfV(val)], grammar);
      {
        reveal parse_Val();
      }
      parse_Tuple(data[index .. index as int + SizeOfV(val)], grammar.t);
    }
  }

  method MarshallBytes(bytes: seq<byte>, data: array<byte>, index: uint64)
    requires index as int + |bytes| <= data.Length
    requires 0 <= index as int + |bytes| < 18446744073709551616
    requires data.Length < 18446744073709551616
    modifies data
    ensures forall i: uint64 {:trigger old(data[i])} {:trigger data[i]} :: 0 <= i < index ==> data[i] == old(data[i])
    ensures forall i: int {:trigger data[i]} :: index as int <= i < index as int + |bytes| ==> data[i] == bytes[i - index as int]
    ensures forall i: int {:trigger old(data[i])} {:trigger data[i]} :: index as int + |bytes| <= i < data.Length ==> data[i] == old(data[i])
    decreases bytes, data, index
  {
    Arrays.CopySeqIntoArray(bytes, 0, data, index, |bytes| as uint64);
  }

  method MarshallByteArray(val: V, grammar: G, data: array<byte>, index: uint64)
      returns (size: uint64)
    requires val.VByteArray?
    requires ValidGrammar(grammar)
    requires ValInGrammar(val, grammar)
    requires ValidVal(val)
    requires index as int + SizeOfV(val) <= data.Length
    requires 0 <= index as int + SizeOfV(val) < 18446744073709551616
    requires data.Length < 18446744073709551616
    modifies data
    ensures parse_Val(data[index .. index as int + SizeOfV(val)], grammar).0.Some? && parse_Val(data[index .. index as int + SizeOfV(val)], grammar).0.v == val
    ensures forall i: uint64 {:trigger old(data[i])} {:trigger data[i]} :: 0 <= i < index ==> data[i] == old(data[i])
    ensures forall i: int {:trigger old(data[i])} {:trigger data[i]} :: index as int + SizeOfV(val) <= i < data.Length ==> data[i] == old(data[i])
    ensures size as int == SizeOfV(val)
    decreases grammar
  {
    MarshallUint64(|val.b| as uint64, data, index);
    assert SeqByteToUint64(data[index .. index + Uint64Size()]) == |val.b| as uint64;
    MarshallBytes(val.b, data, index + 8);
    calc {
      parse_Val(data[index .. index as int + SizeOfV(val)], grammar);
      {
        reveal parse_Val();
      }
      parse_ByteArray(data[index .. index as int + SizeOfV(val)]);
    }
    ghost var data_seq := data[index .. index as int + SizeOfV(val)];
    ghost var tuple := parse_Uint64(data_seq);
    ghost var len := tuple.0;
    ghost var rest := tuple.1;
    assert {:split_here} true;
    assert rest == data[index + 8 .. index as int + SizeOfV(val)] == val.b;
    assert !len.None? && len.v.u as int <= |rest|;
    assert rest[0 .. len.v.u] == val.b;
    size := 8 + |val.b| as uint64;
  }

  method MarshallCase(val: V, grammar: G, data: array<byte>, index: uint64)
      returns (size: uint64)
    requires val.VCase?
    requires ValidGrammar(grammar)
    requires ValInGrammar(val, grammar)
    requires ValidVal(val)
    requires index as int + SizeOfV(val) <= data.Length
    requires 0 <= index as int + SizeOfV(val) < 18446744073709551616
    requires data.Length < 18446744073709551616
    modifies data
    ensures parse_Val(data[index .. index as int + SizeOfV(val)], grammar).0.Some? && parse_Val(data[index .. index as int + SizeOfV(val)], grammar).0.v == val
    ensures forall i: uint64 {:trigger old(data[i])} {:trigger data[i]} :: 0 <= i < index ==> data[i] == old(data[i])
    ensures forall i: int {:trigger old(data[i])} {:trigger data[i]} :: index as int + SizeOfV(val) <= i < data.Length ==> data[i] == old(data[i])
    ensures size as int == SizeOfV(val)
    decreases grammar, -1
  {
    MarshallUint64(val.c, data, index);
    ghost var int_bytes := data[index .. index + Uint64Size()];
    ghost var tuple0 := parse_Uint64(int_bytes);
    ghost var caseID0 := tuple0.0;
    ghost var rest10 := tuple0.1;
    assert !caseID0.None?;
    assert caseID0.v.u == val.c;
    var val_size := MarshallVal(val.val, grammar.cases[val.c], data, index + 8);
    ghost var new_int_bytes := data[index .. index + Uint64Size()];
    assert forall i: uint64 {:auto_trigger} {:trigger new_int_bytes[i]} {:trigger int_bytes[i]} :: 0 <= i < Uint64Size() ==> int_bytes[i] == new_int_bytes[i];
    assert int_bytes == new_int_bytes;
    assert val.VCase?;
    assert grammar.GTaggedUnion?;
    assert val.c as int < |grammar.cases|;
    ghost var bytes := data[index .. index as int + SizeOfV(val)];
    assert bytes[..8] == new_int_bytes;
    calc {
      parse_Val(bytes, grammar);
      {
        reveal parse_Val();
      }
      parse_Case(bytes, grammar.cases);
    }
    assert {:split_here} true;
    ghost var tuple1 := parse_Uint64(bytes);
    ghost var caseID := tuple1.0;
    ghost var rest1 := tuple1.1;
    assert !caseID.None?;
    assert caseID.v.u == val.c;
    assert caseID.v.u as int < |grammar.cases|;
    ghost var tuple2 := parse_Val(rest1, grammar.cases[caseID.v.u]);
    ghost var v := tuple2.0;
    ghost var rest2 := tuple2.1;
    assert !v.None?;
    size := 8 + val_size;
  }

  method MarshallVUint64(val: V, grammar: G, data: array<byte>, index: uint64)
      returns (size: uint64)
    requires val.VUint64?
    requires ValidGrammar(grammar)
    requires ValInGrammar(val, grammar)
    requires index as int + SizeOfV(val) <= data.Length
    requires 0 <= index as int + SizeOfV(val) < 18446744073709551616
    requires data.Length < 18446744073709551616
    modifies data
    ensures parse_Val(data[index .. index as int + SizeOfV(val)], grammar).0.Some? && parse_Val(data[index .. index as int + SizeOfV(val)], grammar).0.v == val
    ensures forall i: uint64 {:trigger old(data[i])} {:trigger data[i]} :: 0 <= i < index ==> data[i] == old(data[i])
    ensures forall i: int {:trigger old(data[i])} {:trigger data[i]} :: index as int + SizeOfV(val) <= i < data.Length ==> data[i] == old(data[i])
    ensures size as int == SizeOfV(val)
    decreases grammar
  {
    MarshallUint64(val.u, data, index);
    calc {
      parse_Val(data[index .. index as int + SizeOfV(val)], grammar);
      {
        reveal parse_Val();
      }
      parse_Uint64(data[index .. index as int + SizeOfV(val)]);
    }
    return 8;
  }

  method MarshallVal(val: V, grammar: G, data: array<byte>, index: uint64)
      returns (size: uint64)
    requires ValidGrammar(grammar)
    requires ValInGrammar(val, grammar)
    requires ValidVal(val)
    requires 0 <= SizeOfV(val) < 18446744073709551616
    requires index as int + SizeOfV(val) <= data.Length
    requires data.Length < 18446744073709551616
    modifies data
    ensures parse_Val(data[index .. index as int + SizeOfV(val)], grammar).0.Some? && parse_Val(data[index .. index as int + SizeOfV(val)], grammar).0.v == val
    ensures forall i: uint64 {:trigger old(data[i])} {:trigger data[i]} :: 0 <= i < index ==> data[i] == old(data[i])
    ensures forall i: int {:trigger old(data[i])} {:trigger data[i]} :: index as int + SizeOfV(val) <= i < data.Length ==> data[i] == old(data[i])
    ensures size as int == SizeOfV(val)
    decreases grammar, 0
  {
    match val
    case {:split false} VUint64(_) =>
      size := MarshallVUint64(val, grammar, data, index);
    case {:split false} VArray(_) =>
      size := MarshallArray(val, grammar, data, index);
    case {:split false} VTuple(_) =>
      size := MarshallTuple(val, grammar, data, index);
    case {:split false} VByteArray(_) =>
      size := MarshallByteArray(val, grammar, data, index);
    case {:split false} VCase(_, _) =>
      size := MarshallCase(val, grammar, data, index);
  }

  method Marshall(val: V, grammar: G) returns (data: array<byte>)
    requires ValidGrammar(grammar)
    requires ValInGrammar(val, grammar)
    requires ValidVal(val)
    requires 0 <= SizeOfV(val) < 18446744073709551616
    ensures fresh(data)
    ensures Demarshallable(data[..], grammar)
    ensures parse_Val(data[..], grammar).0.Some? && parse_Val(data[..], grammar).0.v == val
    ensures parse_Val(data[..], grammar).1 == []
    ensures |data[..]| == SizeOfV(val)
    decreases val, grammar
  {
    var size := ComputeSizeOf(val);
    data := new byte[size];
    var computed_size := MarshallVal(val, grammar, data, 0);
    assert data[0 .. 0 + SizeOfV(val)] == data[0 .. 0 + size] == data[..];
    lemma_parse_Val_view_specific(data[..], val, grammar, 0, size as int);
  }
}

module Common__MarshallInt_i {

  import opened Native__NativeTypes_s

  import opened Native__NativeTypes_i

  import opened Common__Util_i

  import opened Math__power2_i
  method MarshallUint64_guts(n: uint64, data: array<byte>, index: uint64)
    requires index as int + Uint64Size() as int <= data.Length
    requires 0 <= index as int + Uint64Size() as int < 18446744073709551616
    requires data.Length < 18446744073709551616
    modifies data
    ensures SeqByteToUint64(data[index .. index + Uint64Size() as uint64]) == n
    ensures data[0 .. index] == old(data[0 .. index])
    ensures data[index + Uint64Size() as uint64..] == old(data[index + Uint64Size() as uint64..])
    decreases n, data, index
  {
    data[index] := (n / 72057594037927936) as byte;
    data[index + 1] := (n / 281474976710656 % 256) as byte;
    data[index + 2] := (n / 1099511627776 % 256) as byte;
    data[index + 3] := (n / 4294967296 % 256) as byte;
    data[index + 4] := (n / 16777216 % 256) as byte;
    data[index + 5] := (n / 65536 % 256) as byte;
    data[index + 6] := (n / 256 % 256) as byte;
    data[index + 7] := (n % 256) as byte;
    lemma_2toX();
    assert data[index .. index + Uint64Size() as uint64] == Uint64ToSeqByte(n);
    lemma_BEUintToSeqByte_invertability(data[index .. index + Uint64Size() as uint64], n as int, 8);
  }
}

module LiveByzRSL__CTypes_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened Native__NativeTypes_i

  import opened LiveByzRSL__AppInterface_i

  import opened LiveByzRSL__Types_i

  import opened Common__NodeIdentity_i

  import opened Common__UdpClient_i

  import opened Common__Util_i

  import opened Collections__Maps_i

  import opened Collections__Sets_i

  import opened GenericRefinement_i

  import opened Concrete_NodeIdentity_i

  import opened Common__SeqIsUniqueDef_i
  type COperationNumber = int

  datatype CBallot = CBallot(seqno: int, proposer_id: int)

  datatype CRequest = CRequest(client: EndPoint, seqno: int, request: CAppMessage)

  type CRequestBatch = seq<CRequest>

  datatype CReply = CReply(client: EndPoint, seqno: int, reply: CAppMessage)

  type CReplyCache = map<EndPoint, CReply>

  datatype CVote = CVote(max_value_bal: CBallot, max_val: CRequestBatch)

  type CVotes = map<COperationNumber, CVote>

  predicate COperationNumberIsAbstractable(s: COperationNumber)
    decreases s
  {
    true
  }

  predicate COperationNumberIsValid(s: COperationNumber)
    decreases s
  {
    COperationNumberIsAbstractable(s)
  }

  function AbstractifyCOperationNumberToOperationNumber(s: COperationNumber): OperationNumber
    requires COperationNumberIsAbstractable(s)
    decreases s
  {
    s
  }

  predicate CBallotIsValid(s: CBallot)
    decreases s
  {
    CBallotIsAbstractable(s)
  }

  predicate CBallotIsAbstractable(s: CBallot)
    decreases s
  {
    true
  }

  function AbstractifyCBallotToBallot(s: CBallot): Ballot
    requires CBallotIsAbstractable(s)
    decreases s
  {
    Ballot(s.seqno, s.proposer_id)
  }

  predicate CRequestIsValid(s: CRequest)
    decreases s
  {
    CRequestIsAbstractable(s) &&
    EndPointIsValid(s.client) &&
    CAppMessageIsValid(s.request)
  }

  predicate CRequestIsAbstractable(s: CRequest)
    decreases s
  {
    EndPointIsAbstractable(s.client) &&
    CAppMessageIsAbstractable(s.request)
  }

  function AbstractifyCRequestToRequest(s: CRequest): Request
    requires CRequestIsAbstractable(s)
    decreases s
  {
    Request(AbstractifyEndPointToNodeIdentity(s.client), s.seqno, AbstractifyCAppMessageToAppMessage(s.request))
  }

  predicate CRequestBatchIsAbstractable(s: CRequestBatch)
    decreases s
  {
    forall i: CRequest {:trigger CRequestIsAbstractable(i)} {:trigger i.CRequest?} {:trigger i in s} :: 
      (i in s ==>
        i.CRequest?) &&
      (i in s ==>
        CRequestIsAbstractable(i))
  }

  predicate CRequestBatchIsValid(s: CRequestBatch)
    decreases s
  {
    CRequestBatchIsAbstractable(s) &&
    forall i: CRequest {:trigger CRequestIsValid(i)} {:trigger i.CRequest?} {:trigger i in s} :: 
      (i in s ==>
        i.CRequest?) &&
      (i in s ==>
        CRequestIsValid(i))
  }

  function AbstractifyCRequestBatchToRequestBatch(s: CRequestBatch): RequestBatch
    requires CRequestBatchIsAbstractable(s)
    decreases s
  {
    AbstractifySeq(s, AbstractifyCRequestToRequest)
  }

  predicate CReplyIsValid(s: CReply)
    decreases s
  {
    CReplyIsAbstractable(s) &&
    EndPointIsValid(s.client) &&
    CAppMessageIsValid(s.reply)
  }

  predicate CReplyIsAbstractable(s: CReply)
    decreases s
  {
    EndPointIsAbstractable(s.client) &&
    CAppMessageIsAbstractable(s.reply)
  }

  function AbstractifyCReplyToReply(s: CReply): Reply
    requires CReplyIsAbstractable(s)
    decreases s
  {
    Reply(AbstractifyEndPointToNodeIdentity(s.client), s.seqno, AbstractifyCAppMessageToAppMessage(s.reply))
  }

  predicate CReplyCacheIsAbstractable(s: CReplyCache)
    decreases s
  {
    forall i: EndPoint {:trigger s[i]} {:trigger EndPointIsAbstractable(i)} {:trigger i in s} :: 
      (i in s ==>
        EndPointIsAbstractable(i)) &&
      (i in s ==>
        CReplyIsAbstractable(s[i]))
  }

  predicate CReplyCacheIsValid(s: CReplyCache)
    decreases s
  {
    CReplyCacheIsAbstractable(s) &&
    forall i: EndPoint {:trigger s[i]} {:trigger EndPointIsValid(i)} {:trigger i in s} :: 
      (i in s ==>
        EndPointIsValid(i)) &&
      (i in s ==>
        CReplyIsValid(s[i]))
  }

  function AbstractifyCReplyCacheToReplyCache(s: CReplyCache): ReplyCache
    requires CReplyCacheIsAbstractable(s)
    decreases s
  {
    AbstractifyMap(s, AbstractifyEndPointToNodeIdentity, AbstractifyCReplyToReply, AbstractifyNodeIdentityToEndPoint)
  }

  predicate CVoteIsValid(s: CVote)
    decreases s
  {
    CVoteIsAbstractable(s) &&
    CBallotIsValid(s.max_value_bal) &&
    CRequestBatchIsValid(s.max_val)
  }

  predicate CVoteIsAbstractable(s: CVote)
    decreases s
  {
    CBallotIsAbstractable(s.max_value_bal) &&
    CRequestBatchIsAbstractable(s.max_val)
  }

  function AbstractifyCVoteToVote(s: CVote): Vote
    requires CVoteIsAbstractable(s)
    decreases s
  {
    Vote(AbstractifyCBallotToBallot(s.max_value_bal), AbstractifyCRequestBatchToRequestBatch(s.max_val))
  }

  predicate CVotesIsAbstractable(s: CVotes)
    decreases s
  {
    forall i: int {:trigger s[i]} {:trigger COperationNumberIsAbstractable(i)} {:trigger i in s} :: 
      (i in s ==>
        COperationNumberIsAbstractable(i)) &&
      (i in s ==>
        CVoteIsAbstractable(s[i]))
  }

  predicate CVotesIsValid(s: CVotes)
    decreases s
  {
    CVotesIsAbstractable(s) &&
    forall i: int {:trigger s[i]} {:trigger COperationNumberIsValid(i)} {:trigger i in s} :: 
      (i in s ==>
        COperationNumberIsValid(i)) &&
      (i in s ==>
        CVoteIsValid(s[i]))
  }

  function AbstractifyCVotesToVotes(s: CVotes): Votes
    requires CVotesIsAbstractable(s)
    decreases s
  {
    AbstractifyMap(s, AbstractifyOperationNumberToCOperationNumber, AbstractifyCVoteToVote, AbstractifyCOperationNumberToOperationNumber)
  }

  function method CBalLt(ba: CBallot, bb: CBallot): bool
    requires CBallotIsValid(ba)
    requires CBallotIsValid(bb)
    ensures var lr: bool := BalLt(AbstractifyCBallotToBallot(ba), AbstractifyCBallotToBallot(bb)); var cr: bool := CBalLt(ba, bb); cr == lr
    decreases ba, bb
  {
    ba.seqno < bb.seqno || (ba.seqno == bb.seqno && ba.proposer_id < bb.proposer_id)
  }

  function method CBalLeq(ba: CBallot, bb: CBallot): bool
    requires CBallotIsValid(ba)
    requires CBallotIsValid(bb)
    ensures var lr: bool := BalLeq(AbstractifyCBallotToBallot(ba), AbstractifyCBallotToBallot(bb)); var cr: bool := CBalLeq(ba, bb); cr == lr
    decreases ba, bb
  {
    ba.seqno < bb.seqno || (ba.seqno == bb.seqno && ba.proposer_id <= bb.proposer_id)
  }

  function AbstractifyOperationNumberToCOperationNumber(o: OperationNumber): COperationNumber
    ensures AbstractifyOperationNumberToCOperationNumber(o) == o
    decreases o
  {
    o
  }

  function method RequestBatchSizeLimit(): int
  {
    1000
  }

  function method max_reply_cache_size(): int
  {
    256
  }

  function method max_votes_len(): int
  {
    1000
  }
}

module LiveByzRSL__AppInterface_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened Collections__Maps_i

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__Types_i

  import opened Common__GenericMarshalling_i

  import opened Common__NodeIdentity_i

  import opened AppStateMachine_i

  import opened Math__mul_nonlinear_i

  import opened Math__mul_i
  type CAppState = uint64

  datatype CAppMessage = CAppIncrement | CAppReply(response: uint64) | CAppInvalid

  predicate CAppStateIsValid(appstate: CAppState)
    decreases appstate
  {
    true
  }

  predicate CAppStateIsAbstractable(appstate: CAppState)
    decreases appstate
  {
    true
  }

  function AbstractifyCAppStateToAppState(appstate: CAppState): AppState
    requires CAppStateIsAbstractable(appstate)
    decreases appstate
  {
    appstate
  }

  function {:opaque} {:fuel 0, 0} AbstractifyCAppStateSeqToAppStateSeq(s: seq<CAppState>): seq<AppState>
    requires forall i: uint64 {:trigger CAppStateIsAbstractable(i)} {:trigger i in s} :: i in s ==> CAppStateIsAbstractable(i)
    ensures |AbstractifyCAppStateSeqToAppStateSeq(s)| == |s|
    ensures forall i: int {:trigger s[i]} {:trigger AbstractifyCAppStateSeqToAppStateSeq(s)[i]} :: 0 <= i < |AbstractifyCAppStateSeqToAppStateSeq(s)| ==> AbstractifyCAppStateSeqToAppStateSeq(s)[i] == AbstractifyCAppStateToAppState(s[i])
    decreases s
  {
    if |s| == 0 then
      []
    else
      [AbstractifyCAppStateToAppState(s[0])] + AbstractifyCAppStateSeqToAppStateSeq(s[1..])
  }

  function method CAppState_grammar(): G
  {
    GUint64
  }

  function method parse_AppState(val: V): CAppState
    requires ValInGrammar(val, CAppState_grammar())
    ensures CAppStateIsAbstractable(parse_AppState(val))
    decreases val
  {
    val.u as CAppState
  }

  function method AppStateMarshallable(msg: CAppState): bool
    decreases msg
  {
    true
  }

  method MarshallAppState(c: CAppState) returns (val: V)
    requires AppStateMarshallable(c)
    ensures ValInGrammar(val, CAppState_grammar())
    ensures ValidVal(val)
    ensures parse_AppState(val) == c
    decreases c
  {
    val := VUint64(c);
  }

  function max_app_state_size(): int
  {
    32768
  }

  lemma /*{:_induction val}*/ lemma_AppStateBound(c: CAppState, val: V)
    requires ValInGrammar(val, CAppState_grammar())
    requires ValidVal(val)
    requires parse_AppState(val) == c
    ensures SizeOfV(val) < max_app_state_size()
    decreases c, val
  {
  }

  predicate method CAppMessageIsValid(c: CAppMessage)
    decreases c
  {
    CAppMessageIsAbstractable(c)
  }

  predicate method CAppMessageIsAbstractable(c: CAppMessage)
    decreases c
  {
    true
  }

  function AbstractifyCAppMessageToAppMessage(c: CAppMessage): AppMessage
    requires CAppMessageIsAbstractable(c)
    decreases c
  {
    match c {
      case CAppIncrement() =>
        AppIncrementRequest()
      case CAppReply(response) =>
        AppIncrementReply(response)
      case CAppInvalid() =>
        AppInvalidReply()
    }
  }

  function method CAppMessage_grammar(): G
  {
    GTaggedUnion([GTuple([]), GUint64, GTuple([])])
  }

  function method parse_AppMessage(val: V): CAppMessage
    requires ValInGrammar(val, CAppMessage_grammar())
    decreases val
  {
    if val.c == 0 then
      CAppIncrement()
    else if val.c == 1 then
      assert ValInGrammar(val.val, CAppMessage_grammar().cases[1]);
      CAppReply(val.val.u)
    else
      assert val.c == 2; CAppInvalid()
  }

  method MarshallCAppMessage(c: CAppMessage) returns (val: V)
    requires CAppMessageIsAbstractable(c)
    requires CAppMessageIsValid(c)
    ensures ValInGrammar(val, CAppMessage_grammar())
    ensures ValidVal(val)
    ensures parse_AppMessage(val) == c
    decreases c
  {
    match c {
      case {:split false} CAppIncrement() =>
        val := VCase(0, VTuple([]));
      case {:split false} CAppReply(response) =>
        val := VCase(1, VUint64(response));
      case {:split false} CAppInvalid() =>
        val := VCase(2, VTuple([]));
    }
    assert parse_AppMessage(val) == c;
  }

  function method max_val_len(): int
  {
    64
  }

  lemma /*{:_induction val}*/ lemma_AppMessageBound(c: CAppMessage, val: V)
    requires ValInGrammar(val, CAppMessage_grammar())
    requires CAppMessageIsValid(c)
    requires parse_AppMessage(val) == c
    ensures ValidVal(val)
    ensures SizeOfV(val) < max_val_len()
    decreases c, val
  {
  }

  function method CAppStateInit(): CAppState
    ensures var s: CAppState := CAppStateInit(); CAppStateIsAbstractable(s) && AbstractifyCAppStateToAppState(s) == AppInitialize() && AppStateMarshallable(s)
  {
    0 as uint64
  }

  function method CappedIncrImpl(v: uint64): uint64
    requires 0 <= v <= 18446744073709551615
    ensures var v': uint64 := CappedIncrImpl(v); v' == CappedIncr(v)
    decreases v
  {
    if v == 18446744073709551615 then
      v
    else
      v + 1
  }

  function method HandleAppRequest(appState: CAppState, request: CAppMessage): (CAppState, CAppMessage)
    requires CAppStateIsAbstractable(appState)
    requires CAppMessageIsAbstractable(request)
    ensures var (appState': CAppState, reply: CAppMessage) := HandleAppRequest(appState, request); CAppStateIsAbstractable(appState') && CAppMessageIsAbstractable(reply) && AppStateMarshallable(appState') && AppHandleRequest(AbstractifyCAppStateToAppState(appState), AbstractifyCAppMessageToAppMessage(request)) == (AbstractifyCAppStateToAppState(appState'), AbstractifyCAppMessageToAppMessage(reply))
    decreases appState, request
  {
    if request.CAppIncrement? then
      (CappedIncrImpl(appState), CAppReply(CappedIncrImpl(appState)))
    else
      (appState, CAppInvalid())
  }
}

module LiveByzRSL__CMessage_i {

  import opened LiveByzRSL__CTypes_i

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened LiveByzRSL__AppInterface_i

  import opened Logic__Option_i

  import opened LiveByzRSL__Message_i

  import opened GenericRefinement_i

  import opened LiveByzRSL__Environment_i

  import opened Common__NodeIdentity_i

  import opened Common__UdpClient_i

  import opened Environment_s

  import opened Concrete_NodeIdentity_i
  datatype CMessage = CMessage_Invalid | CMessage_Request(seqno_req: int, val: CAppMessage) | CMessage_1a(bal_1a: CBallot) | CMessage_1b(bal_1b: CBallot, log_truncation_point: COperationNumber, votes: CVotes) | CMessage_1c(bal_1c: CBallot, opn_1c: COperationNumber, val_1c: CRequestBatch) | CMessage_2av(bal_2av: CBallot, opn_2av: COperationNumber, val_2av: CRequestBatch) | CMessage_2b(bal_2b: CBallot, opn_2b: COperationNumber, val_2b: CRequestBatch) | CMessage_Heartbeat(bal_heartbeat: CBallot, suspicious: bool, opn_ckpt: COperationNumber) | CMessage_Reply(seqno_reply: int, reply: CAppMessage) | CMessage_StartingPhase2(bal_2: CBallot, logTruncationPoint_2: COperationNumber)

  datatype CPacket = CPacket(dst: EndPoint, src: EndPoint, msg: CMessage)

  datatype CBroadcast = CBroadcast(src: EndPoint, dsts: seq<EndPoint>, msg: CMessage) | CBroadcastNop

  datatype OutboundPackets = Broadcast(broadcast: CBroadcast) | OutboundPacket(p: Option<CPacket>) | PacketSequence(s: seq<CPacket>)

  predicate CMessageIsValid(s: CMessage)
    decreases s
  {
    match s
    case CMessage_Invalid() =>
      CMessageIsAbstractable(s)
    case CMessage_Request(seqno_req, val) =>
      CMessageIsAbstractable(s) &&
      CAppMessageIsValid(s.val)
    case CMessage_1a(bal_1a) =>
      CMessageIsAbstractable(s) &&
      CBallotIsValid(s.bal_1a)
    case CMessage_1b(bal_1b, log_truncation_point, votes) =>
      CMessageIsAbstractable(s) &&
      CBallotIsValid(s.bal_1b) &&
      COperationNumberIsValid(s.log_truncation_point) &&
      CVotesIsValid(s.votes)
    case CMessage_1c(bal_1c, opn_1c, val_1c) =>
      CMessageIsAbstractable(s) &&
      CBallotIsValid(s.bal_1c) &&
      COperationNumberIsValid(s.opn_1c) &&
      CRequestBatchIsValid(s.val_1c)
    case CMessage_2av(bal_2av, opn_2av, val_2av) =>
      CMessageIsAbstractable(s) &&
      CBallotIsValid(bal_2av) &&
      COperationNumberIsValid(opn_2av) &&
      CRequestBatchIsValid(val_2av)
    case CMessage_2b(bal_2b, opn_2b, val_2b) =>
      CMessageIsAbstractable(s) &&
      CBallotIsValid(s.bal_2b) &&
      COperationNumberIsValid(s.opn_2b) &&
      CRequestBatchIsValid(s.val_2b)
    case CMessage_Heartbeat(bal_heartbeat, suspicious, opn_ckpt) =>
      CMessageIsAbstractable(s) &&
      CBallotIsValid(s.bal_heartbeat) &&
      COperationNumberIsValid(s.opn_ckpt)
    case CMessage_Reply(seqno_reply, reply) =>
      CMessageIsAbstractable(s) &&
      CAppMessageIsValid(s.reply)
    case CMessage_StartingPhase2(bal_2, logTruncationPoint_2) =>
      CMessageIsAbstractable(s) &&
      CBallotIsValid(s.bal_2) &&
      COperationNumberIsValid(s.logTruncationPoint_2)
  }

  predicate CMessageIsAbstractable(s: CMessage)
    decreases s
  {
    match s
    case CMessage_Invalid() =>
      true
    case CMessage_Request(seqno_req, val) =>
      CAppMessageIsAbstractable(s.val)
    case CMessage_1a(bal_1a) =>
      CBallotIsAbstractable(s.bal_1a)
    case CMessage_1b(bal_1b, log_truncation_point, votes) =>
      CBallotIsAbstractable(s.bal_1b) &&
      COperationNumberIsAbstractable(s.log_truncation_point) &&
      CVotesIsAbstractable(s.votes)
    case CMessage_1c(bal_1c, opn_1c, val_1c) =>
      CBallotIsAbstractable(s.bal_1c) &&
      COperationNumberIsAbstractable(s.opn_1c) &&
      CRequestBatchIsAbstractable(s.val_1c)
    case CMessage_2av(bal_2av, opn_2av, val_2av) =>
      CBallotIsAbstractable(s.bal_2av) &&
      COperationNumberIsAbstractable(s.opn_2av) &&
      CRequestBatchIsAbstractable(s.val_2av)
    case CMessage_2b(bal_2b, opn_2b, val_2b) =>
      CBallotIsAbstractable(s.bal_2b) &&
      COperationNumberIsAbstractable(s.opn_2b) &&
      CRequestBatchIsAbstractable(s.val_2b)
    case CMessage_Heartbeat(bal_heartbeat, suspicious, opn_ckpt) =>
      CBallotIsAbstractable(s.bal_heartbeat) &&
      COperationNumberIsAbstractable(s.opn_ckpt)
    case CMessage_Reply(seqno_reply, reply) =>
      CAppMessageIsAbstractable(s.reply)
    case CMessage_StartingPhase2(bal_2, logTruncationPoint_2) =>
      CBallotIsAbstractable(s.bal_2) &&
      COperationNumberIsAbstractable(s.logTruncationPoint_2)
  }

  function AbstractifyCMessageToRslMessage(s: CMessage): RslMessage
    requires CMessageIsAbstractable(s)
    decreases s
  {
    match s
    case CMessage_Invalid() =>
      RslMessage_Invalid()
    case CMessage_Request(seqno_req, val) =>
      RslMessage_Request(s.seqno_req, AbstractifyCAppMessageToAppMessage(s.val))
    case CMessage_1a(bal_1a) =>
      RslMessage_1a(AbstractifyCBallotToBallot(s.bal_1a))
    case CMessage_1b(bal_1b, log_truncation_point, votes) =>
      RslMessage_1b(AbstractifyCBallotToBallot(s.bal_1b), AbstractifyCOperationNumberToOperationNumber(s.log_truncation_point), AbstractifyCVotesToVotes(s.votes))
    case CMessage_1c(bal_1c, opn_1c, val_1c) =>
      RslMessage_1c(AbstractifyCBallotToBallot(s.bal_1c), AbstractifyCOperationNumberToOperationNumber(s.opn_1c), AbstractifyCRequestBatchToRequestBatch(s.val_1c))
    case CMessage_2av(bal_2av, opn_2av, val_2av) =>
      RslMessage_2av(AbstractifyCBallotToBallot(s.bal_2av), AbstractifyCOperationNumberToOperationNumber(s.opn_2av), AbstractifyCRequestBatchToRequestBatch(s.val_2av))
    case CMessage_2b(bal_2b, opn_2b, val_2b) =>
      RslMessage_2b(AbstractifyCBallotToBallot(s.bal_2b), AbstractifyCOperationNumberToOperationNumber(s.opn_2b), AbstractifyCRequestBatchToRequestBatch(s.val_2b))
    case CMessage_Heartbeat(bal_heartbeat, suspicious, opn_ckpt) =>
      RslMessage_Heartbeat(AbstractifyCBallotToBallot(s.bal_heartbeat), s.suspicious, AbstractifyCOperationNumberToOperationNumber(s.opn_ckpt))
    case CMessage_Reply(seqno_reply, reply) =>
      RslMessage_Reply(s.seqno_reply, AbstractifyCAppMessageToAppMessage(s.reply))
    case CMessage_StartingPhase2(bal_2, logTruncationPoint_2) =>
      RslMessage_StartingPhase2(AbstractifyCBallotToBallot(s.bal_2), AbstractifyCOperationNumberToOperationNumber(s.logTruncationPoint_2))
  }

  predicate CPacketIsValid(cp: CPacket)
    decreases cp
  {
    CPacketIsAbstractable(cp) &&
    CMessageIsValid(cp.msg) &&
    EndPointIsValid(cp.src) &&
    EndPointIsValid(cp.dst)
  }

  predicate CPacketIsAbstractable(cp: CPacket)
    decreases cp
  {
    CMessageIsAbstractable(cp.msg) &&
    EndPointIsAbstractable(cp.src) &&
    EndPointIsAbstractable(cp.dst)
  }

  function AbstractifyCPacketToRslPacket(cp: CPacket): RslPacket
    requires CPacketIsAbstractable(cp)
    decreases cp
  {
    LPacket(AbstractifyEndPointToNodeIdentity(cp.dst), AbstractifyEndPointToNodeIdentity(cp.src), AbstractifyCMessageToRslMessage(cp.msg))
  }

  predicate CBroadcastIsAbstractable(broadcast: CBroadcast)
    decreases broadcast
  {
    match broadcast
    case CBroadcastNop() =>
      true
    case CBroadcast(src, dsts, msg) =>
      EndPointIsAbstractable(src) &&
      (forall i: int {:trigger broadcast.dsts[i]} :: 
        0 <= i < |broadcast.dsts| ==>
          EndPointIsAbstractable(broadcast.dsts[i])) &&
      CMessageIsAbstractable(broadcast.msg)
  }

  predicate CBroadcastValid(c: CBroadcast)
    decreases c
  {
    CBroadcastIsAbstractable(c) &&
    match c case CBroadcastNop => true case CBroadcast(src, dsts, msg) => EndPointIsValid(src) && (forall i: int {:trigger c.dsts[i]} :: 0 <= i < |c.dsts| ==> EndPointIsValid(c.dsts[i])) && CMessageIsValid(c.msg)
  }

  function {:opaque} {:fuel 0, 0} BuildLBroadcast(src: NodeIdentity, dsts: seq<NodeIdentity>, m: RslMessage): seq<RslPacket>
    ensures |BuildLBroadcast(src, dsts, m)| == |dsts|
    ensures forall i: int {:trigger dsts[i]} {:trigger BuildLBroadcast(src, dsts, m)[i]} :: 0 <= i < |dsts| ==> BuildLBroadcast(src, dsts, m)[i] == LPacket(dsts[i], src, m)
    decreases src, dsts, m
  {
    if |dsts| == 0 then
      []
    else
      [LPacket(dsts[0], src, m)] + BuildLBroadcast(src, dsts[1..], m)
  }

  function AbstractifyCBroadcastToRlsPacketSeq(broadcast: CBroadcast): seq<RslPacket>
    requires CBroadcastIsAbstractable(broadcast)
    decreases broadcast
  {
    match broadcast
    case CBroadcast(_, _, _) =>
      BuildLBroadcast(AbstractifyEndPointToNodeIdentity(broadcast.src), AbstractifyEndPointsToNodeIdentities(broadcast.dsts), AbstractifyCMessageToRslMessage(broadcast.msg))
    case CBroadcastNop() =>
      []
  }

  predicate OutboundPacketsValid(c: OutboundPackets)
    decreases c
  {
    OutboundPacketsIsAbstractable(c) &&
    match c case Broadcast(broadcast) => CBroadcastValid(broadcast) case OutboundPacket(Some(p)) => CPacketIsValid(p) case OutboundPacket(None) => true case PacketSequence(s) => forall i: int {:trigger s[i]} :: 0 <= i < |s| ==> CPacketIsValid(s[i])
  }

  predicate OutboundPacketsIsAbstractable(out: OutboundPackets)
    decreases out
  {
    match out
    case Broadcast(broadcast) =>
      CBroadcastIsAbstractable(broadcast)
    case OutboundPacket(Some(p)) =>
      CPacketIsAbstractable(p)
    case OutboundPacket(None()) =>
      true
    case PacketSequence(s) =>
      forall i: int {:trigger s[i]} :: 
        0 <= i < |s| ==>
          CPacketIsAbstractable(s[i])
  }

  function AbstractifyOutboundCPacketsToSeqOfRslPackets(out: OutboundPackets): seq<RslPacket>
    requires OutboundPacketsIsAbstractable(out)
    decreases out
  {
    match out
    case Broadcast(broadcast) =>
      AbstractifyCBroadcastToRlsPacketSeq(broadcast)
    case OutboundPacket(Some(p)) =>
      [AbstractifyCPacketToRslPacket(p)]
    case OutboundPacket(None()) =>
      []
    case PacketSequence(s) =>
      AbstractifySeq(s, AbstractifyCPacketToRslPacket)
  }

  predicate OutboundPacketsHasCorrectSrc(out: OutboundPackets, me: EndPoint)
    decreases out, me
  {
    match out
    case Broadcast(CBroadcast(src, _, _)) =>
      src == me
    case Broadcast(CBroadcastNop()) =>
      true
    case OutboundPacket(p) =>
      p.Some? ==>
        p.v.src == me
    case PacketSequence(s) =>
      forall p: CPacket {:trigger p.src} {:trigger p in s} :: 
        p in s ==>
          p.src == me
  }
}

module LiveByzRSL__CMessageRefinements_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_i

  import opened Concrete_NodeIdentity_i

  import opened LiveByzRSL__AppInterface_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__CTypes_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Broadcast_i

  import opened Common__NodeIdentity_i

  import opened Common__UdpClient_i

  import opened Environment_s

  import opened Collections__Sets_i

  import opened GenericRefinement_i
  function AbstractifyCMessageToRslPacket(sentTo: EndPoint, sentFrom: EndPoint, msg: CMessage): RslPacket
    requires CMessageIsAbstractable(msg)
    requires EndPointIsValidIPV4(sentTo)
    requires EndPointIsValidIPV4(sentFrom)
    decreases sentTo, sentFrom, msg
  {
    LPacket(AbstractifyEndPointToNodeIdentity(sentTo), AbstractifyEndPointToNodeIdentity(sentFrom), AbstractifyCMessageToRslMessage(msg))
  }

  predicate CPacketsIsValid(cps: set<CPacket>)
    decreases cps
  {
    forall cp: CPacket {:trigger CPacketIsValid(cp)} {:trigger cp in cps} :: 
      cp in cps ==>
        CPacketIsValid(cp)
  }

  predicate CPacketsIsAbstractable(cps: set<CPacket>)
    decreases cps
  {
    forall cp: CPacket {:trigger CPacketIsAbstractable(cp)} {:trigger cp in cps} :: 
      cp in cps ==>
        CPacketIsAbstractable(cp)
  }

  function AbstractifySetOfCPacketsToSetOfRslPackets_transparent(cps: set<CPacket>): set<RslPacket>
    requires CPacketsIsAbstractable(cps)
    ensures forall p: CPacket {:trigger AbstractifyCPacketToRslPacket(p)} {:trigger p in cps} :: p in cps ==> AbstractifyCPacketToRslPacket(p) in AbstractifySetOfCPacketsToSetOfRslPackets_transparent(cps)
    decreases cps
  {
    set cp: CPacket {:trigger AbstractifyCPacketToRslPacket(cp)} {:trigger cp in cps} | cp in cps :: AbstractifyCPacketToRslPacket(cp)
  }

  lemma {:axiom} AbstractifyMapHasEqualSize(cps: set<CPacket>)
    requires CPacketsIsAbstractable(cps)
    ensures |cps| == |AbstractifySetOfCPacketsToSetOfRslPackets_transparent(cps)|
    decreases cps

  function AbstractifySetOfCPacketsToSetOfRslPackets(cps: set<CPacket>): set<RslPacket>
    requires CPacketsIsAbstractable(cps)
    ensures forall p: CPacket {:trigger AbstractifyCPacketToRslPacket(p)} {:trigger p in cps} :: p in cps ==> AbstractifyCPacketToRslPacket(p) in AbstractifySetOfCPacketsToSetOfRslPackets(cps)
    ensures |cps| == |AbstractifySetOfCPacketsToSetOfRslPackets(cps)|
    decreases cps
  {
    AbstractifyMapHasEqualSize(cps);
    AbstractifySetOfCPacketsToSetOfRslPackets_transparent(cps)
  }

  predicate CPacketSeqIsAbstractable(cps: seq<CPacket>)
    decreases cps
  {
    forall i: int {:trigger cps[i]} :: 
      0 <= i < |cps| ==>
        CPacketIsAbstractable(cps[i])
  }

  function {:opaque} {:fuel 0, 0} AbstractifySeqOfCPacketsToSeqOfRslPackets(cps: seq<CPacket>): seq<RslPacket>
    requires CPacketSeqIsAbstractable(cps)
    ensures |cps| == |AbstractifySeqOfCPacketsToSeqOfRslPackets(cps)|
    ensures forall i: int {:trigger cps[i]} {:trigger AbstractifySeqOfCPacketsToSeqOfRslPackets(cps)[i]} :: 0 <= i < |cps| ==> AbstractifySeqOfCPacketsToSeqOfRslPackets(cps)[i] == AbstractifyCPacketToRslPacket(cps[i])
    decreases cps
  {
    if |cps| == 0 then
      []
    else
      [AbstractifyCPacketToRslPacket(cps[0])] + AbstractifySeqOfCPacketsToSeqOfRslPackets(cps[1..])
  }

  predicate CPacketSeqHasCorrectSrc(sent_packets: seq<CPacket>, me: EndPoint)
    decreases sent_packets, me
  {
    forall p: CPacket {:trigger p.src} {:trigger p in sent_packets} :: 
      p in sent_packets ==>
        p.src == me
  }

  predicate CMessageIsInjectiveType(m: CMessage)
    decreases m
  {
    CMessageIsAbstractable(m) &&
    (m.CMessage_1b? || m.CMessage_2b?)
  }

  lemma {:axiom} lemma_AbstractifyCMessageToRslMessage_isInjective(m1: CMessage, m2: CMessage)
    requires CMessageIsInjectiveType(m1) && CMessageIsInjectiveType(m2)
    requires AbstractifyCMessageToRslMessage(m1) == AbstractifyCMessageToRslMessage(m2)
    ensures m1 == m2
    decreases m1, m2

  predicate CPacketIsInjectiveType(p: CPacket)
    decreases p
  {
    CPacketIsAbstractable(p) &&
    CMessageIsInjectiveType(p.msg)
  }

  lemma lemma_AbstractifyCPacketToRslPacket_isInjective()
    ensures forall p1: CPacket, p2: CPacket {:trigger AbstractifyCPacketToRslPacket(p2), AbstractifyCPacketToRslPacket(p1)} {:trigger AbstractifyCPacketToRslPacket(p2), CPacketIsInjectiveType(p1)} {:trigger AbstractifyCPacketToRslPacket(p1), CPacketIsInjectiveType(p2)} {:trigger CPacketIsInjectiveType(p2), CPacketIsInjectiveType(p1)} :: CPacketIsInjectiveType(p1) && CPacketIsInjectiveType(p2) && AbstractifyCPacketToRslPacket(p1) == AbstractifyCPacketToRslPacket(p2) ==> p1 == p2
  {
  }

  predicate SetOfInjectiveTypeCPackets(s: set<CPacket>)
    decreases s
  {
    forall p: CPacket {:trigger CPacketIsInjectiveType(p)} {:trigger p in s} :: 
      p in s ==>
        CPacketIsInjectiveType(p)
  }

  predicate SetOfInjectiveTypeCPacketsIsInjective(s: set<CPacket>)
    decreases s
  {
    SetOfInjectiveTypeCPackets(s) &&
    forall p1: CPacket, p2: CPacket {:trigger AbstractifyCPacketToRslPacket(p2), AbstractifyCPacketToRslPacket(p1)} {:trigger AbstractifyCPacketToRslPacket(p2), p1 in s} {:trigger AbstractifyCPacketToRslPacket(p1), p2 in s} {:trigger p2 in s, p1 in s} :: 
      p1 in s &&
      p2 in s &&
      AbstractifyCPacketToRslPacket(p1) == AbstractifyCPacketToRslPacket(p2) ==>
        p1 == p2
  }

  lemma lemma_SetOfInjectiveTypeCPacketsIsInjective(s: set<CPacket>)
    requires SetOfInjectiveTypeCPackets(s)
    ensures SetOfInjectiveTypeCPacketsIsInjective(s)
    decreases s
  {
  }

  lemma lemma_AbstractifySetOfCPacketsToSetOfRslPackets_isInjective(cps1: set<CPacket>, cps2: set<CPacket>)
    requires CPacketsIsAbstractable(cps1)
    requires CPacketsIsAbstractable(cps2)
    requires SetOfInjectiveTypeCPackets(cps1)
    requires SetOfInjectiveTypeCPackets(cps2)
    requires AbstractifySetOfCPacketsToSetOfRslPackets(cps1) == AbstractifySetOfCPacketsToSetOfRslPackets(cps2)
    ensures cps1 == cps2
    decreases cps1, cps2
  {
  }

  lemma lemma_AbstractifySetOfCPacketsToSetOfRslPackets_cardinality(cps: set<CPacket>)
    requires CPacketsIsAbstractable(cps)
    requires SetOfInjectiveTypeCPackets(cps)
    ensures |cps| == |AbstractifySetOfCPacketsToSetOfRslPackets(cps)|
    decreases cps
  {
  }

  lemma lemma_AbstractifySetOfCPacketsToSetOfRslPackets_properties(cps: set<CPacket>)
    requires CPacketsIsAbstractable(cps)
    ensures SetOfInjectiveTypeCPackets(cps) ==> |cps| == |AbstractifySetOfCPacketsToSetOfRslPackets(cps)|
    ensures AbstractifySetOfCPacketsToSetOfRslPackets({}) == {}
    decreases cps
  {
  }
}

module LiveByzRSL__ParametersState_i {

  import opened Native__NativeTypes_s

  import opened LiveByzRSL__Parameters_i

  import opened Common__UpperBound_i

  import opened Common__UpperBound_s
  datatype CParameters = CParameters(max_log_length: int, baseline_view_timeout_period: int, heartbeat_period: int, max_integer_val: CUpperBound, max_batch_size: int, max_batch_delay: int)

  predicate CParametersIsValid(s: CParameters)
    decreases s
  {
    CParametersIsAbstractable(s) &&
    CUpperBoundIsValid(s.max_integer_val) &&
    s.max_log_length > 0 &&
    s.baseline_view_timeout_period > 0 &&
    s.heartbeat_period > 0 &&
    (s.max_integer_val.CUpperBoundFinite? ==>
      s.max_integer_val.n > s.max_log_length) &&
    s.max_batch_size > 0 &&
    s.max_batch_delay >= 0
  }

  predicate CParametersIsAbstractable(s: CParameters)
    decreases s
  {
    CUpperBoundIsAbstractable(s.max_integer_val)
  }

  function AbstractifyCParametersToLParameters(s: CParameters): LParameters
    requires CParametersIsAbstractable(s)
    decreases s
  {
    LParameters(s.max_log_length, s.baseline_view_timeout_period, s.heartbeat_period, AbstractifyCUpperBoundToUpperBound(s.max_integer_val), s.max_batch_size, s.max_batch_delay)
  }

  function method StaticParams(): CParameters
  {
    CParameters(1000, 1000, 30, CUpperBoundInfinite, 1, 10)
  }
}

module Common__UpperBound_i {

  import opened Native__NativeTypes_s

  import opened Common__UpperBound_s
  datatype CUpperBound = CUpperBoundFinite(n: int) | CUpperBoundInfinite

  function method CLeqUpperBound(x: int, u: CUpperBound): bool
    decreases x, u
  {
    match u
    case CUpperBoundFinite(n) =>
      x <= n
    case CUpperBoundInfinite() =>
      true
  }

  function method CLtUpperBound(x: int, u: CUpperBound): bool
    decreases x, u
  {
    match u
    case CUpperBoundFinite(n) =>
      x < n
    case CUpperBoundInfinite() =>
      true
  }

  predicate CUpperBoundIsAbstractable(c: CUpperBound)
    decreases c
  {
    true
  }

  predicate CUpperBoundIsValid(c: CUpperBound)
    decreases c
  {
    true
  }

  function method UpperBoundedAdditionImpl(x: int, y: int, u: CUpperBound): int
    ensures UpperBoundedAdditionImpl(x, y, u) as int == UpperBoundedAddition(x as int, y as int, AbstractifyCUpperBoundToUpperBound(u))
    decreases x, y, u
  {
    if CLtUpperBound(x + y, u) then
      x + y
    else
      u.n
  }

  function AbstractifyCUpperBoundToUpperBound(u: CUpperBound): UpperBound
    decreases u
  {
    match u
    case CUpperBoundFinite(n) =>
      UpperBoundFinite(n)
    case CUpperBoundInfinite() =>
      UpperBoundInfinite
  }
}

module LiveByzRSL__ProposerModel_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened LiveByzRSL__AppInterface_i

  import opened LiveByzRSL__Broadcast_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__CheckValSafetyImpl_i

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__ConstantsState_i

  import opened LiveByzRSL__CConfiguration_i

  import opened LiveByzRSL__CTypes_i

  import opened LiveByzRSL__Election_i

  import opened LiveByzRSL__ElectionModel_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__PacketParsing_i

  import opened LiveByzRSL__Proposer_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__CheckValSafety_i

  import opened Impl__LiveByzRSL__Broadcast_i

  import opened Collections__Maps_i

  import opened Collections__Sets_i

  import opened Common__NodeIdentity_i

  import opened Common__SeqIsUnique_i

  import opened Common__SeqIsUniqueDef_i

  import opened Common__UdpClient_i

  import opened Common__UpperBound_s

  import opened Common__UpperBound_i

  import opened Common__Util_i

  import opened GenericRefinement_i

  import opened Environment_s

  import opened LiveByzRSL__Environment_i
  datatype CIncompleteBatchTimer = CIncompleteBatchTimerOn(when: int) | CIncompleteBatchTimerOff

  datatype CProposer = CProposer(constants: CReplicaConstants, current_state: int, request_queue: seq<CRequest>, max_ballot_i_sent_1a: CBallot, next_operation_number_to_propose: int, received_1b_packets: seq<CPacket>, highest_seqno_requested_by_client_this_view: map<EndPoint, int>, incomplete_batch_timer: CIncompleteBatchTimer, election_state: CElectionState)

  predicate CIncompleteBatchTimerIsValid(s: CIncompleteBatchTimer)
    decreases s
  {
    match s
    case CIncompleteBatchTimerOn(when) =>
      CIncompleteBatchTimerIsAbstractable(s)
    case CIncompleteBatchTimerOff() =>
      CIncompleteBatchTimerIsAbstractable(s)
  }

  predicate CIncompleteBatchTimerIsAbstractable(s: CIncompleteBatchTimer)
    decreases s
  {
    match s
    case CIncompleteBatchTimerOn(when) =>
      true
    case CIncompleteBatchTimerOff() =>
      true
  }

  function AbstractifyCIncompleteBatchTimerToIncompleteBatchTimer(s: CIncompleteBatchTimer): IncompleteBatchTimer
    requires CIncompleteBatchTimerIsAbstractable(s)
    decreases s
  {
    match s
    case CIncompleteBatchTimerOn(when) =>
      IncompleteBatchTimerOn(s.when)
    case CIncompleteBatchTimerOff() =>
      IncompleteBatchTimerOff()
  }

  predicate CProposerIsValid(s: CProposer)
    decreases s
  {
    CProposerIsAbstractable(s) &&
    CReplicaConstantsIsValid(s.constants) &&
    (forall i: CRequest {:trigger CRequestIsValid(i)} {:trigger i in s.request_queue} :: 
      i in s.request_queue ==>
        CRequestIsValid(i)) &&
    CBallotIsValid(s.max_ballot_i_sent_1a) &&
    (forall i: CPacket {:trigger CPacketIsValid(i)} {:trigger i in s.received_1b_packets} :: 
      i in s.received_1b_packets ==>
        CPacketIsValid(i)) &&
    (forall i: EndPoint {:trigger EndPointIsValid(i)} {:trigger i in s.highest_seqno_requested_by_client_this_view} :: 
      i in s.highest_seqno_requested_by_client_this_view ==>
        EndPointIsValid(i)) &&
    CIncompleteBatchTimerIsValid(s.incomplete_batch_timer) &&
    CElectionStateIsValid(s.election_state) &&
    (forall p: CPacket {:trigger p.msg} {:trigger CPacketIsValid(p)} {:trigger p in s.received_1b_packets} :: 
      (p in s.received_1b_packets ==>
        CPacketIsValid(p)) &&
      (p in s.received_1b_packets ==>
        p.msg.CMessage_1b?) &&
      (p in s.received_1b_packets ==>
        p.msg.bal_1b == s.max_ballot_i_sent_1a) &&
      (p in s.received_1b_packets ==>
        CVotesIsValid(p.msg.votes))) &&
    s.constants == s.election_state.constants &&
    CRequestBatchIsValid(s.request_queue)
  }

  predicate CProposerIsAbstractable(s: CProposer)
    decreases s
  {
    CReplicaConstantsIsAbstractable(s.constants) &&
    (forall i: CRequest {:trigger CRequestIsAbstractable(i)} {:trigger i in s.request_queue} :: 
      i in s.request_queue ==>
        CRequestIsAbstractable(i)) &&
    CBallotIsAbstractable(s.max_ballot_i_sent_1a) &&
    (forall i: CPacket {:trigger CPacketIsAbstractable(i)} {:trigger i in s.received_1b_packets} :: 
      i in s.received_1b_packets ==>
        CPacketIsAbstractable(i)) &&
    (forall i: EndPoint {:trigger EndPointIsAbstractable(i)} {:trigger i in s.highest_seqno_requested_by_client_this_view} :: 
      i in s.highest_seqno_requested_by_client_this_view ==>
        EndPointIsAbstractable(i)) &&
    CIncompleteBatchTimerIsAbstractable(s.incomplete_batch_timer) &&
    CElectionStateIsAbstractable(s.election_state)
  }

  function AbstractifyCProposerToLProposer(s: CProposer): LProposer
    requires CProposerIsValid(s)
    decreases s
  {
    LProposer(AbstractifyCReplicaConstantsToLReplicaConstants(s.constants), s.current_state, AbstractifySeq(s.request_queue, AbstractifyCRequestToRequest), AbstractifyCBallotToBallot(s.max_ballot_i_sent_1a), s.next_operation_number_to_propose, AbstractifySeq(s.received_1b_packets, AbstractifyCPacketToRslPacket), AbstractifyMap(s.highest_seqno_requested_by_client_this_view, AbstractifyEndPointToNodeIdentity, NoChange, AbstractifyNodeIdentityToEndPoint), AbstractifyCIncompleteBatchTimerToIncompleteBatchTimer(s.incomplete_batch_timer), AbstractifyCElectionStateToElectionState(s.election_state))
  }

  function method CIsAfterLogTruncationPoint(opn: COperationNumber, S: seq<CPacket>): bool
    requires COperationNumberIsValid(opn)
    requires forall i: CPacket {:trigger CPacketIsValid(i)} {:trigger i in S} :: i in S ==> CPacketIsValid(i)
    ensures var lr: bool := LIsAfterLogTruncationPoint(AbstractifyCOperationNumberToOperationNumber(opn), AbstractifySeq(S, AbstractifyCPacketToRslPacket)); var cr: bool := CIsAfterLogTruncationPoint(opn, S); cr == lr
    decreases opn, S
  {
    forall p: CPacket {:trigger p.msg} {:trigger p in S} :: 
      p in S &&
      p.msg.CMessage_1b? ==>
        p.msg.log_truncation_point <= opn
  }

  function method CProposerCanNominateUsingOperationNumber(s: CProposer, log_truncation_point: COperationNumber, opn: COperationNumber): bool
    requires CProposerIsValid(s)
    requires COperationNumberIsValid(log_truncation_point)
    requires COperationNumberIsValid(opn)
    ensures var lr: bool := LProposerCanNominateUsingOperationNumber(AbstractifyCProposerToLProposer(s), AbstractifyCOperationNumberToOperationNumber(log_truncation_point), AbstractifyCOperationNumberToOperationNumber(opn)); var cr: bool := CProposerCanNominateUsingOperationNumber(s, log_truncation_point, opn); cr == lr
    decreases s, log_truncation_point, opn
  {
    s.election_state.current_view == s.max_ballot_i_sent_1a &&
    s.current_state == 2 &&
    |s.received_1b_packets| >= CByzQuorumSize(s.constants.all.config) &&
    CSetOfMessage1bAboutBallot(s.received_1b_packets, s.max_ballot_i_sent_1a) &&
    CIsAfterLogTruncationPoint(opn, s.received_1b_packets) &&
    opn < UpperBoundedAdditionImpl(log_truncation_point, s.constants.all.params.max_log_length, s.constants.all.params.max_integer_val) &&
    opn >= 0 &&
    CLtUpperBound(opn, s.constants.all.params.max_integer_val)
  }

  function method CProposerInit(c: CReplicaConstants): CProposer
    requires CReplicaConstantsIsValid(c)
    ensures var s: CProposer := CProposerInit(c); CProposerIsValid(s) && LProposerInit(AbstractifyCProposerToLProposer(s), AbstractifyCReplicaConstantsToLReplicaConstants(c))
    decreases c
  {
    var t1: CReplicaConstants := c;
    var t2: int := 0;
    var t3: seq<CRequest> := [];
    var t4: CBallot := CBallot(0, c.my_index);
    var t5: int := 0;
    var t6: seq<CPacket> := [];
    var t7: map<EndPoint, int> := map[];
    var t8: CElectionState := CElectionStateInit(c);
    var t9: CIncompleteBatchTimer := CIncompleteBatchTimerOff();
    CProposer(t1, t2, t3, t4, t5, t6, t7, t9, t8)
  }

  function method CProposerProcessRequest(s: CProposer, packet: CPacket): CProposer
    requires CProposerIsValid(s)
    requires CPacketIsValid(packet)
    requires packet.msg.CMessage_Request?
    ensures var s': CProposer := CProposerProcessRequest(s, packet); CProposerIsValid(s') && LProposerProcessRequest(AbstractifyCProposerToLProposer(s), AbstractifyCProposerToLProposer(s'), AbstractifyCPacketToRslPacket(packet))
    decreases s, packet
  {
    var t1: CProposer := var val: CRequest := CRequest(packet.src, packet.msg.seqno_req, packet.msg.val); var t1: CElectionState := CElectionStateReflectReceivedRequest(s.election_state, val); var t2: CProposer := if s.current_state != 0 && (val.client !in s.highest_seqno_requested_by_client_this_view || val.seqno > s.highest_seqno_requested_by_client_this_view[val.client]) then var t1: CProposer := s.(election_state := t1, request_queue := s.request_queue + [val], highest_seqno_requested_by_client_this_view := s.highest_seqno_requested_by_client_this_view[val.client := val.seqno]); t1 else var t1: CProposer := s.(election_state := t1); t1; t2;
    t1
  }

  function method CProposerMaybeEnterNewViewAndSend1a(s: CProposer): (CProposer, OutboundPackets)
    requires CProposerIsValid(s)
    ensures var (s': CProposer, broadcast_sent_packets: OutboundPackets) := CProposerMaybeEnterNewViewAndSend1a(s); CProposerIsValid(s') && OutboundPacketsIsValid(broadcast_sent_packets) && LProposerMaybeEnterNewViewAndSend1a(AbstractifyCProposerToLProposer(s), AbstractifyCProposerToLProposer(s'), AbstractifyOutboundCPacketsToSeqOfRslPackets(broadcast_sent_packets))
    decreases s
  {
    var t1: (CProposer, OutboundPackets) := if s.election_state.current_view.proposer_id == s.constants.my_index && CBalLt(s.max_ballot_i_sent_1a, s.election_state.current_view) then var t1: CProposer := s.(current_state := 1, max_ballot_i_sent_1a := s.election_state.current_view, received_1b_packets := [], highest_seqno_requested_by_client_this_view := map[], request_queue := s.election_state.requests_received_prev_epochs + s.election_state.requests_received_this_epoch); var t2: OutboundPackets := Broadcast(BuildBroadcastToEveryone(s.constants.all.config, s.constants.my_index, CMessage_1a(s.election_state.current_view))); (t1, t2) else var t1: CProposer := s; var t2: OutboundPackets := Broadcast(CBroadcastNop); (t1, t2);
    (t1.0, t1.1)
  }

  function method CProposerProcess1b(s: CProposer, p: CPacket): CProposer
    requires CProposerIsValid(s)
    requires CPacketIsValid(p)
    requires p.msg.CMessage_1b?
    requires p.src in s.constants.all.config.replica_ids
    requires p.msg.bal_1b == s.max_ballot_i_sent_1a
    requires s.current_state == 1
    requires forall other_packet: CPacket {:trigger other_packet.src} {:trigger other_packet in s.received_1b_packets} :: other_packet in s.received_1b_packets ==> other_packet.src != p.src
    ensures var s': CProposer := CProposerProcess1b(s, p); CProposerIsValid(s') && LProposerProcess1b(AbstractifyCProposerToLProposer(s), AbstractifyCProposerToLProposer(s'), AbstractifyCPacketToRslPacket(p))
    decreases s, p
  {
    var t1: CProposer := s.(received_1b_packets := s.received_1b_packets + [p]);
    t1
  }

  function method CProposerMaybeEnterPhase2(s: CProposer, log_truncation_point: COperationNumber): (CProposer, OutboundPackets)
    requires CProposerIsValid(s)
    requires COperationNumberIsValid(log_truncation_point)
    ensures var (s': CProposer, broadcast_sent_packets: OutboundPackets) := CProposerMaybeEnterPhase2(s, log_truncation_point); CProposerIsValid(s') && OutboundPacketsIsValid(broadcast_sent_packets) && LProposerMaybeEnterPhase2(AbstractifyCProposerToLProposer(s), AbstractifyCProposerToLProposer(s'), AbstractifyCOperationNumberToOperationNumber(log_truncation_point), AbstractifyOutboundCPacketsToSeqOfRslPackets(broadcast_sent_packets))
    decreases s, log_truncation_point
  {
    var t1: (CProposer, OutboundPackets) := if |s.received_1b_packets| >= CByzQuorumSize(s.constants.all.config) && CSetOfMessage1bAboutBallot(s.received_1b_packets, s.max_ballot_i_sent_1a) && s.current_state == 1 then var t1: CProposer := s.(current_state := 2, next_operation_number_to_propose := log_truncation_point); var t2: OutboundPackets := Broadcast(BuildBroadcastToEveryone(s.constants.all.config, s.constants.my_index, CMessage_StartingPhase2(s.max_ballot_i_sent_1a, log_truncation_point))); (t1, t2) else var t1: CProposer := s; var t2: OutboundPackets := Broadcast(CBroadcastNop); (t1, t2);
    (t1.0, t1.1)
  }

  function method CProposerNominateNewValueAndSend1c(s: CProposer, clock: int, log_truncation_point: COperationNumber): (CProposer, OutboundPackets)
    requires CProposerIsValid(s)
    requires COperationNumberIsValid(log_truncation_point)
    requires CProposerCanNominateUsingOperationNumber(s, log_truncation_point, s.next_operation_number_to_propose)
    requires CAllAcceptorsHadNoProposal(s.received_1b_packets, s.next_operation_number_to_propose)
    ensures var (s': CProposer, broadcast_sent_packets: OutboundPackets) := CProposerNominateNewValueAndSend1c(s, clock, log_truncation_point); CProposerIsValid(s') && OutboundPacketsIsValid(broadcast_sent_packets) && LProposerNominateNewValueAndSend1c(AbstractifyCProposerToLProposer(s), AbstractifyCProposerToLProposer(s'), clock, AbstractifyCOperationNumberToOperationNumber(log_truncation_point), AbstractifyOutboundCPacketsToSeqOfRslPackets(broadcast_sent_packets))
    decreases s, clock, log_truncation_point
  {
    var batchSize: int := if |s.request_queue| <= s.constants.all.params.max_batch_size || s.constants.all.params.max_batch_size < 0 then |s.request_queue| else s.constants.all.params.max_batch_size;
    var t1: (CProposer, OutboundPackets) := var t1: (OutboundPackets, CProposer) := var v: seq<CRequest> := s.request_queue[..batchSize]; var t1: (CProposer, OutboundPackets) := var opn: int := s.next_operation_number_to_propose; var t1: CProposer := s.(request_queue := s.request_queue[batchSize..], next_operation_number_to_propose := s.next_operation_number_to_propose + 1, incomplete_batch_timer := if |s.request_queue| > batchSize then CIncompleteBatchTimerOn(UpperBoundedAdditionImpl(clock, s.constants.all.params.max_batch_delay, s.constants.all.params.max_integer_val)) else CIncompleteBatchTimerOff()); var t2: OutboundPackets := Broadcast(BuildBroadcastToEveryone(s.constants.all.config, s.constants.my_index, CMessage_1c(s.max_ballot_i_sent_1a, opn, v))); (t1, t2); (t1.1, t1.0); (t1.1, t1.0);
    lemma_seq_sub(s.request_queue, AbstractifyCRequestToRequest, 0, batchSize);
    (t1.0, t1.1)
  }

  function method CProposerProcessHeartbeat(s: CProposer, p: CPacket, clock: int): CProposer
    requires CProposerIsValid(s)
    requires CPacketIsValid(p)
    requires p.msg.CMessage_Heartbeat?
    ensures var s': CProposer := CProposerProcessHeartbeat(s, p, clock); CProposerIsValid(s') && LProposerProcessHeartbeat(AbstractifyCProposerToLProposer(s), AbstractifyCProposerToLProposer(s'), AbstractifyCPacketToRslPacket(p), clock)
    decreases s, p, clock
  {
    var t1: CElectionState := CElectionStateProcessHeartbeat(s.election_state, p, clock);
    var t2: (int, seq<CRequest>) := if CBalLt(s.election_state.current_view, t1.current_view) then var t1: int := 0; var t2: seq<CRequest> := []; (t1, t2) else var t1: int := s.current_state; var t2: seq<CRequest> := s.request_queue; (t1, t2);
    var t3: CProposer := s.(election_state := t1, current_state := t2.0, request_queue := t2.1);
    t3
  }

  function method CProposerCheckForViewTimeout(s: CProposer, clock: int): CProposer
    requires CProposerIsValid(s)
    ensures var s': CProposer := CProposerCheckForViewTimeout(s, clock); CProposerIsValid(s') && LProposerCheckForViewTimeout(AbstractifyCProposerToLProposer(s), AbstractifyCProposerToLProposer(s'), clock)
    decreases s, clock
  {
    var t1: CElectionState := CElectionStateCheckForViewTimeout(s.election_state, clock);
    var t2: CProposer := s.(election_state := t1);
    t2
  }

  function method CProposerCheckForQuorumOfViewSuspicions(s: CProposer, clock: int): CProposer
    requires CProposerIsValid(s)
    ensures var s': CProposer := CProposerCheckForQuorumOfViewSuspicions(s, clock); CProposerIsValid(s') && LProposerCheckForQuorumOfViewSuspicions(AbstractifyCProposerToLProposer(s), AbstractifyCProposerToLProposer(s'), clock)
    decreases s, clock
  {
    var t1: CElectionState := CElectionStateCheckForQuorumOfViewSuspicions(s.election_state, clock);
    var t2: (int, seq<CRequest>) := if CBalLt(s.election_state.current_view, t1.current_view) then var t1: int := 0; var t2: seq<CRequest> := []; (t1, t2) else var t1: int := s.current_state; var t2: seq<CRequest> := s.request_queue; (t1, t2);
    var t3: CProposer := s.(election_state := t1, current_state := t2.0, request_queue := t2.1);
    t3
  }

  function method CProposerResetViewTimerDueToExecution(s: CProposer, val: CRequestBatch): CProposer
    requires CProposerIsValid(s)
    requires CRequestBatchIsValid(val)
    ensures var s': CProposer := CProposerResetViewTimerDueToExecution(s, val); CProposerIsValid(s') && LProposerResetViewTimerDueToExecution(AbstractifyCProposerToLProposer(s), AbstractifyCProposerToLProposer(s'), AbstractifyCRequestBatchToRequestBatch(val))
    decreases s, val
  {
    var t1: CElectionState := CElectionStateReflectExecutedRequestBatch(s.election_state, val);
    var t2: CProposer := s.(election_state := t1);
    t2
  }

  method CProposerNominateOldValueAndSend1c(s: CProposer, log_truncation_point: COperationNumber)
      returns (s': CProposer, sent_packets: OutboundPackets)
    requires CProposerIsValid(s)
    requires CProposerCanNominateUsingOperationNumber(s, log_truncation_point, s.next_operation_number_to_propose)
    requires !CAllAcceptorsHadNoProposal(s.received_1b_packets, s.next_operation_number_to_propose)
    ensures CProposerIsValid(s')
    ensures OutboundPacketsIsValid(sent_packets)
    ensures OutboundPacketsHasCorrectSrc(sent_packets, s'.constants.all.config.replica_ids[s'.constants.my_index])
    ensures LProposerNominateOldValueAndSend1c(AbstractifyCProposerToLProposer(s), AbstractifyCProposerToLProposer(s'), AbstractifyCOperationNumberToOperationNumber(log_truncation_point), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets))
    decreases s, log_truncation_point
  {
    var opn := s.next_operation_number_to_propose;
    var byzq := CByzQuorumSize(s.constants.all.config);
    var wq := CMinQuorumSize(s.constants.all.config);
    ghost var ls := AbstractifyCProposerToLProposer(s);
    ghost var lopn := ls.next_operation_number_to_propose;
    ghost var lbyzq := LByzQuorumSize(ls.constants.all.config);
    ghost var lwq := LMinQuorumSize(ls.constants.all.config);
    assert byzq == lbyzq;
    assert wq == lwq;
    if exists p: CPacket {:trigger p.msg} {:trigger p in s.received_1b_packets} :: p in s.received_1b_packets && opn in p.msg.votes && CValIsSafeAt(p.msg.votes[opn].max_val, s.received_1b_packets, opn, byzq, wq) {
      var p :| p in s.received_1b_packets && opn in p.msg.votes && CValIsSafeAt(p.msg.votes[opn].max_val, s.received_1b_packets, opn, byzq, wq);
      assert CValIsSafeAt(p.msg.votes[opn].max_val, s.received_1b_packets, opn, byzq, wq);
      assert LValIsSafeAt(AbstractifyCRequestBatchToRequestBatch(p.msg.votes[opn].max_val), AbstractifySeq(s.received_1b_packets, AbstractifyCPacketToRslPacket), AbstractifyCOperationNumberToOperationNumber(opn), byzq, wq);
      s' := s.(next_operation_number_to_propose := s.next_operation_number_to_propose + 1);
      sent_packets := Broadcast(BuildBroadcastToEveryone(s.constants.all.config, s.constants.my_index, CMessage_1c(s.max_ballot_i_sent_1a, opn, p.msg.votes[opn].max_val)));
      lemma_CProposerNominateOldValueAndSend1c(s, log_truncation_point, s', sent_packets);
      assert LProposerNominateOldValueAndSend1c(AbstractifyCProposerToLProposer(s), AbstractifyCProposerToLProposer(s'), AbstractifyCOperationNumberToOperationNumber(log_truncation_point), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets));
    } else {
      s' := s;
      sent_packets := Broadcast(CBroadcastNop);
      lemma_CProposerNominateOldValueAndSend1c(s, log_truncation_point, s', sent_packets);
      assert LProposerNominateOldValueAndSend1c(AbstractifyCProposerToLProposer(s), AbstractifyCProposerToLProposer(s'), AbstractifyCOperationNumberToOperationNumber(log_truncation_point), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets));
    }
  }

  lemma {:axiom} lemma_CProposerNominateOldValueAndSend1c(s: CProposer, log_truncation_point: COperationNumber, s': CProposer, sent_packets: OutboundPackets)
    requires CProposerIsValid(s)
    requires CProposerCanNominateUsingOperationNumber(s, log_truncation_point, s.next_operation_number_to_propose)
    requires !CAllAcceptorsHadNoProposal(s.received_1b_packets, s.next_operation_number_to_propose)
    ensures CProposerIsValid(s')
    ensures OutboundPacketsIsValid(sent_packets)
    ensures LProposerNominateOldValueAndSend1c(AbstractifyCProposerToLProposer(s), AbstractifyCProposerToLProposer(s'), AbstractifyCOperationNumberToOperationNumber(log_truncation_point), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets))
    decreases s, log_truncation_point, s', sent_packets

  method CProposerMaybeNominateValueAndSend1c(proposer: CProposer, clock: int, log_truncation_point: COperationNumber)
      returns (proposer': CProposer, sent_packets: OutboundPackets)
    requires CProposerIsValid(proposer)
    ensures CProposerIsValid(proposer')
    ensures OutboundPacketsIsValid(sent_packets)
    ensures OutboundPacketsHasCorrectSrc(sent_packets, proposer'.constants.all.config.replica_ids[proposer'.constants.my_index])
    ensures LProposerMaybeNominateValueAndSend1c(AbstractifyCProposerToLProposer(proposer), AbstractifyCProposerToLProposer(proposer'), clock as int, AbstractifyCOperationNumberToOperationNumber(log_truncation_point), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets))
    decreases proposer, clock, log_truncation_point
  {
    if !CProposerCanNominateUsingOperationNumber(proposer, log_truncation_point, proposer.next_operation_number_to_propose) {
      proposer' := proposer;
      sent_packets := Broadcast(CBroadcastNop);
    } else if !CAllAcceptorsHadNoProposal(proposer.received_1b_packets, proposer.next_operation_number_to_propose) {
      proposer', sent_packets := CProposerNominateOldValueAndSend1c(proposer, log_truncation_point);
    } else if |proposer.request_queue| >= proposer.constants.all.params.max_batch_size as int || (|proposer.request_queue| > 0 && proposer.incomplete_batch_timer.CIncompleteBatchTimerOn? && clock >= proposer.incomplete_batch_timer.when) {
      var (proposer'_, sent_packets_) := CProposerNominateNewValueAndSend1c(proposer, clock, log_truncation_point);
      proposer' := proposer'_;
      sent_packets := sent_packets_;
    } else if |proposer.request_queue| > 0 && proposer.incomplete_batch_timer.CIncompleteBatchTimerOff? {
      proposer' := proposer.(incomplete_batch_timer := CIncompleteBatchTimerOn(UpperBoundedAdditionImpl(clock, proposer.constants.all.params.max_batch_delay, proposer.constants.all.params.max_integer_val)));
      sent_packets := Broadcast(CBroadcastNop);
    } else {
      proposer' := proposer;
      sent_packets := Broadcast(CBroadcastNop);
    }
  }
}

module LiveByzRSL__ElectionModel_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__ConstantsState_i

  import opened LiveByzRSL__CConfiguration_i

  import opened LiveByzRSL__CTypes_i

  import opened LiveByzRSL__Election_i

  import opened LiveByzRSL__Types_i

  import opened Common__NodeIdentity_i

  import opened Common__SeqIsUnique_i

  import opened Common__SeqIsUniqueDef_i

  import opened Common__UpperBound_s

  import opened Common__UpperBound_i

  import opened Common__Util_i

  import opened Collections__Seqs_s

  import opened Collections__Sets_i

  import opened GenericRefinement_i
  datatype CElectionState = CElectionState(constants: CReplicaConstants, current_view: CBallot, current_view_suspectors: set<int>, epoch_end_time: int, epoch_length: int, requests_received_this_epoch: seq<CRequest>, requests_received_prev_epochs: seq<CRequest>)

  predicate CElectionStateIsValid(s: CElectionState)
    decreases s
  {
    CElectionStateIsAbstractable(s) &&
    CReplicaConstantsIsValid(s.constants) &&
    CBallotIsValid(s.current_view) &&
    (forall i: CRequest {:trigger CRequestIsValid(i)} {:trigger i in s.requests_received_this_epoch} :: 
      i in s.requests_received_this_epoch ==>
        CRequestIsValid(i)) &&
    forall i: CRequest {:trigger CRequestIsValid(i)} {:trigger i in s.requests_received_prev_epochs} :: 
      i in s.requests_received_prev_epochs ==>
        CRequestIsValid(i)
  }

  predicate CElectionStateIsAbstractable(s: CElectionState)
    decreases s
  {
    CReplicaConstantsIsAbstractable(s.constants) &&
    CBallotIsAbstractable(s.current_view) &&
    (forall i: CRequest {:trigger CRequestIsAbstractable(i)} {:trigger i in s.requests_received_this_epoch} :: 
      i in s.requests_received_this_epoch ==>
        CRequestIsAbstractable(i)) &&
    forall i: CRequest {:trigger CRequestIsAbstractable(i)} {:trigger i in s.requests_received_prev_epochs} :: 
      i in s.requests_received_prev_epochs ==>
        CRequestIsAbstractable(i)
  }

  function AbstractifyCElectionStateToElectionState(s: CElectionState): ElectionState
    requires CElectionStateIsAbstractable(s)
    decreases s
  {
    ElectionState(AbstractifyCReplicaConstantsToLReplicaConstants(s.constants), AbstractifyCBallotToBallot(s.current_view), s.current_view_suspectors, s.epoch_end_time, s.epoch_length, AbstractifySeq(s.requests_received_this_epoch, AbstractifyCRequestToRequest), AbstractifySeq(s.requests_received_prev_epochs, AbstractifyCRequestToRequest))
  }

  function method CComputeSuccessorView(b: CBallot, c: CConstants): CBallot
    requires CBallotIsValid(b)
    requires CConstantsIsValid(c)
    ensures var lr: Ballot := ComputeSuccessorView(AbstractifyCBallotToBallot(b), AbstractifyCConstantsToLConstants(c)); var cr: CBallot := CComputeSuccessorView(b, c); CBallotIsValid(cr) && AbstractifyCBallotToBallot(cr) == lr
    decreases b, c
  {
    if b.proposer_id + 1 < |c.config.replica_ids| then
      CBallot(b.seqno, b.proposer_id + 1)
    else
      CBallot(b.seqno + 1, 0)
  }

  function method CBoundRequestSequence(s: seq<CRequest>, lengthBound: CUpperBound): seq<CRequest>
    requires forall i: CRequest {:trigger CRequestIsValid(i)} {:trigger i in s} :: i in s ==> CRequestIsValid(i)
    requires CUpperBoundIsValid(lengthBound)
    ensures var lr: seq<Request> := BoundRequestSequence(AbstractifySeq(s, AbstractifyCRequestToRequest), AbstractifyCUpperBoundToUpperBound(lengthBound)); var cr: seq<CRequest> := CBoundRequestSequence(s, lengthBound); (forall i: CRequest {:trigger CRequestIsValid(i)} {:trigger i in cr} :: i in cr ==> CRequestIsValid(i)) && AbstractifySeq(cr, AbstractifyCRequestToRequest) == lr
    decreases s, lengthBound
  {
    if lengthBound.CUpperBoundFinite? && 0 <= lengthBound.n && lengthBound.n < |s| then
      s[..lengthBound.n]
    else
      s
  }

  function method CRequestsMatch(r1: CRequest, r2: CRequest): bool
    requires CRequestIsValid(r1)
    requires CRequestIsValid(r2)
    ensures CRequestsMatch(r1, r2) == RequestsMatch(AbstractifyCRequestToRequest(r1), AbstractifyCRequestToRequest(r2))
    decreases r1, r2
  {
    r1.CRequest? &&
    r2.CRequest? &&
    r1.client == r2.client &&
    r1.seqno == r2.seqno
  }

  function method CRequestSatisfiedBy(r1: CRequest, r2: CRequest): bool
    requires CRequestIsValid(r1)
    requires CRequestIsValid(r2)
    ensures CRequestSatisfiedBy(r1, r2) == RequestSatisfiedBy(AbstractifyCRequestToRequest(r1), AbstractifyCRequestToRequest(r2))
    decreases r1, r2
  {
    r1.CRequest? &&
    r2.CRequest? &&
    r1.client == r2.client &&
    r1.seqno <= r2.seqno
  }

  function method CRemoveAllSatisfiedRequestsInSequence(s: seq<CRequest>, r: CRequest): seq<CRequest>
    requires forall i: CRequest {:trigger CRequestIsValid(i)} {:trigger i in s} :: i in s ==> CRequestIsValid(i)
    requires CRequestIsValid(r)
    ensures forall i: CRequest {:trigger CRequestIsValid(i)} {:trigger i.CRequest?} {:trigger i in CRemoveAllSatisfiedRequestsInSequence(s, r)} :: (i in CRemoveAllSatisfiedRequestsInSequence(s, r) ==> i.CRequest?) && (i in CRemoveAllSatisfiedRequestsInSequence(s, r) ==> CRequestIsValid(i))
    ensures AbstractifySeq(CRemoveAllSatisfiedRequestsInSequence(s, r), AbstractifyCRequestToRequest) == RemoveAllSatisfiedRequestsInSequence(AbstractifySeq(s, AbstractifyCRequestToRequest), AbstractifyCRequestToRequest(r))
    decreases s, r
  {
    if |s| == 0 then
      []
    else if CRequestSatisfiedBy(s[0], r) then
      CRemoveAllSatisfiedRequestsInSequence(s[1..], r)
    else
      [s[0]] + CRemoveAllSatisfiedRequestsInSequence(s[1..], r)
  }

  function method CCheckRequestValidInReqSeq(s: seq<CRequest>, r: CRequest): bool
    requires forall i: CRequest {:trigger CRequestIsValid(i)} {:trigger i in s} :: i in s ==> CRequestIsValid(i)
    requires CRequestIsValid(r)
    ensures var lr: bool := CheckRequestValidInReqSeq(AbstractifySeq(s, AbstractifyCRequestToRequest), AbstractifyCRequestToRequest(r)); var cr: bool := CCheckRequestValidInReqSeq(s, r); cr == lr
    decreases s, r
  {
    exists i: CRequest {:trigger i.request} {:trigger CRequestsMatch(i, r)} {:trigger i in s} :: 
      i in s &&
      CRequestsMatch(i, r) &&
      i.request == r.request
  }

  function method CCheckRequestValid(s: CElectionState, r: CRequest): bool
    requires CElectionStateIsValid(s)
    requires CRequestIsValid(r)
    ensures var lr: bool := CheckRequestValid(AbstractifyCElectionStateToElectionState(s), AbstractifyCRequestToRequest(r)); var cr: bool := CCheckRequestValid(s, r); cr == lr
    decreases s, r
  {
    CCheckRequestValidInReqSeq(s.requests_received_this_epoch, r) || CCheckRequestValidInReqSeq(s.requests_received_prev_epochs, r)
  }

  function method CElectionStateInit(c: CReplicaConstants): CElectionState
    requires CReplicaConstantsIsValid(c)
    requires |c.all.config.replica_ids| > 0
    ensures var es: CElectionState := CElectionStateInit(c); CElectionStateIsValid(es) && ElectionStateInit(AbstractifyCElectionStateToElectionState(es), AbstractifyCReplicaConstantsToLReplicaConstants(c))
    decreases c
  {
    var t1: CReplicaConstants := c;
    var t2: CBallot := CBallot(1, 0);
    var t3: set<int> := {};
    var t4: int := 0;
    var t5: int := c.all.params.baseline_view_timeout_period;
    var t6: seq<CRequest> := [];
    var t7: seq<CRequest> := [];
    CElectionState(t1, t2, t3, t4, t5, t6, t7)
  }

  function method CElectionStateProcessHeartbeat(es: CElectionState, p: CPacket, clock: int): CElectionState
    requires CElectionStateIsValid(es)
    requires CPacketIsValid(p)
    requires p.msg.CMessage_Heartbeat?
    ensures var es': CElectionState := CElectionStateProcessHeartbeat(es, p, clock); CElectionStateIsValid(es') && ElectionStateProcessHeartbeat(AbstractifyCElectionStateToElectionState(es), AbstractifyCElectionStateToElectionState(es'), AbstractifyCPacketToRslPacket(p), clock)
    decreases es, p, clock
  {
    var t1: CElectionState := if p.src !in es.constants.all.config.replica_ids then var t1: CElectionState := es; t1 else var t1: CElectionState := var sender_index: int := CGetReplicaIndex(p.src, es.constants.all.config); var t1: CElectionState := if p.msg.bal_heartbeat == es.current_view && p.msg.suspicious then var t1: CElectionState := es.(current_view_suspectors := es.current_view_suspectors + {sender_index}); t1 else var t1: CElectionState := if CBalLt(es.current_view, p.msg.bal_heartbeat) then var t1: CElectionState := var new_epoch_length: int := UpperBoundedAdditionImpl(es.epoch_length, es.epoch_length, es.constants.all.params.max_integer_val); var t1: CElectionState := es.(current_view := p.msg.bal_heartbeat, current_view_suspectors := if p.msg.suspicious then {sender_index} else {}, epoch_length := new_epoch_length, epoch_end_time := UpperBoundedAdditionImpl(clock, new_epoch_length, es.constants.all.params.max_integer_val), requests_received_prev_epochs := CBoundRequestSequence(es.requests_received_prev_epochs + es.requests_received_this_epoch, es.constants.all.params.max_integer_val), requests_received_this_epoch := []); t1; t1 else var t1: CElectionState := es; t1; t1; t1; t1;
    t1
  }

  function method CElectionStateCheckForViewTimeout(es: CElectionState, clock: int): CElectionState
    requires CElectionStateIsValid(es)
    ensures var es': CElectionState := CElectionStateCheckForViewTimeout(es, clock); CElectionStateIsValid(es') && ElectionStateCheckForViewTimeout(AbstractifyCElectionStateToElectionState(es), AbstractifyCElectionStateToElectionState(es'), clock)
    decreases es, clock
  {
    var t1: CElectionState := if clock < es.epoch_end_time then var t1: CElectionState := es; t1 else var t1: CElectionState := if |es.requests_received_prev_epochs| == 0 then var t1: CElectionState := var new_epoch_length: int := es.constants.all.params.baseline_view_timeout_period; var t1: CElectionState := es.(epoch_length := new_epoch_length, epoch_end_time := UpperBoundedAdditionImpl(clock, new_epoch_length, es.constants.all.params.max_integer_val), requests_received_prev_epochs := es.requests_received_this_epoch, requests_received_this_epoch := []); t1; t1 else var t1: CElectionState := es.(current_view_suspectors := es.current_view_suspectors + {es.constants.my_index}, epoch_end_time := UpperBoundedAdditionImpl(clock, es.epoch_length, es.constants.all.params.max_integer_val), requests_received_prev_epochs := CBoundRequestSequence(es.requests_received_prev_epochs + es.requests_received_this_epoch, es.constants.all.params.max_integer_val), requests_received_this_epoch := []); t1; t1;
    t1
  }

  function method CElectionStateCheckForQuorumOfViewSuspicions(es: CElectionState, clock: int): CElectionState
    requires CElectionStateIsValid(es)
    ensures var es': CElectionState := CElectionStateCheckForQuorumOfViewSuspicions(es, clock); CElectionStateIsValid(es') && ElectionStateCheckForQuorumOfViewSuspicions(AbstractifyCElectionStateToElectionState(es), AbstractifyCElectionStateToElectionState(es'), clock)
    decreases es, clock
  {
    var t1: CElectionState := if |es.current_view_suspectors| < CMinQuorumSize(es.constants.all.config) || !CLtUpperBound(es.current_view.seqno, es.constants.all.params.max_integer_val) then var t1: CElectionState := es; t1 else var t1: CElectionState := var new_epoch_length: int := UpperBoundedAdditionImpl(es.epoch_length, es.epoch_length, es.constants.all.params.max_integer_val); var t1: CElectionState := es.(current_view := CComputeSuccessorView(es.current_view, es.constants.all), current_view_suspectors := {}, epoch_length := new_epoch_length, epoch_end_time := UpperBoundedAdditionImpl(clock, new_epoch_length, es.constants.all.params.max_integer_val), requests_received_prev_epochs := CBoundRequestSequence(es.requests_received_prev_epochs + es.requests_received_this_epoch, es.constants.all.params.max_integer_val), requests_received_this_epoch := []); t1; t1;
    t1
  }

  function method CElectionStateReflectReceivedRequest(es: CElectionState, req: CRequest): CElectionState
    requires CElectionStateIsValid(es)
    requires CRequestIsValid(req)
    ensures var es': CElectionState := CElectionStateReflectReceivedRequest(es, req); CElectionStateIsValid(es') && ElectionStateReflectReceivedRequest(AbstractifyCElectionStateToElectionState(es), AbstractifyCElectionStateToElectionState(es'), AbstractifyCRequestToRequest(req))
    decreases es, req
  {
    var t1: CElectionState := if exists earlier_req: CRequest {:trigger CRequestsMatch(earlier_req, req)} {:trigger earlier_req in es.requests_received_prev_epochs} :: earlier_req in es.requests_received_prev_epochs && CRequestsMatch(earlier_req, req) then var t1: CElectionState := es; t1 else var t1: CElectionState := if exists earlier_req: CRequest {:trigger CRequestsMatch(earlier_req, req)} {:trigger earlier_req in es.requests_received_this_epoch} :: earlier_req in es.requests_received_this_epoch && CRequestsMatch(earlier_req, req) then var t1: CElectionState := es; t1 else var t1: CElectionState := es.(requests_received_this_epoch := CBoundRequestSequence(es.requests_received_this_epoch + [req], es.constants.all.params.max_integer_val)); t1; t1;
    t1
  }

  function method CRemoveExecutedRequestBatch(reqs: seq<CRequest>, batch: CRequestBatch): seq<CRequest>
    requires forall i: CRequest {:trigger CRequestIsValid(i)} {:trigger i in reqs} :: i in reqs ==> CRequestIsValid(i)
    requires CRequestBatchIsValid(batch)
    ensures forall i: CRequest {:trigger CRequestIsValid(i)} {:trigger i.CRequest?} {:trigger i in CRemoveExecutedRequestBatch(reqs, batch)} :: (i in CRemoveExecutedRequestBatch(reqs, batch) ==> i.CRequest?) && (i in CRemoveExecutedRequestBatch(reqs, batch) ==> CRequestIsValid(i))
    ensures AbstractifySeq(CRemoveExecutedRequestBatch(reqs, batch), AbstractifyCRequestToRequest) == RemoveExecutedRequestBatch(AbstractifySeq(reqs, AbstractifyCRequestToRequest), AbstractifyCRequestBatchToRequestBatch(batch))
    decreases |batch|
  {
    if |batch| == 0 then
      reqs
    else
      CRemoveExecutedRequestBatch(CRemoveAllSatisfiedRequestsInSequence(reqs, batch[0]), batch[1..])
  }

  function method CElectionStateReflectExecutedRequestBatch(es: CElectionState, batch: CRequestBatch): CElectionState
    requires CElectionStateIsValid(es)
    requires CRequestBatchIsValid(batch)
    ensures var es': CElectionState := CElectionStateReflectExecutedRequestBatch(es, batch); CElectionStateIsValid(es') && ElectionStateReflectExecutedRequestBatch(AbstractifyCElectionStateToElectionState(es), AbstractifyCElectionStateToElectionState(es'), AbstractifyCRequestBatchToRequestBatch(batch))
    decreases es, batch
  {
    var t1: CElectionState := es.(requests_received_prev_epochs := CRemoveExecutedRequestBatch(es.requests_received_prev_epochs, batch), requests_received_this_epoch := CRemoveExecutedRequestBatch(es.requests_received_this_epoch, batch));
    t1
  }
}

module Impl__LiveByzRSL__Broadcast_i {

  import opened Native__NativeTypes_s

  import opened LiveByzRSL__Broadcast_i

  import opened LiveByzRSL__CConfiguration_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__PacketParsing_i

  import opened LiveByzRSL__ConstantsState_i
  function method {:opaque} {:fuel 0, 0} BuildBroadcastToEveryone(config: CConfiguration, my_index: int, msg: CMessage): CBroadcast
    requires CConfigurationIsValid(config)
    requires ReplicaIndexValid(my_index, config)
    requires CMessageIsAbstractable(msg)
    requires Marshallable(msg)
    ensures var broadcast: CBroadcast := BuildBroadcastToEveryone(config, my_index, msg); CBroadcastIsValid(broadcast) && CBroadcastIsAbstractable(broadcast) && OutboundPacketsHasCorrectSrc(Broadcast(broadcast), config.replica_ids[my_index]) && LBroadcastToEveryone(AbstractifyCConfigurationToLConfiguration(config), my_index as int, AbstractifyCMessageToRslMessage(msg), AbstractifyCBroadcastToRlsPacketSeq(broadcast))
    decreases config, my_index, msg
  {
    if my_index < |config.replica_ids| then
      CBroadcast(config.replica_ids[my_index], config.replica_ids, msg)
    else
      CBroadcastNop
  }
}

module LiveByzRSL__CheckValSafetyImpl_i {

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__CTypes_i

  import opened LiveByzRSL__CheckValSafety_i

  import opened GenericRefinement_i
  function method CConvert1bPacketsSeqToMsgSeq(S: seq<CPacket>): seq<CMessage>
    requires forall i: CPacket {:trigger CPacketIsValid(i)} {:trigger i in S} :: i in S ==> CPacketIsValid(i)
    requires CSeqOfMessage1b(S)
    requires forall p: CPacket {:trigger p.msg} {:trigger p in S} :: p in S ==> p.msg.CMessage_1b?
    ensures |S| == |CConvert1bPacketsSeqToMsgSeq(S)|
    ensures forall m: CMessage {:trigger m.CMessage_1b?} {:trigger m in CConvert1bPacketsSeqToMsgSeq(S)} :: m in CConvert1bPacketsSeqToMsgSeq(S) ==> m.CMessage_1b?
    ensures var lr: seq<RslMessage> := Convert1bPacketsSeqToMsgSeq(AbstractifySeq(S, AbstractifyCPacketToRslPacket)); var cr: seq<CMessage> := CConvert1bPacketsSeqToMsgSeq(S); (forall i: CMessage {:trigger CMessageIsValid(i)} {:trigger i in cr} :: i in cr ==> CMessageIsValid(i)) && AbstractifySeq(cr, AbstractifyCMessageToRslMessage) == lr
    decreases S
  {
    if |S| == 0 then
      []
    else
      reveal_Convert1bPacketsSeqToMsgSeq(); assert CPacketIsValid(S[0]); assert CMessageIsValid(S[0].msg); [S[0].msg] + CConvert1bPacketsSeqToMsgSeq(S[1..])
  }

  function method CSeqOfMessage1b(S: seq<CPacket>): bool
    requires forall i: CPacket {:trigger CPacketIsValid(i)} {:trigger i in S} :: i in S ==> CPacketIsValid(i)
    ensures var lr: bool := LSeqOfMessage1b(AbstractifySeq(S, AbstractifyCPacketToRslPacket)); var cr: bool := CSeqOfMessage1b(S); cr == lr
    decreases S
  {
    forall p: CPacket {:trigger p.msg} {:trigger p in S} :: 
      p in S ==>
        p.msg.CMessage_1b?
  }

  function method CSetOfMessage1bAboutBallot(S: seq<CPacket>, b: CBallot): bool
    requires forall i: CPacket {:trigger CPacketIsValid(i)} {:trigger i in S} :: i in S ==> CPacketIsValid(i)
    requires CBallotIsValid(b)
    ensures var lr: bool := LSetOfMessage1bAboutBallot(AbstractifySeq(S, AbstractifyCPacketToRslPacket), AbstractifyCBallotToBallot(b)); var cr: bool := CSetOfMessage1bAboutBallot(S, b); cr == lr
    decreases S, b
  {
    CSeqOfMessage1b(S) &&
    forall p: CPacket {:trigger p.msg} {:trigger p in S} :: 
      p in S ==>
        p.msg.bal_1b == b
  }

  function method CAllAcceptorsHadNoProposal(S: seq<CPacket>, opn: COperationNumber): bool
    requires forall i: CPacket {:trigger CPacketIsValid(i)} {:trigger i in S} :: i in S ==> CPacketIsValid(i)
    requires COperationNumberIsValid(opn)
    requires CSeqOfMessage1b(S)
    ensures var lr: bool := LAllAcceptorsHadNoProposal(AbstractifySeq(S, AbstractifyCPacketToRslPacket), AbstractifyCOperationNumberToOperationNumber(opn)); var cr: bool := CAllAcceptorsHadNoProposal(S, opn); cr == lr
    decreases S, opn
  {
    forall p: CPacket {:trigger p.msg} {:trigger p in S} :: 
      p in S ==>
        !(opn in p.msg.votes)
  }

  function method CCountInVotes(v: CRequestBatch, c: CBallot, opn: COperationNumber, S: seq<CPacket>): int
    requires CRequestBatchIsValid(v)
    requires CBallotIsValid(c)
    requires COperationNumberIsValid(opn)
    requires forall i: CPacket {:trigger CPacketIsValid(i)} {:trigger i in S} :: i in S ==> CPacketIsValid(i)
    requires forall p: CPacket {:trigger p.msg} {:trigger p in S} :: p in S ==> p.msg.CMessage_1b?
    ensures CCountInVotes(v, c, opn, S) > 0 ==> exists p: CPacket {:trigger p.msg} {:trigger p in S} :: p in S && opn in p.msg.votes && CBalLeq(c, p.msg.votes[opn].max_value_bal)
    ensures var lr: int := CountInVotes(AbstractifyCRequestBatchToRequestBatch(v), AbstractifyCBallotToBallot(c), AbstractifyCOperationNumberToOperationNumber(opn), AbstractifySeq(S, AbstractifyCPacketToRslPacket)); var cr: int := CCountInVotes(v, c, opn, S); cr == lr
    decreases v, c, opn, S
  {
    ghost var ls: seq<RslPacket> := AbstractifySeq(S, AbstractifyCPacketToRslPacket);
    ghost var lv: RequestBatch := AbstractifyCRequestBatchToRequestBatch(v);
    ghost var lopn: OperationNumber := AbstractifyCOperationNumberToOperationNumber(opn);
    ghost var lc: Ballot := AbstractifyCBallotToBallot(c);
    if |S| == 0 then
      0
    else
      lemma_seq_sub(S, AbstractifyCPacketToRslPacket, 1, |S|); ghost var r_remain: int := CCountInVotes(v, c, opn, S[1..]); ghost var ls_remian: seq<RslPacket> := AbstractifySeq(S[1..], AbstractifyCPacketToRslPacket); ghost var lr_remian: int := CountInVotes(lv, lc, lopn, ls_remian); assert r_remain == lr_remian; ghost var cur: int := if opn in S[0].msg.votes && CBalLeq(c, S[0].msg.votes[opn].max_value_bal) && S[0].msg.votes[opn].max_val == v then 1 else 0; ghost var s_first: CPacket := S[0]; assert CPacketIsValid(s_first); CCountInVotes(v, c, opn, S[1..]) + if opn in S[0].msg.votes && CBalLeq(c, S[0].msg.votes[opn].max_value_bal) && S[0].msg.votes[opn].max_val == v then 1 else 0
  }

  function method CSetOfMessage1b(S: seq<CPacket>): bool
    requires forall i: CPacket {:trigger CPacketIsValid(i)} {:trigger i in S} :: i in S ==> CPacketIsValid(i)
    ensures var lr: bool := LSetOfMessage1b(AbstractifySeq(S, AbstractifyCPacketToRslPacket)); var cr: bool := CSetOfMessage1b(S); cr == lr
    decreases S
  {
    forall p: CPacket {:trigger p.msg} {:trigger p in S} :: 
      p in S ==>
        p.msg.CMessage_1b?
  }

  function method Cmax_balInS(c: CBallot, S: seq<CPacket>, opn: COperationNumber): bool
    requires CBallotIsValid(c)
    requires forall i: CPacket {:trigger CPacketIsValid(i)} {:trigger i in S} :: i in S ==> CPacketIsValid(i)
    requires COperationNumberIsValid(opn)
    requires CSetOfMessage1b(S)
    ensures var lr: bool := Lmax_balInS(AbstractifyCBallotToBallot(c), AbstractifySeq(S, AbstractifyCPacketToRslPacket), AbstractifyCOperationNumberToOperationNumber(opn)); var cr: bool := Cmax_balInS(c, S, opn); cr == lr
    decreases c, S, opn
  {
    forall p: CPacket {:trigger p.msg} {:trigger p in S} :: 
      p in S &&
      opn in p.msg.votes ==>
        CBalLeq(p.msg.votes[opn].max_value_bal, c)
  }

  function method CAllVotesWithLargerBalHasSameValue(v: CRequestBatch, b: CBallot, p1bs: seq<CPacket>, opn: COperationNumber): bool
    requires CRequestBatchIsValid(v)
    requires CBallotIsValid(b)
    requires forall i: CPacket {:trigger CPacketIsValid(i)} {:trigger i in p1bs} :: i in p1bs ==> CPacketIsValid(i)
    requires COperationNumberIsValid(opn)
    requires forall p: CPacket {:trigger p.msg} {:trigger p in p1bs} :: p in p1bs ==> p.msg.CMessage_1b?
    ensures var lr: bool := AllVotesWithLargerBalHasSameValue(AbstractifyCRequestBatchToRequestBatch(v), AbstractifyCBallotToBallot(b), AbstractifySeq(p1bs, AbstractifyCPacketToRslPacket), AbstractifyCOperationNumberToOperationNumber(opn)); var cr: bool := CAllVotesWithLargerBalHasSameValue(v, b, p1bs, opn); cr == lr
    decreases v, b, p1bs, opn
  {
    forall p: CPacket {:trigger p.msg} {:trigger p in p1bs} :: 
      p in p1bs &&
      opn in p.msg.votes &&
      CBalLeq(b, p.msg.votes[opn].max_value_bal) ==>
        p.msg.votes[opn].max_val == v
  }

  function method CValIsSafeAt(v: CRequestBatch, p1bs: seq<CPacket>, opn: COperationNumber, byzq: int, wq: int): bool
    requires CRequestBatchIsValid(v)
    requires forall i: CPacket {:trigger CPacketIsValid(i)} {:trigger i in p1bs} :: i in p1bs ==> CPacketIsValid(i)
    requires COperationNumberIsValid(opn)
    requires forall p: CPacket {:trigger p.msg} {:trigger p in p1bs} :: p in p1bs ==> p.msg.CMessage_1b?
    ensures var lr: bool := LValIsSafeAt(AbstractifyCRequestBatchToRequestBatch(v), AbstractifySeq(p1bs, AbstractifyCPacketToRslPacket), AbstractifyCOperationNumberToOperationNumber(opn), byzq, wq); var cr: bool := CValIsSafeAt(v, p1bs, opn, byzq, wq); cr == lr
    decreases v, p1bs, opn, byzq, wq
  {
    exists p: CPacket {:trigger p.msg} {:trigger p in p1bs} :: 
      p in p1bs &&
      opn in p.msg.votes &&
      CCountInVotes(v, p.msg.votes[opn].max_value_bal, opn, p1bs) >= wq &&
      CAllVotesWithLargerBalHasSameValue(v, p.msg.votes[opn].max_value_bal, p1bs, opn)
  }
}

module LiveByzRSL__AcceptorModel_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened LiveByzRSL__Acceptor_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__CConfiguration_i

  import opened LiveByzRSL__CTypes_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__PacketParsing_i

  import opened LiveByzRSL__ParametersState_i

  import opened LiveByzRSL__ConstantsState_i

  import opened LiveByzRSL__Types_i

  import opened Impl__LiveByzRSL__Broadcast_i

  import opened Collections__Maps_i

  import opened Collections__Maps2_s

  import opened Collections__Sets_i

  import opened Common__NodeIdentity_i

  import opened Common__UpperBound_s

  import opened Common__UpperBound_i

  import opened Common__Util_i

  import opened Common__UdpClient_i

  import opened Environment_s

  import opened Collections__CountMatches_i

  import opened GenericRefinement_i
  datatype CAcceptorTuple = CAcceptorTuple(received_2av_packets: seq<CPacket>)

  type CReceived2avs = map<COperationNumber, CAcceptorTuple>

  datatype CValToBeSent2b = CValToBeSent2bKnown(v: CRequestBatch, bal: CBallot) | CValToBeSent2bUnknown

  datatype CAcceptor = CAcceptor(constants: CReplicaConstants, max_bal: CBallot, votes: CVotes, last_checkpointed_operation: seq<COperationNumber>, log_truncation_point: COperationNumber, received_1b_packets: seq<CPacket>, received_2avs: CReceived2avs, opn_to_be_send_2b: COperationNumber, val_to_be_sent_2b: CValToBeSent2b)

  predicate CAcceptorTupleIsValid(s: CAcceptorTuple)
    decreases s
  {
    CAcceptorTupleIsAbstractable(s) &&
    SeqIsValid(s.received_2av_packets, CPacketIsValid)
  }

  predicate CAcceptorTupleIsAbstractable(s: CAcceptorTuple)
    decreases s
  {
    SeqIsAbstractable(s.received_2av_packets, AbstractifyCPacketToRslPacket)
  }

  function AbstractifyCAcceptorTupleToAcceptorTuple(s: CAcceptorTuple): AcceptorTuple
    requires CAcceptorTupleIsAbstractable(s)
    decreases s
  {
    AcceptorTuple(AbstractifySeq(s.received_2av_packets, AbstractifyCPacketToRslPacket))
  }

  predicate CReceived2avsIsAbstractable(s: CReceived2avs)
    decreases s
  {
    forall i: int {:trigger s[i]} {:trigger COperationNumberIsAbstractable(i)} {:trigger i in s} :: 
      (i in s ==>
        COperationNumberIsAbstractable(i)) &&
      (i in s ==>
        CAcceptorTupleIsAbstractable(s[i]))
  }

  predicate CReceived2avsIsValid(s: CReceived2avs)
    decreases s
  {
    CReceived2avsIsAbstractable(s) &&
    forall i: int {:trigger s[i]} {:trigger COperationNumberIsValid(i)} {:trigger i in s} :: 
      (i in s ==>
        COperationNumberIsValid(i)) &&
      (i in s ==>
        CAcceptorTupleIsValid(s[i]))
  }

  function AbstractifyCReceived2avsToReceived2avs(s: CReceived2avs): Received2avs
    requires CReceived2avsIsAbstractable(s)
    decreases s
  {
    AbstractifyMap(s, AbstractifyCOperationNumberToOperationNumber, AbstractifyCAcceptorTupleToAcceptorTuple, AbstractifyOperationNumberToCOperationNumber)
  }

  predicate CValToBeSent2bIsValid(s: CValToBeSent2b)
    decreases s
  {
    match s
    case CValToBeSent2bKnown(v, bal) =>
      CValToBeSent2bIsAbstractable(s) &&
      CRequestBatchIsValid(s.v) &&
      CBallotIsValid(s.bal)
    case CValToBeSent2bUnknown() =>
      CValToBeSent2bIsAbstractable(s)
  }

  predicate CValToBeSent2bIsAbstractable(s: CValToBeSent2b)
    decreases s
  {
    match s
    case CValToBeSent2bKnown(v, bal) =>
      CRequestBatchIsAbstractable(s.v) &&
      CBallotIsAbstractable(s.bal)
    case CValToBeSent2bUnknown() =>
      true
  }

  function AbstractifyCValToBeSent2bToValToBeSent2b(s: CValToBeSent2b): ValToBeSent2b
    requires CValToBeSent2bIsAbstractable(s)
    decreases s
  {
    match s
    case CValToBeSent2bKnown(v, bal) =>
      ValToBeSent2bKnown(AbstractifyCRequestBatchToRequestBatch(s.v), AbstractifyCBallotToBallot(s.bal))
    case CValToBeSent2bUnknown() =>
      ValToBeSent2bUnknown()
  }

  predicate CAcceptorIsValid(s: CAcceptor)
    decreases s
  {
    CAcceptorIsAbstractable(s) &&
    CReplicaConstantsIsValid(s.constants) &&
    CBallotIsValid(s.max_bal) &&
    CVotesIsValid(s.votes) &&
    (forall i: int {:trigger COperationNumberIsValid(i)} {:trigger i in s.last_checkpointed_operation} :: 
      i in s.last_checkpointed_operation ==>
        COperationNumberIsValid(i)) &&
    COperationNumberIsValid(s.log_truncation_point) &&
    SeqIsValid(s.received_1b_packets, CPacketIsValid) &&
    CReceived2avsIsValid(s.received_2avs) &&
    COperationNumberIsValid(s.opn_to_be_send_2b) &&
    CValToBeSent2bIsValid(s.val_to_be_sent_2b) &&
    |s.last_checkpointed_operation| == |s.constants.all.config.replica_ids|
  }

  predicate CAcceptorIsAbstractable(s: CAcceptor)
    decreases s
  {
    CReplicaConstantsIsAbstractable(s.constants) &&
    CBallotIsAbstractable(s.max_bal) &&
    CVotesIsAbstractable(s.votes) &&
    (forall i: int {:trigger COperationNumberIsAbstractable(i)} {:trigger i in s.last_checkpointed_operation} :: 
      i in s.last_checkpointed_operation ==>
        COperationNumberIsAbstractable(i)) &&
    COperationNumberIsAbstractable(s.log_truncation_point) &&
    SeqIsAbstractable(s.received_1b_packets, AbstractifyCPacketToRslPacket) &&
    CReceived2avsIsAbstractable(s.received_2avs) &&
    COperationNumberIsAbstractable(s.opn_to_be_send_2b) &&
    CValToBeSent2bIsAbstractable(s.val_to_be_sent_2b)
  }

  function AbstractifyCAcceptorToLAcceptor(s: CAcceptor): LAcceptor
    requires CAcceptorIsAbstractable(s)
    decreases s
  {
    LAcceptor(AbstractifyCReplicaConstantsToLReplicaConstants(s.constants), AbstractifyCBallotToBallot(s.max_bal), AbstractifyCVotesToVotes(s.votes), AbstractifySeq(s.last_checkpointed_operation, AbstractifyCOperationNumberToOperationNumber), AbstractifyCOperationNumberToOperationNumber(s.log_truncation_point), AbstractifySeq(s.received_1b_packets, AbstractifyCPacketToRslPacket), AbstractifyCReceived2avsToReceived2avs(s.received_2avs), AbstractifyCOperationNumberToOperationNumber(s.opn_to_be_send_2b), AbstractifyCValToBeSent2bToValToBeSent2b(s.val_to_be_sent_2b))
  }

  function method CCountMatchedValInReceived2avs(s: seq<CPacket>, v: CRequestBatch): int
    requires forall i: CPacket {:trigger CPacketIsValid(i)} {:trigger i in s} :: i in s ==> CPacketIsValid(i)
    requires CRequestBatchIsValid(v)
    requires forall p: CPacket {:trigger p.msg} {:trigger p in s} :: p in s ==> p.msg.CMessage_2av?
    ensures var lr: int := CountMatchedValInReceived2avs(AbstractifySeq(s, AbstractifyCPacketToRslPacket), AbstractifyCRequestBatchToRequestBatch(v)); var cr: int := CCountMatchedValInReceived2avs(s, v); cr == lr
    decreases s, v
  {
    ghost var ls: seq<RslPacket> := AbstractifySeq(s, AbstractifyCPacketToRslPacket);
    ghost var lv: RequestBatch := AbstractifyCRequestBatchToRequestBatch(v);
    if |s| == 0 then
      0
    else
      lemma_seq_sub(s, AbstractifyCPacketToRslPacket, 0, |s| - 1); ghost var r_prev: int := CCountMatchedValInReceived2avs(s[..|s| - 1], v); ghost var ls_prev: seq<RslPacket> := AbstractifySeq(s[..|s| - 1], AbstractifyCPacketToRslPacket); ghost var lr_prev: int := CountMatchedValInReceived2avs(ls_prev, lv); assert r_prev == lr_prev; ghost var cur: int := if s[|s| - 1].msg.val_2av == v then 1 else 0; ghost var s_last: CPacket := s[|s| - 1]; assert CPacketIsValid(s_last); CCountMatchedValInReceived2avs(s[..|s| - 1], v) + if s[|s| - 1].msg.val_2av == v then 1 else 0
  }

  function method CCountMatchedInRequestBatches(s: seq<CRequestBatch>, v: CRequestBatch): int
    requires forall i: CRequestBatch {:trigger CRequestBatchIsValid(i)} {:trigger i in s} :: i in s ==> CRequestBatchIsValid(i)
    requires CRequestBatchIsValid(v)
    ensures var lr: int := CountMatchedInRequestBatches(AbstractifySeq(s, AbstractifyCRequestBatchToRequestBatch), AbstractifyCRequestBatchToRequestBatch(v)); var cr: int := CCountMatchedInRequestBatches(s, v); cr == lr
    decreases s, v
  {
    ghost var ls: seq<RequestBatch> := AbstractifySeq(s, AbstractifyCRequestBatchToRequestBatch);
    ghost var lv: RequestBatch := AbstractifyCRequestBatchToRequestBatch(v);
    if |s| == 0 then
      0
    else
      lemma_seq_sub(s, AbstractifyCRequestBatchToRequestBatch, 0, |s| - 1); ghost var r_prev: int := CCountMatchedInRequestBatches(s[..|s| - 1], v); ghost var ls_prev: seq<RequestBatch> := AbstractifySeq(s[..|s| - 1], AbstractifyCRequestBatchToRequestBatch); ghost var lr_prev: int := CountMatchedInRequestBatches(ls_prev, lv); assert r_prev == lr_prev; ghost var cur: int := if s[|s| - 1] == v then 1 else 0; ghost var s_last: seq<CRequest> := s[|s| - 1]; assert CRequestBatchIsValid(s_last); CCountMatchedInRequestBatches(s[..|s| - 1], v) + if s[|s| - 1] == v then 1 else 0
  }

  function method CHasReceivedSame2avFromByzQuorum(r2avs: CAcceptorTuple, n: int): bool
    requires CAcceptorTupleIsValid(r2avs)
    requires forall p: CPacket {:trigger p.msg} {:trigger p in r2avs.received_2av_packets} :: p in r2avs.received_2av_packets ==> p.msg.CMessage_2av?
    ensures var lr: bool := HasReceivedSame2avFromByzQuorum(AbstractifyCAcceptorTupleToAcceptorTuple(r2avs), n); var cr: bool := CHasReceivedSame2avFromByzQuorum(r2avs, n); cr == lr
    decreases r2avs, n
  {
    exists p: CPacket {:trigger p.msg} {:trigger p in r2avs.received_2av_packets} :: 
      p in r2avs.received_2av_packets &&
      CCountMatchedValInReceived2avs(r2avs.received_2av_packets, p.msg.val_2av) >= n
  }

  function method CIsByzQuorumSendSame2av(vals: seq<CRequestBatch>, n: int): bool
    requires forall i: CRequestBatch {:trigger CRequestBatchIsValid(i)} {:trigger i in vals} :: i in vals ==> CRequestBatchIsValid(i)
    ensures var lr: bool := IsByzQuorumSendSame2av(AbstractifySeq(vals, AbstractifyCRequestBatchToRequestBatch), n); var cr: bool := CIsByzQuorumSendSame2av(vals, n); cr == lr
    decreases vals, n
  {
    exists v: CRequestBatch {:trigger CCountMatchedInRequestBatches(vals, v)} {:trigger v in vals} :: 
      v in vals &&
      CCountMatchedInRequestBatches(vals, v) >= n
  }

  function method CHasReceived2avOfOpn(received_2avs: CReceived2avs, opn: COperationNumber): bool
    requires CReceived2avsIsValid(received_2avs)
    requires COperationNumberIsValid(opn)
    ensures var lr: bool := HasReceived2avOfOpn(AbstractifyCReceived2avsToReceived2avs(received_2avs), AbstractifyCOperationNumberToOperationNumber(opn)); var cr: bool := CHasReceived2avOfOpn(received_2avs, opn); cr == lr
    decreases received_2avs, opn
  {
    opn in received_2avs
  }

  function method CAcceptorTupleIsUniqueSeq(tup: CAcceptorTuple): bool
    requires CAcceptorTupleIsValid(tup)
    ensures var lr: bool := AcceptorTupleIsUniqueSeq(AbstractifyCAcceptorTupleToAcceptorTuple(tup)); var cr: bool := CAcceptorTupleIsUniqueSeq(tup); cr == lr
    decreases tup
  {
    lemma_CAcceptorTupleIsUniqueSeq(tup);
    forall i: int, j: int {:trigger tup.received_2av_packets[j], tup.received_2av_packets[i]} :: 
      (0 <= i < |tup.received_2av_packets| &&
      0 <= j < |tup.received_2av_packets| &&
      i != j ==>
        tup.received_2av_packets[i] != tup.received_2av_packets[j]) &&
      (0 <= i < |tup.received_2av_packets| &&
      0 <= j < |tup.received_2av_packets| &&
      i != j ==>
        tup.received_2av_packets[i].src != tup.received_2av_packets[j].src)
  }

  function method CReceived2avSetCorrect(r2avs: CAcceptorTuple, bal: CBallot, opn: COperationNumber, c: CConfiguration): bool
    requires CAcceptorTupleIsValid(r2avs)
    requires CBallotIsValid(bal)
    requires COperationNumberIsValid(opn)
    requires CConfigurationIsValid(c)
    ensures var lr: bool := Received2avSetCorrect(AbstractifyCAcceptorTupleToAcceptorTuple(r2avs), AbstractifyCBallotToBallot(bal), AbstractifyCOperationNumberToOperationNumber(opn), AbstractifyCConfigurationToLConfiguration(c)); var cr: bool := CReceived2avSetCorrect(r2avs, bal, opn, c); cr == lr
    decreases r2avs, bal, opn, c
  {
    |r2avs.received_2av_packets| <= |c.replica_ids| &&
    forall p: CPacket {:trigger p.src} {:trigger p.msg} {:trigger p in r2avs.received_2av_packets} :: 
      (p in r2avs.received_2av_packets ==>
        p.msg.CMessage_2av?) &&
      (p in r2avs.received_2av_packets ==>
        p.msg.opn_2av == opn) &&
      (p in r2avs.received_2av_packets ==>
        p.msg.bal_2av == bal) &&
      (p in r2avs.received_2av_packets ==>
        p.src in c.replica_ids)
  }

  function method CAcceptorStateCorrect(r2avs: CReceived2avs, bal: CBallot, c: CConfiguration): bool
    requires CReceived2avsIsValid(r2avs)
    requires CBallotIsValid(bal)
    requires CConfigurationIsValid(c)
    ensures var lr: bool := AcceptorStateCorrect(AbstractifyCReceived2avsToReceived2avs(r2avs), AbstractifyCBallotToBallot(bal), AbstractifyCConfigurationToLConfiguration(c)); var cr: bool := CAcceptorStateCorrect(r2avs, bal, c); cr == lr
    decreases r2avs, bal, c
  {
    forall opn: int {:trigger r2avs[opn]} {:trigger opn in r2avs} :: 
      (opn in r2avs ==>
        CReceived2avSetCorrect(r2avs[opn], bal, opn, c)) &&
      (opn in r2avs ==>
        CAcceptorTupleIsUniqueSeq(r2avs[opn]))
  }

  function method CIsLogTruncationPointValid(log_truncation_point: COperationNumber, last_checkpointed_operation: seq<COperationNumber>, config: CConfiguration): bool
    requires COperationNumberIsValid(log_truncation_point)
    requires forall i: int {:trigger COperationNumberIsValid(i)} {:trigger i in last_checkpointed_operation} :: i in last_checkpointed_operation ==> COperationNumberIsValid(i)
    requires CConfigurationIsValid(config)
    ensures var lr: bool := IsLogTruncationPointValid(AbstractifyCOperationNumberToOperationNumber(log_truncation_point), AbstractifySeq(last_checkpointed_operation, AbstractifyCOperationNumberToOperationNumber), AbstractifyCConfigurationToLConfiguration(config)); var cr: bool := CIsLogTruncationPointValid(log_truncation_point, last_checkpointed_operation, config); cr == lr
    decreases log_truncation_point, last_checkpointed_operation, config
  {
    assert AbstractifySeq(last_checkpointed_operation, AbstractifyCOperationNumberToOperationNumber) == last_checkpointed_operation;
    IsNthHighestValueInSequence(log_truncation_point, last_checkpointed_operation, CByzQuorumSize(config))
  }

  function method CRemoveVotesBeforeLogTruncationPoint(votes: CVotes, log_truncation_point: COperationNumber): CVotes
    requires CVotesIsValid(votes)
    requires COperationNumberIsValid(log_truncation_point)
    ensures var votes': CVotes := CRemoveVotesBeforeLogTruncationPoint(votes, log_truncation_point); CVotesIsValid(votes') && RemoveVotesBeforeLogTruncationPoint(AbstractifyCVotesToVotes(votes), AbstractifyCVotesToVotes(votes'), AbstractifyCOperationNumberToOperationNumber(log_truncation_point))
    decreases votes, log_truncation_point
  {
    var t1: map<int, CVote> := map opn: int {:trigger votes[opn]} {:trigger opn in votes} | opn in votes && opn >= log_truncation_point :: votes[opn];
    t1
  }

  function method CAddVoteAndRemoveOldOnes(votes: CVotes, new_opn: COperationNumber, new_vote: CVote, log_truncation_point: COperationNumber): CVotes
    requires CVotesIsValid(votes)
    requires COperationNumberIsValid(new_opn)
    requires CVoteIsValid(new_vote)
    requires COperationNumberIsValid(log_truncation_point)
    ensures var votes': CVotes := CAddVoteAndRemoveOldOnes(votes, new_opn, new_vote, log_truncation_point); CVotesIsValid(votes') && LAddVoteAndRemoveOldOnes(AbstractifyCVotesToVotes(votes), AbstractifyCVotesToVotes(votes'), AbstractifyCOperationNumberToOperationNumber(new_opn), AbstractifyCVoteToVote(new_vote), AbstractifyCOperationNumberToOperationNumber(log_truncation_point))
    decreases votes, new_opn, new_vote, log_truncation_point
  {
    var t1: map<int, CVote> := map opn: int {:trigger votes[opn]} {:trigger opn in votes.Keys + {new_opn}} | opn in votes.Keys + {new_opn} && opn >= log_truncation_point :: if opn == new_opn then new_vote else votes[opn];
    t1
  }

  function method CAcceptorInit(c: CReplicaConstants): CAcceptor
    requires CReplicaConstantsIsValid(c)
    ensures var a: CAcceptor := CAcceptorInit(c); CAcceptorIsValid(a) && LAcceptorInit(AbstractifyCAcceptorToLAcceptor(a), AbstractifyCReplicaConstantsToLReplicaConstants(c))
    decreases c
  {
    var t1: CReplicaConstants := c;
    var t2: CBallot := CBallot(0, 0);
    var t3: map<int, CVote> := map[];
    var t4: seq<int> := seq(|c.all.config.replica_ids|, (idx: int) => 0);
    var t5: int := 0;
    var t6: map<int, CAcceptorTuple> := map[];
    var t7: seq<CPacket> := [];
    var t8: int := 0;
    var t9: CValToBeSent2b := CValToBeSent2bUnknown();
    CAcceptor(t1, t2, t3, t4, t5, t7, t6, t8, t9)
  }

  function method CAcceptorMaybeEnterNewView(s: CAcceptor): CAcceptor
    requires CAcceptorIsValid(s)
    ensures var s': CAcceptor := CAcceptorMaybeEnterNewView(s); CAcceptorIsValid(s') && LAcceptorMaybeEnterNewView(AbstractifyCAcceptorToLAcceptor(s), AbstractifyCAcceptorToLAcceptor(s'))
    decreases s
  {
    var t1: CAcceptor := s.(received_1b_packets := []);
    t1
  }

  function method CAcceptorProcess1a(s: CAcceptor, inp: CPacket): (CAcceptor, OutboundPackets)
    requires CAcceptorIsValid(s)
    requires CPacketIsValid(inp)
    requires inp.msg.CMessage_1a?
    ensures var (s': CAcceptor, sent_packets: OutboundPackets) := CAcceptorProcess1a(s, inp); CAcceptorIsValid(s') && OutboundPacketsIsValid(sent_packets) && LAcceptorProcess1a(AbstractifyCAcceptorToLAcceptor(s), AbstractifyCAcceptorToLAcceptor(s'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets))
    decreases s, inp
  {
    var t1: (OutboundPackets, CAcceptor) := var m: CMessage := inp.msg; var t1: (CAcceptor, OutboundPackets) := if inp.src in s.constants.all.config.replica_ids && CBalLt(s.max_bal, m.bal_1a) && CReplicaConstantsValid(s.constants) then var t1: OutboundPackets := Broadcast(BuildBroadcastToEveryone(s.constants.all.config, s.constants.my_index, CMessage_1b(m.bal_1a, s.log_truncation_point, s.votes))); var t2: CAcceptor := s.(max_bal := m.bal_1a); (t2, t1) else var t1: CAcceptor := s; var t2: OutboundPackets := Broadcast(CBroadcastNop); (t1, t2); (t1.1, t1.0);
    (t1.1, t1.0)
  }

  function method CAcceptorProcess1b(s: CAcceptor, p: CPacket): CAcceptor
    requires CAcceptorIsValid(s)
    requires CPacketIsValid(p)
    requires p.msg.CMessage_1b?
    requires p.src in s.constants.all.config.replica_ids
    requires forall other_packet: CPacket {:trigger other_packet.src} {:trigger other_packet in s.received_1b_packets} :: other_packet in s.received_1b_packets ==> other_packet.src != p.src
    ensures var s': CAcceptor := CAcceptorProcess1b(s, p); CAcceptorIsValid(s') && LAcceptorProcess1b(AbstractifyCAcceptorToLAcceptor(s), AbstractifyCAcceptorToLAcceptor(s'), AbstractifyCPacketToRslPacket(p))
    decreases s, p
  {
    var t1: CAcceptor := s.(received_1b_packets := s.received_1b_packets + [p]);
    t1
  }

  function method CAcceptorProcess1c(s: CAcceptor, inp: CPacket): (CAcceptor, OutboundPackets)
    requires CAcceptorIsValid(s)
    requires CPacketIsValid(inp)
    requires inp.msg.CMessage_1c?
    requires inp.src in s.constants.all.config.replica_ids
    requires CBalLeq(s.max_bal, inp.msg.bal_1c)
    requires CLeqUpperBound(inp.msg.opn_1c, s.constants.all.params.max_integer_val)
    ensures var (s': CAcceptor, sent_packets: OutboundPackets) := CAcceptorProcess1c(s, inp); CAcceptorIsValid(s') && OutboundPacketsIsValid(sent_packets) && LAcceptorProcess1c(AbstractifyCAcceptorToLAcceptor(s), AbstractifyCAcceptorToLAcceptor(s'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets))
    decreases s, inp
  {
    var t1: (OutboundPackets, CAcceptor) := var m: CMessage := inp.msg; var t1: (CAcceptor, OutboundPackets) := var newLogTruncationPoint: int := if inp.msg.opn_1c - s.constants.all.params.max_log_length + 1 > s.log_truncation_point then inp.msg.opn_1c - s.constants.all.params.max_log_length + 1 else s.log_truncation_point; var t1: OutboundPackets := Broadcast(BuildBroadcastToEveryone(s.constants.all.config, s.constants.my_index, CMessage_2av(m.bal_1c, m.opn_1c, m.val_1c))); var t2: map<COperationNumber, CVote> := if s.log_truncation_point <= inp.msg.opn_1c then var t1: CVotes := CAddVoteAndRemoveOldOnes(s.votes, m.opn_1c, CVote(m.bal_1c, m.val_1c), newLogTruncationPoint); t1 else var t1: CVotes := s.votes; t1; var t3: CAcceptor := s.(max_bal := m.bal_1c, log_truncation_point := newLogTruncationPoint, votes := t2); (t3, t1); (t1.1, t1.0);
    (t1.1, t1.0)
  }

  function method CAcceptorProcess2av(s: CAcceptor, inp: CPacket): CAcceptor
    requires CAcceptorIsValid(s)
    requires CPacketIsValid(inp)
    requires inp.msg.CMessage_2av?
    ensures var s': CAcceptor := CAcceptorProcess2av(s, inp); CAcceptorIsValid(s') && LAcceptorProcess2av(AbstractifyCAcceptorToLAcceptor(s), AbstractifyCAcceptorToLAcceptor(s'), AbstractifyCPacketToRslPacket(inp))
    decreases s, inp
  {
    lemma_AbstractifyMap_properties(s.received_2avs, AbstractifyCOperationNumberToOperationNumber, AbstractifyCAcceptorTupleToAcceptorTuple, AbstractifyOperationNumberToCOperationNumber);
    ghost var ss: LAcceptor := AbstractifyCAcceptorToLAcceptor(s);
    ghost var p: RslPacket := AbstractifyCPacketToRslPacket(inp);
    var t1: CAcceptor := var m: CMessage := inp.msg; var t1: CAcceptor := var opn: COperationNumber := m.opn_2av; var t1: CAcceptor := if inp.src !in s.constants.all.config.replica_ids || CBalLt(m.bal_2av, s.max_bal) then var t1: CAcceptor := s; t1 else var t1: CAcceptor := if CBalLt(s.max_bal, m.bal_2av) then var t1: CAcceptor := var tup': CAcceptorTuple := CAcceptorTuple([inp]); assert CAcceptorTupleIsAbstractable(tup'); ghost var t': AcceptorTuple := AcceptorTuple([p]); assert t' == AbstractifyCAcceptorTupleToAcceptorTuple(tup'); var t1: CAcceptor := s.(max_bal := m.bal_2av, received_2avs := map[opn := tup']); t1; t1 else var t1: CAcceptor := if opn !in s.received_2avs then var t1: CAcceptor := var tup': CAcceptorTuple := CAcceptorTuple([inp]); assert CAcceptorTupleIsAbstractable(tup'); ghost var t': AcceptorTuple := AcceptorTuple([p]); assert t' == AbstractifyCAcceptorTupleToAcceptorTuple(tup'); var t1: CAcceptor := s.(received_2avs := s.received_2avs[opn := tup']); t1; t1 else var t1: CAcceptor := if exists p: CPacket {:trigger p.src} {:trigger p in s.received_2avs[opn].received_2av_packets} :: p in s.received_2avs[opn].received_2av_packets && p.src == inp.src then var t1: CAcceptor := s; t1 else var t1: CAcceptor := var tup: CAcceptorTuple := s.received_2avs[opn]; var t1: CAcceptor := var tup': CAcceptorTuple := tup.(received_2av_packets := tup.received_2av_packets + [inp]); ghost var t: AcceptorTuple := ss.received_2avs[opn]; ghost var t': AcceptorTuple := t.(received_2av_packets := t.received_2av_packets + [p]); assert t' == AbstractifyCAcceptorTupleToAcceptorTuple(tup'); var t1: CAcceptor := s.(received_2avs := s.received_2avs[opn := tup']); t1; t1; t1; t1; t1; t1; t1; t1;
    t1
  }

  function method CAcceptorDecide2bVal(s: CAcceptor, bal: CBallot, opn: COperationNumber, v: CRequestBatch): CAcceptor
    requires CAcceptorIsValid(s)
    requires CBallotIsValid(bal)
    requires COperationNumberIsValid(opn)
    requires CRequestBatchIsValid(v)
    requires s.opn_to_be_send_2b in s.received_2avs
    requires opn == s.opn_to_be_send_2b
    requires s.val_to_be_sent_2b.CValToBeSent2bUnknown?
    ensures var s': CAcceptor := CAcceptorDecide2bVal(s, bal, opn, v); CAcceptorIsValid(s') && LAcceptorDecide2bVal(AbstractifyCAcceptorToLAcceptor(s), AbstractifyCAcceptorToLAcceptor(s'), AbstractifyCBallotToBallot(bal), AbstractifyCOperationNumberToOperationNumber(opn), AbstractifyCRequestBatchToRequestBatch(v))
    decreases s, bal, opn, v
  {
    var t1: CAcceptor := s.(val_to_be_sent_2b := CValToBeSent2bKnown(v, bal));
    t1
  }

  function method CAcceptorSent2b(s: CAcceptor): (CAcceptor, OutboundPackets)
    requires CAcceptorIsValid(s)
    requires s.val_to_be_sent_2b.CValToBeSent2bKnown?
    requires s.val_to_be_sent_2b.bal == s.max_bal
    ensures var (s': CAcceptor, sent_packets: OutboundPackets) := CAcceptorSent2b(s); CAcceptorIsValid(s') && OutboundPacketsIsValid(sent_packets) && LAcceptorSent2b(AbstractifyCAcceptorToLAcceptor(s), AbstractifyCAcceptorToLAcceptor(s'), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets))
    decreases s
  {
    var t1: (OutboundPackets, CAcceptor) := var opn: COperationNumber := s.opn_to_be_send_2b; var t1: (CAcceptor, OutboundPackets) := var v: CRequestBatch := s.val_to_be_sent_2b.v; var t1: (OutboundPackets, CAcceptor) := var bal: CBallot := s.val_to_be_sent_2b.bal; var t1: (CAcceptor, OutboundPackets) := var newLogTruncationPoint: int := if opn - s.constants.all.params.max_log_length + 1 > s.log_truncation_point then opn - s.constants.all.params.max_log_length + 1 else s.log_truncation_point; var t1: OutboundPackets := Broadcast(BuildBroadcastToEveryone(s.constants.all.config, s.constants.my_index, CMessage_2b(bal, opn, v))); var t2: (map<COperationNumber, CVote>, int) := if s.log_truncation_point <= opn then var t1: CVotes := CAddVoteAndRemoveOldOnes(s.votes, opn, CVote(bal, v), newLogTruncationPoint); var t2: int := newLogTruncationPoint; (t1, t2) else var t1: CVotes := s.votes; var t2: COperationNumber := s.log_truncation_point; (t1, t2); var t3: CAcceptor := s.(opn_to_be_send_2b := s.opn_to_be_send_2b + 1, val_to_be_sent_2b := CValToBeSent2bUnknown(), votes := t2.0, log_truncation_point := t2.1); (t3, t1); (t1.1, t1.0); (t1.1, t1.0); (t1.1, t1.0);
    (t1.1, t1.0)
  }

  function method CAcceptorForgetReceived2avs(s: CAcceptor, opn: COperationNumber): CAcceptor
    requires CAcceptorIsValid(s)
    requires COperationNumberIsValid(opn)
    ensures var s': CAcceptor := CAcceptorForgetReceived2avs(s, opn); CAcceptorIsValid(s') && LAcceptorForgetReceived2avs(AbstractifyCAcceptorToLAcceptor(s), AbstractifyCAcceptorToLAcceptor(s'), AbstractifyCOperationNumberToOperationNumber(opn))
    decreases s, opn
  {
    var t1: CAcceptor := if opn in s.received_2avs then var t1: CAcceptor := s.(received_2avs := RemoveElt(s.received_2avs, opn)); t1 else var t1: CAcceptor := s; t1;
    t1
  }

  function method CAcceptorProcessHeartbeat(s: CAcceptor, inp: CPacket): CAcceptor
    requires CAcceptorIsValid(s)
    requires CPacketIsValid(inp)
    requires inp.msg.CMessage_Heartbeat?
    ensures var s': CAcceptor := CAcceptorProcessHeartbeat(s, inp); CAcceptorIsValid(s') && LAcceptorProcessHeartbeat(AbstractifyCAcceptorToLAcceptor(s), AbstractifyCAcceptorToLAcceptor(s'), AbstractifyCPacketToRslPacket(inp))
    decreases s, inp
  {
    var t1: CAcceptor := if inp.src in s.constants.all.config.replica_ids then var t1: CAcceptor := var sender_index: int := CGetReplicaIndex(inp.src, s.constants.all.config); var t1: CAcceptor := if 0 <= sender_index && sender_index < |s.last_checkpointed_operation| && inp.msg.opn_ckpt > s.last_checkpointed_operation[sender_index] then var t1: CAcceptor := s.(last_checkpointed_operation := s.last_checkpointed_operation[sender_index := inp.msg.opn_ckpt]); t1 else var t1: CAcceptor := s; t1; t1; t1 else var t1: CAcceptor := s; t1;
    t1
  }

  function method CAcceptorTruncateLog(s: CAcceptor, opn: COperationNumber): CAcceptor
    requires CAcceptorIsValid(s)
    requires COperationNumberIsValid(opn)
    ensures var s': CAcceptor := CAcceptorTruncateLog(s, opn); CAcceptorIsValid(s') && LAcceptorTruncateLog(AbstractifyCAcceptorToLAcceptor(s), AbstractifyCAcceptorToLAcceptor(s'), AbstractifyCOperationNumberToOperationNumber(opn))
    decreases s, opn
  {
    var t1: CAcceptor := if opn <= s.log_truncation_point then var t1: CAcceptor := s; t1 else var t1: CVotes := CRemoveVotesBeforeLogTruncationPoint(s.votes, opn); var t2: CAcceptor := s.(log_truncation_point := opn, votes := t1); t2;
    t1
  }

  lemma lemma_AcceptorTupleIsUniqueSeq(tup: CAcceptorTuple, ltup: AcceptorTuple)
    requires CAcceptorTupleIsValid(tup)
    requires ltup == AbstractifyCAcceptorTupleToAcceptorTuple(tup)
    ensures (forall i: int, j: int {:trigger tup.received_2av_packets[j], tup.received_2av_packets[i]} :: (0 <= i < |tup.received_2av_packets| && 0 <= j < |tup.received_2av_packets| && i != j ==> tup.received_2av_packets[i] != tup.received_2av_packets[j]) && (0 <= i < |tup.received_2av_packets| && 0 <= j < |tup.received_2av_packets| && i != j ==> tup.received_2av_packets[i].src != tup.received_2av_packets[j].src)) == forall i: int, j: int {:trigger ltup.received_2av_packets[j], ltup.received_2av_packets[i]} :: (0 <= i < |ltup.received_2av_packets| && 0 <= j < |ltup.received_2av_packets| && i != j ==> ltup.received_2av_packets[i] != ltup.received_2av_packets[j]) && (0 <= i < |ltup.received_2av_packets| && 0 <= j < |ltup.received_2av_packets| && i != j ==> ltup.received_2av_packets[i].src != ltup.received_2av_packets[j].src)
    decreases tup, ltup
  {
  }

  lemma lemma_CAcceptorTupleIsUniqueSeq(tup: CAcceptorTuple)
    requires CAcceptorTupleIsValid(tup)
    ensures ghost var lr: bool := AcceptorTupleIsUniqueSeq(AbstractifyCAcceptorTupleToAcceptorTuple(tup)); ghost var cr: bool := forall i: int, j: int {:trigger tup.received_2av_packets[j], tup.received_2av_packets[i]} :: (0 <= i < |tup.received_2av_packets| && 0 <= j < |tup.received_2av_packets| && i != j ==> tup.received_2av_packets[i] != tup.received_2av_packets[j]) && (0 <= i < |tup.received_2av_packets| && 0 <= j < |tup.received_2av_packets| && i != j ==> tup.received_2av_packets[i].src != tup.received_2av_packets[j].src); cr == lr
    decreases tup
  {
  }
}

module LiveByzRSL__LearnerModel_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened LiveByzRSL__AppInterface_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__CTypes_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__AcceptorModel_i

  import opened LiveByzRSL__CConfiguration_i

  import opened LiveByzRSL__Learner_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__PacketParsing_i

  import opened LiveByzRSL__ConstantsState_i

  import opened LiveByzRSL__Types_i

  import opened Collections__Maps_i

  import opened Collections__Sets_i

  import opened Common__NodeIdentity_i

  import opened Common__SeqIsUnique_i

  import opened Common__SeqIsUniqueDef_i

  import opened Common__UdpClient_i

  import opened Concrete_NodeIdentity_i

  import opened GenericRefinement_i
  datatype CLearnerTuple = CLearnerTuple(received_2bs: seq<CPacket>)

  type CLearnerState = map<COperationNumber, CLearnerTuple>

  datatype CLearner = CLearner(constants: CReplicaConstants, max_ballot_seen: CBallot, unexecuted_learner_state: CLearnerState)

  predicate CLearnerTupleIsValid(s: CLearnerTuple)
    decreases s
  {
    CLearnerTupleIsAbstractable(s) &&
    SeqIsValid(s.received_2bs, CPacketIsValid)
  }

  predicate CLearnerTupleIsAbstractable(s: CLearnerTuple)
    decreases s
  {
    SeqIsAbstractable(s.received_2bs, AbstractifyCPacketToRslPacket)
  }

  function AbstractifyCLearnerTupleToLearnerTuple(s: CLearnerTuple): LearnerTuple
    requires CLearnerTupleIsAbstractable(s)
    decreases s
  {
    LearnerTuple(AbstractifySeq(s.received_2bs, AbstractifyCPacketToRslPacket))
  }

  predicate CLearnerStateIsAbstractable(s: CLearnerState)
    decreases s
  {
    forall i: int {:trigger s[i]} {:trigger COperationNumberIsAbstractable(i)} {:trigger i in s} :: 
      (i in s ==>
        COperationNumberIsAbstractable(i)) &&
      (i in s ==>
        CLearnerTupleIsAbstractable(s[i]))
  }

  predicate CLearnerStateIsValid(s: CLearnerState)
    decreases s
  {
    CLearnerStateIsAbstractable(s) &&
    forall i: int {:trigger s[i]} {:trigger COperationNumberIsValid(i)} {:trigger i in s} :: 
      (i in s ==>
        COperationNumberIsValid(i)) &&
      (i in s ==>
        CLearnerTupleIsValid(s[i]))
  }

  function AbstractifyCLearnerStateToLearnerState(s: CLearnerState): LearnerState
    requires CLearnerStateIsAbstractable(s)
    decreases s
  {
    AbstractifyMap(s, AbstractifyCOperationNumberToOperationNumber, AbstractifyCLearnerTupleToLearnerTuple, AbstractifyOperationNumberToCOperationNumber)
  }

  predicate CLearnerIsValid(s: CLearner)
    decreases s
  {
    CLearnerIsAbstractable(s) &&
    CReplicaConstantsIsValid(s.constants) &&
    CBallotIsValid(s.max_ballot_seen) &&
    CLearnerStateIsValid(s.unexecuted_learner_state)
  }

  predicate CLearnerIsAbstractable(s: CLearner)
    decreases s
  {
    CReplicaConstantsIsAbstractable(s.constants) &&
    CBallotIsAbstractable(s.max_ballot_seen) &&
    CLearnerStateIsAbstractable(s.unexecuted_learner_state)
  }

  function AbstractifyCLearnerToLLearner(s: CLearner): LLearner
    requires CLearnerIsAbstractable(s)
    decreases s
  {
    LLearner(AbstractifyCReplicaConstantsToLReplicaConstants(s.constants), AbstractifyCBallotToBallot(s.max_ballot_seen), AbstractifyCLearnerStateToLearnerState(s.unexecuted_learner_state))
  }

  function method CCountMatchedValInReceived2bs(s: seq<CPacket>, v: CRequestBatch): int
    requires forall i: CPacket {:trigger CPacketIsValid(i)} {:trigger i in s} :: i in s ==> CPacketIsValid(i)
    requires CRequestBatchIsValid(v)
    requires forall p: CPacket {:trigger p.msg} {:trigger p in s} :: p in s ==> p.msg.CMessage_2b?
    ensures var lr: int := CountMatchedValInReceived2bs(AbstractifySeq(s, AbstractifyCPacketToRslPacket), AbstractifyCRequestBatchToRequestBatch(v)); var cr: int := CCountMatchedValInReceived2bs(s, v); cr == lr
    decreases s, v
  {
    ghost var ls: seq<RslPacket> := AbstractifySeq(s, AbstractifyCPacketToRslPacket);
    ghost var lv: RequestBatch := AbstractifyCRequestBatchToRequestBatch(v);
    if |s| == 0 then
      0
    else
      lemma_seq_sub(s, AbstractifyCPacketToRslPacket, 0, |s| - 1); ghost var r_prev: int := CCountMatchedValInReceived2bs(s[..|s| - 1], v); ghost var ls_prev: seq<RslPacket> := AbstractifySeq(s[..|s| - 1], AbstractifyCPacketToRslPacket); ghost var lr_prev: int := CountMatchedValInReceived2bs(ls_prev, lv); assert r_prev == lr_prev; ghost var cur: int := if s[|s| - 1].msg.val_2b == v then 1 else 0; ghost var s_last: CPacket := s[|s| - 1]; assert CPacketIsValid(s_last); CCountMatchedValInReceived2bs(s[..|s| - 1], v) + if s[|s| - 1].msg.val_2b == v then 1 else 0
  }

  function method CIsWeakQuorumSendSame2b(vals: seq<CRequestBatch>, n: int): bool
    requires forall i: CRequestBatch {:trigger CRequestBatchIsValid(i)} {:trigger i in vals} :: i in vals ==> CRequestBatchIsValid(i)
    ensures var lr: bool := IsWeakQuorumSendSame2b(AbstractifySeq(vals, AbstractifyCRequestBatchToRequestBatch), n); var cr: bool := CIsWeakQuorumSendSame2b(vals, n); cr == lr
    decreases vals, n
  {
    exists v: CRequestBatch {:trigger CCountMatchedInRequestBatches(vals, v)} {:trigger v in vals} :: 
      v in vals &&
      CCountMatchedInRequestBatches(vals, v) >= n
  }

  function method CHasReceivedSame2bFromWeakQuorum(tup: CLearnerTuple, n: int): bool
    requires CLearnerTupleIsValid(tup)
    requires forall p: CPacket {:trigger p.msg} {:trigger p in tup.received_2bs} :: p in tup.received_2bs ==> p.msg.CMessage_2b?
    ensures var lr: bool := HasReceivedSame2bFromWeakQuorum(AbstractifyCLearnerTupleToLearnerTuple(tup), n); var cr: bool := CHasReceivedSame2bFromWeakQuorum(tup, n); cr == lr
    decreases tup, n
  {
    exists p: CPacket {:trigger p.msg} {:trigger p in tup.received_2bs} :: 
      p in tup.received_2bs &&
      CCountMatchedValInReceived2bs(tup.received_2bs, p.msg.val_2b) >= n
  }

  function method CLearnerTupleIsUniqueSeq(tup: CLearnerTuple): bool
    requires CLearnerTupleIsValid(tup)
    ensures var lr: bool := LearnerTupleIsUniqueSeq(AbstractifyCLearnerTupleToLearnerTuple(tup)); var cr: bool := CLearnerTupleIsUniqueSeq(tup); cr == lr
    decreases tup
  {
    lemma_CLearnerTupleIsUniqueSeq(tup);
    forall i: int, j: int {:trigger tup.received_2bs[j], tup.received_2bs[i]} :: 
      (0 <= i < |tup.received_2bs| &&
      0 <= j < |tup.received_2bs| &&
      i != j ==>
        tup.received_2bs[i] != tup.received_2bs[j]) &&
      (0 <= i < |tup.received_2bs| &&
      0 <= j < |tup.received_2bs| &&
      i != j ==>
        tup.received_2bs[i].src != tup.received_2bs[j].src)
  }

  function method CLearnerTupleCorrect(tup: CLearnerTuple, bal: CBallot, opn: COperationNumber, c: CConfiguration): bool
    requires CLearnerTupleIsValid(tup)
    requires CBallotIsValid(bal)
    requires COperationNumberIsValid(opn)
    requires CConfigurationIsValid(c)
    ensures var lr: bool := LearnerTupleCorrect(AbstractifyCLearnerTupleToLearnerTuple(tup), AbstractifyCBallotToBallot(bal), AbstractifyCOperationNumberToOperationNumber(opn), AbstractifyCConfigurationToLConfiguration(c)); var cr: bool := CLearnerTupleCorrect(tup, bal, opn, c); cr == lr
    decreases tup, bal, opn, c
  {
    |tup.received_2bs| <= |c.replica_ids| &&
    forall p: CPacket {:trigger p.src} {:trigger p.msg} {:trigger p in tup.received_2bs} :: 
      (p in tup.received_2bs ==>
        p.msg.CMessage_2b?) &&
      (p in tup.received_2bs ==>
        p.msg.opn_2b == opn) &&
      (p in tup.received_2bs ==>
        p.msg.bal_2b == bal) &&
      (p in tup.received_2bs ==>
        p.src in c.replica_ids)
  }

  function method CLearnerStateCorrect(ls: CLearnerState, bal: CBallot, c: CConfiguration): bool
    requires CLearnerStateIsValid(ls)
    requires CBallotIsValid(bal)
    requires CConfigurationIsValid(c)
    ensures var lr: bool := LearnerStateCorrect(AbstractifyCLearnerStateToLearnerState(ls), AbstractifyCBallotToBallot(bal), AbstractifyCConfigurationToLConfiguration(c)); var cr: bool := CLearnerStateCorrect(ls, bal, c); cr == lr
    decreases ls, bal, c
  {
    forall opn: int {:trigger ls[opn]} {:trigger opn in ls} :: 
      (opn in ls ==>
        CLearnerTupleCorrect(ls[opn], bal, opn, c)) &&
      (opn in ls ==>
        CLearnerTupleIsUniqueSeq(ls[opn]))
  }

  function method CLearnerInit(c: CReplicaConstants): CLearner
    requires CReplicaConstantsIsValid(c)
    ensures var l: CLearner := CLearnerInit(c); CLearnerIsValid(l) && LLearnerInit(AbstractifyCLearnerToLLearner(l), AbstractifyCReplicaConstantsToLReplicaConstants(c))
    decreases c
  {
    var t1: CReplicaConstants := c;
    var t2: CBallot := CBallot(0, 0);
    var t3: map<int, CLearnerTuple> := map[];
    CLearner(t1, t2, t3)
  }

  function method CLearnerProcess2b(s: CLearner, packet: CPacket): CLearner
    requires CLearnerIsValid(s)
    requires CPacketIsValid(packet)
    requires packet.msg.CMessage_2b?
    ensures var s': CLearner := CLearnerProcess2b(s, packet); CLearnerIsValid(s') && LLearnerProcess2b(AbstractifyCLearnerToLLearner(s), AbstractifyCLearnerToLLearner(s'), AbstractifyCPacketToRslPacket(packet))
    decreases s, packet
  {
    lemma_AbstractifyMap_properties(s.unexecuted_learner_state, AbstractifyCOperationNumberToOperationNumber, AbstractifyCLearnerTupleToLearnerTuple, AbstractifyOperationNumberToCOperationNumber);
    ghost var ss: LLearner := AbstractifyCLearnerToLLearner(s);
    ghost var p: RslPacket := AbstractifyCPacketToRslPacket(packet);
    var t1: CLearner := var m: CMessage := packet.msg; var t1: CLearner := var opn: COperationNumber := m.opn_2b; var t1: CLearner := if packet.src !in s.constants.all.config.replica_ids || CBalLt(m.bal_2b, s.max_ballot_seen) then var t1: CLearner := s; t1 else var t1: CLearner := if CBalLt(s.max_ballot_seen, m.bal_2b) then var t1: CLearner := var tup': CLearnerTuple := CLearnerTuple([packet]); assert CLearnerTupleIsAbstractable(tup'); ghost var t': LearnerTuple := LearnerTuple([p]); assert t' == AbstractifyCLearnerTupleToLearnerTuple(tup'); var t1: CLearner := s.(max_ballot_seen := m.bal_2b, unexecuted_learner_state := map[opn := tup']); t1; t1 else var t1: CLearner := if opn !in s.unexecuted_learner_state then var t1: CLearner := var tup': CLearnerTuple := CLearnerTuple([packet]); assert CLearnerTupleIsAbstractable(tup'); ghost var t': LearnerTuple := LearnerTuple([p]); assert t' == AbstractifyCLearnerTupleToLearnerTuple(tup'); var t1: CLearner := s.(unexecuted_learner_state := s.unexecuted_learner_state[opn := tup']); t1; t1 else var t1: CLearner := if exists p: CPacket {:trigger p.src} {:trigger p in s.unexecuted_learner_state[opn].received_2bs} :: p in s.unexecuted_learner_state[opn].received_2bs && p.src == packet.src then var t1: CLearner := s; t1 else var t1: CLearner := var tup: CLearnerTuple := s.unexecuted_learner_state[opn]; var t1: CLearner := var tup': CLearnerTuple := tup.(received_2bs := tup.received_2bs + [packet]); ghost var t: LearnerTuple := ss.unexecuted_learner_state[opn]; ghost var t': LearnerTuple := t.(received_2bs := t.received_2bs + [p]); assert t' == AbstractifyCLearnerTupleToLearnerTuple(tup'); var t1: CLearner := s.(unexecuted_learner_state := s.unexecuted_learner_state[opn := tup']); t1; t1; t1; t1; t1; t1; t1; t1;
    t1
  }

  function method CLearnerForgetDecision(s: CLearner, opn: COperationNumber): CLearner
    requires CLearnerIsValid(s)
    requires COperationNumberIsValid(opn)
    ensures var s': CLearner := CLearnerForgetDecision(s, opn); CLearnerIsValid(s') && LLearnerForgetDecision(AbstractifyCLearnerToLLearner(s), AbstractifyCLearnerToLLearner(s'), AbstractifyCOperationNumberToOperationNumber(opn))
    decreases s, opn
  {
    var t1: CLearner := if opn in s.unexecuted_learner_state then var t1: CLearner := s.(unexecuted_learner_state := RemoveElt(s.unexecuted_learner_state, opn)); t1 else var t1: CLearner := s; t1;
    t1
  }

  function method CLearnerForgetOperationsBefore(s: CLearner, ops_complete: COperationNumber): CLearner
    requires CLearnerIsValid(s)
    requires COperationNumberIsValid(ops_complete)
    ensures var s': CLearner := CLearnerForgetOperationsBefore(s, ops_complete); CLearnerIsValid(s') && LLearnerForgetOperationsBefore(AbstractifyCLearnerToLLearner(s), AbstractifyCLearnerToLLearner(s'), AbstractifyCOperationNumberToOperationNumber(ops_complete))
    decreases s, ops_complete
  {
    var t1: CLearner := s.(unexecuted_learner_state := map op: int {:trigger s.unexecuted_learner_state[op]} {:trigger op in s.unexecuted_learner_state} | op in s.unexecuted_learner_state && op >= ops_complete :: s.unexecuted_learner_state[op]);
    t1
  }

  lemma lemma_LearnerTupleIsUniqueSeq(tup: CLearnerTuple, ltup: LearnerTuple)
    requires CLearnerTupleIsValid(tup)
    requires ltup == AbstractifyCLearnerTupleToLearnerTuple(tup)
    ensures (forall i: int, j: int {:trigger tup.received_2bs[j], tup.received_2bs[i]} :: (0 <= i < |tup.received_2bs| && 0 <= j < |tup.received_2bs| && i != j ==> tup.received_2bs[i] != tup.received_2bs[j]) && (0 <= i < |tup.received_2bs| && 0 <= j < |tup.received_2bs| && i != j ==> tup.received_2bs[i].src != tup.received_2bs[j].src)) == forall i: int, j: int {:trigger ltup.received_2bs[j], ltup.received_2bs[i]} :: (0 <= i < |ltup.received_2bs| && 0 <= j < |ltup.received_2bs| && i != j ==> ltup.received_2bs[i] != ltup.received_2bs[j]) && (0 <= i < |ltup.received_2bs| && 0 <= j < |ltup.received_2bs| && i != j ==> ltup.received_2bs[i].src != ltup.received_2bs[j].src)
    decreases tup, ltup
  {
  }

  lemma lemma_CLearnerTupleIsUniqueSeq(tup: CLearnerTuple)
    requires CLearnerTupleIsValid(tup)
    ensures ghost var lr: bool := LearnerTupleIsUniqueSeq(AbstractifyCLearnerTupleToLearnerTuple(tup)); ghost var cr: bool := forall i: int, j: int {:trigger tup.received_2bs[j], tup.received_2bs[i]} :: (0 <= i < |tup.received_2bs| && 0 <= j < |tup.received_2bs| && i != j ==> tup.received_2bs[i] != tup.received_2bs[j]) && (0 <= i < |tup.received_2bs| && 0 <= j < |tup.received_2bs| && i != j ==> tup.received_2bs[i].src != tup.received_2bs[j].src); cr == lr
    decreases tup
  {
  }
}

module LiveByzRSL__ExecutorModel_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened LiveByzRSL__AppInterface_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__CTypes_i

  import opened LiveByzRSL__CConfiguration_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Executor_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__PacketParsing_i

  import opened LiveByzRSL__ConstantsState_i

  import opened LiveByzRSL__StateMachine_i

  import opened LiveByzRSL__Types_i

  import opened Impl__LiveByzRSL__Broadcast_i

  import opened Common__NodeIdentity_i

  import opened Common__UdpClient_i

  import opened Common__UpperBound_s

  import opened Common__UpperBound_i

  import opened Common__Util_i

  import opened Concrete_NodeIdentity_i

  import opened Collections__Maps_i

  import opened Logic__Option_i

  import opened Environment_s

  import opened AppStateMachine_i

  import opened Temporal__Temporal_s

  import opened LiveByzRSL__CStateMachine_i

  import opened GenericRefinement_i
  datatype COutstandingOperation = COutstandingOpKnown(v: CRequestBatch, bal: CBallot) | COutstandingOpUnknown

  datatype CExecutor = CExecutor(constants: CReplicaConstants, app: CAppState, ops_complete: int, max_bal_reflected: CBallot, next_op_to_execute: COutstandingOperation, reply_cache: CReplyCache)

  predicate COutstandingOperationIsValid(s: COutstandingOperation)
    decreases s
  {
    match s
    case COutstandingOpKnown(v, bal) =>
      COutstandingOperationIsAbstractable(s) &&
      CRequestBatchIsValid(s.v) &&
      CBallotIsValid(s.bal)
    case COutstandingOpUnknown() =>
      COutstandingOperationIsAbstractable(s)
  }

  predicate COutstandingOperationIsAbstractable(s: COutstandingOperation)
    decreases s
  {
    match s
    case COutstandingOpKnown(v, bal) =>
      CRequestBatchIsAbstractable(s.v) &&
      CBallotIsAbstractable(s.bal)
    case COutstandingOpUnknown() =>
      true
  }

  function AbstractifyCOutstandingOperationToOutstandingOperation(s: COutstandingOperation): OutstandingOperation
    requires COutstandingOperationIsAbstractable(s)
    decreases s
  {
    match s
    case COutstandingOpKnown(v, bal) =>
      OutstandingOpKnown(AbstractifyCRequestBatchToRequestBatch(s.v), AbstractifyCBallotToBallot(s.bal))
    case COutstandingOpUnknown() =>
      OutstandingOpUnknown()
  }

  predicate CExecutorIsValid(s: CExecutor)
    decreases s
  {
    CExecutorIsAbstractable(s) &&
    CReplicaConstantsIsValid(s.constants) &&
    CAppStateIsValid(s.app) &&
    CBallotIsValid(s.max_bal_reflected) &&
    COutstandingOperationIsValid(s.next_op_to_execute) &&
    CReplyCacheIsValid(s.reply_cache)
  }

  predicate CExecutorIsAbstractable(s: CExecutor)
    decreases s
  {
    CReplicaConstantsIsAbstractable(s.constants) &&
    CAppStateIsAbstractable(s.app) &&
    CBallotIsAbstractable(s.max_bal_reflected) &&
    COutstandingOperationIsAbstractable(s.next_op_to_execute) &&
    CReplyCacheIsAbstractable(s.reply_cache)
  }

  function AbstractifyCExecutorToLExecutor(s: CExecutor): LExecutor
    requires CExecutorIsAbstractable(s)
    decreases s
  {
    LExecutor(AbstractifyCReplicaConstantsToLReplicaConstants(s.constants), AbstractifyCAppStateToAppState(s.app), s.ops_complete, AbstractifyCBallotToBallot(s.max_bal_reflected), AbstractifyCOutstandingOperationToOutstandingOperation(s.next_op_to_execute), AbstractifyCReplyCacheToReplyCache(s.reply_cache))
  }

  function method CExecutorInit(c: CReplicaConstants): CExecutor
    requires CReplicaConstantsIsValid(c)
    ensures var s: CExecutor := CExecutorInit(c); CExecutorIsValid(s) && LExecutorInit(AbstractifyCExecutorToLExecutor(s), AbstractifyCReplicaConstantsToLReplicaConstants(c))
    decreases c
  {
    var t1: CReplicaConstants := c;
    var t2: CAppState := CAppStateInit();
    var t3: int := 0;
    var t4: CBallot := CBallot(0, 0);
    var t5: COutstandingOperation := COutstandingOpUnknown();
    var t6: map<EndPoint, CReply> := map[];
    CExecutor(t1, t2, t3, t4, t5, t6)
  }

  function method CExecutorGetDecision(s: CExecutor, bal: CBallot, opn: COperationNumber, v: CRequestBatch): CExecutor
    requires CExecutorIsValid(s)
    requires CBallotIsValid(bal)
    requires COperationNumberIsValid(opn)
    requires CRequestBatchIsValid(v)
    requires opn == s.ops_complete
    requires s.next_op_to_execute.COutstandingOpUnknown?
    ensures var s': CExecutor := CExecutorGetDecision(s, bal, opn, v); CExecutorIsValid(s') && LExecutorGetDecision(AbstractifyCExecutorToLExecutor(s), AbstractifyCExecutorToLExecutor(s'), AbstractifyCBallotToBallot(bal), AbstractifyCOperationNumberToOperationNumber(opn), AbstractifyCRequestBatchToRequestBatch(v))
    decreases s, bal, opn, v
  {
    var t1: CExecutor := s.(next_op_to_execute := COutstandingOpKnown(v, bal));
    t1
  }

  function method CGetPacketsFromReplies(me: EndPoint, requests: seq<CRequest>, replies: seq<CReply>): seq<CPacket>
    requires EndPointIsValid(me)
    requires CRequestBatchIsValid(requests)
    requires forall i: CRequest {:trigger CRequestIsValid(i)} {:trigger i in requests} :: i in requests ==> CRequestIsValid(i)
    requires forall i: CReply {:trigger CReplyIsValid(i)} {:trigger i.CReply?} {:trigger i in replies} :: (i in replies ==> i.CReply?) && (i in replies ==> CReplyIsValid(i))
    requires |requests| == |replies|
    ensures forall p: CPacket {:trigger CPacketIsAbstractable(p)} {:trigger p.msg} {:trigger p.src} {:trigger p in CGetPacketsFromReplies(me, requests, replies)} :: (p in CGetPacketsFromReplies(me, requests, replies) ==> p.src == me) && (p in CGetPacketsFromReplies(me, requests, replies) ==> p.msg.CMessage_Reply?) && (p in CGetPacketsFromReplies(me, requests, replies) ==> CPacketIsAbstractable(p))
    ensures var lr: seq<RslPacket> := GetPacketsFromReplies(AbstractifyEndPointToNodeIdentity(me), AbstractifySeq(requests, AbstractifyCRequestToRequest), AbstractifySeq(replies, AbstractifyCReplyToReply)); var cr: seq<CPacket> := CGetPacketsFromReplies(me, requests, replies); true && AbstractifySeq(cr, AbstractifyCPacketToRslPacket) == lr
    decreases me, requests, replies
  {
    if |requests| == 0 then
      []
    else
      [CPacket(requests[0].client, me, CMessage_Reply(requests[0].seqno, replies[0].reply))] + CGetPacketsFromReplies(me, requests[1..], replies[1..])
  }

  function method CClientsInReplies(replies: seq<CReply>): CReplyCache
    requires forall i: CReply {:trigger CReplyIsValid(i)} {:trigger i.CReply?} {:trigger i in replies} :: (i in replies ==> i.CReply?) && (i in replies ==> CReplyIsValid(i))
    ensures var m: CReplyCache := CClientsInReplies(replies); (forall c: EndPoint {:trigger m[c]} {:trigger c in m} :: c in m ==> m[c].client == c) && forall c: EndPoint {:trigger m[c]} {:trigger c in m} :: c in m ==> exists req_idx: int {:trigger replies[req_idx]} :: 0 <= req_idx && req_idx < |replies| && replies[req_idx].client == c && m[c] == replies[req_idx]
    ensures var lr: ReplyCache := LClientsInReplies(AbstractifySeq(replies, AbstractifyCReplyToReply)); var cr: CReplyCache := CClientsInReplies(replies); CReplyCacheIsValid(cr) && AbstractifyCReplyCacheToReplyCache(cr) == lr
    decreases replies
  {
    var r: map<EndPoint, CReply> := if |replies| == 0 then map[] else CClientsInReplies(replies[1..])[replies[0].client := replies[0]];
    r
  }

  function method CUpdateNewCache(c: CReplyCache, replies: seq<CReply>): CReplyCache
    requires CReplyCacheIsValid(c)
    requires forall i: int {:trigger replies[i]} :: 0 <= i < |replies| ==> CReplyIsValid(replies[i])
    ensures var c': CReplyCache := CUpdateNewCache(c, replies); CReplyCacheIsValid(c') && UpdateNewCache(AbstractifyCReplyCacheToReplyCache(c), AbstractifyCReplyCacheToReplyCache(c'), AbstractifySeq(replies, AbstractifyCReplyToReply))
    decreases c, replies
  {
    var t1: map<EndPoint, CReply> := var nc: CReplyCache := CClientsInReplies(replies); var t1: map<EndPoint, CReply> := map client: EndPoint {:trigger nc[client]} {:trigger c[client]} {:trigger client in c} {:trigger client in c.Keys + nc.Keys} | client in c.Keys + nc.Keys :: if client in c then c[client] else nc[client]; t1;
    assert CReplyCacheIsValid(t1);
    assert UpdateNewCache(AbstractifyCReplyCacheToReplyCache(c), AbstractifyCReplyCacheToReplyCache(t1), AbstractifySeq(replies, AbstractifyCReplyToReply));
    t1
  }

  function method CExecutorExecute(s: CExecutor): (CExecutor, OutboundPackets)
    requires CExecutorIsValid(s)
    requires s.next_op_to_execute.COutstandingOpKnown?
    requires CLtUpperBound(s.ops_complete, s.constants.all.params.max_integer_val)
    requires CReplicaConstantsValid(s.constants)
    ensures var (s': CExecutor, non_empty_sequential_sent_packets: OutboundPackets) := CExecutorExecute(s); CExecutorIsValid(s') && OutboundPacketsIsValid(non_empty_sequential_sent_packets) && LExecutorExecute(AbstractifyCExecutorToLExecutor(s), AbstractifyCExecutorToLExecutor(s'), AbstractifyOutboundCPacketsToSeqOfRslPackets(non_empty_sequential_sent_packets))
    decreases s
  {
    var t1: (OutboundPackets, CExecutor) := var batch: CRequestBatch := s.next_op_to_execute.v; var t1: (CExecutor, OutboundPackets) := var temp: (seq<CAppState>, seq<CReply>) := CHandleRequestBatch(s.app, batch); var t1: (OutboundPackets, CExecutor) := var new_state: uint64 := temp.0[|temp.0| - 1]; var t1: (CExecutor, OutboundPackets) := var replies: seq<CReply> := temp.1; var t1: (CExecutor, OutboundPackets) := var clients: CReplyCache := CClientsInReplies(replies); var t1: CReplicaConstants := s.constants; var t2: uint64 := new_state; var t3: int := s.ops_complete + 1; var t4: CBallot := if CBalLeq(s.max_bal_reflected, s.next_op_to_execute.bal) then s.next_op_to_execute.bal else s.max_bal_reflected; var t5: COutstandingOperation := COutstandingOpUnknown(); var t6: CReplyCache := CUpdateNewCache(s.reply_cache, replies); var t7: OutboundPackets := PacketSequence(CGetPacketsFromReplies(s.constants.all.config.replica_ids[s.constants.my_index], batch, replies)); (CExecutor(t1, t2, t3, t4, t5, t6), t7); (t1.0, t1.1); (t1.1, t1.0); (t1.1, t1.0); (t1.1, t1.0);
    (t1.1, t1.0)
  }

  function method CExecutorProcessStartingPhase2(s: CExecutor, inp: CPacket): (CExecutor, OutboundPackets)
    requires CExecutorIsValid(s)
    requires CPacketIsValid(inp)
    requires inp.msg.CMessage_StartingPhase2?
    ensures var (s': CExecutor, broadcast_sent_packets: OutboundPackets) := CExecutorProcessStartingPhase2(s, inp); CExecutorIsValid(s') && OutboundPacketsIsValid(broadcast_sent_packets) && LExecutorProcessStartingPhase2(AbstractifyCExecutorToLExecutor(s), AbstractifyCExecutorToLExecutor(s'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(broadcast_sent_packets))
    decreases s, inp
  {
    var t1: (CExecutor, OutboundPackets) := if inp.src in s.constants.all.config.replica_ids && inp.msg.logTruncationPoint_2 > s.ops_complete then var t1: CExecutor := s; var t2: OutboundPackets := Broadcast(CBroadcastNop); (t1, t2) else var t1: CExecutor := s; var t2: OutboundPackets := Broadcast(CBroadcastNop); (t1, t2);
    (t1.0, t1.1)
  }

  function method CExecutorProcessRequest(s: CExecutor, inp: CPacket): OutboundPackets
    requires CExecutorIsValid(s)
    requires CPacketIsValid(inp)
    requires inp.msg.CMessage_Request?
    requires inp.src in s.reply_cache
    requires s.reply_cache[inp.src].CReply?
    requires inp.msg.seqno_req <= s.reply_cache[inp.src].seqno
    ensures var sequential_sent_packets: OutboundPackets := CExecutorProcessRequest(s, inp); OutboundPacketsIsValid(sequential_sent_packets) && LExecutorProcessRequest(AbstractifyCExecutorToLExecutor(s), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(sequential_sent_packets))
    decreases s, inp
  {
    var t1: OutboundPackets := if inp.msg.seqno_req == s.reply_cache[inp.src].seqno && CReplicaConstantsValid(s.constants) then var t1: OutboundPackets := var r: CReply := s.reply_cache[inp.src]; var t1: OutboundPackets := PacketSequence([CPacket(r.client, s.constants.all.config.replica_ids[s.constants.my_index], CMessage_Reply(r.seqno, r.reply))]); t1; t1 else var t1: OutboundPackets := PacketSequence([]); t1;
    t1
  }
}

module LiveByzRSL__CStateMachine_i {

  import opened LiveByzRSL__StateMachine_i

  import opened LiveByzRSL__AppInterface_i

  import opened LiveByzRSL__CTypes_i

  import opened LiveByzRSL__Types_i

  import opened Native__NativeTypes_i

  import opened Native__NativeTypes_s

  import opened GenericRefinement_i

  import opened AppStateMachine_i
  function method CHandleRequest(state: CAppState, request: CRequest): (CAppState, CReply)
    requires CAppStateIsValid(state)
    requires CRequestIsValid(request)
    ensures var (lr0: AppState, lr1: Reply) := HandleRequest(AbstractifyCAppStateToAppState(state), AbstractifyCRequestToRequest(request)); var (cr0: CAppState, cr1: CReply) := CHandleRequest(state, request); CAppStateIsValid(cr0) && CReplyIsValid(cr1) && (AbstractifyCAppStateToAppState(cr0), AbstractifyCReplyToReply(cr1)) == (lr0, lr1)
    decreases state, request
  {
    var (new_state: CAppState, reply: CAppMessage) := HandleAppRequest(state, request.request);
    (new_state, CReply(request.client, request.seqno, reply))
  }

  function method {:opaque} {:fuel 0, 0} CHandleRequestBatchHidden(state: CAppState, batch: CRequestBatch): (seq<CAppState>, seq<CReply>)
    requires CAppStateIsValid(state)
    requires CRequestBatchIsValid(batch)
    ensures var (states: seq<CAppState>, replies: seq<CReply>) := CHandleRequestBatchHidden(state, batch); |states| == |batch| + 1 && |replies| == |batch| && forall i: int {:trigger replies[i]} :: 0 <= i && i < |batch| ==> replies[i].CReply?
    ensures var (lr0: seq<AppState>, lr1: seq<Reply>) := HandleRequestBatchHidden(AbstractifyCAppStateToAppState(state), AbstractifyCRequestBatchToRequestBatch(batch)); var (cr0: seq<CAppState>, cr1: seq<CReply>) := CHandleRequestBatchHidden(state, batch); (forall i: uint64 {:trigger CAppStateIsValid(i)} {:trigger i in cr0} :: i in cr0 ==> CAppStateIsValid(i)) && (forall i: CReply {:trigger CReplyIsValid(i)} {:trigger i in cr1} :: i in cr1 ==> CReplyIsValid(i)) && (AbstractifySeq(cr0, AbstractifyCAppStateToAppState), AbstractifySeq(cr1, AbstractifyCReplyToReply)) == (lr0, lr1)
    decreases |batch|
  {
    reveal_HandleRequestBatchHidden();
    if |batch| == 0 then
      var states: seq<uint64> := [state];
      var replies: seq<CReply> := [];
      ghost var s: AppState := AbstractifyCAppStateToAppState(state);
      ghost var b: RequestBatch := AbstractifyCRequestBatchToRequestBatch(batch);
      var (ss': seq<AppState>, rs': seq<Reply>) := HandleRequestBatchHidden(s, b);
      assert AbstractifySeq(states, AbstractifyCAppStateToAppState) == ss';
      assert AbstractifySeq(replies, AbstractifyCReplyToReply) == rs';
      assert HandleRequestBatchHidden(AbstractifyCAppStateToAppState(state), AbstractifyCRequestBatchToRequestBatch(batch)) == (AbstractifySeq(states, AbstractifyCAppStateToAppState), AbstractifySeq(replies, AbstractifyCReplyToReply));
      ([state], [])
    else
      var (restStates: seq<CAppState>, restReplies: seq<CReply>) := CHandleRequestBatchHidden(state, batch[..|batch| - 1]); var (new_state: CAppState, reply: CAppMessage) := HandleAppRequest(restStates[|restStates| - 1], batch[|batch| - 1].request); var states: seq<CAppState> := restStates + [new_state]; var replies: seq<CReply> := restReplies + [CReply(batch[|batch| - 1].client, batch[|batch| - 1].seqno, reply)]; ghost var s: AppState := AbstractifyCAppStateToAppState(state); ghost var b: RequestBatch := AbstractifyCRequestBatchToRequestBatch(batch); var (rs: seq<AppState>, rp: seq<Reply>) := HandleRequestBatchHidden(s, b[..|b| - 1]); var (s1: AppState, r: AppMessage) := AppHandleRequest(rs[|rs| - 1], b[|b| - 1].request); assert b[..|b| - 1] == AbstractifyCRequestBatchToRequestBatch(batch[..|batch| - 1]); var (ss': seq<AppState>, rs': seq<Reply>) := HandleRequestBatchHidden(s, b); assert AbstractifySeq(states, AbstractifyCAppStateToAppState) == ss'; assert AbstractifySeq(replies, AbstractifyCReplyToReply) == rs'; assert HandleRequestBatchHidden(AbstractifyCAppStateToAppState(state), AbstractifyCRequestBatchToRequestBatch(batch)) == (AbstractifySeq(states, AbstractifyCAppStateToAppState), AbstractifySeq(replies, AbstractifyCReplyToReply)); (restStates + [new_state], restReplies + [CReply(batch[|batch| - 1].client, batch[|batch| - 1].seqno, reply)])
  }

  function method CHandleRequestBatch(state: CAppState, batch: CRequestBatch): (seq<CAppState>, seq<CReply>)
    requires CAppStateIsValid(state)
    requires CRequestBatchIsValid(batch)
    ensures var (states: seq<CAppState>, replies: seq<CReply>) := CHandleRequestBatch(state, batch); states[0] == state && |states| == |batch| + 1 && |replies| == |batch| && (forall i: int {:trigger replies[i]} :: 0 <= i && i < |batch| ==> replies[i].CReply?) && (forall i: int, _t#0: int {:trigger batch[i], states[_t#0]} {:trigger states[i], states[_t#0]} {:trigger replies[i], states[_t#0]} | _t#0 == i + 1 :: 0 <= i && i < |batch| ==> (states[_t#0], replies[i].reply) == HandleAppRequest(states[i], batch[i].request)) && forall i: int {:trigger batch[i]} {:trigger replies[i]} :: (0 <= i && i < |batch| ==> replies[i].client == batch[i].client) && (0 <= i && i < |batch| ==> replies[i].seqno == batch[i].seqno)
    ensures var (lr0: seq<AppState>, lr1: seq<Reply>) := HandleRequestBatch(AbstractifyCAppStateToAppState(state), AbstractifyCRequestBatchToRequestBatch(batch)); var (cr0: seq<CAppState>, cr1: seq<CReply>) := CHandleRequestBatch(state, batch); (forall i: uint64 {:trigger CAppStateIsValid(i)} {:trigger i in cr0} :: i in cr0 ==> CAppStateIsValid(i)) && (forall i: CReply {:trigger CReplyIsValid(i)} {:trigger i in cr1} :: i in cr1 ==> CReplyIsValid(i)) && (AbstractifySeq(cr0, AbstractifyCAppStateToAppState), AbstractifySeq(cr1, AbstractifyCReplyToReply)) == (lr0, lr1)
    decreases state, batch
  {
    var (states: seq<CAppState>, replies: seq<CReply>) := CHandleRequestBatchHidden(state, batch);
    lemma_CHandleRequestBatchHidden(state, batch, states, replies);
    (states, replies)
  }

  lemma {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ /*{:_induction state, batch}*/ lemma_CHandleRequestBatchHidden(state: CAppState, batch: CRequestBatch, states: seq<CAppState>, replies: seq<CReply>)
    requires CAppStateIsValid(state)
    requires CRequestBatchIsValid(batch)
    requires (states, replies) == CHandleRequestBatchHidden(state, batch)
    ensures states[0] == state && |states| == |batch| + 1 && |replies| == |batch| && (forall i: int {:trigger replies[i]} :: 0 <= i < |batch| ==> replies[i].CReply?) && (forall i: int, _t#0: int {:trigger batch[i], states[_t#0]} {:trigger states[i], states[_t#0]} {:trigger replies[i], states[_t#0]} | _t#0 == i + 1 :: 0 <= i && i < |batch| ==> (states[_t#0], replies[i].reply) == HandleAppRequest(states[i], batch[i].request)) && forall i: int {:trigger batch[i]} {:trigger replies[i]} :: (0 <= i < |batch| ==> replies[i].client == batch[i].client) && (0 <= i < |batch| ==> replies[i].seqno == batch[i].seqno)
    decreases |batch|
  {
  }
}

module LiveByzRSL__CClockReading_i {

  import opened Native__NativeTypes_s

  import opened LiveByzRSL__ClockReading_i
  datatype CClockReading = CClockReading(t: int)

  function AbstractifyCClockReadingToClockReading(cclock: CClockReading): ClockReading
    decreases cclock
  {
    ClockReading(cclock.t as int)
  }
}

module LiveByzRSL__ReplicaImplClass_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened Collections__Seqs_i

  import opened Math__mod_auto_i

  import opened LiveByzRSL__AcceptorModel_i

  import opened LiveByzRSL__AppInterface_i

  import opened LiveByzRSL__CClockReading_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__ConstantsState_i

  import opened LiveByzRSL__CConfiguration_i

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__CTypes_i

  import opened LiveByzRSL__ElectionModel_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__ExecutorModel_i

  import opened LiveByzRSL__LearnerModel_i

  import opened LiveByzRSL__PacketParsing_i

  import opened LiveByzRSL__ParametersState_i

  import opened LiveByzRSL__ProposerModel_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__ReplicaModel_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__UdpRSL_i

  import opened Common__GenericMarshalling_i

  import opened Common__UdpClient_i

  import opened Common__Util_i

  import opened Common__UpperBound_i
  class ReplicaImpl {
    var replica: CReplica
    var nextActionIndex: uint64
    var netClient: UdpClient?
    var localAddr: EndPoint
    var msg_grammar: G
    ghost var Repr: set<object>

    constructor ()
    {
      netClient := null;
      var rcs := CReplicaConstants(0, CConstants(CConfiguration([]), CParameters(0, 0, 0, CUpperBoundInfinite(), 0, 0)));
      var election_state := CElectionState(rcs, CBallot(0, 0), {}, 0, 0, [], []);
      var proposer_state := CProposer(rcs, 0, [], CBallot(0, 0), 0, [], map[], CIncompleteBatchTimerOff(), election_state);
      var acceptor_state := CAcceptor(rcs, CBallot(0, 0), map[], [], 0, [], map[], 0, CValToBeSent2bUnknown());
      var learner_state := CLearner(rcs, CBallot(0, 0), map[]);
      var app_state := CAppStateInit();
      var executor_state := CExecutor(rcs, app_state, 0, CBallot(0, 0), COutstandingOpUnknown(), map[]);
      replica := CReplica(rcs, 0, proposer_state, acceptor_state, learner_state, executor_state);
    }

    predicate Valid()
      reads this, if netClient != null then UdpClientIsValid.reads(netClient) else {}
      decreases (if netClient != null then UdpClientIsValid.reads(netClient) else {}) + {this}
    {
      CReplicaIsAbstractable(replica) &&
      CReplicaIsValid(replica) &&
      0 <= nextActionIndex as int < 12 &&
      netClient != null &&
      UdpClientIsValid(netClient) &&
      netClient.LocalEndPoint() == localAddr &&
      netClient.LocalEndPoint() == replica.constants.all.config.replica_ids[replica.constants.my_index] &&
      Repr == {this} + UdpClientRepr(netClient) &&
      msg_grammar == CMessage_grammar()
    }

    function Env(): HostEnvironment
      requires netClient != null
      reads this, UdpClientIsValid.reads(netClient)
      decreases UdpClientIsValid.reads(netClient) + {this}
    {
      netClient.env
    }

    function AbstractifyToLReplica(): LReplica
      requires CReplicaIsValid(replica)
      reads this
      decreases {this}
    {
      AbstractifyCReplicaToLReplica(replica)
    }

    function AbstractifyToLScheduler(): LScheduler
      requires CReplicaIsValid(replica)
      reads this
      decreases {this}
    {
      LScheduler(AbstractifyCReplicaToLReplica(replica), nextActionIndex as int)
    }

    method ConstructUdpClient(constants: CReplicaConstants, ghost env_: HostEnvironment)
        returns (ok: bool, client: UdpClient?)
      requires env_.Valid() && env_.ok.ok()
      requires CReplicaConstantsIsValid(constants)
      modifies env_.ok
      ensures ok ==> client != null && UdpClientIsValid(client) && client.LocalEndPoint() == constants.all.config.replica_ids[constants.my_index] && client.env == env_
      decreases constants, env_
    {
      var my_ep := constants.all.config.replica_ids[constants.my_index];
      var ip_byte_array := new byte[|my_ep.addr|];
      assert EndPointIsValidIPV4(my_ep);
      seqIntoArrayOpt(my_ep.addr, ip_byte_array);
      var ip_endpoint;
      ok, ip_endpoint := IPEndPoint.Construct(ip_byte_array, my_ep.port, env_);
      if !ok {
        return;
      }
      ok, client := UdpClient.Construct(ip_endpoint, env_);
      if ok {
        calc {
          client.LocalEndPoint();
          ip_endpoint.EP();
          my_ep;
        }
      }
    }

    lemma {:axiom} Replica_Init_Helper1(constants: CReplicaConstants, env_: HostEnvironment, ok: bool)
      requires env_.Valid() && env_.ok.ok()
      requires CReplicaConstantsIsValid(constants)
      requires WellFormedLConfiguration(AbstractifyCReplicaConstantsToLReplicaConstants(constants).all.config)
      ensures ok ==> Valid() && Env() == env_ && this.replica.constants == constants && LSchedulerInit(AbstractifyToLScheduler(), AbstractifyCReplicaConstantsToLReplicaConstants(constants))
      decreases constants, env_, ok

    lemma {:axiom} Replica_Init_Helper2(env_: HostEnvironment)
      ensures env_.Valid() && env_.ok.ok()
      decreases env_

    method {:timeLimitMultiplier 7} /*{:_timeLimit 70}*/ Replica_Init(constants: CReplicaConstants, ghost env_: HostEnvironment) returns (ok: bool)
      requires env_.Valid() && env_.ok.ok()
      requires CReplicaConstantsIsValid(constants)
      requires WellFormedLConfiguration(AbstractifyCReplicaConstantsToLReplicaConstants(constants).all.config)
      modifies this, netClient, env_.ok
      ensures ok ==> Valid() && Env() == env_ && this.replica.constants == constants && LSchedulerInit(AbstractifyToLScheduler(), AbstractifyCReplicaConstantsToLReplicaConstants(constants))
      decreases constants, env_
    {
      ok, netClient := ConstructUdpClient(constants, env_);
      if ok {
        replica := CReplicaInit(constants);
        nextActionIndex := 0;
        localAddr := replica.constants.all.config.replica_ids[replica.constants.my_index];
        Repr := {this} + UdpClientRepr(netClient);
        this.msg_grammar := CMessage_grammar();
      }
      Replica_Init_Helper2(env_);
      Replica_Init_Helper1(constants, env_, ok);
    }

    predicate ReceivedPacketProperties(cpacket: CPacket, netEvent0: UdpEvent, io0: RslIo)
      requires CConfigurationIsValid(replica.constants.all.config)
      reads this
      decreases {this}, cpacket, netEvent0, io0
    {
      CPacketIsSendable(cpacket) &&
      io0.LIoOpReceive? &&
      UdpEventIsAbstractable(netEvent0) &&
      io0 == AbstractifyUdpEventToRslIo(netEvent0) &&
      UdpEventIsAbstractable(netEvent0) &&
      netEvent0.LIoOpReceive? &&
      AbstractifyCPacketToRslPacket(cpacket) == AbstractifyNetPacketToRslPacket(netEvent0.r)
    }
  }
}

module LiveByzRSL__UdpRSL_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened Common__GenericMarshalling_i

  import opened Common__NodeIdentity_i

  import opened Common__UdpClient_i

  import opened Common__Util_i

  import opened LiveByzRSL__CClockReading_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__CConfiguration_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__PacketParsing_i

  import opened Impl__LiveByzRSL__Broadcast_i

  import opened Logic__Option_i

  import opened Environment_s
  datatype ReceiveResult = RRFail | RRTimeout | RRPacket(cpacket: CPacket)

  predicate UdpEventIsAbstractable(evt: UdpEvent)
    decreases evt
  {
    match evt
    case LIoOpSend(s) =>
      UdpPacketIsAbstractable(s)
    case LIoOpReceive(r) =>
      UdpPacketIsAbstractable(r)
    case LIoOpTimeoutReceive() =>
      true
    case LIoOpReadClock(t) =>
      true
  }

  function AbstractifyUdpEventToRslIo(evt: UdpEvent): RslIo
    requires UdpEventIsAbstractable(evt)
    decreases evt
  {
    match evt
    case LIoOpSend(s) =>
      LIoOpSend(AbstractifyUdpPacketToRslPacket(s))
    case LIoOpReceive(r) =>
      LIoOpReceive(AbstractifyUdpPacketToRslPacket(r))
    case LIoOpTimeoutReceive() =>
      LIoOpTimeoutReceive()
    case LIoOpReadClock(t) =>
      LIoOpReadClock(t as int)
  }

  predicate UdpEventLogIsAbstractable(rawlog: seq<UdpEvent>)
    decreases rawlog
  {
    forall i: int {:trigger rawlog[i]} :: 
      0 <= i < |rawlog| ==>
        UdpEventIsAbstractable(rawlog[i])
  }

  function {:opaque} {:fuel 0, 0} AbstractifyRawLogToIos(rawlog: seq<UdpEvent>): seq<RslIo>
    requires UdpEventLogIsAbstractable(rawlog)
    ensures |AbstractifyRawLogToIos(rawlog)| == |rawlog|
    ensures forall i: int {:trigger AbstractifyUdpEventToRslIo(rawlog[i])} {:trigger AbstractifyRawLogToIos(rawlog)[i]} :: 0 <= i < |rawlog| ==> AbstractifyRawLogToIos(rawlog)[i] == AbstractifyUdpEventToRslIo(rawlog[i])
    decreases rawlog
  {
    if rawlog == [] then
      []
    else
      [AbstractifyUdpEventToRslIo(rawlog[0])] + AbstractifyRawLogToIos(rawlog[1..])
  }

  lemma /*{:_induction rawlog}*/ lemma_EstablishAbstractifyRawLogToIos(rawlog: seq<UdpEvent>, ios: seq<RslIo>)
    requires UdpEventLogIsAbstractable(rawlog)
    requires |rawlog| == |ios|
    requires forall i: int {:trigger rawlog[i]} {:trigger ios[i]} :: 0 <= i < |rawlog| ==> ios[i] == AbstractifyUdpEventToRslIo(rawlog[i])
    ensures AbstractifyRawLogToIos(rawlog) == ios
    decreases rawlog, ios
  {
  }

  predicate RawIoConsistentWithSpecIO(rawlog: seq<UdpEvent>, ios: seq<RslIo>)
    decreases rawlog, ios
  {
    UdpEventLogIsAbstractable(rawlog) &&
    AbstractifyRawLogToIos(rawlog) == ios
  }

  predicate OnlySentMarshallableData(rawlog: seq<UdpEvent>)
    decreases rawlog
  {
    forall io: LIoOp<EndPoint, seq<byte>> {:trigger io.s} {:trigger io.LIoOpSend?} {:trigger io in rawlog} :: 
      (io in rawlog &&
      io.LIoOpSend? ==>
        UdpPacketBound(io.s.msg)) &&
      (io in rawlog &&
      io.LIoOpSend? ==>
        Marshallable(PaxosDemarshallData(io.s.msg)))
  }

  method GetEndPoint(ipe: IPEndPoint) returns (ep: EndPoint)
    ensures ep == ipe.EP()
    ensures EndPointIsValidIPV4(ep)
    decreases ipe
  {
    var addr := ipe.GetAddress();
    var port := ipe.GetPort();
    ep := EndPoint(addr[..], port);
  }

  method {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ Receive(udpClient: UdpClient, localAddr: EndPoint, config: CConfiguration, msg_grammar: G)
      returns (rr: ReceiveResult, ghost udpEvent: UdpEvent)
    requires UdpClientIsValid(udpClient)
    requires udpClient.LocalEndPoint() == localAddr
    requires CConfigurationIsValid(config)
    requires msg_grammar == CMessage_grammar()
    modifies UdpClientRepr(udpClient)
    ensures udpClient.env == old(udpClient.env)
    ensures udpClient.LocalEndPoint() == old(udpClient.LocalEndPoint())
    ensures UdpClientOk(udpClient) <==> !rr.RRFail?
    ensures old(UdpClientRepr(udpClient)) == UdpClientRepr(udpClient)
    ensures !rr.RRFail? ==> udpClient.IsOpen() && old(udpClient.env.udp.history()) + [udpEvent] == udpClient.env.udp.history()
    ensures rr.RRTimeout? ==> udpEvent.LIoOpTimeoutReceive?
    ensures rr.RRPacket? ==> udpEvent.LIoOpReceive? && UdpPacketIsAbstractable(udpEvent.r) && CPacketIsAbstractable(rr.cpacket) && CMessageIs64Bit(rr.cpacket.msg) && EndPointIsValidIPV4(rr.cpacket.src) && AbstractifyCPacketToRslPacket(rr.cpacket) == AbstractifyUdpPacketToRslPacket(udpEvent.r) && rr.cpacket.msg == PaxosDemarshallData(udpEvent.r.msg)
    decreases udpClient, localAddr, config, msg_grammar
  {
    var timeout := 0;
    ghost var old_udp_history := udpClient.env.udp.history();
    var ok, timedOut, remote, buffer := udpClient.Receive(timeout);
    if !ok {
      rr := RRFail();
      return;
    }
    if timedOut {
      rr := RRTimeout();
      udpEvent := LIoOpTimeoutReceive();
      return;
    }
    udpEvent := LIoOpReceive(LPacket(udpClient.LocalEndPoint(), remote.EP(), buffer[..]));
    assert udpClient.env.udp.history() == old_udp_history + [udpEvent];
    var start_time := Time.GetDebugTimeTicks();
    lemma_CMessageGrammarValid();
    var cmessage := PaxosDemarshallDataMethod(buffer, msg_grammar);
    var end_time := Time.GetDebugTimeTicks();
    RecordTimingSeq(""PaxosDemarshallDataMethod"", start_time, end_time);
    var srcEp := GetEndPoint(remote);
    var cpacket := CPacket(localAddr, srcEp, cmessage);
    rr := RRPacket(cpacket);
    assert udpClient.env.udp.history() == old_udp_history + [udpEvent];
    if cmessage.CMessage_Invalid? {
      RecordTimingSeq(""DemarshallMessage_Invalid"", start_time, end_time);
    } else if cmessage.CMessage_Request? {
      RecordTimingSeq(""DemarshallMessage_Request"", start_time, end_time);
    } else if cmessage.CMessage_1a? {
      RecordTimingSeq(""DemarshallMessage_1a"", start_time, end_time);
    } else if cmessage.CMessage_1b? {
      RecordTimingSeq(""DemarshallMessage_1b"", start_time, end_time);
    } else if cmessage.CMessage_1c? {
      RecordTimingSeq(""DemarshallMessage_1c"", start_time, end_time);
    } else if cmessage.CMessage_2av? {
      RecordTimingSeq(""DemarshallMessage_2av"", start_time, end_time);
    } else if cmessage.CMessage_2b? {
      RecordTimingSeq(""DemarshallMessage_2b"", start_time, end_time);
    } else if cmessage.CMessage_Heartbeat? {
      RecordTimingSeq(""DemarshallMessage_Heartbeat"", start_time, end_time);
    } else if cmessage.CMessage_Reply? {
      RecordTimingSeq(""DemarshallMessage_Reply"", start_time, end_time);
    } else if cmessage.CMessage_StartingPhase2? {
      RecordTimingSeq(""DemarshallMessage_StartingPhase2"", start_time, end_time);
    }
    assert EndPointIsValidIPV4(udpClient.LocalEndPoint());
    assert AbstractifyCPacketToRslPacket(rr.cpacket) == AbstractifyUdpPacketToRslPacket(udpEvent.r);
  }

  method ReadClock(udpClient: UdpClient) returns (clock: CClockReading, ghost clockEvent: UdpEvent)
    requires UdpClientIsValid(udpClient)
    modifies UdpClientRepr(udpClient)
    ensures old(UdpClientRepr(udpClient)) == UdpClientRepr(udpClient)
    ensures UdpClientIsValid(udpClient)
    ensures udpClient.env == old(udpClient.env)
    ensures old(udpClient.env.udp.history()) + [clockEvent] == udpClient.env.udp.history()
    ensures clockEvent.LIoOpReadClock?
    ensures clock.t as int == clockEvent.t
    ensures UdpClientIsValid(udpClient)
    ensures UdpEventIsAbstractable(clockEvent)
    ensures udpClient.LocalEndPoint() == old(udpClient.LocalEndPoint())
    decreases udpClient
  {
    var t := Time.GetTime(udpClient.env);
    clockEvent := LIoOpReadClock(t as int);
    clock := CClockReading(t as int);
  }

  predicate SendLogEntryReflectsPacket(event: UdpEvent, cpacket: CPacket)
    decreases event, cpacket
  {
    event.LIoOpSend? &&
    UdpPacketIsAbstractable(event.s) &&
    CPacketIsAbstractable(cpacket) &&
    AbstractifyCPacketToRslPacket(cpacket) == AbstractifyUdpPacketToRslPacket(event.s)
  }

  predicate SendLogReflectsPacket(udpEventLog: seq<UdpEvent>, packet: Option<CPacket>)
    decreases udpEventLog, packet
  {
    match packet {
      case Some(p) =>
        |udpEventLog| == 1 &&
        SendLogEntryReflectsPacket(udpEventLog[0], p)
      case None() =>
        udpEventLog == []
    }
  }

  predicate SendLogReflectsPacketSeq(udpEventLog: seq<UdpEvent>, packets: seq<CPacket>)
    decreases udpEventLog, packets
  {
    |udpEventLog| == |packets| &&
    forall i: int {:trigger packets[i]} {:trigger udpEventLog[i]} :: 
      0 <= i < |packets| ==>
        SendLogEntryReflectsPacket(udpEventLog[i], packets[i])
  }

  predicate SendLogMatchesRefinement(udpEventLog: seq<UdpEvent>, broadcast: CBroadcast, index: int)
    requires CBroadcastIsAbstractable(broadcast)
    requires broadcast.CBroadcast?
    requires 0 <= |udpEventLog| <= |broadcast.dsts|
    requires 0 <= index < |udpEventLog|
    decreases udpEventLog, broadcast, index
  {
    udpEventLog[index].LIoOpSend? &&
    UdpPacketIsAbstractable(udpEventLog[index].s) &&
    AbstractifyCBroadcastToRlsPacketSeq(broadcast)[index] == AbstractifyUdpPacketToRslPacket(udpEventLog[index].s)
  }

  predicate SendLogReflectsBroadcastPrefix(udpEventLog: seq<UdpEvent>, broadcast: CBroadcast)
    requires CBroadcastIsAbstractable(broadcast)
    requires broadcast.CBroadcast?
    decreases udpEventLog, broadcast
  {
    0 <= |udpEventLog| <= |broadcast.dsts| &&
    forall i: int {:trigger SendLogMatchesRefinement(udpEventLog, broadcast, i)} :: 
      0 <= i < |udpEventLog| ==>
        SendLogMatchesRefinement(udpEventLog, broadcast, i)
  }

  predicate SendLogReflectsBroadcast(udpEventLog: seq<UdpEvent>, broadcast: CBroadcast)
    requires CBroadcastIsAbstractable(broadcast)
    decreases udpEventLog, broadcast
  {
    if broadcast.CBroadcastNop? then
      udpEventLog == []
    else
      SendLogReflectsBroadcastPrefix(udpEventLog, broadcast) && |udpEventLog| == |broadcast.dsts|
  }

  lemma lemma_UdpEventLogAppend(broadcast: CBroadcast, udpEventLog: seq<UdpEvent>, udpEvent: UdpEvent)
    requires broadcast.CBroadcast?
    requires CBroadcastIsValid(broadcast)
    requires SendLogReflectsBroadcastPrefix(udpEventLog, broadcast)
    requires |udpEventLog| < |broadcast.dsts|
    requires udpEvent.LIoOpSend?
    requires UdpPacketIsAbstractable(udpEvent.s)
    requires CMessageIsAbstractable(PaxosDemarshallData(udpEvent.s.msg))
    requires udpEvent.s.dst == broadcast.dsts[|udpEventLog|]
    requires udpEvent.s.src == broadcast.src
    requires BufferRefinementAgreesWithMessageRefinement(broadcast.msg, udpEvent.s.msg)
    ensures SendLogReflectsBroadcastPrefix(udpEventLog + [udpEvent], broadcast)
    decreases broadcast, udpEventLog, udpEvent
  {
  }

  method SendBroadcast(udpClient: UdpClient, broadcast: CBroadcast, ghost localAddr_: EndPoint)
      returns (ok: bool, ghost udpEventLog: seq<UdpEvent>)
    requires UdpClientIsValid(udpClient)
    requires CBroadcastIsValid(broadcast)
    requires udpClient.LocalEndPoint() == localAddr_
    requires broadcast.CBroadcast? ==> broadcast.src == localAddr_
    modifies UdpClientRepr(udpClient)
    ensures old(UdpClientRepr(udpClient)) == UdpClientRepr(udpClient)
    ensures udpClient.env == old(udpClient.env)
    ensures udpClient.LocalEndPoint() == old(udpClient.LocalEndPoint())
    ensures UdpClientOk(udpClient) <==> ok
    ensures ok ==> UdpClientIsValid(udpClient) && udpClient.IsOpen() && old(udpClient.env.udp.history()) + udpEventLog == udpClient.env.udp.history() && OnlySentMarshallableData(udpEventLog) && SendLogReflectsBroadcast(udpEventLog, broadcast)
    decreases udpClient, broadcast, localAddr_
  {
    ok := true;
    udpEventLog := [];
    if broadcast.CBroadcastNop? {
    } else {
      assert CMessageIsAbstractable(broadcast.msg);
      assert Marshallable(broadcast.msg);
      var buffer := PaxosMarshall(broadcast.msg);
      assert UdpPacketBound(buffer[..]);
      calc ==> {
        true;
        CBroadcastIsValid(broadcast);
        CBroadcastIsAbstractable(broadcast);
        CMessageIsAbstractable(broadcast.msg);
      }
      var i: uint64 := 0;
      while i < |broadcast.dsts| as uint64
        invariant 0 <= i as int <= |broadcast.dsts|
        invariant |udpEventLog| == i as int
        invariant UdpClientRepr(udpClient) == old(UdpClientRepr(udpClient))
        invariant udpClient.env == old(udpClient.env)
        invariant udpClient.LocalEndPoint() == old(udpClient.LocalEndPoint())
        invariant UdpClientIsValid(udpClient)
        invariant UdpClientOk(udpClient)
        invariant old(udpClient.env.udp.history()) + udpEventLog == udpClient.env.udp.history()
        invariant UdpPacketBound(buffer[..])
        invariant Marshallable(PaxosDemarshallData(buffer[..]))
        invariant BufferRefinementAgreesWithMessageRefinement(broadcast.msg, buffer[..])
        invariant SendLogReflectsBroadcastPrefix(udpEventLog, broadcast)
        invariant CMessageIsAbstractable(PaxosDemarshallData(buffer[..]))
        invariant OnlySentMarshallableData(udpEventLog)
        decreases |broadcast.dsts| as uint64 as int - i as int
      {
        ghost var udpEventLog_old := udpEventLog;
        var dstEp: EndPoint := broadcast.dsts[i];
        var dstAddrAry := seqToArrayOpt(dstEp.addr);
        var remote;
        ok, remote := IPEndPoint.Construct(dstAddrAry, dstEp.port, udpClient.env);
        if !ok {
          return;
        }
        ok := udpClient.Send(remote, buffer);
        if !ok {
          return;
        }
        ghost var udpEvent := LIoOpSend(LPacket(remote.EP(), udpClient.LocalEndPoint(), buffer[..]));
        udpEventLog := udpEventLog + [udpEvent];
        lemma_UdpEventLogAppend(broadcast, udpEventLog_old, udpEvent);
        i := i + 1;
      }
    }
  }

  method SendPacket(udpClient: UdpClient, packets: OutboundPackets, ghost localAddr_: EndPoint)
      returns (ok: bool, ghost udpEventLog: seq<UdpEvent>)
    requires UdpClientIsValid(udpClient)
    requires packets.OutboundPacket?
    requires OutboundPacketsIsValid(packets)
    requires udpClient.LocalEndPoint() == localAddr_
    requires OutboundPacketsHasCorrectSrc(packets, localAddr_)
    modifies UdpClientRepr(udpClient)
    ensures old(UdpClientRepr(udpClient)) == UdpClientRepr(udpClient)
    ensures udpClient.env == old(udpClient.env)
    ensures udpClient.LocalEndPoint() == old(udpClient.LocalEndPoint())
    ensures UdpClientOk(udpClient) <==> ok
    ensures ok ==> UdpClientIsValid(udpClient) && udpClient.IsOpen() && old(udpClient.env.udp.history()) + udpEventLog == udpClient.env.udp.history() && OnlySentMarshallableData(udpEventLog) && SendLogReflectsPacket(udpEventLog, packets.p)
    decreases udpClient, packets, localAddr_
  {
    var j: uint64 := 0;
    udpEventLog := [];
    ok := true;
    var opt_packet := packets.p;
    if opt_packet.None? {
    } else {
      var cpacket := opt_packet.v;
      ghost var udpEventLog_old := udpEventLog;
      var dstEp: EndPoint := cpacket.dst;
      var dstAddrAry := seqToArrayOpt(dstEp.addr);
      var remote;
      ok, remote := IPEndPoint.Construct(dstAddrAry, dstEp.port, udpClient.env);
      if !ok {
        return;
      }
      assert CMessageIsAbstractable(cpacket.msg);
      assert Marshallable(cpacket.msg);
      var marshall_start_time := Time.GetDebugTimeTicks();
      var buffer := PaxosMarshall(cpacket.msg);
      var marshall_end_time := Time.GetDebugTimeTicks();
      RecordTimingSeq(""SendBatch_PaxosMarshall"", marshall_start_time, marshall_end_time);
      ghost var data := buffer[..];
      assert BufferRefinementAgreesWithMessageRefinement(cpacket.msg, data);
      ok := udpClient.Send(remote, buffer);
      if !ok {
        return;
      }
      ghost var udpEvent := LIoOpSend(LPacket(remote.EP(), udpClient.LocalEndPoint(), buffer[..]));
      ghost var udp := udpEvent.s;
      calc {
        AbstractifyCPacketToRslPacket(cpacket);
        LPacket(AbstractifyEndPointToNodeIdentity(cpacket.dst), AbstractifyEndPointToNodeIdentity(cpacket.src), AbstractifyCMessageToRslMessage(cpacket.msg));
        LPacket(AbstractifyEndPointToNodeIdentity(udp.dst), AbstractifyEndPointToNodeIdentity(udp.src), AbstractifyCMessageToRslMessage(cpacket.msg));
        AbstractifyBufferToRslPacket(udp.src, udp.dst, data);
        AbstractifyBufferToRslPacket(udp.src, udp.dst, udp.msg);
        AbstractifyUdpPacketToRslPacket(udpEvent.s);
      }
      assert SendLogEntryReflectsPacket(udpEvent, cpacket);
      udpEventLog := [udpEvent];
    }
  }

  method {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ SendPacketSequence(udpClient: UdpClient, packets: OutboundPackets, ghost localAddr_: EndPoint)
      returns (ok: bool, ghost udpEventLog: seq<UdpEvent>)
    requires UdpClientIsValid(udpClient)
    requires OutboundPacketsIsValid(packets)
    requires packets.PacketSequence?
    requires udpClient.LocalEndPoint() == localAddr_
    requires OutboundPacketsHasCorrectSrc(packets, localAddr_)
    modifies UdpClientRepr(udpClient)
    ensures old(UdpClientRepr(udpClient)) == UdpClientRepr(udpClient)
    ensures udpClient.env == old(udpClient.env)
    ensures udpClient.LocalEndPoint() == old(udpClient.LocalEndPoint())
    ensures UdpClientOk(udpClient) <==> ok
    ensures ok ==> UdpClientIsValid(udpClient) && udpClient.IsOpen() && old(udpClient.env.udp.history()) + udpEventLog == udpClient.env.udp.history() && OnlySentMarshallableData(udpEventLog) && SendLogReflectsPacketSeq(udpEventLog, packets.s)
    decreases udpClient, packets, localAddr_
  {
    var cpackets := packets.s;
    var j: int := 0;
    udpEventLog := [];
    ok := true;
    ghost var udpEventLog_old := udpEventLog;
    ghost var udpClientEnvHistory_old := old(udpClient.env.udp.history());
    var i: int := 0;
    while i < |cpackets| as int
      invariant old(UdpClientRepr(udpClient)) == UdpClientRepr(udpClient)
      invariant udpClient.env == old(udpClient.env)
      invariant udpClient.LocalEndPoint() == old(udpClient.LocalEndPoint())
      invariant UdpClientOk(udpClient) <==> ok
      invariant ok ==> UdpClientIsValid(udpClient) && udpClient.IsOpen()
      invariant ok ==> udpClientEnvHistory_old + udpEventLog == udpClient.env.udp.history()
      invariant i == 0 ==> |udpEventLog| == 0
      invariant 0 < i as int < |cpackets| ==> |udpEventLog| == |cpackets[0 .. i]|
      invariant 0 < i as int < |cpackets| ==> SendLogReflectsPacketSeq(udpEventLog, cpackets[0 .. i])
      invariant i as int >= |cpackets| ==> SendLogReflectsPacketSeq(udpEventLog, cpackets)
      invariant OnlySentMarshallableData(udpEventLog)
      decreases |cpackets| as int - i
    {
      var cpacket := cpackets[i];
      var dstEp: EndPoint := cpacket.dst;
      assert cpacket in cpackets;
      assert OutboundPacketsIsValid(packets);
      var dstAddrAry := seqToArrayOpt(dstEp.addr);
      var remote;
      ok, remote := IPEndPoint.Construct(dstAddrAry, dstEp.port, udpClient.env);
      if !ok {
        return;
      }
      assert CMessageIsAbstractable(cpacket.msg);
      assert Marshallable(cpacket.msg);
      var buffer := PaxosMarshall(cpacket.msg);
      ghost var data := buffer[..];
      assert BufferRefinementAgreesWithMessageRefinement(cpacket.msg, data);
      ok := udpClient.Send(remote, buffer);
      if !ok {
        return;
      }
      ghost var udpEvent := LIoOpSend(LPacket(remote.EP(), udpClient.LocalEndPoint(), buffer[..]));
      ghost var udp := udpEvent.s;
      calc {
        AbstractifyCPacketToRslPacket(cpacket);
        LPacket(AbstractifyEndPointToNodeIdentity(cpacket.dst), AbstractifyEndPointToNodeIdentity(cpacket.src), AbstractifyCMessageToRslMessage(cpacket.msg));
        LPacket(AbstractifyEndPointToNodeIdentity(udp.dst), AbstractifyEndPointToNodeIdentity(udp.src), AbstractifyCMessageToRslMessage(cpacket.msg));
        AbstractifyBufferToRslPacket(udp.src, udp.dst, data);
        AbstractifyBufferToRslPacket(udp.src, udp.dst, udp.msg);
        AbstractifyUdpPacketToRslPacket(udpEvent.s);
      }
      assert SendLogEntryReflectsPacket(udpEvent, cpacket);
      udpEventLog := udpEventLog + [udpEvent];
      assert cpackets[0 .. i as int + 1] == cpackets[0 .. i as int] + [cpacket];
      assert SendLogReflectsPacketSeq(udpEventLog, cpackets[0 .. i as int + 1]);
      i := i + 1;
    }
  }
}

module LiveByzRSL__ReplicaImplProcessPacketX_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened Collections__Seqs_i

  import opened Math__mod_auto_i

  import opened LiveByzRSL__CClockReading_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__CMessageRefinements_i

  import opened LiveByzRSL__CConfiguration_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__PacketParsing_i

  import opened LiveByzRSL__QRelations_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__ReplicaImplLemmas_i

  import opened LiveByzRSL__ReplicaImplClass_i

  import opened LiveByzRSL__ReplicaImplReadClock_i

  import opened LiveByzRSL__ReplicaImplProcessPacketNoClock_i

  import opened LiveByzRSL__ReplicaModel_i

  import opened LiveBysRSL_ReplicaImplConditions_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__UdpRSL_i

  import opened LiveByzRSL__Unsendable_i

  import opened Common__UdpClient_i

  import opened Environment_s

  import opened Common__Util_i
  method ReplicaNextProcessPacketTimeout(r: ReplicaImpl, ghost old_net_history: seq<UdpEvent>, ghost timeout_event: UdpEvent)
      returns (ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires r.Env().udp.history() == old_net_history + [timeout_event]
    requires timeout_event.LIoOpTimeoutReceive?
    ensures Q_LReplica_Next_ProcessPacket(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios)
    ensures RawIoConsistentWithSpecIO(UdpEventLog, ios)
    ensures old_net_history + UdpEventLog == r.Env().udp.history()
    ensures OnlySentMarshallableData(UdpEventLog)
    decreases r, old_net_history, timeout_event
  {
    ios := [LIoOpTimeoutReceive()];
    UdpEventLog := [timeout_event];
    lemma_EstablishQLReplicaNextProcessPacketFromTimeout(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios);
  }

  method ReplicaNextProcessPacketUnmarshallable(r: ReplicaImpl, ghost old_net_history: seq<UdpEvent>, rr: ReceiveResult, ghost receive_event: UdpEvent)
      returns (ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires r.Env().udp.history() == old_net_history + [receive_event]
    requires rr.RRPacket?
    requires receive_event.LIoOpReceive?
    requires !Marshallable(rr.cpacket.msg)
    requires NetPacketIsAbstractable(receive_event.r)
    requires CPacketIsAbstractable(rr.cpacket)
    requires AbstractifyCPacketToRslPacket(rr.cpacket) == AbstractifyNetPacketToRslPacket(receive_event.r)
    requires rr.cpacket.msg == PaxosDemarshallData(receive_event.r.msg)
    ensures IosReflectIgnoringUnsendable(UdpEventLog)
    ensures RawIoConsistentWithSpecIO(UdpEventLog, ios)
    ensures old_net_history + UdpEventLog == r.Env().udp.history()
    ensures OnlySentMarshallableData(UdpEventLog)
    decreases r, old_net_history, rr, receive_event
  {
    ghost var receive_io := LIoOpReceive(AbstractifyNetPacketToRslPacket(receive_event.r));
    UdpEventLog := [receive_event];
    ios := [receive_io];
  }

  method ReplicaNextProcessPacketHeartbeat(r: ReplicaImpl, ghost old_net_history: seq<UdpEvent>, rr: ReceiveResult, ghost receive_event: UdpEvent)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires r.Env().udp.history() == old_net_history + [receive_event]
    requires rr.RRPacket?
    requires receive_event.LIoOpReceive?
    requires rr.cpacket.msg.CMessage_Heartbeat?
    requires NetPacketIsAbstractable(receive_event.r)
    requires CPacketIsSendable(rr.cpacket)
    requires AbstractifyCPacketToRslPacket(rr.cpacket) == AbstractifyNetPacketToRslPacket(receive_event.r)
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env().Valid() && r.Env().ok.ok() ==> ok
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && Q_LReplica_Next_ProcessPacket(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && old_net_history + UdpEventLog == r.Env().udp.history()
    decreases r, old_net_history, rr, receive_event
  {
    ok := true;
    ghost var receive_io := LIoOpReceive(AbstractifyNetPacketToRslPacket(receive_event.r));
    assert r.ReceivedPacketProperties(rr.cpacket, receive_event, receive_io);
    ghost var midEnv := r.Env();
    assert midEnv == old(r.Env());
    ok, UdpEventLog, ios := Replica_Next_ReadClockAndProcessPacket(r, rr.cpacket, old_net_history, receive_event, receive_io);
    assert ok ==> r.Env() == midEnv == old(r.Env());
    if ok {
      assert Q_LReplica_Next_ProcessPacket(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios);
    }
    reveal Q_LReplica_Next_ProcessPacket();
  }

  method ReplicaNextProcessPacketNonHeartbeat(r: ReplicaImpl, ghost old_net_history: seq<UdpEvent>, rr: ReceiveResult, ghost receive_event: UdpEvent)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires r.Env().udp.history() == old_net_history + [receive_event]
    requires rr.RRPacket?
    requires receive_event.LIoOpReceive?
    requires !rr.cpacket.msg.CMessage_Heartbeat?
    requires NetPacketIsAbstractable(receive_event.r)
    requires CConfigurationIsValid(r.replica.constants.all.config)
    requires CPacketIsSendable(rr.cpacket)
    requires AbstractifyCPacketToRslPacket(rr.cpacket) == AbstractifyNetPacketToRslPacket(receive_event.r)
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env().Valid() && r.Env().ok.ok() ==> ok
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && Q_LReplica_Next_ProcessPacket(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && old_net_history + UdpEventLog == r.Env().udp.history()
    decreases r, old_net_history, rr, receive_event
  {
    ok := true;
    ghost var receive_io := LIoOpReceive(AbstractifyNetPacketToRslPacket(receive_event.r));
    assert r.ReceivedPacketProperties(rr.cpacket, receive_event, receive_io);
    ghost var midEnv := r.Env();
    assert midEnv == old(r.Env());
    ok, UdpEventLog, ios := Replica_Next_ProcessPacketWithoutReadingClock_body(r, rr.cpacket, old_net_history, receive_event, receive_io);
    assert ok ==> r.Env() == midEnv == old(r.Env());
    if ok {
      lemma_EstablishQLReplicaNextProcessPacket(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios);
    }
  }

  method Replica_Next_ProcessPacketX(r: ReplicaImpl)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires CConfigurationIsValid(r.replica.constants.all.config)
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env().Valid() && r.Env().ok.ok() ==> ok
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && (Q_LReplica_Next_ProcessPacket(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios) || (IosReflectIgnoringUnsendable(UdpEventLog) && old(r.AbstractifyToLReplica()) == r.AbstractifyToLReplica())) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history()
    decreases r
  {
    ghost var old_net_history := r.Env().udp.history();
    var rr;
    ghost var receive_event;
    rr, receive_event := Receive(r.netClient, r.localAddr, r.replica.constants.all.config, r.msg_grammar);
    assert r.Env() == old(r.Env());
    if rr.RRFail? {
      ok := false;
      return;
    } else if rr.RRTimeout? {
      ok := true;
      UdpEventLog, ios := ReplicaNextProcessPacketTimeout(r, old_net_history, receive_event);
    } else {
      var marshallable := DetermineIfMessageMarshallable(rr.cpacket.msg);
      if !marshallable {
        ok := true;
        UdpEventLog, ios := ReplicaNextProcessPacketUnmarshallable(r, old_net_history, rr, receive_event);
      } else if rr.cpacket.msg.CMessage_Heartbeat? {
        ok, UdpEventLog, ios := ReplicaNextProcessPacketHeartbeat(r, old_net_history, rr, receive_event);
      } else {
        ok, UdpEventLog, ios := ReplicaNextProcessPacketNonHeartbeat(r, old_net_history, rr, receive_event);
      }
    }
  }
}

module LiveByzRSL__ReplicaImplReadClock_i {

  import opened LiveByzRSL__QRelations_i

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened Collections__Seqs_i

  import opened Math__mod_auto_i

  import opened LiveByzRSL__CClockReading_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__CMessageRefinements_i

  import opened LiveByzRSL__CConfiguration_i

  import opened LiveByzRSL__CTypes_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__PacketParsing_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__ReplicaModel_i

  import opened LiveByzRSL__ReplicaImplLemmas_i

  import opened LiveByzRSL__ReplicaImplClass_i

  import opened LiveByzRSL__ReplicaImplDelivery_i

  import opened LiveBysRSL_ReplicaImplConditions_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__UdpRSL_i

  import opened Environment_s

  import opened Common__UdpClient_i

  import opened LiveByzRSL__ConstantsState_i
  lemma {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ /*{:_induction send_ios, all_ios}*/ lemma_ReplicaNextReadClockAndProcessPacketHelper(old_history: seq<UdpEvent>, pre_clock_history: seq<UdpEvent>, pre_delivery_history: seq<UdpEvent>, final_history: seq<UdpEvent>, receive_event: UdpEvent, clock_event: UdpEvent, send_events: seq<UdpEvent>, all_events: seq<UdpEvent>, receive_io: RslIo, clock_io: RslIo, send_ios: seq<RslIo>, ios_head: seq<RslIo>, all_ios: seq<RslIo>)
    requires pre_clock_history == old_history + [receive_event]
    requires pre_delivery_history == pre_clock_history + [clock_event]
    requires final_history == pre_delivery_history + send_events
    requires all_events == [receive_event, clock_event] + send_events
    requires UdpEventIsAbstractable(receive_event)
    requires receive_io == AbstractifyUdpEventToRslIo(receive_event)
    requires UdpEventIsAbstractable(clock_event)
    requires clock_io == AbstractifyUdpEventToRslIo(clock_event)
    requires RawIoConsistentWithSpecIO(send_events, send_ios)
    requires all_events == [receive_event, clock_event] + send_events
    requires ios_head == [receive_io, clock_io]
    requires all_ios == ios_head + send_ios
    requires receive_io.LIoOpReceive?
    requires clock_io.LIoOpReadClock?
    requires AllIosAreSends(send_ios)
    requires OnlySentMarshallableData(send_events)
    ensures final_history == old_history + all_events
    ensures RawIoConsistentWithSpecIO(all_events, all_ios)
    ensures ExtractSentPacketsFromIos(all_ios) == ExtractSentPacketsFromIos(send_ios)
    ensures forall io: LIoOp<NodeIdentity, RslMessage> {:trigger io.LIoOpSend?} {:trigger io in all_ios[2..]} :: io in all_ios[2..] ==> io.LIoOpSend?
    ensures OnlySentMarshallableData(all_events)
    decreases old_history, pre_clock_history, pre_delivery_history, final_history, receive_event, clock_event, send_events, all_events, receive_io, clock_io, send_ios, ios_head, all_ios
  {
  }

  method {:fuel CReplicaIsValid, 0, 0} {:timeLimitMultiplier 3} /*{:_timeLimit 30}*/ Replica_Next_ReadClockAndProcessPacket(r: ReplicaImpl, cpacket: CPacket, ghost old_net_history: seq<UdpEvent>, ghost receive_event: UdpEvent, ghost receive_io: RslIo)
      returns (ok: bool, ghost net_event_log: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires CConfigurationIsValid(r.replica.constants.all.config)
    requires r.ReceivedPacketProperties(cpacket, receive_event, receive_io)
    requires r.Env().udp.history() == old_net_history + [receive_event]
    requires cpacket.msg.CMessage_Heartbeat?
    requires Replica_Next_Process_Heartbeat_Preconditions(r.replica, cpacket)
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && CReplicaIsValid(r.replica) && r.nextActionIndex == old(r.nextActionIndex) && LReplica_Next_ReadClockAndProcessPacket_preconditions(ios) && ios[0] == receive_io && Q_LReplica_Next_ProcessPacket(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(net_event_log, ios) && OnlySentMarshallableData(net_event_log) && old_net_history + net_event_log == r.Env().udp.history()
    decreases r, cpacket, old_net_history, receive_event, receive_io
  {
    ghost var old_r_AbstractifyToLReplica := old(r.AbstractifyToLReplica());
    var clock, clock_event := ReadClock(r.netClient);
    ghost var clock_io := LIoOpReadClock(clock.t as int);
    assert clock.t as int == clock_event.t;
    assert clock_io == AbstractifyUdpEventToRslIo(clock_event);
    var sent_packets;
    var (t0, t1) := CReplicaNextProcessHeartbeat(r.replica, cpacket, clock.t);
    r.replica := t0;
    sent_packets := t1;
    ghost var send_events, send_ios;
    ghost var pre_delivery_history := r.Env().udp.history();
    ok, send_events, send_ios := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    ghost var ios_head := [receive_io, clock_io];
    ios := ios_head + send_ios;
    net_event_log := [receive_event, clock_event] + send_events;
    lemma_ReplicaNextReadClockAndProcessPacketHelper(old_net_history, old(r.Env().udp.history()), pre_delivery_history, r.Env().udp.history(), receive_event, clock_event, send_events, net_event_log, receive_io, clock_io, send_ios, ios_head, ios);
    assert LReplica_Next_ReadClockAndProcessPacket_preconditions(ios);
    assert LReplicaNextReadClockAndProcessPacket(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios);
    assert LReplicaNextProcessPacket(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios);
    assert Q_LReplica_Next_ProcessPacket(old_r_AbstractifyToLReplica, r.AbstractifyToLReplica(), ios) by {
      reveal Q_LReplica_Next_ProcessPacket();
    }
  }
}

module LiveByzRSL__ReplicaImplDelivery_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened Collections__Seqs_i

  import opened Math__mod_auto_i

  import opened LiveByzRSL__CClockReading_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__CMessageRefinements_i

  import opened LiveByzRSL__CTypes_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__PacketParsing_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__ReplicaModel_i

  import opened LiveByzRSL__ReplicaImplLemmas_i

  import opened LiveByzRSL__ReplicaImplClass_i

  import opened LiveByzRSL__QRelations_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__UdpRSL_i

  import opened Common__NodeIdentity_i

  import opened Common__UdpClient_i

  import opened Common__Util_i

  import opened Environment_s
  method DeliverPacket(r: ReplicaImpl, packets: OutboundPackets)
      returns (ok: bool, ghost netEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires packets.OutboundPacket?
    requires OutboundPacketsIsValid(packets)
    requires OutboundPacketsHasCorrectSrc(packets, r.replica.constants.all.config.replica_ids[r.replica.constants.my_index])
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures r.replica == old(r.replica)
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && AllIosAreSends(ios) && AbstractifyOutboundCPacketsToSeqOfRslPackets(packets) == ExtractSentPacketsFromIos(ios) && OnlySentMarshallableData(netEventLog) && RawIoConsistentWithSpecIO(netEventLog, ios) && old(r.Env().udp.history()) + netEventLog == r.Env().udp.history()
    decreases r, packets
  {
    ok, netEventLog := SendPacket(r.netClient, packets, r.localAddr);
    if !ok {
      print ""ReplicaImplDelivery: send packet fail\n"";
      return;
    }
    ios := MapSentPacketToIos(packets.p);
    lemma_MapSentPacketToIosExtractSentPacketsFromIosEquivalence(packets.p, ios);
    if packets.p.None? {
    } else {
    }
  }

  method {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ DeliverPacketSequence(r: ReplicaImpl, packets: OutboundPackets)
      returns (ok: bool, ghost netEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires packets.PacketSequence?
    requires OutboundPacketsIsValid(packets)
    requires OutboundPacketsIsAbstractable(packets)
    requires OutboundPacketsHasCorrectSrc(packets, r.replica.constants.all.config.replica_ids[r.replica.constants.my_index])
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures r.replica == old(r.replica)
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && AllIosAreSends(ios) && AbstractifyOutboundCPacketsToSeqOfRslPackets(packets) == ExtractSentPacketsFromIos(ios) && OnlySentMarshallableData(netEventLog) && RawIoConsistentWithSpecIO(netEventLog, ios) && old(r.Env().udp.history()) + netEventLog == r.Env().udp.history()
    decreases r, packets
  {
    ok, netEventLog := SendPacketSequence(r.netClient, packets, r.localAddr);
    if !ok {
      print ""ReplicaImplDelivery: send packetseq fail\n"";
      return;
    }
    ios := MapSentPacketSeqToIos(packets.s);
    lemma_MapSentPacketSeqToIosExtractSentPacketsFromIosEquivalence(packets, ios);
  }

  method {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ DeliverBroadcast(r: ReplicaImpl, broadcast: CBroadcast)
      returns (ok: bool, ghost netEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires CBroadcastIsValid(broadcast)
    requires broadcast.CBroadcast? ==> broadcast.src == r.replica.constants.all.config.replica_ids[r.replica.constants.my_index]
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures r.replica == old(r.replica)
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && AllIosAreSends(ios) && AbstractifyCBroadcastToRlsPacketSeq(broadcast) == ExtractSentPacketsFromIos(ios) && OnlySentMarshallableData(netEventLog) && RawIoConsistentWithSpecIO(netEventLog, ios) && old(r.Env().udp.history()) + netEventLog == r.Env().udp.history()
    decreases r, broadcast
  {
    ok, netEventLog := SendBroadcast(r.netClient, broadcast, r.localAddr);
    if !ok {
      print ""ReplicaImplDelivery: send broadcast fail\n"";
      return;
    }
    ios := MapBroadcastToIos(broadcast);
    lemma_MapBroadcastToIosExtractSentPacketsFromIosEquivalence(broadcast, ios);
    lemma_NetEventLogToBroadcastRefinable(netEventLog, broadcast);
    assert UdpEventLogIsAbstractable(netEventLog);
    if broadcast.CBroadcastNop? {
      assert RawIoConsistentWithSpecIO(netEventLog, ios);
    } else {
      ghost var broadcast_ios := BuildBroadcastIos(AbstractifyEndPointToNodeIdentity(broadcast.src), AbstractifyEndPointsToNodeIdentities(broadcast.dsts), AbstractifyCMessageToRslMessage(broadcast.msg));
      calc {
        AbstractifyRawLogToIos(netEventLog);
        {
          forall i: int | 0 <= i < |AbstractifyRawLogToIos(netEventLog)|
            ensures AbstractifyRawLogToIos(netEventLog)[i] == LIoOpSend(LPacket(AbstractifyEndPointsToNodeIdentities(broadcast.dsts)[i], AbstractifyEndPointToNodeIdentity(broadcast.src), AbstractifyCMessageToRslMessage(broadcast.msg)))
          {
            calc {
              AbstractifyRawLogToIos(netEventLog)[i];
              AbstractifyUdpEventToRslIo(netEventLog[i]);
              {
                lemma_NetEventLogToBroadcast(netEventLog, broadcast, i);
              }
              LIoOpSend(AbstractifyCBroadcastToRlsPacketSeq(broadcast)[i]);
              LIoOpSend(BuildLBroadcast(AbstractifyEndPointToNodeIdentity(broadcast.src), AbstractifyEndPointsToNodeIdentities(broadcast.dsts), AbstractifyCMessageToRslMessage(broadcast.msg))[i]);
              LIoOpSend(LPacket(AbstractifyEndPointsToNodeIdentities(broadcast.dsts)[i], AbstractifyEndPointToNodeIdentity(broadcast.src), AbstractifyCMessageToRslMessage(broadcast.msg)));
            }
          }
          forall i: int | 0 <= i < |broadcast_ios|
            ensures broadcast_ios[i] == LIoOpSend(LPacket(AbstractifyEndPointsToNodeIdentities(broadcast.dsts)[i], AbstractifyEndPointToNodeIdentity(broadcast.src), AbstractifyCMessageToRslMessage(broadcast.msg)))
          {
            calc {
              LIoOpSend(LPacket(AbstractifyEndPointsToNodeIdentities(broadcast.dsts)[i], AbstractifyEndPointToNodeIdentity(broadcast.src), AbstractifyCMessageToRslMessage(broadcast.msg)));
              BuildBroadcastIos(AbstractifyEndPointToNodeIdentity(broadcast.src), AbstractifyEndPointsToNodeIdentities(broadcast.dsts), AbstractifyCMessageToRslMessage(broadcast.msg))[i];
              broadcast_ios[i];
            }
          }
        }
        broadcast_ios;
        BuildBroadcastIos(AbstractifyEndPointToNodeIdentity(broadcast.src), AbstractifyEndPointsToNodeIdentities(broadcast.dsts), AbstractifyCMessageToRslMessage(broadcast.msg));
        MapBroadcastToIos(broadcast);
        ios;
      }
      assert RawIoConsistentWithSpecIO(netEventLog, ios);
    }
    if broadcast.CBroadcastNop? || (broadcast.CBroadcast? && |broadcast.dsts| as uint64 == 0) {
    } else if broadcast.CBroadcast? && |broadcast.dsts| as uint64 == 1 {
    } else {
    }
  }

  method DeliverOutboundPackets(r: ReplicaImpl, packets: OutboundPackets)
      returns (ok: bool, ghost netEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires OutboundPacketsIsValid(packets)
    requires OutboundPacketsIsAbstractable(packets)
    requires OutboundPacketsHasCorrectSrc(packets, r.replica.constants.all.config.replica_ids[r.replica.constants.my_index])
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures r.replica == old(r.replica)
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && AllIosAreSends(ios) && AbstractifyOutboundCPacketsToSeqOfRslPackets(packets) == ExtractSentPacketsFromIos(ios) && OnlySentMarshallableData(netEventLog) && RawIoConsistentWithSpecIO(netEventLog, ios) && OnlySentMarshallableData(netEventLog) && old(r.Env().udp.history()) + netEventLog == r.Env().udp.history()
    decreases r, packets
  {
    match packets {
      case {:split false} OutboundPacket(p) =>
        ok, netEventLog, ios := DeliverPacket(r, packets);
      case {:split false} PacketSequence(s) =>
        ok, netEventLog, ios := DeliverPacketSequence(r, packets);
      case {:split false} Broadcast(broadcast) =>
        ok, netEventLog, ios := DeliverBroadcast(r, broadcast);
    }
  }
}

module LiveByzRSL__ReplicaImplLemmas_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened Collections__Seqs_i

  import opened Math__mod_auto_i

  import opened LiveByzRSL__CClockReading_i

  import opened LiveByzRSL__ClockReading_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__CMessageRefinements_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__PacketParsing_i

  import opened LiveByzRSL__QRelations_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__ReplicaModel_i

  import opened LiveBysRSL_ReplicaImplConditions_i

  import opened LiveByzRSL__UdpRSL_i

  import opened Common__NodeIdentity_i

  import opened Concrete_NodeIdentity_i

  import opened Logic__Option_i

  import opened Environment_s
  function MapSentPacketToIos(sent_packet: Option<CPacket>): seq<RslIo>
    requires OutboundPacketsIsValid(OutboundPacket(sent_packet))
    decreases sent_packet
  {
    match sent_packet {
      case Some(p) =>
        [LIoOpSend(AbstractifyCPacketToRslPacket(p))]
      case None() =>
        []
    }
  }

  function {:opaque} {:fuel 0, 0} MapSentPacketSeqToIos(sent_packets: seq<CPacket>): seq<RslIo>
    requires OutboundPacketsIsValid(PacketSequence(sent_packets))
    requires OutboundPacketsIsAbstractable(PacketSequence(sent_packets))
    ensures |MapSentPacketSeqToIos(sent_packets)| == |sent_packets|
    ensures forall i: int {:trigger sent_packets[i]} {:trigger MapSentPacketSeqToIos(sent_packets)[i]} :: 0 <= i < |sent_packets| ==> MapSentPacketSeqToIos(sent_packets)[i] == LIoOpSend(AbstractifyCPacketToRslPacket(sent_packets[i]))
    decreases sent_packets
  {
    if |sent_packets| == 0 then
      []
    else if |sent_packets| == 1 then
      [LIoOpSend(AbstractifyCPacketToRslPacket(sent_packets[0]))]
    else
      [LIoOpSend(AbstractifyCPacketToRslPacket(sent_packets[0]))] + MapSentPacketSeqToIos(sent_packets[1..])
  }

  lemma {:timeLimitMultiplier 3} /*{:_timeLimit 30}*/ /*{:_induction ios}*/ lemma_MapSentPacketSeqToIosExtractSentPacketsFromIosEquivalence(sent_packets: OutboundPackets, ios: seq<RslIo>)
    requires sent_packets.PacketSequence?
    requires OutboundPacketsIsValid(sent_packets)
    requires OutboundPacketsIsAbstractable(sent_packets)
    requires ios == MapSentPacketSeqToIos(sent_packets.s)
    requires forall i: int {:trigger sent_packets.s[i]} :: 0 <= i < |sent_packets.s| ==> CPacketIsSendable(sent_packets.s[i])
    ensures AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets) == ExtractSentPacketsFromIos(ios)
    decreases |ios|
  {
  }

  function {:opaque} {:fuel 0, 0} BuildBroadcastIos(src: NodeIdentity, dsts: seq<NodeIdentity>, msg: RslMessage): seq<RslIo>
    ensures |BuildBroadcastIos(src, dsts, msg)| == |dsts|
    ensures forall i: int {:trigger dsts[i]} {:trigger BuildBroadcastIos(src, dsts, msg)[i]} :: 0 <= i < |dsts| ==> BuildBroadcastIos(src, dsts, msg)[i] == LIoOpSend(LPacket(dsts[i], src, msg))
    decreases src, dsts, msg
  {
    if |dsts| == 0 then
      []
    else
      [LIoOpSend(LPacket(dsts[0], src, msg))] + BuildBroadcastIos(src, dsts[1..], msg)
  }

  function MapBroadcastToIos(broadcast: CBroadcast): seq<RslIo>
    requires CBroadcastIsAbstractable(broadcast)
    decreases broadcast
  {
    match broadcast
    case CBroadcast(_, _, _) =>
      BuildBroadcastIos(AbstractifyEndPointToNodeIdentity(broadcast.src), AbstractifyEndPointsToNodeIdentities(broadcast.dsts), AbstractifyCMessageToRslMessage(broadcast.msg))
    case CBroadcastNop() =>
      []
  }

  predicate LReplica_Next_ReadClockAndProcessPacket_preconditions(ios: seq<RslIo>)
    decreases ios
  {
    |ios| >= 1 &&
    ios[0].LIoOpReceive? &&
    ios[0].r.msg.RslMessage_Heartbeat?
  }

  lemma /*{:_induction ios}*/ lemma_MapSentPacketToIosExtractSentPacketsFromIosEquivalence(sent_packet: Option<CPacket>, ios: seq<RslIo>)
    requires OutboundPacketsIsValid(OutboundPacket(sent_packet))
    requires ios == MapSentPacketToIos(sent_packet)
    ensures AbstractifyOutboundCPacketsToSeqOfRslPackets(OutboundPacket(sent_packet)) == ExtractSentPacketsFromIos(ios)
    decreases sent_packet, ios
  {
  }

  lemma /*{:_induction ios}*/ lemma_ExtractSentPacketsFromIos(ios: seq<RslIo>)
    requires AllIosAreSends(ios)
    ensures |ExtractSentPacketsFromIos(ios)| == |ios|
    ensures forall i: int {:auto_trigger} {:trigger ios[i]} {:trigger ExtractSentPacketsFromIos(ios)[i]} :: 0 <= i < |ios| ==> ExtractSentPacketsFromIos(ios)[i] == ios[i].s
    decreases ios
  {
  }

  lemma /*{:_induction ios}*/ lemma_MapBroadcastToIosExtractSentPacketsFromIosEquivalence(broadcast: CBroadcast, ios: seq<RslIo>)
    requires CBroadcastIsAbstractable(broadcast)
    requires ios == MapBroadcastToIos(broadcast)
    requires AllIosAreSends(ios)
    ensures AbstractifyCBroadcastToRlsPacketSeq(broadcast) == ExtractSentPacketsFromIos(ios)
    decreases broadcast, ios
  {
  }

  lemma lemma_NetEventLogToBroadcast(netEventLog: seq<UdpEvent>, broadcast: CBroadcast, index: int)
    requires CBroadcastIsValid(broadcast)
    requires broadcast.CBroadcast?
    requires 0 <= index < |netEventLog|
    requires SendLogReflectsBroadcast(netEventLog, broadcast)
    ensures netEventLog[index].LIoOpSend?
    ensures NetPacketIsAbstractable(netEventLog[index].s)
    ensures AbstractifyNetPacketToRslPacket(netEventLog[index].s) == AbstractifyCBroadcastToRlsPacketSeq(broadcast)[index]
    decreases netEventLog, broadcast, index
  {
  }

  lemma lemma_NetEventLogToBroadcastRefinable(netEventLog: seq<UdpEvent>, broadcast: CBroadcast)
    requires CBroadcastIsValid(broadcast)
    requires SendLogReflectsBroadcast(netEventLog, broadcast)
    ensures UdpEventLogIsAbstractable(netEventLog)
    decreases netEventLog, broadcast
  {
  }

  lemma /*{:_induction ios_head, ios_tail}*/ lemma_ExtractSentPacketsFromIosDoesNotMindSomeClutter(ios_head: seq<RslIo>, ios_tail: seq<RslIo>)
    requires forall i: int {:trigger ios_head[i]} :: 0 <= i < |ios_head| ==> !ios_head[i].LIoOpSend?
    ensures ExtractSentPacketsFromIos(ios_tail) == ExtractSentPacketsFromIos(ios_head + ios_tail)
    decreases ios_head, ios_tail
  {
  }

  predicate NoClockMessage(msg: CMessage)
    decreases msg
  {
    msg.CMessage_Request? || msg.CMessage_1a? || msg.CMessage_1b? || msg.CMessage_StartingPhase2? || msg.CMessage_1c? || msg.CMessage_2av? || msg.CMessage_2b? || msg.CMessage_Reply?
  }

  lemma lemma_YesWeHaveNoPackets()
    ensures AbstractifyOutboundCPacketsToSeqOfRslPackets(Broadcast(CBroadcastNop)) == []
  {
  }

  lemma lemma_CombineAbstractifyNetEventToRslIo(ios_head: seq<RslIo>, ios_tail: seq<RslIo>, ios: seq<RslIo>, log_head: seq<UdpEvent>, log_tail: seq<UdpEvent>, log: seq<UdpEvent>)
    requires |log_head| == |ios_head|
    requires forall i: int {:trigger ios_head[i]} {:trigger log_head[i]} :: (0 <= i < |log_head| ==> UdpEventIsAbstractable(log_head[i])) && (0 <= i < |log_head| ==> ios_head[i] == AbstractifyUdpEventToRslIo(log_head[i]))
    requires |log_tail| == |ios_tail|
    requires forall i: int {:trigger ios_tail[i]} {:trigger log_tail[i]} :: (0 <= i < |log_tail| ==> UdpEventIsAbstractable(log_tail[i])) && (0 <= i < |log_tail| ==> ios_tail[i] == AbstractifyUdpEventToRslIo(log_tail[i]))
    requires ios == ios_head + ios_tail
    requires log == log_head + log_tail
    ensures forall i: int {:trigger log[i]} {:trigger ios[i]} :: 0 <= i < |log| ==> ios[i] == AbstractifyUdpEventToRslIo(log[i])
    decreases ios_head, ios_tail, ios, log_head, log_tail, log
  {
  }

  lemma lemma_NetEventLogIsAbstractableExtend(log_head: seq<UdpEvent>, log_tail: seq<UdpEvent>, log: seq<UdpEvent>)
    requires log == log_head + log_tail
    requires UdpEventLogIsAbstractable(log_head)
    requires UdpEventLogIsAbstractable(log_tail)
    ensures UdpEventLogIsAbstractable(log)
    decreases log_head, log_tail, log
  {
  }

  lemma /*{:_induction ios_tail}*/ lemma_ReplicaNoReceiveReadClockNextHelper(replica: LReplica, replica': CReplica, clock: CClockReading, sent_packets: OutboundPackets, nextActionIndex: int, ios: seq<RslIo>, io0: RslIo, ios_head: seq<RslIo>, ios_tail: seq<RslIo>, netEvent0: UdpEvent, log_head: seq<UdpEvent>, log_tail: seq<UdpEvent>, netEventLog: seq<UdpEvent>)
    requires netEvent0.LIoOpReadClock?
    requires clock.t as int == netEvent0.t
    requires UdpEventIsAbstractable(netEvent0)
    requires io0 == LIoOpReadClock(clock.t as int)
    requires ReplicaCommonPostconditions(replica, replica', sent_packets)
    requires ghost var lreplica': LReplica := AbstractifyCReplicaToLReplica(replica'); ghost var lclock: ClockReading := AbstractifyCClockReadingToClockReading(clock); ghost var lsent_packets: seq<RslPacket> := AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets); (nextActionIndex == 3 || 9 <= nextActionIndex <= 11) && (nextActionIndex == 3 ==> Q_LReplica_Next_ReadClock_MaybeNominateValueAndSend1c(replica, lreplica', lclock, lsent_packets)) && (nextActionIndex == 9 ==> Q_LReplica_Next_ReadClock_CheckForViewTimeout(replica, lreplica', lclock, lsent_packets)) && (nextActionIndex == 10 ==> Q_LReplica_Next_ReadClock_CheckForQuorumOfViewSuspicions(replica, lreplica', lclock, lsent_packets)) && (nextActionIndex == 11 ==> Q_LReplica_Next_ReadClock_MaybeSendHeartbeat(replica, lreplica', lclock, lsent_packets))
    requires AllIosAreSends(ios_tail)
    requires AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets) == ExtractSentPacketsFromIos(ios_tail)
    requires RawIoConsistentWithSpecIO(log_tail, ios_tail)
    requires ios_head == [io0]
    requires log_head == [netEvent0]
    requires ios == ios_head + ios_tail
    requires netEventLog == log_head + log_tail
    ensures RawIoConsistentWithSpecIO(netEventLog, ios)
    ensures Q_LReplica_NoReceive_Next(replica, nextActionIndex as int, AbstractifyCReplicaToLReplica(replica'), ios)
    ensures forall io: LIoOp<NodeIdentity, RslMessage> {:trigger io.LIoOpSend?} {:trigger io in ios[1..]} :: io in ios[1..] ==> io.LIoOpSend?
    decreases replica, replica', clock, sent_packets, nextActionIndex, ios, io0, ios_head, ios_tail, netEvent0, log_head, log_tail, netEventLog
  {
  }
}

module LiveByzRSL__QRelations_i {

  import opened LiveByzRSL__ClockReading_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Replica_i
  predicate AllIosAreSends(ios: seq<RslIo>)
    decreases ios
  {
    forall i: int {:trigger ios[i]} :: 
      0 <= i < |ios| ==>
        ios[i].LIoOpSend?
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_Process_Invalid(replica: LReplica, replica': LReplica, lpacket: RslPacket, sent_packets: seq<RslPacket>)
    decreases replica, replica', lpacket, sent_packets
  {
    lpacket.msg.RslMessage_Invalid? &&
    LReplicaNextProcessInvalid(replica, replica', lpacket, sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_Process_Request(replica: LReplica, replica': LReplica, lpacket: RslPacket, sent_packets: seq<RslPacket>)
    decreases replica, replica', lpacket, sent_packets
  {
    lpacket.msg.RslMessage_Request? &&
    LReplicaNextProcessRequest(replica, replica', lpacket, sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_Process_1a(replica: LReplica, replica': LReplica, lpacket: RslPacket, sent_packets: seq<RslPacket>)
    decreases replica, replica', lpacket, sent_packets
  {
    lpacket.msg.RslMessage_1a? &&
    LReplicaNextProcess1a(replica, replica', lpacket, sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_Process_1b(replica: LReplica, replica': LReplica, lpacket: RslPacket, sent_packets: seq<RslPacket>)
    decreases replica, replica', lpacket, sent_packets
  {
    lpacket.msg.RslMessage_1b? &&
    LReplicaNextProcess1b(replica, replica', lpacket, sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_Process_StartingPhase2(replica: LReplica, replica': LReplica, lpacket: RslPacket, sent_packets: seq<RslPacket>)
    decreases replica, replica', lpacket, sent_packets
  {
    lpacket.msg.RslMessage_StartingPhase2? &&
    LReplicaNextProcessStartingPhase2(replica, replica', lpacket, sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_Process_1c(replica: LReplica, replica': LReplica, lpacket: RslPacket, sent_packets: seq<RslPacket>)
    decreases replica, replica', lpacket, sent_packets
  {
    lpacket.msg.RslMessage_1c? &&
    LReplicaNextProcess1c(replica, replica', lpacket, sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_Process_2av(replica: LReplica, replica': LReplica, lpacket: RslPacket, sent_packets: seq<RslPacket>)
    decreases replica, replica', lpacket, sent_packets
  {
    lpacket.msg.RslMessage_2av? &&
    LReplicaNextProcess2av(replica, replica', lpacket, sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_Process_2b(replica: LReplica, replica': LReplica, lpacket: RslPacket, sent_packets: seq<RslPacket>)
    decreases replica, replica', lpacket, sent_packets
  {
    lpacket.msg.RslMessage_2b? &&
    LReplicaNextProcess2b(replica, replica', lpacket, sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_Process_Reply(replica: LReplica, replica': LReplica, lpacket: RslPacket, sent_packets: seq<RslPacket>)
    decreases replica, replica', lpacket, sent_packets
  {
    lpacket.msg.RslMessage_Reply? &&
    LReplicaNextProcessReply(replica, replica', lpacket, sent_packets)
  }

  predicate LReplica_Next_ProcessPacketWithoutReadingClock_preconditions(ios: seq<RslIo>)
    decreases ios
  {
    |ios| >= 1 &&
    ios[0].LIoOpReceive? &&
    !ios[0].r.msg.RslMessage_Heartbeat?
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_ProcessPacketWithoutReadingClock(replica: LReplica, replica': LReplica, ios: seq<RslIo>)
    decreases replica, replica', ios
  {
    LReplica_Next_ProcessPacketWithoutReadingClock_preconditions(ios) &&
    LReplicaNextProcessPacketWithoutReadingClock(replica, replica', ios)
  }

  predicate Establish_Q_LReplica_Next_ProcessPacketWithoutReadingClock_preconditions(replica: LReplica, replica': LReplica, lpacket: RslPacket, sent_packets: seq<RslPacket>, ios: seq<RslIo>)
    decreases replica, replica', lpacket, sent_packets, ios
  {
    sent_packets == ExtractSentPacketsFromIos(ios) &&
    ((lpacket.msg.RslMessage_Request? && Q_LReplica_Next_Process_Request(replica, replica', lpacket, sent_packets)) || (lpacket.msg.RslMessage_1a? && Q_LReplica_Next_Process_1a(replica, replica', lpacket, sent_packets)) || (lpacket.msg.RslMessage_1b? && Q_LReplica_Next_Process_1b(replica, replica', lpacket, sent_packets)) || (lpacket.msg.RslMessage_StartingPhase2? && Q_LReplica_Next_Process_StartingPhase2(replica, replica', lpacket, sent_packets)) || (lpacket.msg.RslMessage_1c? && Q_LReplica_Next_Process_1c(replica, replica', lpacket, sent_packets)) || (lpacket.msg.RslMessage_2av? && Q_LReplica_Next_Process_2av(replica, replica', lpacket, sent_packets)) || (lpacket.msg.RslMessage_2b? && Q_LReplica_Next_Process_2b(replica, replica', lpacket, sent_packets)) || (lpacket.msg.RslMessage_Reply? && Q_LReplica_Next_Process_Reply(replica, replica', lpacket, sent_packets))) &&
    sent_packets == ExtractSentPacketsFromIos(ios)
  }

  lemma /*{:_induction ios}*/ lemma_EstablishQLReplicaNextProcessPacketWithoutReadingClock(replica: LReplica, replica': LReplica, lpacket: RslPacket, sent_packets: seq<RslPacket>, ios: seq<RslIo>)
    requires |ios| >= 1
    requires ios[0].LIoOpReceive?
    requires !ios[0].r.msg.RslMessage_Heartbeat?
    requires lpacket == ios[0].r
    requires AllIosAreSends(ios[1..])
    requires sent_packets == ExtractSentPacketsFromIos(ios)
    requires Establish_Q_LReplica_Next_ProcessPacketWithoutReadingClock_preconditions(replica, replica', lpacket, sent_packets, ios)
    ensures Q_LReplica_Next_ProcessPacketWithoutReadingClock(replica, replica', ios)
    decreases replica, replica', lpacket, sent_packets, ios
  {
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_Spontaneous_MaybeEnterNewViewAndSend1a(replica: LReplica, replica': LReplica, sent_packets: seq<RslPacket>)
    decreases replica, replica', sent_packets
  {
    LReplicaNextSpontaneousMaybeEnterNewViewAndSend1a(replica, replica', sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_Spontaneous_MaybeEnterPhase2(replica: LReplica, replica': LReplica, sent_packets: seq<RslPacket>)
    decreases replica, replica', sent_packets
  {
    LReplicaNextSpontaneousMaybeEnterPhase2(replica, replica', sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_Spontaneous_TruncateLogBasedOnCheckpoints(replica: LReplica, replica': LReplica, sent_packets: seq<RslPacket>)
    decreases replica, replica', sent_packets
  {
    LReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(replica, replica', sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_Spontaneous_MaybeDecide2bVal(replica: LReplica, replica': LReplica, sent_packets: seq<RslPacket>)
    decreases replica, replica', sent_packets
  {
    LReplicaNextSpontaneousMaybeDecide2bVal(replica, replica', sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_Spontaneous_MaybeSend2b(replica: LReplica, replica': LReplica, sent_packets: seq<RslPacket>)
    decreases replica, replica', sent_packets
  {
    LReplicaNextSpontaneousMaybeSend2b(replica, replica', sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_Spontaneous_MaybeMakeDecision(replica: LReplica, replica': LReplica, sent_packets: seq<RslPacket>)
    decreases replica, replica', sent_packets
  {
    LReplicaNextSpontaneousMaybeMakeDecision(replica, replica', sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_Spontaneous_MaybeExecute(replica: LReplica, replica': LReplica, sent_packets: seq<RslPacket>)
    decreases replica, replica', sent_packets
  {
    LReplicaNextSpontaneousMaybeExecute(replica, replica', sent_packets)
  }

  lemma /*{:_induction ios}*/ lemma_EstablishQLReplicaNoReceiveNextFromNoClock(replica: LReplica, replica': LReplica, sent_packets: seq<RslPacket>, nextActionIndex: int, ios: seq<RslIo>)
    requires sent_packets == ExtractSentPacketsFromIos(ios)
    requires SpontaneousIos(ios, 0)
    requires (nextActionIndex == 1 && Q_LReplica_Next_Spontaneous_MaybeEnterNewViewAndSend1a(replica, replica', sent_packets)) || (nextActionIndex == 2 && Q_LReplica_Next_Spontaneous_MaybeEnterPhase2(replica, replica', sent_packets)) || (nextActionIndex == 4 && Q_LReplica_Next_Spontaneous_MaybeDecide2bVal(replica, replica', sent_packets)) || (nextActionIndex == 5 && Q_LReplica_Next_Spontaneous_MaybeSend2b(replica, replica', sent_packets)) || (nextActionIndex == 6 && Q_LReplica_Next_Spontaneous_TruncateLogBasedOnCheckpoints(replica, replica', sent_packets)) || (nextActionIndex == 7 && Q_LReplica_Next_Spontaneous_MaybeMakeDecision(replica, replica', sent_packets)) || (nextActionIndex == 8 && Q_LReplica_Next_Spontaneous_MaybeExecute(replica, replica', sent_packets))
    ensures Q_LReplica_NoReceive_Next(replica, nextActionIndex as int, replica', ios)
    decreases replica, replica', sent_packets, nextActionIndex, ios
  {
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_ReadClock_MaybeNominateValueAndSend1c(replica: LReplica, replica': LReplica, clock: ClockReading, sent_packets: seq<RslPacket>)
    decreases replica, replica', clock, sent_packets
  {
    LReplicaNextReadClockMaybeNominateValueAndSend1c(replica, replica', clock, sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_ReadClock_CheckForViewTimeout(replica: LReplica, replica': LReplica, clock: ClockReading, sent_packets: seq<RslPacket>)
    decreases replica, replica', clock, sent_packets
  {
    LReplicaNextReadClockCheckForViewTimeout(replica, replica', clock, sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_ReadClock_CheckForQuorumOfViewSuspicions(replica: LReplica, replica': LReplica, clock: ClockReading, sent_packets: seq<RslPacket>)
    decreases replica, replica', clock, sent_packets
  {
    LReplicaNextReadClockCheckForQuorumOfViewSuspicions(replica, replica', clock, sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_ReadClock_MaybeSendHeartbeat(replica: LReplica, replica': LReplica, clock: ClockReading, sent_packets: seq<RslPacket>)
    decreases replica, replica', clock, sent_packets
  {
    LReplicaNextReadClockMaybeSendHeartbeat(replica, replica', clock, sent_packets)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_NoReceive_Next(replica: LReplica, nextActionIndex: int, replica': LReplica, ios: seq<RslIo>)
    decreases replica, nextActionIndex, replica', ios
  {
    LReplicaNoReceiveNext(replica, nextActionIndex, replica', ios)
  }

  predicate {:opaque} {:fuel 0, 0} Q_LReplica_Next_ProcessPacket(replica: LReplica, replica': LReplica, ios: seq<RslIo>)
    decreases replica, replica', ios
  {
    LReplicaNextProcessPacket(replica, replica', ios)
  }

  lemma lemma_EstablishQLReplicaNextProcessPacket(replica: LReplica, replica': LReplica, ios: seq<RslIo>)
    requires Q_LReplica_Next_ProcessPacketWithoutReadingClock(replica, replica', ios)
    ensures Q_LReplica_Next_ProcessPacket(replica, replica', ios)
    decreases replica, replica', ios
  {
  }

  lemma lemma_EstablishQLReplicaNextProcessPacketFromTimeout(replica: LReplica, replica': LReplica, ios: seq<RslIo>)
    requires |ios| == 1
    requires ios[0].LIoOpTimeoutReceive?
    requires replica == replica'
    ensures Q_LReplica_Next_ProcessPacket(replica, replica', ios)
    decreases replica, replica', ios
  {
  }

  predicate {:opaque} {:fuel 0, 0} Q_LScheduler_Next(s: LScheduler, s': LScheduler, ios: seq<RslIo>)
    decreases s, s', ios
  {
    LSchedulerNext(s, s', ios)
  }

  predicate Establish_Q_LReplica_NoReceive_Next_preconditions(replica: LReplica, replica': LReplica, clock: ClockReading, sent_packets: seq<RslPacket>, nextActionIndex: int, ios: seq<RslIo>)
    decreases replica, replica', clock, sent_packets, nextActionIndex, ios
  {
    SpontaneousIos(ios, 1) &&
    sent_packets == ExtractSentPacketsFromIos(ios) &&
    clock == SpontaneousClock(ios) &&
    ((nextActionIndex == 3 && Q_LReplica_Next_ReadClock_MaybeNominateValueAndSend1c(replica, replica', clock, sent_packets)) || (nextActionIndex == 9 && Q_LReplica_Next_ReadClock_CheckForViewTimeout(replica, replica', clock, sent_packets)) || (nextActionIndex == 10 && Q_LReplica_Next_ReadClock_CheckForQuorumOfViewSuspicions(replica, replica', clock, sent_packets)) || (nextActionIndex == 11 && Q_LReplica_Next_ReadClock_MaybeSendHeartbeat(replica, replica', clock, sent_packets))) &&
    sent_packets == ExtractSentPacketsFromIos(ios)
  }

  lemma lemma_EstablishQLReplicaNoReceiveNextFromReadClock(replica: LReplica, replica': LReplica, clock: ClockReading, sent_packets: seq<RslPacket>, nextActionIndex: int, ios: seq<RslIo>)
    requires Establish_Q_LReplica_NoReceive_Next_preconditions(replica, replica', clock, sent_packets, nextActionIndex, ios)
    ensures Q_LReplica_NoReceive_Next(replica, nextActionIndex, replica', ios)
    decreases replica, replica', clock, sent_packets, nextActionIndex, ios
  {
  }

  lemma lemma_EstablishQLSchedulerNext(replica: LReplica, replica': LReplica, ios: seq<RslIo>, s: LScheduler, s': LScheduler)
    requires 0 <= s.nextActionIndex <= 11
    requires 0 == s.nextActionIndex ==> Q_LReplica_Next_ProcessPacket(replica, replica', ios)
    requires 0 < s.nextActionIndex <= 6 ==> Q_LReplica_NoReceive_Next(replica, s.nextActionIndex, replica', ios)
    requires 6 < s.nextActionIndex <= 11 ==> Q_LReplica_NoReceive_Next(replica, s.nextActionIndex, replica', ios)
    requires s.replica == replica
    requires s'.replica == replica'
    requires s'.nextActionIndex == (s.nextActionIndex + 1) % LReplicaNumActions()
    ensures Q_LScheduler_Next(s, s', ios)
    decreases replica, replica', ios, s, s'
  {
  }
}

module LiveBysRSL_ReplicaImplConditions_i {

  import opened LiveByzRSL__ReplicaModel_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__CClockReading_i

  import opened LiveByzRSL__PacketParsing_i

  import opened LiveByzRSL__ConstantsState_i
  predicate Replica_Common_Preconditions(replica: CReplica, inp: CPacket)
    decreases replica, inp
  {
    CReplicaIsValid(replica) &&
    CPacketIsSendable(inp)
  }

  predicate Replica_Next_Process_Heartbeat_Preconditions(replica: CReplica, inp: CPacket)
    decreases replica, inp
  {
    inp.msg.CMessage_Heartbeat? &&
    CReplicaIsValid(replica) &&
    CPacketIsValid(inp) &&
    CMessageIsMarshallable(inp.msg)
  }

  predicate Replica_Next_ReadClock_MaybeNominateValueAndSend1c_Preconditions(replica: CReplica)
    decreases replica
  {
    CReplicaIsValid(replica)
  }

  predicate Replica_Next_ReadClock_MaybeNominateValueAndSend2av_Preconditions(replica: CReplica)
    decreases replica
  {
    CReplicaIsValid(replica)
  }

  predicate Replica_Next_ReadClock_CheckForViewTimeout_Preconditions(replica: CReplica)
    decreases replica
  {
    CReplicaIsValid(replica)
  }

  predicate Replica_Next_ReadClock_CheckForQuorumOfViewSuspicions_Preconditions(replica: CReplica)
    decreases replica
  {
    CReplicaIsValid(replica)
  }

  predicate Replica_Next_ReadClock_MaybeSendHeartbeat_Preconditions(replica: CReplica)
    decreases replica
  {
    CReplicaIsValid(replica)
  }

  predicate Replica_Next_MaybeEnterNewViewAndSend1a_Preconditions(replica: CReplica)
    decreases replica
  {
    CReplicaIsValid(replica)
  }

  predicate Replica_Next_MaybeEnterPhase2_Preconditions(replica: CReplica)
    decreases replica
  {
    CReplicaIsValid(replica)
  }

  predicate Replica_Next_Spontaneous_TruncateLogBasedOnCheckpoints_Preconditions(replica: CReplica)
    decreases replica
  {
    CReplicaIsValid(replica)
  }

  predicate Replica_Next_Spontaneous_MaybeMakeDecision_Preconditions(replica: CReplica)
    decreases replica
  {
    CReplicaIsValid(replica)
  }

  predicate Replica_Next_Spontaneous_MaybeExecute_Preconditions(replica: CReplica)
    decreases replica
  {
    CReplicaIsValid(replica)
  }

  predicate Replica_Next_Process_Request_Preconditions(replica: CReplica, inp: CPacket)
    decreases replica, inp
  {
    inp.msg.CMessage_Request? &&
    CReplicaIsValid(replica) &&
    CPacketIsValid(inp) &&
    CMessageIsMarshallable(inp.msg)
  }

  predicate Replica_Next_Process_1a_Preconditions(replica: CReplica, inp: CPacket)
    decreases replica, inp
  {
    inp.msg.CMessage_1a? &&
    CReplicaIsValid(replica) &&
    CPacketIsValid(inp) &&
    CMessageIsMarshallable(inp.msg)
  }

  predicate Replica_Next_Process_1b_Preconditions(replica: CReplica, inp: CPacket)
    decreases replica, inp
  {
    inp.msg.CMessage_1b? &&
    CReplicaIsValid(replica) &&
    CPacketIsValid(inp) &&
    CMessageIsMarshallable(inp.msg)
  }

  predicate Replica_Next_Process_StartingPhase2_Preconditions(replica: CReplica, inp: CPacket)
    decreases replica, inp
  {
    inp.msg.CMessage_StartingPhase2? &&
    CReplicaIsValid(replica) &&
    CPacketIsValid(inp) &&
    CMessageIsMarshallable(inp.msg)
  }

  predicate Replica_Next_Process_1c_Preconditions(replica: CReplica, inp: CPacket)
    decreases replica, inp
  {
    inp.msg.CMessage_1c? &&
    CReplicaIsValid(replica) &&
    CPacketIsValid(inp) &&
    CMessageIsMarshallable(inp.msg)
  }

  predicate Replica_Next_Process_2av_Preconditions(replica: CReplica, inp: CPacket)
    decreases replica, inp
  {
    inp.msg.CMessage_2av? &&
    CReplicaIsValid(replica) &&
    CPacketIsValid(inp) &&
    CMessageIsMarshallable(inp.msg)
  }

  predicate Replica_Next_Process_2b_Preconditions(replica: CReplica, inp: CPacket)
    decreases replica, inp
  {
    inp.msg.CMessage_2b? &&
    CReplicaIsValid(replica) &&
    CPacketIsValid(inp) &&
    CMessageIsMarshallable(inp.msg)
  }

  predicate Replica_Next_Process_2b_Postconditions(replica: LReplica, replica': CReplica, inp: CPacket, packets_sent: OutboundPackets)
    decreases replica, replica', inp, packets_sent
  {
    CPacketIsAbstractable(inp) &&
    inp.msg.CMessage_2b? &&
    Replica_Common_Postconditions(replica, replica', inp, packets_sent) &&
    LReplicaNextProcess2b(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_Process_1c_Postconditions(replica: LReplica, replica': CReplica, inp: CPacket, packets_sent: OutboundPackets)
    decreases replica, replica', inp, packets_sent
  {
    CPacketIsAbstractable(inp) &&
    inp.msg.CMessage_1c? &&
    Replica_Common_Postconditions(replica, replica', inp, packets_sent) &&
    LReplicaNextProcess1c(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_Process_2av_Postconditions(replica: LReplica, replica': CReplica, inp: CPacket, packets_sent: OutboundPackets)
    decreases replica, replica', inp, packets_sent
  {
    CPacketIsAbstractable(inp) &&
    inp.msg.CMessage_2av? &&
    Replica_Common_Postconditions(replica, replica', inp, packets_sent) &&
    LReplicaNextProcess2av(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_Process_StartingPhase2_Postconditions(replica: LReplica, replica': CReplica, inp: CPacket, packets_sent: OutboundPackets)
    decreases replica, replica', inp, packets_sent
  {
    CPacketIsAbstractable(inp) &&
    inp.msg.CMessage_StartingPhase2? &&
    Replica_Common_Postconditions(replica, replica', inp, packets_sent) &&
    LReplicaNextProcessStartingPhase2(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_Process_1b_Postconditions(replica: LReplica, replica': CReplica, inp: CPacket, packets_sent: OutboundPackets)
    decreases replica, replica', inp, packets_sent
  {
    CPacketIsAbstractable(inp) &&
    inp.msg.CMessage_1b? &&
    Replica_Common_Postconditions(replica, replica', inp, packets_sent) &&
    LReplicaNextProcess1b(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_Process_1a_Postconditions(replica: LReplica, replica': CReplica, inp: CPacket, packets_sent: OutboundPackets)
    decreases replica, replica', inp, packets_sent
  {
    CPacketIsAbstractable(inp) &&
    inp.msg.CMessage_1a? &&
    Replica_Common_Postconditions(replica, replica', inp, packets_sent) &&
    LReplicaNextProcess1a(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_Process_Request_Postconditions(replica: LReplica, replica': CReplica, inp: CPacket, packets_sent: OutboundPackets)
    decreases replica, replica', inp, packets_sent
  {
    CPacketIsAbstractable(inp) &&
    inp.msg.CMessage_Request? &&
    Replica_Common_Postconditions(replica, replica', inp, packets_sent) &&
    LReplicaNextProcessRequest(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate ReplicaCommonPostconditions(replica: LReplica, replica': CReplica, sent_packets: OutboundPackets)
    decreases replica, replica', sent_packets
  {
    CReplicaConstantsIsValid(replica'.constants) &&
    AbstractifyCReplicaConstantsToLReplicaConstants(replica'.constants) == replica.constants &&
    CReplicaIsAbstractable(replica') &&
    CReplicaIsValid(replica') &&
    OutboundPacketsIsValid(sent_packets) &&
    OutboundPacketsIsAbstractable(sent_packets) &&
    OutboundPacketsHasCorrectSrc(sent_packets, replica'.constants.all.config.replica_ids[replica'.constants.my_index])
  }

  predicate Replica_Next_Process_Heartbeat_Postconditions(replica: LReplica, replica': CReplica, inp: CPacket, clock: int, packets_sent: OutboundPackets)
    decreases replica, replica', inp, clock, packets_sent
  {
    CPacketIsAbstractable(inp) &&
    inp.msg.CMessage_Heartbeat? &&
    Replica_Common_Postconditions(replica, replica', inp, packets_sent) &&
    LReplicaNextProcessHeartbeat(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCPacketToRslPacket(inp), clock as int, AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_ReadClock_MaybeNominateValueAndSend1c_Postconditions(replica: LReplica, replica': CReplica, clock: CClockReading, packets_sent: OutboundPackets)
    decreases replica, replica', clock, packets_sent
  {
    Replica_Common_Postconditions_NoPacket(replica, replica', packets_sent) &&
    LReplicaNextReadClockMaybeNominateValueAndSend1c(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCClockReadingToClockReading(clock), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_ReadClock_CheckForViewTimeout_Postconditions(replica: LReplica, replica': CReplica, clock: CClockReading, packets_sent: OutboundPackets)
    decreases replica, replica', clock, packets_sent
  {
    Replica_Common_Postconditions_NoPacket(replica, replica', packets_sent) &&
    LReplicaNextReadClockCheckForViewTimeout(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCClockReadingToClockReading(clock), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_ReadClock_CheckForQuorumOfViewSuspicions_Postconditions(replica: LReplica, replica': CReplica, clock: CClockReading, packets_sent: OutboundPackets)
    decreases replica, replica', clock, packets_sent
  {
    Replica_Common_Postconditions_NoPacket(replica, replica', packets_sent) &&
    LReplicaNextReadClockCheckForQuorumOfViewSuspicions(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCClockReadingToClockReading(clock), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_ReadClock_MaybeSendHeartbeat_Postconditions(replica: LReplica, replica': CReplica, clock: CClockReading, packets_sent: OutboundPackets)
    decreases replica, replica', clock, packets_sent
  {
    Replica_Common_Postconditions_NoPacket(replica, replica', packets_sent) &&
    LReplicaNextReadClockMaybeSendHeartbeat(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCClockReadingToClockReading(clock), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_MaybeEnterNewViewAndSend1a_Postconditions(replica: LReplica, replica': CReplica, packets_sent: OutboundPackets)
    decreases replica, replica', packets_sent
  {
    Replica_Common_Postconditions_NoPacket(replica, replica', packets_sent) &&
    LReplicaNextSpontaneousMaybeEnterNewViewAndSend1a(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_MaybeEnterPhase2_Postconditions(replica: LReplica, replica': CReplica, packets_sent: OutboundPackets)
    decreases replica, replica', packets_sent
  {
    Replica_Common_Postconditions_NoPacket(replica, replica', packets_sent) &&
    LReplicaNextSpontaneousMaybeEnterPhase2(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_Spontaneous_TruncateLogBasedOnCheckpoints_Postconditions(replica: LReplica, replica': CReplica, packets_sent: OutboundPackets)
    decreases replica, replica', packets_sent
  {
    Replica_Common_Postconditions_NoPacket(replica, replica', packets_sent) &&
    LReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_Spontaneous_MaybeDecide2bVal_Postconditions(replica: LReplica, replica': CReplica, packets_sent: OutboundPackets)
    decreases replica, replica', packets_sent
  {
    Replica_Common_Postconditions_NoPacket(replica, replica', packets_sent) &&
    LReplicaNextSpontaneousMaybeDecide2bVal(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_MaybeSend2b_Postconditions(replica: LReplica, replica': CReplica, packets_sent: OutboundPackets)
    decreases replica, replica', packets_sent
  {
    Replica_Common_Postconditions_NoPacket(replica, replica', packets_sent) &&
    LReplicaNextSpontaneousMaybeSend2b(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_Spontaneous_MaybeMakeDecision_Postconditions(replica: LReplica, replica': CReplica, packets_sent: OutboundPackets)
    decreases replica, replica', packets_sent
  {
    Replica_Common_Postconditions_NoPacket(replica, replica', packets_sent) &&
    LReplicaNextSpontaneousMaybeMakeDecision(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }

  predicate Replica_Next_Spontaneous_MaybeExecute_Postconditions(replica: LReplica, replica': CReplica, packets_sent: OutboundPackets)
    decreases replica, replica', packets_sent
  {
    Replica_Common_Postconditions_NoPacket(replica, replica', packets_sent) &&
    LReplicaNextSpontaneousMaybeExecute(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
  }
}

module LiveByzRSL__ReplicaImplProcessPacketNoClock_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened Collections__Seqs_i

  import opened Math__mod_auto_i

  import opened LiveByzRSL__AppInterface_i

  import opened LiveByzRSL__CClockReading_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__CMessageRefinements_i

  import opened LiveByzRSL__CConfiguration_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__PacketParsing_i

  import opened LiveByzRSL__QRelations_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__ConstantsState_i

  import opened LiveByzRSL__ReplicaImplLemmas_i

  import opened LiveByzRSL__ReplicaImplClass_i

  import opened LiveByzRSL__ReplicaImplDelivery_i

  import opened LiveByzRSL__ReplicaModel_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__UdpRSL_i

  import opened LiveBysRSL_ReplicaImplConditions_i

  import opened Common__UdpClient_i

  import opened Environment_s

  import opened Logic__Option_i

  import opened Common__Util_i
  lemma lemma_ReplicaNextProcessPacketWithoutReadingClockHelper(cpacket: CPacket, sent_packets: OutboundPackets, old_net_history: seq<UdpEvent>, post_receive_net_history: seq<UdpEvent>, current_net_history: seq<UdpEvent>, receive_event: UdpEvent, send_events: seq<UdpEvent>, receive_io: RslIo, send_ios: seq<RslIo>)
      returns (UdpEventLog: seq<UdpEvent>, ios: seq<RslIo>)
    requires post_receive_net_history == old_net_history + [receive_event]
    requires current_net_history == post_receive_net_history + send_events
    requires receive_event.LIoOpReceive?
    requires !cpacket.msg.CMessage_Heartbeat?
    requires CPacketIsAbstractable(cpacket)
    requires UdpEventIsAbstractable(receive_event)
    requires AbstractifyCPacketToRslPacket(cpacket) == AbstractifyNetPacketToRslPacket(receive_event.r)
    requires receive_io == AbstractifyUdpEventToRslIo(receive_event)
    requires AllIosAreSends(send_ios)
    requires OutboundPacketsIsAbstractable(sent_packets)
    requires AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets) == ExtractSentPacketsFromIos(send_ios)
    requires RawIoConsistentWithSpecIO(send_events, send_ios)
    requires OnlySentMarshallableData(send_events)
    ensures RawIoConsistentWithSpecIO(UdpEventLog, ios)
    ensures |ios| >= 1
    ensures ios[0] == receive_io
    ensures AllIosAreSends(ios[1..])
    ensures current_net_history == old_net_history + UdpEventLog
    ensures AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets) == ExtractSentPacketsFromIos(ios)
    ensures OnlySentMarshallableData(UdpEventLog)
    decreases cpacket, sent_packets, old_net_history, post_receive_net_history, current_net_history, receive_event, send_events, receive_io, send_ios
  {
  }

  method {:fuel CReplicaIsValid, 0, 0} ReplicaNextProcessPacketInvalid(r: ReplicaImpl, cpacket: CPacket, ghost old_net_history: seq<UdpEvent>, ghost receive_event: UdpEvent, ghost receive_io: RslIo)
      returns (ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires old_net_history + [receive_event] == r.Env().udp.history()
    requires CConfigurationIsValid(r.replica.constants.all.config)
    requires r.ReceivedPacketProperties(cpacket, receive_event, receive_io)
    requires cpacket.msg.CMessage_Invalid?
    requires LReplica_Next_ProcessPacketWithoutReadingClock_preconditions([receive_io])
    ensures LReplica_Next_ProcessPacketWithoutReadingClock_preconditions(ios)
    ensures Q_LReplica_Next_ProcessPacketWithoutReadingClock(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios)
    ensures RawIoConsistentWithSpecIO(UdpEventLog, ios)
    ensures old_net_history + UdpEventLog == r.Env().udp.history()
    ensures OnlySentMarshallableData(UdpEventLog)
    decreases r, cpacket, old_net_history, receive_event, receive_io
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    ghost var rreplica := AbstractifyCReplicaToLReplica(r.replica);
    ghost var lpacket := AbstractifyCPacketToRslPacket(cpacket);
    var sent_packets := OutboundPacket(None());
    assert AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets) == [];
    assert Q_LReplica_Next_Process_Invalid(rreplica, r.AbstractifyToLReplica(), lpacket, AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets));
    ghost var send_events := [];
    ghost var send_ios := [];
    UdpEventLog, ios := lemma_ReplicaNextProcessPacketWithoutReadingClockHelper(cpacket, sent_packets, old_net_history, old(r.Env().udp.history()), r.Env().udp.history(), receive_event, send_events, receive_io, send_ios);
    lemma_EstablishQLReplicaNextProcessPacketWithoutReadingClock(rreplica, AbstractifyCReplicaToLReplica(r.replica), lpacket, AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets), ios);
  }

  lemma lemma_RevealQFromReplicaNextProcessRequestPostconditions(replica: LReplica, replica': CReplica, inp: CPacket, packets_sent: OutboundPackets)
    requires Replica_Next_Process_Request_Postconditions(replica, replica', inp, packets_sent)
    ensures Q_LReplica_Next_Process_Request(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', inp, packets_sent
  {
  }

  method {:fuel CReplicaIsValid, 0, 0} {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ ReplicaNextProcessPacketRequest(r: ReplicaImpl, cpacket: CPacket, ghost old_net_history: seq<UdpEvent>, ghost receive_event: UdpEvent, ghost receive_io: RslIo)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires old_net_history + [receive_event] == r.Env().udp.history()
    requires CConfigurationIsValid(r.replica.constants.all.config)
    requires r.ReceivedPacketProperties(cpacket, receive_event, receive_io)
    requires cpacket.msg.CMessage_Request?
    requires LReplica_Next_ProcessPacketWithoutReadingClock_preconditions([receive_io])
    requires Replica_Next_Process_Request_Preconditions(r.replica, cpacket)
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && LReplica_Next_ProcessPacketWithoutReadingClock_preconditions(ios) && Q_LReplica_Next_ProcessPacketWithoutReadingClock(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios) && OnlySentMarshallableData(UdpEventLog) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && r.Env() == old(r.Env()) && old_net_history + UdpEventLog == r.Env().udp.history()
    decreases r, cpacket, old_net_history, receive_event, receive_io
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    ghost var lpacket := AbstractifyCPacketToRslPacket(cpacket);
    ghost var net_client_old := r.netClient;
    ghost var net_addr_old := r.netClient.LocalEndPoint();
    assert UdpClientIsValid(net_client_old);
    var sent_packets;
    var (ta, tb) := CReplicaNextProcessRequest(r.replica, cpacket);
    r.replica := ta;
    sent_packets := tb;
    assert net_client_old == r.netClient;
    assert UdpClientIsValid(r.netClient);
    assert net_addr_old == r.netClient.LocalEndPoint();
    lemma_RevealQFromReplicaNextProcessRequestPostconditions(replica_old, r.replica, cpacket, sent_packets);
    assert OutboundPacketsHasCorrectSrc(sent_packets, r.replica.constants.all.config.replica_ids[r.replica.constants.my_index]);
    ghost var send_events, send_ios;
    assert r.Valid();
    ok, send_events, send_ios := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    UdpEventLog, ios := lemma_ReplicaNextProcessPacketWithoutReadingClockHelper(cpacket, sent_packets, old_net_history, old(r.Env().udp.history()), r.Env().udp.history(), receive_event, send_events, receive_io, send_ios);
    lemma_EstablishQLReplicaNextProcessPacketWithoutReadingClock(replica_old, AbstractifyCReplicaToLReplica(r.replica), lpacket, AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets), ios);
  }

  lemma lemma_RevealQFromReplicaNextProcess1aPostconditions(replica: LReplica, replica': CReplica, inp: CPacket, packets_sent: OutboundPackets)
    requires Replica_Next_Process_1a_Postconditions(replica, replica', inp, packets_sent)
    ensures Q_LReplica_Next_Process_1a(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', inp, packets_sent
  {
  }

  method {:fuel CReplicaIsValid, 0, 0} {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ ReplicaNextProcessPacket1a(r: ReplicaImpl, cpacket: CPacket, ghost old_net_history: seq<UdpEvent>, ghost receive_event: UdpEvent, ghost receive_io: RslIo)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires old_net_history + [receive_event] == r.Env().udp.history()
    requires CConfigurationIsValid(r.replica.constants.all.config)
    requires r.ReceivedPacketProperties(cpacket, receive_event, receive_io)
    requires cpacket.msg.CMessage_1a?
    requires LReplica_Next_ProcessPacketWithoutReadingClock_preconditions([receive_io])
    requires Replica_Next_Process_1a_Preconditions(r.replica, cpacket)
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && LReplica_Next_ProcessPacketWithoutReadingClock_preconditions(ios) && Q_LReplica_Next_ProcessPacketWithoutReadingClock(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && r.Env() == old(r.Env()) && old_net_history + UdpEventLog == r.Env().udp.history()
    decreases r, cpacket, old_net_history, receive_event, receive_io
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    ghost var lpacket := AbstractifyCPacketToRslPacket(cpacket);
    ghost var net_client_old := r.netClient;
    ghost var net_addr_old := r.netClient.LocalEndPoint();
    assert UdpClientIsValid(net_client_old);
    var sent_packets;
    var (t0, t1) := CReplicaNextProcess1a(r.replica, cpacket);
    r.replica := t0;
    sent_packets := t1;
    assert net_client_old == r.netClient;
    assert UdpClientIsValid(r.netClient);
    assert net_addr_old == r.netClient.LocalEndPoint();
    lemma_RevealQFromReplicaNextProcess1aPostconditions(replica_old, r.replica, cpacket, sent_packets);
    assert OutboundPacketsHasCorrectSrc(sent_packets, r.replica.constants.all.config.replica_ids[r.replica.constants.my_index]);
    ghost var send_events, send_ios;
    assert r.Valid();
    ok, send_events, send_ios := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    UdpEventLog, ios := lemma_ReplicaNextProcessPacketWithoutReadingClockHelper(cpacket, sent_packets, old_net_history, old(r.Env().udp.history()), r.Env().udp.history(), receive_event, send_events, receive_io, send_ios);
    lemma_EstablishQLReplicaNextProcessPacketWithoutReadingClock(replica_old, AbstractifyCReplicaToLReplica(r.replica), lpacket, AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets), ios);
  }

  lemma lemma_RevealQFromReplicaNextProcess1bPostconditions(replica: LReplica, replica': CReplica, inp: CPacket, packets_sent: OutboundPackets)
    requires Replica_Next_Process_1b_Postconditions(replica, replica', inp, packets_sent)
    ensures Q_LReplica_Next_Process_1b(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', inp, packets_sent
  {
  }

  method {:fuel CReplicaIsValid, 0, 0} {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ ReplicaNextProcessPacket1b(r: ReplicaImpl, cpacket: CPacket, ghost old_net_history: seq<UdpEvent>, ghost receive_event: UdpEvent, ghost receive_io: RslIo)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires old_net_history + [receive_event] == r.Env().udp.history()
    requires CConfigurationIsValid(r.replica.constants.all.config)
    requires r.ReceivedPacketProperties(cpacket, receive_event, receive_io)
    requires cpacket.msg.CMessage_1b?
    requires LReplica_Next_ProcessPacketWithoutReadingClock_preconditions([receive_io])
    requires Replica_Next_Process_1b_Preconditions(r.replica, cpacket)
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && LReplica_Next_ProcessPacketWithoutReadingClock_preconditions(ios) && Q_LReplica_Next_ProcessPacketWithoutReadingClock(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && r.Env() == old(r.Env()) && old_net_history + UdpEventLog == r.Env().udp.history()
    decreases r, cpacket, old_net_history, receive_event, receive_io
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    ghost var lpacket := AbstractifyCPacketToRslPacket(cpacket);
    ghost var net_client_old := r.netClient;
    ghost var net_addr_old := r.netClient.LocalEndPoint();
    assert UdpClientIsValid(net_client_old);
    var sent_packets;
    var (t0, t1) := CReplicaNextProcess1b(r.replica, cpacket);
    r.replica := t0;
    sent_packets := t1;
    assert net_client_old == r.netClient;
    assert UdpClientIsValid(r.netClient);
    assert net_addr_old == r.netClient.LocalEndPoint();
    lemma_RevealQFromReplicaNextProcess1bPostconditions(replica_old, r.replica, cpacket, sent_packets);
    assert OutboundPacketsHasCorrectSrc(sent_packets, r.replica.constants.all.config.replica_ids[r.replica.constants.my_index]);
    ghost var send_events, send_ios;
    assert r.Valid();
    ok, send_events, send_ios := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    UdpEventLog, ios := lemma_ReplicaNextProcessPacketWithoutReadingClockHelper(cpacket, sent_packets, old_net_history, old(r.Env().udp.history()), r.Env().udp.history(), receive_event, send_events, receive_io, send_ios);
    lemma_EstablishQLReplicaNextProcessPacketWithoutReadingClock(replica_old, AbstractifyCReplicaToLReplica(r.replica), lpacket, AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets), ios);
  }

  lemma lemma_RevealQFromReplicaNextProcessStartingPhase2Postconditions(replica: LReplica, replica': CReplica, inp: CPacket, packets_sent: OutboundPackets)
    requires Replica_Next_Process_StartingPhase2_Postconditions(replica, replica', inp, packets_sent)
    ensures Q_LReplica_Next_Process_StartingPhase2(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', inp, packets_sent
  {
  }

  method {:fuel CReplicaIsValid, 0, 0} {:timeLimitMultiplier 5} /*{:_timeLimit 50}*/ ReplicaNextProcessPacketStartingPhase2(r: ReplicaImpl, cpacket: CPacket, ghost old_net_history: seq<UdpEvent>, ghost receive_event: UdpEvent, ghost receive_io: RslIo)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires old_net_history + [receive_event] == r.Env().udp.history()
    requires CConfigurationIsValid(r.replica.constants.all.config)
    requires r.ReceivedPacketProperties(cpacket, receive_event, receive_io)
    requires cpacket.msg.CMessage_StartingPhase2?
    requires LReplica_Next_ProcessPacketWithoutReadingClock_preconditions([receive_io])
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && LReplica_Next_ProcessPacketWithoutReadingClock_preconditions(ios) && Q_LReplica_Next_ProcessPacketWithoutReadingClock(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && r.Env() == old(r.Env()) && old_net_history + UdpEventLog == r.Env().udp.history()
    decreases r, cpacket, old_net_history, receive_event, receive_io
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    ghost var lpacket := AbstractifyCPacketToRslPacket(cpacket);
    ghost var net_client_old := r.netClient;
    ghost var net_addr_old := r.netClient.LocalEndPoint();
    assert UdpClientIsValid(net_client_old);
    var sent_packets;
    var (t0, t1) := CReplicaNextProcessStartingPhase2(r.replica, cpacket);
    r.replica := t0;
    sent_packets := t1;
    assert net_client_old == r.netClient;
    assert UdpClientIsValid(r.netClient);
    assert net_addr_old == r.netClient.LocalEndPoint();
    lemma_RevealQFromReplicaNextProcessStartingPhase2Postconditions(replica_old, r.replica, cpacket, sent_packets);
    assert OutboundPacketsHasCorrectSrc(sent_packets, r.replica.constants.all.config.replica_ids[r.replica.constants.my_index]);
    ghost var send_events, send_ios;
    assert r.Valid();
    ok, send_events, send_ios := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    UdpEventLog, ios := lemma_ReplicaNextProcessPacketWithoutReadingClockHelper(cpacket, sent_packets, old_net_history, old(r.Env().udp.history()), r.Env().udp.history(), receive_event, send_events, receive_io, send_ios);
    lemma_EstablishQLReplicaNextProcessPacketWithoutReadingClock(replica_old, AbstractifyCReplicaToLReplica(r.replica), lpacket, AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets), ios);
  }

  lemma lemma_RevealQFromReplicaNextProcess1cPostconditions(replica: LReplica, replica': CReplica, inp: CPacket, packets_sent: OutboundPackets)
    requires Replica_Next_Process_1c_Postconditions(replica, replica', inp, packets_sent)
    ensures Q_LReplica_Next_Process_1c(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', inp, packets_sent
  {
  }

  method {:fuel CReplicaIsValid, 0, 0} {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ ReplicaNextProcessPacket1c(r: ReplicaImpl, cpacket: CPacket, ghost old_net_history: seq<UdpEvent>, ghost receive_event: UdpEvent, ghost receive_io: RslIo)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires old_net_history + [receive_event] == r.Env().udp.history()
    requires CConfigurationIsValid(r.replica.constants.all.config)
    requires r.ReceivedPacketProperties(cpacket, receive_event, receive_io)
    requires cpacket.msg.CMessage_1c?
    requires LReplica_Next_ProcessPacketWithoutReadingClock_preconditions([receive_io])
    requires Replica_Next_Process_1c_Preconditions(r.replica, cpacket)
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && LReplica_Next_ProcessPacketWithoutReadingClock_preconditions(ios) && Q_LReplica_Next_ProcessPacketWithoutReadingClock(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && r.Env() == old(r.Env()) && old_net_history + UdpEventLog == r.Env().udp.history()
    decreases r, cpacket, old_net_history, receive_event, receive_io
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    ghost var lpacket := AbstractifyCPacketToRslPacket(cpacket);
    ghost var net_client_old := r.netClient;
    ghost var net_addr_old := r.netClient.LocalEndPoint();
    assert UdpClientIsValid(net_client_old);
    var sent_packets;
    var t0, t1 := CReplicaNextProcess1c(r.replica, cpacket);
    r.replica := t0;
    sent_packets := t1;
    assert net_client_old == r.netClient;
    assert UdpClientIsValid(r.netClient);
    assert net_addr_old == r.netClient.LocalEndPoint();
    lemma_RevealQFromReplicaNextProcess1cPostconditions(replica_old, r.replica, cpacket, sent_packets);
    assert OutboundPacketsHasCorrectSrc(sent_packets, r.replica.constants.all.config.replica_ids[r.replica.constants.my_index]);
    ghost var send_events, send_ios;
    assert r.Valid();
    ok, send_events, send_ios := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    UdpEventLog, ios := lemma_ReplicaNextProcessPacketWithoutReadingClockHelper(cpacket, sent_packets, old_net_history, old(r.Env().udp.history()), r.Env().udp.history(), receive_event, send_events, receive_io, send_ios);
    lemma_EstablishQLReplicaNextProcessPacketWithoutReadingClock(replica_old, AbstractifyCReplicaToLReplica(r.replica), lpacket, AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets), ios);
  }

  lemma lemma_RevealQFromReplicaNextProcess2avPostconditions(replica: LReplica, replica': CReplica, inp: CPacket, packets_sent: OutboundPackets)
    requires Replica_Next_Process_2av_Postconditions(replica, replica', inp, packets_sent)
    ensures Q_LReplica_Next_Process_2av(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', inp, packets_sent
  {
  }

  method {:fuel CReplicaIsValid, 0, 0} {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ ReplicaNextProcessPacket2av(r: ReplicaImpl, cpacket: CPacket, ghost old_net_history: seq<UdpEvent>, ghost receive_event: UdpEvent, ghost receive_io: RslIo)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires old_net_history + [receive_event] == r.Env().udp.history()
    requires CConfigurationIsValid(r.replica.constants.all.config)
    requires r.ReceivedPacketProperties(cpacket, receive_event, receive_io)
    requires cpacket.msg.CMessage_2av?
    requires LReplica_Next_ProcessPacketWithoutReadingClock_preconditions([receive_io])
    requires Replica_Next_Process_2av_Preconditions(r.replica, cpacket)
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && LReplica_Next_ProcessPacketWithoutReadingClock_preconditions(ios) && Q_LReplica_Next_ProcessPacketWithoutReadingClock(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && r.Env() == old(r.Env()) && old_net_history + UdpEventLog == r.Env().udp.history()
    decreases r, cpacket, old_net_history, receive_event, receive_io
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    ghost var lpacket := AbstractifyCPacketToRslPacket(cpacket);
    ghost var net_client_old := r.netClient;
    ghost var net_addr_old := r.netClient.LocalEndPoint();
    assert UdpClientIsValid(net_client_old);
    var sent_packets;
    var (t0, t1) := CReplicaNextProcess2av(r.replica, cpacket);
    r.replica := t0;
    sent_packets := t1;
    assert net_client_old == r.netClient;
    assert UdpClientIsValid(r.netClient);
    assert net_addr_old == r.netClient.LocalEndPoint();
    lemma_RevealQFromReplicaNextProcess2avPostconditions(replica_old, r.replica, cpacket, sent_packets);
    assert OutboundPacketsHasCorrectSrc(sent_packets, r.replica.constants.all.config.replica_ids[r.replica.constants.my_index]);
    ghost var send_events, send_ios;
    assert r.Valid();
    ok, send_events, send_ios := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    UdpEventLog, ios := lemma_ReplicaNextProcessPacketWithoutReadingClockHelper(cpacket, sent_packets, old_net_history, old(r.Env().udp.history()), r.Env().udp.history(), receive_event, send_events, receive_io, send_ios);
    lemma_EstablishQLReplicaNextProcessPacketWithoutReadingClock(replica_old, AbstractifyCReplicaToLReplica(r.replica), lpacket, AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets), ios);
  }

  lemma lemma_RevealQFromReplicaNextProcess2bPostconditions(replica: LReplica, replica': CReplica, inp: CPacket, packets_sent: OutboundPackets)
    requires Replica_Next_Process_2b_Postconditions(replica, replica', inp, packets_sent)
    ensures Q_LReplica_Next_Process_2b(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCPacketToRslPacket(inp), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', inp, packets_sent
  {
  }

  method {:fuel CReplicaIsValid, 0, 0} {:timeLimitMultiplier 2} /*{:_timeLimit 20}*/ ReplicaNextProcessPacket2b(r: ReplicaImpl, cpacket: CPacket, ghost old_net_history: seq<UdpEvent>, ghost receive_event: UdpEvent, ghost receive_io: RslIo)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires old_net_history + [receive_event] == r.Env().udp.history()
    requires CConfigurationIsValid(r.replica.constants.all.config)
    requires r.ReceivedPacketProperties(cpacket, receive_event, receive_io)
    requires cpacket.msg.CMessage_2b?
    requires LReplica_Next_ProcessPacketWithoutReadingClock_preconditions([receive_io])
    requires Replica_Next_Process_2b_Preconditions(r.replica, cpacket)
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && LReplica_Next_ProcessPacketWithoutReadingClock_preconditions(ios) && Q_LReplica_Next_ProcessPacketWithoutReadingClock(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && r.Env() == old(r.Env()) && old_net_history + UdpEventLog == r.Env().udp.history()
    decreases r, cpacket, old_net_history, receive_event, receive_io
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    ghost var lpacket := AbstractifyCPacketToRslPacket(cpacket);
    ghost var net_client_old := r.netClient;
    ghost var net_addr_old := r.netClient.LocalEndPoint();
    assert UdpClientIsValid(net_client_old);
    var sent_packets;
    var (t0, t1) := CReplicaNextProcess2b(r.replica, cpacket);
    r.replica := t0;
    sent_packets := t1;
    assert net_client_old == r.netClient;
    assert UdpClientIsValid(r.netClient);
    assert net_addr_old == r.netClient.LocalEndPoint();
    lemma_RevealQFromReplicaNextProcess2bPostconditions(replica_old, r.replica, cpacket, sent_packets);
    assert OutboundPacketsHasCorrectSrc(sent_packets, r.replica.constants.all.config.replica_ids[r.replica.constants.my_index]);
    ghost var send_events, send_ios;
    assert r.Valid();
    ok, send_events, send_ios := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    UdpEventLog, ios := lemma_ReplicaNextProcessPacketWithoutReadingClockHelper(cpacket, sent_packets, old_net_history, old(r.Env().udp.history()), r.Env().udp.history(), receive_event, send_events, receive_io, send_ios);
    lemma_EstablishQLReplicaNextProcessPacketWithoutReadingClock(replica_old, AbstractifyCReplicaToLReplica(r.replica), lpacket, AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets), ios);
  }

  method {:fuel CReplicaIsValid, 0, 0} ReplicaNextProcessPacketReply(r: ReplicaImpl, cpacket: CPacket, ghost old_net_history: seq<UdpEvent>, ghost receive_event: UdpEvent, ghost receive_io: RslIo)
      returns (ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires old_net_history + [receive_event] == r.Env().udp.history()
    requires CConfigurationIsValid(r.replica.constants.all.config)
    requires r.ReceivedPacketProperties(cpacket, receive_event, receive_io)
    requires cpacket.msg.CMessage_Reply?
    requires LReplica_Next_ProcessPacketWithoutReadingClock_preconditions([receive_io])
    ensures LReplica_Next_ProcessPacketWithoutReadingClock_preconditions(ios)
    ensures Q_LReplica_Next_ProcessPacketWithoutReadingClock(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios)
    ensures RawIoConsistentWithSpecIO(UdpEventLog, ios)
    ensures OnlySentMarshallableData(UdpEventLog)
    ensures old_net_history + UdpEventLog == r.Env().udp.history()
    decreases r, cpacket, old_net_history, receive_event, receive_io
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    ghost var lpacket := AbstractifyCPacketToRslPacket(cpacket);
    var sent_packets := Broadcast(CBroadcastNop);
    lemma_YesWeHaveNoPackets();
    reveal Q_LReplica_Next_Process_Reply();
    assert Q_LReplica_Next_Process_Reply(replica_old, r.AbstractifyToLReplica(), lpacket, AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets));
    ghost var send_events := [];
    ghost var send_ios := [];
    calc {
      ExtractSentPacketsFromIos(send_ios);
      {
        reveal ExtractSentPacketsFromIos();
      }
      [];
    }
    UdpEventLog, ios := lemma_ReplicaNextProcessPacketWithoutReadingClockHelper(cpacket, sent_packets, old_net_history, old(r.Env().udp.history()), r.Env().udp.history(), receive_event, send_events, receive_io, send_ios);
    lemma_EstablishQLReplicaNextProcessPacketWithoutReadingClock(replica_old, AbstractifyCReplicaToLReplica(r.replica), lpacket, AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets), ios);
  }

  method {:fuel CReplicaIsValid, 0, 0} Replica_Next_ProcessPacketWithoutReadingClock_body(r: ReplicaImpl, cpacket: CPacket, ghost old_net_history: seq<UdpEvent>, ghost receive_event: UdpEvent, ghost receive_io: RslIo)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.Valid()
    requires old_net_history + [receive_event] == r.Env().udp.history()
    requires CConfigurationIsValid(r.replica.constants.all.config)
    requires r.ReceivedPacketProperties(cpacket, receive_event, receive_io)
    requires NoClockMessage(cpacket.msg)
    requires LReplica_Next_ProcessPacketWithoutReadingClock_preconditions([receive_io])
    requires cpacket.msg.CMessage_2b? ==> Replica_Next_Process_2b_Preconditions(r.replica, cpacket)
    requires cpacket.msg.CMessage_1c? ==> Replica_Next_Process_1c_Preconditions(r.replica, cpacket)
    requires cpacket.msg.CMessage_2av? ==> Replica_Next_Process_2av_Preconditions(r.replica, cpacket)
    requires cpacket.msg.CMessage_1a? ==> Replica_Next_Process_1a_Preconditions(r.replica, cpacket)
    requires cpacket.msg.CMessage_1b? ==> Replica_Next_Process_1b_Preconditions(r.replica, cpacket)
    requires cpacket.msg.CMessage_Request? ==> Replica_Next_Process_Request_Preconditions(r.replica, cpacket)
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && LReplica_Next_ProcessPacketWithoutReadingClock_preconditions(ios) && Q_LReplica_Next_ProcessPacketWithoutReadingClock(old(r.AbstractifyToLReplica()), r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && r.Env() == old(r.Env()) && old_net_history + UdpEventLog == r.Env().udp.history()
    decreases r, cpacket, old_net_history, receive_event, receive_io
  {
    if cpacket.msg.CMessage_Invalid? {
      ok := true;
      UdpEventLog, ios := ReplicaNextProcessPacketInvalid(r, cpacket, old_net_history, receive_event, receive_io);
    } else if cpacket.msg.CMessage_Request? {
      ok, UdpEventLog, ios := ReplicaNextProcessPacketRequest(r, cpacket, old_net_history, receive_event, receive_io);
    } else if cpacket.msg.CMessage_1a? {
      ok, UdpEventLog, ios := ReplicaNextProcessPacket1a(r, cpacket, old_net_history, receive_event, receive_io);
    } else if cpacket.msg.CMessage_1b? {
      ok, UdpEventLog, ios := ReplicaNextProcessPacket1b(r, cpacket, old_net_history, receive_event, receive_io);
    } else if cpacket.msg.CMessage_StartingPhase2? {
      ok, UdpEventLog, ios := ReplicaNextProcessPacketStartingPhase2(r, cpacket, old_net_history, receive_event, receive_io);
    } else if cpacket.msg.CMessage_1c? {
      ok, UdpEventLog, ios := ReplicaNextProcessPacket1c(r, cpacket, old_net_history, receive_event, receive_io);
    } else if cpacket.msg.CMessage_2av? {
      ok, UdpEventLog, ios := ReplicaNextProcessPacket2av(r, cpacket, old_net_history, receive_event, receive_io);
    } else if cpacket.msg.CMessage_2b? {
      ok, UdpEventLog, ios := ReplicaNextProcessPacket2b(r, cpacket, old_net_history, receive_event, receive_io);
    } else if cpacket.msg.CMessage_Reply? {
      ok := true;
      UdpEventLog, ios := ReplicaNextProcessPacketReply(r, cpacket, old_net_history, receive_event, receive_io);
    } else {
      assert false;
    }
  }
}

module LiveByzRSL__Unsendable_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__PacketParsing_i

  import opened Common__GenericMarshalling_i

  import opened Environment_s
  predicate IosReflectIgnoringUnsendable(ios: seq<LIoOp<EndPoint, seq<byte>>>)
    decreases ios
  {
    |ios| == 1 &&
    ios[0].LIoOpReceive? &&
    (!Demarshallable(ios[0].r.msg, CMessage_grammar()) || !Marshallable(parse_Message(DemarshallFunc(ios[0].r.msg, CMessage_grammar()))))
  }

  predicate HostNextIgnoreUnsendable(s: LScheduler, s': LScheduler, ios: seq<LIoOp<EndPoint, seq<byte>>>)
    decreases s, s', ios
  {
    s.nextActionIndex == 0 &&
    s' == s.(nextActionIndex := 1) &&
    IosReflectIgnoringUnsendable(ios)
  }
}

module LiveByzRSL__ReplicaImplNoReceiveNoClock_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened Collections__Seqs_i

  import opened Math__mod_auto_i

  import opened LiveByzRSL__CClockReading_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__CMessageRefinements_i

  import opened LiveByzRSL__CTypes_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__QRelations_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__ReplicaImplLemmas_i

  import opened LiveByzRSL__ReplicaImplClass_i

  import opened LiveByzRSL__ReplicaImplDelivery_i

  import opened LiveByzRSL__ReplicaModel_i

  import opened LiveByzRSL__PacketParsing_i

  import opened LiveBysRSL_ReplicaImplConditions_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__UdpRSL_i

  import opened Common__UdpClient_i

  import opened Environment_s
  lemma lemma_RevealQFromReplicaNextSpontaneousMaybeEnterNewViewAndSend1aPostconditions(replica: LReplica, replica': CReplica, packets_sent: OutboundPackets)
    requires Replica_Next_MaybeEnterNewViewAndSend1a_Postconditions(replica, replica', packets_sent)
    ensures Q_LReplica_Next_Spontaneous_MaybeEnterNewViewAndSend1a(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', packets_sent
  {
  }

  method ReplicaNoReceiveNoClockNextSpontaneousMaybeEnterNewViewAndSend1a(r: ReplicaImpl)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.nextActionIndex == 1
    requires r.Valid()
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && Q_LReplica_NoReceive_Next(old(r.AbstractifyToLReplica()), r.nextActionIndex as int, r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history()
    decreases r
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    var sent_packets;
    var (t0, t1) := CReplicaNextSpontaneousMaybeEnterNewViewAndSend1a(r.replica);
    r.replica := t0;
    sent_packets := t1;
    lemma_RevealQFromReplicaNextSpontaneousMaybeEnterNewViewAndSend1aPostconditions(replica_old, r.replica, sent_packets);
    ok, UdpEventLog, ios := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    assert old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history();
    assert SpontaneousIos(ios, 0);
    assert AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets) == ExtractSentPacketsFromIos(ios);
    assert r.Env() == old(r.Env());
    assert RawIoConsistentWithSpecIO(UdpEventLog, ios);
    lemma_EstablishQLReplicaNoReceiveNextFromNoClock(replica_old, r.AbstractifyToLReplica(), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets), r.nextActionIndex as int, ios);
  }

  lemma lemma_RevealQFromReplicaNextSpontaneousMaybeEnterPhase2Postconditions(replica: LReplica, replica': CReplica, packets_sent: OutboundPackets)
    requires Replica_Next_MaybeEnterPhase2_Postconditions(replica, replica', packets_sent)
    ensures Q_LReplica_Next_Spontaneous_MaybeEnterPhase2(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', packets_sent
  {
  }

  method ReplicaNoReceiveNoClockNextSpontaneousMaybeEnterPhase2(r: ReplicaImpl)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.nextActionIndex == 2
    requires r.Valid()
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && Q_LReplica_NoReceive_Next(old(r.AbstractifyToLReplica()), r.nextActionIndex as int, r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history()
    decreases r
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    var sent_packets;
    var (t0, t1) := CReplicaNextSpontaneousMaybeEnterPhase2(r.replica);
    r.replica := t0;
    sent_packets := t1;
    lemma_RevealQFromReplicaNextSpontaneousMaybeEnterPhase2Postconditions(replica_old, r.replica, sent_packets);
    ok, UdpEventLog, ios := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    assert old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history();
    assert SpontaneousIos(ios, 0);
    assert AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets) == ExtractSentPacketsFromIos(ios);
    assert r.Env() == old(r.Env());
    assert RawIoConsistentWithSpecIO(UdpEventLog, ios);
    lemma_EstablishQLReplicaNoReceiveNextFromNoClock(replica_old, r.AbstractifyToLReplica(), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets), r.nextActionIndex as int, ios);
  }

  lemma lemma_RevealQFromReplicaNextSpontaneousMaybeDecide2bValPostconditions(replica: LReplica, replica': CReplica, packets_sent: OutboundPackets)
    requires Replica_Next_Spontaneous_MaybeDecide2bVal_Postconditions(replica, replica', packets_sent)
    ensures Q_LReplica_Next_Spontaneous_MaybeDecide2bVal(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', packets_sent
  {
  }

  method {:fuel AbstractifyCReplicaToLReplica, 0, 0} {:fuel CReplicaIsValid, 0, 0} ReplicaNoReceiveNoClockNextSpontaneousMaybeDecide2bVal(r: ReplicaImpl)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.nextActionIndex == 4
    requires r.Valid()
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && Q_LReplica_NoReceive_Next(old(r.AbstractifyToLReplica()), r.nextActionIndex as int, r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history()
    decreases r
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    var sent_packets;
    var replica;
    assert CReplicaIsValid(r.replica);
    replica, sent_packets := CReplicaNextSpontaneousMaybeDecide2bVal(r.replica);
    assert CReplicaIsValid(replica);
    assert replica.constants == r.replica.constants;
    r.replica := replica;
    lemma_RevealQFromReplicaNextSpontaneousMaybeDecide2bValPostconditions(replica_old, r.replica, sent_packets);
    assert CReplicaIsAbstractable(r.replica);
    assert CReplicaIsValid(r.replica);
    assert r.Valid();
    ok, UdpEventLog, ios := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    assert old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history();
    assert SpontaneousIos(ios, 0);
    assert AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets) == ExtractSentPacketsFromIos(ios);
    assert r.Env() == old(r.Env());
    assert RawIoConsistentWithSpecIO(UdpEventLog, ios);
    lemma_EstablishQLReplicaNoReceiveNextFromNoClock(replica_old, r.AbstractifyToLReplica(), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets), r.nextActionIndex as int, ios);
  }

  lemma lemma_RevealQFromReplicaNextSpontaneousMaybeSend2bPostconditions(replica: LReplica, replica': CReplica, packets_sent: OutboundPackets)
    requires Replica_Next_MaybeSend2b_Postconditions(replica, replica', packets_sent)
    ensures Q_LReplica_Next_Spontaneous_MaybeSend2b(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', packets_sent
  {
  }

  method ReplicaNoReceiveNoClockNextSpontaneousMaybeSend2b(r: ReplicaImpl)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.nextActionIndex == 5
    requires r.Valid()
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && Q_LReplica_NoReceive_Next(old(r.AbstractifyToLReplica()), r.nextActionIndex as int, r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history()
    decreases r
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    var sent_packets;
    var (t0, t1) := CReplicaNextSpontaneousMaybeSend2b(r.replica);
    r.replica := t0;
    sent_packets := t1;
    lemma_RevealQFromReplicaNextSpontaneousMaybeSend2bPostconditions(replica_old, r.replica, sent_packets);
    ok, UdpEventLog, ios := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    assert old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history();
    assert SpontaneousIos(ios, 0);
    assert AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets) == ExtractSentPacketsFromIos(ios);
    assert r.Env() == old(r.Env());
    assert RawIoConsistentWithSpecIO(UdpEventLog, ios);
    lemma_EstablishQLReplicaNoReceiveNextFromNoClock(replica_old, r.AbstractifyToLReplica(), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets), r.nextActionIndex as int, ios);
  }

  lemma lemma_RevealQFromReplicaNextSpontaneousTruncateLogBasedOnCheckpointsPostconditions(replica: LReplica, replica': CReplica, packets_sent: OutboundPackets)
    requires Replica_Next_Spontaneous_TruncateLogBasedOnCheckpoints_Postconditions(replica, replica', packets_sent)
    ensures Q_LReplica_Next_Spontaneous_TruncateLogBasedOnCheckpoints(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', packets_sent
  {
  }

  method ReplicaNoReceiveNoClockNextSpontaneousTruncateLogBasedOnCheckpoints(r: ReplicaImpl)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.nextActionIndex == 6
    requires r.Valid()
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && Q_LReplica_NoReceive_Next(old(r.AbstractifyToLReplica()), r.nextActionIndex as int, r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history()
    decreases r
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    var sent_packets;
    var replica;
    assert CReplicaIsValid(r.replica);
    replica, sent_packets := CReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(r.replica);
    assert CReplicaIsValid(replica);
    r.replica := replica;
    lemma_RevealQFromReplicaNextSpontaneousTruncateLogBasedOnCheckpointsPostconditions(replica_old, r.replica, sent_packets);
    assert CReplicaIsAbstractable(r.replica);
    assert CReplicaIsValid(r.replica);
    assert r.Valid();
    assert OutboundPacketsIsValid(sent_packets);
    assert OutboundPacketsIsAbstractable(sent_packets);
    assert OutboundPacketsHasCorrectSrc(sent_packets, r.replica.constants.all.config.replica_ids[r.replica.constants.my_index]);
    ok, UdpEventLog, ios := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    assert old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history();
    assert SpontaneousIos(ios, 0);
    assert AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets) == ExtractSentPacketsFromIos(ios);
    assert r.Env() == old(r.Env());
    assert RawIoConsistentWithSpecIO(UdpEventLog, ios);
    lemma_EstablishQLReplicaNoReceiveNextFromNoClock(replica_old, r.AbstractifyToLReplica(), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets), r.nextActionIndex as int, ios);
  }

  lemma lemma_RevealQFromReplicaNextSpontaneousMaybeMakeDecisionPostconditions(replica: LReplica, replica': CReplica, packets_sent: OutboundPackets)
    requires Replica_Next_Spontaneous_MaybeMakeDecision_Postconditions(replica, replica', packets_sent)
    ensures Q_LReplica_Next_Spontaneous_MaybeMakeDecision(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', packets_sent
  {
  }

  method {:fuel AbstractifyCReplicaToLReplica, 0, 0} {:fuel CReplicaIsValid, 0, 0} ReplicaNoReceiveNoClockNextSpontaneousMaybeMakeDecision(r: ReplicaImpl)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.nextActionIndex == 7
    requires r.Valid()
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && Q_LReplica_NoReceive_Next(old(r.AbstractifyToLReplica()), r.nextActionIndex as int, r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history()
    decreases r
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    var sent_packets;
    var replica;
    assert CReplicaIsValid(r.replica);
    assert r.Valid();
    replica, sent_packets := CReplicaNextSpontaneousMaybeMakeDecision(r.replica);
    assert CReplicaIsValid(replica);
    r.replica := replica;
    lemma_RevealQFromReplicaNextSpontaneousMaybeMakeDecisionPostconditions(replica_old, r.replica, sent_packets);
    assert CReplicaIsAbstractable(r.replica);
    assert CReplicaIsValid(r.replica);
    assert r.Valid();
    assert OutboundPacketsIsValid(sent_packets);
    assert OutboundPacketsIsAbstractable(sent_packets);
    assert OutboundPacketsHasCorrectSrc(sent_packets, r.replica.constants.all.config.replica_ids[r.replica.constants.my_index]);
    ok, UdpEventLog, ios := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    assert old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history();
    assert SpontaneousIos(ios, 0);
    assert AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets) == ExtractSentPacketsFromIos(ios);
    assert r.Env() == old(r.Env());
    assert RawIoConsistentWithSpecIO(UdpEventLog, ios);
    lemma_EstablishQLReplicaNoReceiveNextFromNoClock(replica_old, r.AbstractifyToLReplica(), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets), r.nextActionIndex as int, ios);
  }

  lemma lemma_RevealQFromReplicaNextSpontaneousMaybeExecutePostconditions(replica: LReplica, replica': CReplica, packets_sent: OutboundPackets)
    requires Replica_Next_Spontaneous_MaybeExecute_Postconditions(replica, replica', packets_sent)
    ensures Q_LReplica_Next_Spontaneous_MaybeExecute(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', packets_sent
  {
  }

  method ReplicaNoReceiveNoClockNextSpontaneousMaybeExecute(r: ReplicaImpl)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.nextActionIndex == 8
    requires r.Valid()
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && Q_LReplica_NoReceive_Next(old(r.AbstractifyToLReplica()), r.nextActionIndex as int, r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history()
    decreases r
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    var sent_packets;
    var (t0, t1) := CReplicaNextSpontaneousMaybeExecute(r.replica);
    assert CReplicaIsValid(t0);
    r.replica := t0;
    sent_packets := t1;
    lemma_RevealQFromReplicaNextSpontaneousMaybeExecutePostconditions(replica_old, r.replica, sent_packets);
    assert CReplicaIsValid(r.replica);
    ok, UdpEventLog, ios := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    assert old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history();
    assert SpontaneousIos(ios, 0);
    assert AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets) == ExtractSentPacketsFromIos(ios);
    assert r.Env() == old(r.Env());
    assert RawIoConsistentWithSpecIO(UdpEventLog, ios);
    assert Q_LReplica_Next_Spontaneous_MaybeExecute(replica_old, r.AbstractifyToLReplica(), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets));
    lemma_EstablishQLReplicaNoReceiveNextFromNoClock(replica_old, r.AbstractifyToLReplica(), AbstractifyOutboundCPacketsToSeqOfRslPackets(sent_packets), r.nextActionIndex as int, ios);
  }

  method Replica_NoReceive_NoClock_Next(r: ReplicaImpl)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.nextActionIndex == 1 || r.nextActionIndex == 2 || r.nextActionIndex == 4 || r.nextActionIndex == 5 || r.nextActionIndex == 6 || r.nextActionIndex == 7 || r.nextActionIndex == 8
    requires r.Valid()
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.nextActionIndex == old(r.nextActionIndex) && Q_LReplica_NoReceive_Next(old(r.AbstractifyToLReplica()), r.nextActionIndex as int, r.AbstractifyToLReplica(), ios) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && OnlySentMarshallableData(UdpEventLog) && old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history()
    decreases r
  {
    if r.nextActionIndex == 1 {
      ok, UdpEventLog, ios := ReplicaNoReceiveNoClockNextSpontaneousMaybeEnterNewViewAndSend1a(r);
    } else if r.nextActionIndex == 2 {
      ok, UdpEventLog, ios := ReplicaNoReceiveNoClockNextSpontaneousMaybeEnterPhase2(r);
    } else if r.nextActionIndex == 4 {
      ok, UdpEventLog, ios := ReplicaNoReceiveNoClockNextSpontaneousMaybeDecide2bVal(r);
    } else if r.nextActionIndex == 5 {
      ok, UdpEventLog, ios := ReplicaNoReceiveNoClockNextSpontaneousMaybeSend2b(r);
    } else if r.nextActionIndex == 6 {
      ok, UdpEventLog, ios := ReplicaNoReceiveNoClockNextSpontaneousTruncateLogBasedOnCheckpoints(r);
    } else if r.nextActionIndex == 7 {
      ok, UdpEventLog, ios := ReplicaNoReceiveNoClockNextSpontaneousMaybeMakeDecision(r);
    } else if r.nextActionIndex == 8 {
      ok, UdpEventLog, ios := ReplicaNoReceiveNoClockNextSpontaneousMaybeExecute(r);
    }
  }
}

module LiveByzRSL__ReplicaImplNoReceiveClock_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened Collections__Seqs_i

  import opened Math__mod_auto_i

  import opened LiveByzRSL__CClockReading_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__CMessageRefinements_i

  import opened LiveByzRSL__CTypes_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__QRelations_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__ReplicaModel_i

  import opened LiveBysRSL_ReplicaImplConditions_i

  import opened LiveByzRSL__ReplicaImplLemmas_i

  import opened LiveByzRSL__ReplicaImplClass_i

  import opened LiveByzRSL__ReplicaImplDelivery_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__UdpRSL_i

  import opened Common__UdpClient_i

  import opened Environment_s
  lemma lemma_ReplicaNoReceiveReadClockNextHelper2(oldHistory: seq<UdpEvent>, preDeliveryHistory: seq<UdpEvent>, finalHistory: seq<UdpEvent>, log_head: seq<UdpEvent>, log_tail: seq<UdpEvent>, log_head_and_tail: seq<UdpEvent>)
    requires preDeliveryHistory == oldHistory + log_head
    requires finalHistory == preDeliveryHistory + log_tail
    requires log_head_and_tail == log_head + log_tail
    requires forall io: LIoOp<EndPoint, seq<byte>> {:trigger io.LIoOpSend?} {:trigger io in log_head} :: io in log_head ==> !io.LIoOpSend?
    requires OnlySentMarshallableData(log_tail)
    ensures finalHistory == oldHistory + log_head_and_tail
    ensures OnlySentMarshallableData(log_head_and_tail)
    decreases oldHistory, preDeliveryHistory, finalHistory, log_head, log_tail, log_head_and_tail
  {
  }

  lemma lemma_RevealQFromReplicaNextMaybeNominateValueAndSend1cPostconditions(replica: LReplica, replica': CReplica, clock: CClockReading, packets_sent: OutboundPackets)
    requires Replica_Next_ReadClock_MaybeNominateValueAndSend1c_Postconditions(replica, replica', clock, packets_sent)
    ensures Q_LReplica_Next_ReadClock_MaybeNominateValueAndSend1c(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCClockReadingToClockReading(clock), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', clock, packets_sent
  {
  }

  method {:fuel CReplicaIsValid, 0, 0} {:timeLimitMultiplier 3} /*{:_timeLimit 30}*/ ReplicaNoReceiveReadClockNextMaybeNominateValueAndSend1c(r: ReplicaImpl)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.nextActionIndex == 3
    requires r.Valid()
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.Env() == old(r.Env()) && r.nextActionIndex == old(r.nextActionIndex) && Q_LReplica_NoReceive_Next(old(r.AbstractifyToLReplica()), r.nextActionIndex as int, r.AbstractifyToLReplica(), ios) && OnlySentMarshallableData(UdpEventLog) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history()
    decreases r
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    var clock, UdpEvent0 := ReadClock(r.netClient);
    ghost var io0 := LIoOpReadClock(clock.t as int);
    var sent_packets;
    r.replica, sent_packets := CReplicaNextReadClockMaybeNominateValueAndSend1c(r.replica, clock);
    lemma_RevealQFromReplicaNextMaybeNominateValueAndSend1cPostconditions(replica_old, r.replica, clock, sent_packets);
    assert r.Valid();
    ghost var preDeliveryHistory := r.Env().udp.history();
    ghost var log_tail, ios_tail;
    ok, log_tail, ios_tail := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    ghost var ios_head := [io0];
    ghost var log_head := [UdpEvent0];
    ios := ios_head + ios_tail;
    UdpEventLog := log_head + log_tail;
    lemma_ReplicaNoReceiveReadClockNextHelper2(old(r.Env().udp.history()), preDeliveryHistory, r.Env().udp.history(), log_head, log_tail, UdpEventLog);
    lemma_ReplicaNoReceiveReadClockNextHelper(replica_old, r.replica, clock, sent_packets, r.nextActionIndex as int, ios, io0, ios_head, ios_tail, UdpEvent0, log_head, log_tail, UdpEventLog);
  }

  lemma lemma_RevealQFromReplicaNextCheckForViewTimeoutPostconditions(replica: LReplica, replica': CReplica, clock: CClockReading, packets_sent: OutboundPackets)
    requires Replica_Next_ReadClock_CheckForViewTimeout_Postconditions(replica, replica', clock, packets_sent)
    ensures Q_LReplica_Next_ReadClock_CheckForViewTimeout(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCClockReadingToClockReading(clock), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', clock, packets_sent
  {
  }

  method {:fuel CReplicaIsValid, 0, 0} {:timeLimitMultiplier 3} /*{:_timeLimit 30}*/ ReplicaNoReceiveReadClockNextCheckForViewTimeout(r: ReplicaImpl)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.nextActionIndex == 9
    requires r.Valid()
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.Env() == old(r.Env()) && r.nextActionIndex == old(r.nextActionIndex) && Q_LReplica_NoReceive_Next(old(r.AbstractifyToLReplica()), r.nextActionIndex as int, r.AbstractifyToLReplica(), ios) && OnlySentMarshallableData(UdpEventLog) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history()
    decreases r
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    var clock, UdpEvent0 := ReadClock(r.netClient);
    ghost var io0 := LIoOpReadClock(clock.t as int);
    var sent_packets;
    var (t0, t1) := CReplicaNextReadClockCheckForViewTimeout(r.replica, clock);
    r.replica := t0;
    sent_packets := t1;
    lemma_RevealQFromReplicaNextCheckForViewTimeoutPostconditions(replica_old, r.replica, clock, sent_packets);
    assert r.Valid();
    ghost var preDeliveryHistory := r.Env().udp.history();
    ghost var log_tail, ios_tail;
    ok, log_tail, ios_tail := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    ghost var ios_head := [io0];
    ghost var log_head := [UdpEvent0];
    ios := ios_head + ios_tail;
    UdpEventLog := log_head + log_tail;
    lemma_ReplicaNoReceiveReadClockNextHelper2(old(r.Env().udp.history()), preDeliveryHistory, r.Env().udp.history(), log_head, log_tail, UdpEventLog);
    lemma_ReplicaNoReceiveReadClockNextHelper(replica_old, r.replica, clock, sent_packets, r.nextActionIndex as int, ios, io0, ios_head, ios_tail, UdpEvent0, log_head, log_tail, UdpEventLog);
  }

  lemma lemma_RevealQFromReplicaNextCheckForQuorumOfViewSuspicionsPostconditions(replica: LReplica, replica': CReplica, clock: CClockReading, packets_sent: OutboundPackets)
    requires Replica_Next_ReadClock_CheckForQuorumOfViewSuspicions_Postconditions(replica, replica', clock, packets_sent)
    ensures Q_LReplica_Next_ReadClock_CheckForQuorumOfViewSuspicions(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCClockReadingToClockReading(clock), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', clock, packets_sent
  {
  }

  method {:fuel CReplicaIsValid, 0, 0} {:timeLimitMultiplier 3} /*{:_timeLimit 30}*/ ReplicaNoReceiveReadClockNextCheckForQuorumOfViewSuspicions(r: ReplicaImpl)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.nextActionIndex == 10
    requires r.Valid()
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.Env() == old(r.Env()) && r.nextActionIndex == old(r.nextActionIndex) && Q_LReplica_NoReceive_Next(old(r.AbstractifyToLReplica()), r.nextActionIndex as int, r.AbstractifyToLReplica(), ios) && OnlySentMarshallableData(UdpEventLog) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history()
    decreases r
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    var clock, UdpEvent0 := ReadClock(r.netClient);
    ghost var io0 := LIoOpReadClock(clock.t as int);
    var sent_packets;
    var (t0, t1) := CReplicaNextReadClockCheckForQuorumOfViewSuspicions(r.replica, clock);
    r.replica := t0;
    sent_packets := t1;
    lemma_RevealQFromReplicaNextCheckForQuorumOfViewSuspicionsPostconditions(replica_old, r.replica, clock, sent_packets);
    assert r.Valid();
    ghost var preDeliveryHistory := r.Env().udp.history();
    ghost var log_tail, ios_tail;
    ok, log_tail, ios_tail := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    ghost var ios_head := [io0];
    ghost var log_head := [UdpEvent0];
    ios := ios_head + ios_tail;
    UdpEventLog := log_head + log_tail;
    lemma_ReplicaNoReceiveReadClockNextHelper2(old(r.Env().udp.history()), preDeliveryHistory, r.Env().udp.history(), log_head, log_tail, UdpEventLog);
    lemma_ReplicaNoReceiveReadClockNextHelper(replica_old, r.replica, clock, sent_packets, r.nextActionIndex as int, ios, io0, ios_head, ios_tail, UdpEvent0, log_head, log_tail, UdpEventLog);
  }

  lemma lemma_RevealQFromReplicaNextMaybeSendHeartbeatPostconditions(replica: LReplica, replica': CReplica, clock: CClockReading, packets_sent: OutboundPackets)
    requires Replica_Next_ReadClock_MaybeSendHeartbeat_Postconditions(replica, replica', clock, packets_sent)
    ensures Q_LReplica_Next_ReadClock_MaybeSendHeartbeat(replica, AbstractifyCReplicaToLReplica(replica'), AbstractifyCClockReadingToClockReading(clock), AbstractifyOutboundCPacketsToSeqOfRslPackets(packets_sent))
    decreases replica, replica', clock, packets_sent
  {
  }

  method {:fuel CReplicaIsValid, 0, 0} {:timeLimitMultiplier 3} /*{:_timeLimit 30}*/ ReplicaNoReceiveReadClockNextMaybeSendHeartbat(r: ReplicaImpl)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.nextActionIndex == 11
    requires r.Valid()
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.Env() == old(r.Env()) && r.nextActionIndex == old(r.nextActionIndex) && Q_LReplica_NoReceive_Next(old(r.AbstractifyToLReplica()), r.nextActionIndex as int, r.AbstractifyToLReplica(), ios) && OnlySentMarshallableData(UdpEventLog) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history()
    decreases r
  {
    ghost var replica_old := AbstractifyCReplicaToLReplica(r.replica);
    var clock, UdpEvent0 := ReadClock(r.netClient);
    ghost var io0 := LIoOpReadClock(clock.t as int);
    var sent_packets;
    var (t0, t1) := CReplicaNextReadClockMaybeSendHeartbeat(r.replica, clock);
    r.replica := t0;
    sent_packets := t1;
    lemma_RevealQFromReplicaNextMaybeSendHeartbeatPostconditions(replica_old, r.replica, clock, sent_packets);
    assert r.Valid();
    ghost var preDeliveryHistory := r.Env().udp.history();
    ghost var log_tail, ios_tail;
    ok, log_tail, ios_tail := DeliverOutboundPackets(r, sent_packets);
    if !ok {
      return;
    }
    ghost var ios_head := [io0];
    ghost var log_head := [UdpEvent0];
    ios := ios_head + ios_tail;
    UdpEventLog := log_head + log_tail;
    lemma_ReplicaNoReceiveReadClockNextHelper2(old(r.Env().udp.history()), preDeliveryHistory, r.Env().udp.history(), log_head, log_tail, UdpEventLog);
    lemma_ReplicaNoReceiveReadClockNextHelper(replica_old, r.replica, clock, sent_packets, r.nextActionIndex as int, ios, io0, ios_head, ios_tail, UdpEvent0, log_head, log_tail, UdpEventLog);
  }

  method {:fuel CReplicaIsValid, 0, 0} Replica_NoReceive_ReadClock_Next(r: ReplicaImpl)
      returns (ok: bool, ghost UdpEventLog: seq<UdpEvent>, ghost ios: seq<RslIo>)
    requires r.nextActionIndex == 3 || 9 <= r.nextActionIndex <= 11
    requires r.Valid()
    modifies r.Repr
    ensures r.Repr == old(r.Repr)
    ensures r.netClient != null
    ensures ok == UdpClientOk(r.netClient)
    ensures r.Env() == old(r.Env())
    ensures ok ==> r.Valid() && r.Env() == old(r.Env()) && r.nextActionIndex == old(r.nextActionIndex) && Q_LReplica_NoReceive_Next(old(r.AbstractifyToLReplica()), r.nextActionIndex as int, r.AbstractifyToLReplica(), ios) && OnlySentMarshallableData(UdpEventLog) && RawIoConsistentWithSpecIO(UdpEventLog, ios) && old(r.Env().udp.history()) + UdpEventLog == r.Env().udp.history()
    decreases r
  {
    if r.nextActionIndex == 3 {
      ok, UdpEventLog, ios := ReplicaNoReceiveReadClockNextMaybeNominateValueAndSend1c(r);
    } else if r.nextActionIndex == 9 {
      ok, UdpEventLog, ios := ReplicaNoReceiveReadClockNextCheckForViewTimeout(r);
    } else if r.nextActionIndex == 10 {
      ok, UdpEventLog, ios := ReplicaNoReceiveReadClockNextCheckForQuorumOfViewSuspicions(r);
    } else if r.nextActionIndex == 11 {
      ok, UdpEventLog, ios := ReplicaNoReceiveReadClockNextMaybeSendHeartbat(r);
    }
  }
}

module LiveByzRSL__CmdLineParser_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened CmdLineParser_i

  import opened Common__UdpClient_i

  import opened LiveByzRSL__CConfiguration_i

  import opened Common__SeqIsUniqueDef_i

  import opened LiveByzRSL__Configuration_i

  import opened Common__NodeIdentity_i
  function paxos_config_parsing(args: seq<seq<uint16>>): CConfiguration
    decreases args
  {
    if args != [] && |args[1..]| % 2 == 0 then
      var (ok: bool, endpoints: seq<EndPoint>) := parse_end_points(args[1..]);
      CConfiguration(endpoints)
    else
      CConfiguration([])
  }

  function paxos_parse_id(ip: seq<uint16>, port: seq<uint16>): EndPoint
    decreases ip, port
  {
    var (ok: bool, ep: EndPoint) := parse_end_point(ip, port);
    ep
  }

  function paxos_cmd_line_parsing(env: HostEnvironment): (CConfiguration, EndPoint)
    reads env, env.constants
    decreases {env, env.constants}, env
  {
    ghost var args: seq<seq<uint16>> := env.constants.CommandLineArgs();
    if |args| < 2 then
      (CConfiguration([]), EndPoint([0, 0, 0, 0], 0))
    else
      ghost var penultimate_arg: seq<uint16>, final_arg: seq<uint16> := args[|args| - 2], args[|args| - 1]; ghost var config: CConfiguration := paxos_config_parsing(args[..|args| - 2]); ghost var me: EndPoint := paxos_parse_id(penultimate_arg, final_arg); (config, me)
  }

  lemma lemma_MinQuorumSizeLessThanReplicaCount(config: CConfiguration)
    requires CConfigurationIsAbstractable(config)
    requires |config.replica_ids| > 0
    requires SeqIsUnique(config.replica_ids)
    ensures LMinQuorumSize(AbstractifyCConfigurationToLConfiguration(config)) <= |config.replica_ids|
    decreases config
  {
  }

  method parse_cmd_line(ghost env: HostEnvironment)
      returns (ok: bool, config: CConfiguration, my_index: int)
    requires HostEnvironmentIsValid(env)
    ensures ok ==> CConfigurationIsValid(config)
    ensures ok ==> |config.replica_ids| > 0
    ensures ok ==> 0 <= my_index as int < |config.replica_ids|
    ensures var (config': CConfiguration, my_ep': EndPoint) := paxos_cmd_line_parsing(env); ok ==> config == config' && config.replica_ids[my_index] == my_ep'
    decreases env
  {
    ok := false;
    var num_args := HostConstants.NumCommandLineArgs(env);
    if num_args < 4 || num_args % 2 != 1 {
      print ""Incorrect number of command line arguments.\n"";
      print ""Expected: ./Main.exe [IP port]+ [IP port]\n"";
      print ""  where the final argument is one of the IP-port pairs provided earlier \n"";
      return;
    }
    var args := collect_cmd_line_args(env);
    assert args == env.constants.CommandLineArgs();
    var tuple1 := parse_end_points(args[1 .. |args| - 2]);
    ok := tuple1.0;
    var endpoints := tuple1.1;
    if !ok || |endpoints| >= 18446744073709551615 {
      ok := false;
      return;
    }
    var tuple2 := parse_end_point(args[|args| - 2], args[|args| - 1]);
    ok := tuple2.0;
    if !ok {
      return;
    }
    var unique := test_unique'(endpoints);
    if !unique {
      ok := false;
      return;
    }
    config := CConfiguration(endpoints);
    lemma_ConfigInit(tuple2.1, config);
    lemma_MinQuorumSizeLessThanReplicaCount(config);
    my_index := CGetReplicaIndex(tuple2.1, config);
    if !ok {
      return;
    }
    ghost var ghost_tuple := paxos_cmd_line_parsing(env);
    ghost var config', my_ep' := ghost_tuple.0, ghost_tuple.1;
    assert endpoints == config'.replica_ids;
    assert config == config';
    assert config.replica_ids[my_index] == my_ep';
  }

  lemma {:axiom} lemma_ConfigInit(id: EndPoint, c: CConfiguration)
    ensures CConfigurationIsValid(c)
    ensures id in c.replica_ids
    decreases id, c
}

module CmdLineParser_i {

  import opened Native__Io_s

  import opened Native__NativeTypes_s

  import opened Math__power_s

  import opened Common__SeqIsUniqueDef_i

  import opened Common__UdpClient_i
  function method ascii_to_int(short: uint16): (bool, byte)
    ensures var tuple: (bool, byte) := ascii_to_int(short); tuple.0 ==> 0 <= tuple.1 <= 9
    decreases short
  {
    if 48 <= short <= 57 then
      (true, (short - 48) as byte)
    else
      (false, 0)
  }

  method power10(e: nat) returns (val: int)
    ensures val == power(10, e)
    decreases e
  {
    reveal power();
    if e == 0 {
      return 1;
    } else {
      var tmp := power10(e - 1);
      return 10 * tmp;
    }
  }

  function method shorts_to_bytes(shorts: seq<uint16>): (bool, seq<byte>)
    decreases shorts
  {
    if |shorts| == 0 then
      (true, [])
    else
      var tuple: (bool, seq<byte>) := shorts_to_bytes(shorts[1..]); var ok: bool, rest: seq<byte> := tuple.0, tuple.1; var tuple': (bool, byte) := ascii_to_int(shorts[0]); var ok': bool, a_byte: byte := tuple'.0, tuple'.1; if ok && ok' then (true, [a_byte] + rest) else (false, [])
  }

  function method bytes_to_decimal(bytes: seq<byte>): nat
    decreases bytes
  {
    if |bytes| == 0 then
      0
    else
      bytes[|bytes| - 1] as int + 10 * bytes_to_decimal(bytes[0 .. |bytes| - 1])
  }

  function method shorts_to_nat(shorts: seq<uint16>): (bool, int)
    decreases shorts
  {
    if |shorts| == 0 then
      (false, 0)
    else
      var tuple: (bool, seq<byte>) := shorts_to_bytes(shorts); var ok: bool, bytes: seq<byte> := tuple.0, tuple.1; if !ok then (false, 0) else (true, bytes_to_decimal(bytes))
  }

  function method shorts_to_byte(shorts: seq<uint16>): (bool, byte)
    decreases shorts
  {
    var tuple: (bool, int) := shorts_to_nat(shorts);
    var ok: bool, val: int := tuple.0, tuple.1;
    if 0 <= val < 256 then
      (true, val as byte)
    else
      (false, 0)
  }

  function method shorts_to_uint16(shorts: seq<uint16>): (bool, uint16)
    decreases shorts
  {
    var tuple: (bool, int) := shorts_to_nat(shorts);
    var ok: bool, val: int := tuple.0, tuple.1;
    if 0 <= val < 65536 then
      (true, val as uint16)
    else
      (false, 0)
  }

  function method shorts_to_uint32(shorts: seq<uint16>): (bool, uint32)
    decreases shorts
  {
    var tuple: (bool, int) := shorts_to_nat(shorts);
    var ok: bool, val: int := tuple.0, tuple.1;
    if 0 <= val < 4294967296 then
      (true, val as uint32)
    else
      (false, 0)
  }

  function method is_ascii_period(short: uint16): bool
    decreases short
  {
    short == 46
  }

  function method parse_ip_addr_helper(ip_shorts: seq<uint16>, current_octet_shorts: seq<uint16>): (bool, seq<byte>)
    decreases ip_shorts, current_octet_shorts
  {
    if |ip_shorts| == 0 then
      var tuple: (bool, byte) := shorts_to_byte(current_octet_shorts);
      var okay: bool, b: byte := tuple.0, tuple.1;
      if !okay then
        (false, [])
      else
        (true, [b])
    else if is_ascii_period(ip_shorts[0]) then
      var tuple: (bool, byte) := shorts_to_byte(current_octet_shorts);
      var okay: bool, b: byte := tuple.0, tuple.1;
      if !okay then
        (false, [])
      else
        var tuple': (bool, seq<byte>) := parse_ip_addr_helper(ip_shorts[1..], []); var ok: bool, ip_bytes: seq<byte> := tuple'.0, tuple'.1; if !ok then (false, []) else (true, [b] + ip_bytes)
    else
      parse_ip_addr_helper(ip_shorts[1..], current_octet_shorts + [ip_shorts[0]])
  }

  function method parse_ip_addr(ip_shorts: seq<uint16>): (bool, seq<byte>)
    decreases ip_shorts
  {
    var tuple: (bool, seq<byte>) := parse_ip_addr_helper(ip_shorts, []);
    var ok: bool, ip_bytes: seq<byte> := tuple.0, tuple.1;
    if ok && |ip_bytes| == 4 then
      (true, ip_bytes)
    else
      (false, [])
  }

  function method {:opaque} {:fuel 0, 0} parse_end_point(ip_shorts: seq<uint16>, port_shorts: seq<uint16>): (bool, EndPoint)
    ensures var tuple: (bool, EndPoint) := parse_end_point(ip_shorts, port_shorts); var ok: bool, ep: EndPoint := tuple.0, tuple.1; ok ==> EndPointIsValidIPV4(ep)
    decreases ip_shorts, port_shorts
  {
    var tuple: (bool, seq<byte>) := parse_ip_addr(ip_shorts);
    var okay: bool, ip_bytes: seq<byte> := tuple.0, tuple.1;
    if !okay then
      (false, EndPoint([0, 0, 0, 0], 0))
    else
      var tuple': (bool, uint16) := shorts_to_uint16(port_shorts); var okay': bool, port: uint16 := tuple'.0, tuple'.1; if !okay' then (false, EndPoint([0, 0, 0, 0], 0)) else (true, EndPoint(ip_bytes, port))
  }

  method test_unique'(endpoints: seq<EndPoint>) returns (unique: bool)
    ensures unique <==> SeqIsUnique(endpoints)
    decreases endpoints
  {
    unique := true;
    var i := 0;
    while i < |endpoints|
      invariant 0 <= i <= |endpoints|
      invariant forall j: int, k: int {:trigger endpoints[k], endpoints[j]} :: 0 <= j < |endpoints| && 0 <= k < i && j != k ==> endpoints[j] != endpoints[k]
      decreases |endpoints| - i
    {
      var j := 0;
      while j < |endpoints|
        invariant 0 <= j <= |endpoints|
        invariant forall k: int {:trigger endpoints[k]} :: 0 <= k < j && k != i ==> endpoints[i] != endpoints[k]
        decreases |endpoints| - j
      {
        if i != j && endpoints[i] == endpoints[j] {
          unique := false;
          reveal_SeqIsUnique();
          return;
        }
        j := j + 1;
      }
      i := i + 1;
    }
    reveal SeqIsUnique();
  }

  function method parse_end_points(args: seq<seq<uint16>>): (bool, seq<EndPoint>)
    requires |args| % 2 == 0
    ensures var (ok: bool, endpoints: seq<EndPoint>) := parse_end_points(args); ok ==> forall e: EndPoint {:trigger EndPointIsValidIPV4(e)} {:trigger e in endpoints} :: e in endpoints ==> EndPointIsValidIPV4(e)
    decreases args
  {
    if |args| == 0 then
      (true, [])
    else
      var (ok1: bool, ep: EndPoint) := parse_end_point(args[0], args[1]); var (ok2: bool, rest: seq<EndPoint>) := parse_end_points(args[2..]); if !(ok1 && ok2) then (false, []) else (true, [ep] + rest)
  }

  method collect_cmd_line_args(ghost env: HostEnvironment) returns (args: seq<seq<uint16>>)
    requires HostEnvironmentIsValid(env)
    ensures |env.constants.CommandLineArgs()| == |args|
    ensures forall i: int {:trigger env.constants.CommandLineArgs()[i]} {:trigger args[i]} :: 0 <= i < |env.constants.CommandLineArgs()| ==> args[i] == env.constants.CommandLineArgs()[i]
    decreases env
  {
    var num_args := HostConstants.NumCommandLineArgs(env);
    var i := 0;
    args := [];
    while i < num_args
      invariant 0 <= i <= num_args
      invariant |env.constants.CommandLineArgs()[0 .. i]| == |args|
      invariant forall j: uint32 {:trigger env.constants.CommandLineArgs()[j]} {:trigger args[j]} :: 0 <= j < i ==> args[j] == env.constants.CommandLineArgs()[j]
      decreases num_args as int - i as int
    {
      var arg := HostConstants.GetCommandLineArg(i as uint64, env);
      args := args + [arg[..]];
      i := i + 1;
    }
  }
}

module DirectRefinement__Refinement_i {

  import opened DirectRefinement__StateMachine_i

  import opened DirectRefinement__HandleRequestBatch_i

  import opened DirectRefinement__Chosen_i

  import opened DirectRefinement__Execution_i

  import opened DirectRefinement__Requests_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Constants_i

  import opened CommonProof__Chosen_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__StateMachine_i

  import opened LiveByzRSL__Types_i

  import opened Collections__Seqs_s

  import opened Collections__Sets_i

  import opened Collections__Maps2_s

  import opened Temporal__Temporal_s

  import opened AppStateMachine_i

  import opened Concrete_NodeIdentity_i
  function GetServerAddresses(ps: RslState): set<NodeIdentity>
    decreases ps
  {
    MapSeqToSet(ps.constants.config.replica_ids, (x: EndPoint) => x)
  }

  function ProduceIntermediateAbstractState(server_addresses: set<NodeIdentity>, batches: seq<RequestBatch>, reqs_in_last_batch: int): RSLSystemState
    requires |batches| > 0
    requires 0 <= reqs_in_last_batch <= |last(batches)|
    decreases server_addresses, batches, reqs_in_last_batch
  {
    ghost var requests: set<Request> := set batch_num: int, req_num: int {:trigger batches[batch_num][req_num]} | 0 <= batch_num < |batches| && 0 <= req_num < if batch_num == |batches| - 1 then reqs_in_last_batch else |batches[batch_num]| :: batches[batch_num][req_num];
    ghost var replies: set<Reply> := set batch_num: int, req_num: int {:trigger GetReplyFromRequestBatches(batches, batch_num, req_num)} | 0 <= batch_num < |batches| && 0 <= req_num < if batch_num == |batches| - 1 then reqs_in_last_batch else |batches[batch_num]| :: GetReplyFromRequestBatches(batches, batch_num, req_num);
    ghost var stateBeforePrevBatch: AppState := GetAppStateFromRequestBatches(all_but_last(batches));
    ghost var appStatesDuringBatch: seq<AppState> := HandleRequestBatch(stateBeforePrevBatch, last(batches)).0;
    RSLSystemState(server_addresses, appStatesDuringBatch[reqs_in_last_batch], requests, replies)
  }

  function ProduceAbstractState(server_addresses: set<NodeIdentity>, batches: seq<RequestBatch>): RSLSystemState
    decreases server_addresses, batches
  {
    ghost var requests: set<Request> := set batch_num: int, req_num: int {:trigger batches[batch_num][req_num]} | 0 <= batch_num < |batches| && 0 <= req_num < |batches[batch_num]| :: batches[batch_num][req_num];
    ghost var replies: set<Reply> := set batch_num: int, req_num: int {:trigger GetReplyFromRequestBatches(batches, batch_num, req_num)} | 0 <= batch_num < |batches| && 0 <= req_num < |batches[batch_num]| :: GetReplyFromRequestBatches(batches, batch_num, req_num);
    RSLSystemState(server_addresses, GetAppStateFromRequestBatches(batches), requests, replies)
  }

  predicate SystemRefinementRelation(ps: RslState, rs: RSLSystemState)
    decreases ps, rs
  {
    exists qs: seq<QuorumOf2bs> {:trigger GetSequenceOfRequestBatches(qs)} {:trigger IsMaximalQuorumOf2bsSequence(ps, qs)} :: 
      IsMaximalQuorumOf2bsSequence(ps, qs) &&
      rs == ProduceAbstractState(GetServerAddresses(ps), GetSequenceOfRequestBatches(qs))
  }

  function {:opaque} {:fuel 0, 0} ConvertBehaviorSeqToImap<T>(s: seq<T>): imap<int, T>
    requires |s| > 0
    ensures imaptotal(ConvertBehaviorSeqToImap(s))
    ensures forall i: int {:trigger s[i]} {:trigger ConvertBehaviorSeqToImap(s)[i]} :: 0 <= i < |s| ==> ConvertBehaviorSeqToImap(s)[i] == s[i]
    decreases s
  {
    imap i: int {:trigger s[i]} | true :: if i < 0 then s[0] else if 0 <= i < |s| then s[i] else last(s)
  }

  lemma /*{:_induction qs}*/ lemma_ProduceAbstractStateSatisfiesRefinementRelation(b: Behavior<RslState>, c: LConstants, i: int, qs: seq<QuorumOf2bs>, rs: RSLSystemState)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires IsMaximalQuorumOf2bsSequence(b[i], qs)
    requires rs == ProduceAbstractState(GetServerAddresses(b[i]), GetSequenceOfRequestBatches(qs))
    ensures RslSystemRefinement(b[i], rs)
    decreases c, i, qs, rs
  {
  }

  lemma lemma_GetBehaviorRefinementForBehaviorOfOneStep(b: Behavior<RslState>, c: LConstants) returns (high_level_behavior: seq<RSLSystemState>)
    requires imaptotal(b)
    requires RslInit(c, b[0])
    ensures RslSystemBehaviorRefinementCorrectImap(b, 1, high_level_behavior)
    ensures |high_level_behavior| == 1
    ensures SystemRefinementRelation(b[0], high_level_behavior[0])
    decreases c
  {
  }

  predicate RslSystemBehaviorRefinementCorrectImap(b: Behavior<RslState>, prefix_len: int, high_level_behavior: seq<RSLSystemState>)
    decreases prefix_len, high_level_behavior
  {
    imaptotal(b) &&
    |high_level_behavior| == prefix_len &&
    (forall i: int {:trigger high_level_behavior[i]} {:trigger b[i]} :: 
      0 <= i < prefix_len ==>
        RslSystemRefinement(b[i], high_level_behavior[i])) &&
    |high_level_behavior| > 0 &&
    RslSystemInit(high_level_behavior[0], MapSeqToSet(b[0].constants.config.replica_ids, (x: EndPoint) => x)) &&
    forall i: int {:trigger RslSystemNext(high_level_behavior[i], high_level_behavior[i + 1])} :: 
      0 <= i < |high_level_behavior| - 1 ==>
        RslSystemNext(high_level_behavior[i], high_level_behavior[i + 1])
  }

  lemma lemma_FirstProduceIntermediateAbstractStateProducesAbstractState(server_addresses: set<NodeIdentity>, batches: seq<RequestBatch>)
    requires |batches| > 0
    ensures ProduceAbstractState(server_addresses, all_but_last(batches)) == ProduceIntermediateAbstractState(server_addresses, batches, 0)
    decreases server_addresses, batches
  {
  }

  lemma lemma_LastProduceIntermediateAbstractStateProducesAbstractState(server_addresses: set<NodeIdentity>, batches: seq<RequestBatch>)
    requires |batches| > 0
    ensures ProduceAbstractState(server_addresses, batches) == ProduceIntermediateAbstractState(server_addresses, batches, |last(batches)|)
    decreases server_addresses, batches
  {
  }

  lemma lemma_ProduceIntermediateAbstractStatesSatisfiesNext(server_addresses: set<NodeIdentity>, batches: seq<RequestBatch>, reqs_in_last_batch: int)
      returns (request: Request)
    requires |batches| > 0
    requires 0 <= reqs_in_last_batch < |last(batches)|
    ensures request == last(batches)[reqs_in_last_batch]
    ensures RslSystemNextServerExecutesRequest(ProduceIntermediateAbstractState(server_addresses, batches, reqs_in_last_batch), ProduceIntermediateAbstractState(server_addresses, batches, reqs_in_last_batch + 1), request)
    decreases server_addresses, batches, reqs_in_last_batch
  {
  }

  lemma lemma_DemonstrateRslSystemNextWhenBatchExtended(server_addresses: set<NodeIdentity>, s: RSLSystemState, s': RSLSystemState, batches: seq<RequestBatch>, count: int)
      returns (intermediate_states: seq<RSLSystemState>, batch: seq<Request>)
    requires |batches| > 0
    requires 0 <= count <= |last(batches)|
    requires s == ProduceIntermediateAbstractState(server_addresses, batches, 0)
    requires s' == ProduceIntermediateAbstractState(server_addresses, batches, count)
    ensures RslStateSequenceReflectsBatchExecution(s, s', intermediate_states, batch)
    ensures RslSystemNext(s, s')
    decreases count
  {
  }

  lemma lemma_DemonstrateRslSystemNextWhenBatchesAdded(server_addresses: set<NodeIdentity>, s: RSLSystemState, s': RSLSystemState, batches: seq<RequestBatch>, batches': seq<RequestBatch>)
      returns (intermediate_states: seq<RSLSystemState>, batch: seq<Request>)
    requires s == ProduceAbstractState(server_addresses, batches)
    requires s' == ProduceAbstractState(server_addresses, batches')
    requires |batches| <= |batches'|
    requires batches'[..|batches|] == batches
    ensures RslStateSequenceReflectsBatchExecution(s, s', intermediate_states, batch)
    ensures RslSystemNext(s, s')
    decreases |batches'|
  {
  }

  lemma lemma_GetBehaviorRefinementForPrefix(b: Behavior<RslState>, c: LConstants, i: int)
      returns (high_level_behavior: seq<RSLSystemState>)
    requires 0 <= i
    requires IsValidBehaviorPrefix(b, c, i)
    ensures RslSystemBehaviorRefinementCorrectImap(b, i + 1, high_level_behavior)
    ensures SystemRefinementRelation(b[i], last(high_level_behavior))
    decreases c, i
  {
  }

  lemma lemma_GetBehaviorRefinement(low_level_behavior: seq<RslState>, c: LConstants) returns (high_level_behavior: seq<RSLSystemState>)
    requires |low_level_behavior| > 0
    requires RslInit(c, low_level_behavior[0])
    requires forall i: int {:trigger RslNext(low_level_behavior[i], low_level_behavior[i + 1])} :: 0 <= i < |low_level_behavior| - 1 ==> RslNext(low_level_behavior[i], low_level_behavior[i + 1])
    ensures RslSystemBehaviorRefinementCorrect(MapSeqToSet(c.config.replica_ids, (x: EndPoint) => x), low_level_behavior, high_level_behavior)
    decreases low_level_behavior, c
  {
  }
}

module DirectRefinement__StateMachine_i {

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Types_i

  import opened Concrete_NodeIdentity_i

  import opened AppStateMachine_i

  import opened Collections__Seqs_s
  datatype RSLSystemState = RSLSystemState(server_addresses: set<NodeIdentity>, app: AppState, requests: set<Request>, replies: set<Reply>)

  predicate RslSystemInit(s: RSLSystemState, server_addresses: set<NodeIdentity>)
    decreases s, server_addresses
  {
    s.server_addresses == server_addresses &&
    s.app == AppInitialize() &&
    s.requests == {} &&
    s.replies == {}
  }

  predicate RslSystemNextServerExecutesRequest(s: RSLSystemState, s': RSLSystemState, req: Request)
    decreases s, s', req
  {
    s'.server_addresses == s.server_addresses &&
    s'.requests == s.requests + {req} &&
    s'.app == AppHandleRequest(s.app, req.request).0 &&
    s'.replies == s.replies + {Reply(req.client, req.seqno, AppHandleRequest(s.app, req.request).1)}
  }

  predicate RslStateSequenceReflectsBatchExecution(s: RSLSystemState, s': RSLSystemState, intermediate_states: seq<RSLSystemState>, batch: seq<Request>)
    decreases s, s', intermediate_states, batch
  {
    |intermediate_states| == |batch| + 1 &&
    intermediate_states[0] == s &&
    last(intermediate_states) == s' &&
    forall i: int, _t#0: int {:trigger batch[i], intermediate_states[_t#0]} {:trigger intermediate_states[_t#0], intermediate_states[i]} | _t#0 == i + 1 :: 
      0 <= i &&
      i < |batch| ==>
        RslSystemNextServerExecutesRequest(intermediate_states[i], intermediate_states[_t#0], batch[i])
  }

  predicate RslSystemNext(s: RSLSystemState, s': RSLSystemState)
    decreases s, s'
  {
    exists intermediate_states: seq<RSLSystemState>, batch: seq<Request> {:trigger RslStateSequenceReflectsBatchExecution(s, s', intermediate_states, batch)} :: 
      RslStateSequenceReflectsBatchExecution(s, s', intermediate_states, batch)
  }

  predicate RslSystemRefinement(ps: RslState, rs: RSLSystemState)
    decreases ps, rs
  {
    (forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.dst} {:trigger p.msg} {:trigger p.src} {:trigger p in ps.environment.sentPackets} :: 
      p in ps.environment.sentPackets &&
      p.src in rs.server_addresses &&
      p.msg.RslMessage_Reply? ==>
        Reply(p.dst, p.msg.seqno_reply, p.msg.reply) in rs.replies) &&
    forall req: Request {:trigger req in rs.requests} :: 
      req in rs.requests ==>
        exists p: LPacket<NodeIdentity, RslMessage> {:trigger p.src} {:trigger p.msg} {:trigger p.dst} {:trigger p in ps.environment.sentPackets} :: 
          p in ps.environment.sentPackets &&
          p.dst in rs.server_addresses &&
          p.msg.RslMessage_Request? &&
          req == Request(p.src, p.msg.seqno_req, p.msg.val)
  }

  predicate RslSystemBehaviorRefinementCorrect(server_addresses: set<NodeIdentity>, low_level_behavior: seq<RslState>, high_level_behavior: seq<RSLSystemState>)
    decreases server_addresses, low_level_behavior, high_level_behavior
  {
    |high_level_behavior| == |low_level_behavior| &&
    (forall i: int {:trigger high_level_behavior[i]} {:trigger low_level_behavior[i]} :: 
      0 <= i < |low_level_behavior| ==>
        RslSystemRefinement(low_level_behavior[i], high_level_behavior[i])) &&
    |high_level_behavior| > 0 &&
    RslSystemInit(high_level_behavior[0], server_addresses) &&
    forall i: int {:trigger high_level_behavior[i], high_level_behavior[i + 1]} :: 
      0 <= i < |high_level_behavior| - 1 ==>
        RslSystemNext(high_level_behavior[i], high_level_behavior[i + 1])
  }
}

module LiveByzRSL__DistributedSystem_i {

  import opened Collections__Maps2_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Parameters_i

  import opened Concrete_NodeIdentity_i

  import opened Environment_s
  datatype RslState = RslState(constants: LConstants, environment: LEnvironment<NodeIdentity, RslMessage>, replicas: seq<LScheduler>, clients: set<NodeIdentity>)

  predicate RslMapsComplete(ps: RslState)
    decreases ps
  {
    |ps.replicas| == |ps.constants.config.replica_ids|
  }

  predicate RslConstantsUnchanged(ps: RslState, ps': RslState)
    decreases ps, ps'
  {
    |ps'.replicas| == |ps.replicas| &&
    ps'.clients == ps.clients &&
    ps'.constants == ps.constants
  }

  predicate RslInit(con: LConstants, ps: RslState)
    decreases con, ps
  {
    WellFormedLConfiguration(con.config) &&
    WFLParameters(con.params) &&
    ps.constants == con &&
    LEnvironment_Init(ps.environment) &&
    RslMapsComplete(ps) &&
    forall i: int {:trigger LReplicaConstants(i, con)} {:trigger ps.replicas[i]} :: 
      0 <= i < |con.config.replica_ids| ==>
        LSchedulerInit(ps.replicas[i], LReplicaConstants(i, con))
  }

  predicate RslNextCommon(ps: RslState, ps': RslState)
    decreases ps, ps'
  {
    RslMapsComplete(ps) &&
    RslConstantsUnchanged(ps, ps') &&
    LEnvironment_Next(ps.environment, ps'.environment)
  }

  predicate RslNextOneReplica(ps: RslState, ps': RslState, idx: int, ios: seq<RslIo>)
    decreases ps, ps', idx, ios
  {
    RslNextCommon(ps, ps') &&
    0 <= idx < |ps.constants.config.replica_ids| &&
    LSchedulerNext(ps.replicas[idx], ps'.replicas[idx], ios) &&
    ps.environment.nextStep == LEnvStepHostIos(ps.constants.config.replica_ids[idx], ios) &&
    ps'.replicas == ps.replicas[idx := ps'.replicas[idx]]
  }

  predicate RslNextEnvironment(ps: RslState, ps': RslState)
    decreases ps, ps'
  {
    RslNextCommon(ps, ps') &&
    !ps.environment.nextStep.LEnvStepHostIos? &&
    ps'.replicas == ps.replicas
  }

  predicate RslNextOneExternal(ps: RslState, ps': RslState, eid: NodeIdentity, ios: seq<RslIo>)
    decreases ps, ps', eid, ios
  {
    RslNextCommon(ps, ps') &&
    eid !in ps.constants.config.replica_ids &&
    ps.environment.nextStep == LEnvStepHostIos(eid, ios) &&
    ps'.replicas == ps.replicas
  }

  predicate RslNext(ps: RslState, ps': RslState)
    decreases ps, ps'
  {
    (exists idx: int, ios: seq<RslIo> {:trigger RslNextOneReplica(ps, ps', idx, ios)} :: RslNextOneReplica(ps, ps', idx, ios)) || (exists eid: NodeIdentity, ios: seq<RslIo> {:trigger RslNextOneExternal(ps, ps', eid, ios)} :: RslNextOneExternal(ps, ps', eid, ios)) || RslNextEnvironment(ps, ps')
  }
}

module Collections__Maps2_i {

  import opened Collections__Maps2_s
  type imap2<!K1, !K2, V> = imap<K1, imap<K2, V>>

  function maprange<KT, VT>(m: map<KT, VT>): set<VT>
    decreases m
  {
    set k: KT {:trigger m[k]} {:trigger k in m} | k in m :: m[k]
  }

  predicate imap2total<K1(!new), K2(!new), V>(m: imap2<K1, K2, V>)
  {
    imaptotal(m) &&
    forall k1: K1 {:trigger m[k1]} :: 
      imaptotal(m[k1])
  }

  predicate imaptotal_(f: imap<int, int>)
  {
    imaptotal(f)
  }

  predicate monotonic(f: imap<int, int>)
  {
    forall i1: int, i2: int {:trigger f[i2], f[i1]} {:trigger f[i2], i1 in f} {:trigger f[i1], i2 in f} {:trigger i2 in f, i1 in f} :: 
      i1 in f &&
      i2 in f &&
      i1 <= i2 ==>
        f[i1] <= f[i2]
  }

  predicate monotonic_from(start: int, f: imap<int, int>)
    decreases start
  {
    forall i1: int, i2: int {:trigger f[i2], f[i1]} {:trigger f[i2], i1 in f} {:trigger f[i1], i2 in f} {:trigger i2 in f, i1 in f} :: 
      i1 in f &&
      i2 in f &&
      start <= i1 <= i2 ==>
        f[i1] <= f[i2]
  }

  predicate behaviorMonotonic<S>(b: imap<int, S>, f: imap<S, int>)
    requires imaptotal(b)
    requires imaptotal(f)
  {
    forall i1: int, i2: int {:trigger b[i2], b[i1]} :: 
      i1 <= i2 ==>
        f[b[i1]] <= f[b[i2]]
  }

  lemma Lemma_EqualityConditionForMapsWithSameDomain<S, T>(m1: map<S, T>, m2: map<S, T>)
    requires mapdomain(m1) == mapdomain(m2)
    requires forall s: S {:trigger m2[s]} {:trigger m1[s]} {:trigger s in m2} {:trigger s in m1} :: s in m1 && s in m2 ==> m1[s] == m2[s]
    ensures m1 == m2
    decreases m1, m2
  {
  }

  lemma Lemma_imap2equiv<K1, K2, V>(f: imap2<K1, K2, V>, g: imap2<K1, K2, V>)
    requires forall k1: K1 {:trigger k1 in g} {:trigger k1 in f} :: k1 in f <==> k1 in g
    requires forall k1: K1 {:trigger g[k1]} {:trigger f[k1]} {:trigger k1 in f} :: k1 in f ==> f[k1] == g[k1]
    ensures f == g
  {
  }

  predicate TLe(i: int, j: int)
    decreases i, j
  {
    i <= j
  }

  lemma Lemma_imapInductionRange(start: int, end: int, f: imap<int, bool>)
    requires TLe(start, end)
    requires forall i: int {:trigger i in f} {:trigger TLe(i, end)} {:trigger TLe(start, i)} :: TLe(start, i) && TLe(i, end) ==> i in f
    requires forall i: int, _t#0: int {:trigger f[_t#0], f[i]} {:trigger f[_t#0], TLe(start, i)} {:trigger f[i], TLe(_t#0, end)} {:trigger TLe(_t#0, end), TLe(start, i)} | _t#0 == i + 1 :: TLe(start, i) && TLe(_t#0, end) && f[i] ==> f[_t#0]
    requires f[start]
    ensures f[end]
    decreases end - start
  {
  }
}

module DirectRefinement__HandleRequestBatch_i {

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__StateMachine_i

  import opened LiveByzRSL__Types_i

  import opened Collections__Seqs_s

  import opened AppStateMachine_i
  function GetAppStateFromRequestBatches(batches: seq<RequestBatch>): AppState
    decreases batches
  {
    if |batches| == 0 then
      AppInitialize()
    else
      last(HandleRequestBatch(GetAppStateFromRequestBatches(all_but_last(batches)), last(batches)).0)
  }

  function GetReplyFromRequestBatches(batches: seq<RequestBatch>, batch_num: int, req_num: int): Reply
    requires 0 <= batch_num < |batches|
    requires 0 <= req_num < |batches[batch_num]|
    decreases batches, batch_num, req_num
  {
    ghost var prev_state: AppState := GetAppStateFromRequestBatches(batches[..batch_num]);
    ghost var result: (seq<AppState>, seq<Reply>) := HandleRequestBatch(prev_state, batches[batch_num]);
    result.1[req_num]
  }

  lemma lemma_GetReplyFromRequestBatchesMatchesInSubsequence(batches1: seq<RequestBatch>, batches2: seq<RequestBatch>, batch_num: int, req_num: int)
    requires 0 <= batch_num < |batches1| <= |batches2|
    requires batches1 == batches2[..|batches1|]
    requires 0 <= req_num < |batches1[batch_num]|
    ensures GetReplyFromRequestBatches(batches1, batch_num, req_num) == GetReplyFromRequestBatches(batches2, batch_num, req_num)
    decreases batches1, batches2, batch_num, req_num
  {
  }
}

module DirectRefinement__Chosen_i {

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__StateMachine_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__Configuration_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Chosen_i

  import opened CommonProof__Constants_i

  import opened CommonProof__Environment_i

  import opened Collections__Seqs_s

  import opened Collections__Sets_i

  import opened DirectRefinement__HandleRequestBatch_i

  import opened Temporal__Temporal_s
  predicate IsValidQuorumOf2bsSequence(ps: RslState, qs: seq<QuorumOf2bs>)
    decreases ps, qs
  {
    forall opn: int {:trigger qs[opn]} :: 
      (0 <= opn < |qs| ==>
        qs[opn].opn == opn) &&
      (0 <= opn < |qs| ==>
        IsValidQuorumOf2bs(ps, qs[opn]))
  }

  predicate IsMaximalQuorumOf2bsSequence(ps: RslState, qs: seq<QuorumOf2bs>)
    decreases ps, qs
  {
    IsValidQuorumOf2bsSequence(ps, qs) &&
    !exists q: QuorumOf2bs {:trigger q.opn} {:trigger IsValidQuorumOf2bs(ps, q)} :: IsValidQuorumOf2bs(ps, q) && q.opn == |qs|
  }

  function {:opaque} {:fuel 0, 0} GetSequenceOfRequestBatches(qs: seq<QuorumOf2bs>): seq<RequestBatch>
    ensures |GetSequenceOfRequestBatches(qs)| == |qs|
    decreases qs
  {
    if |qs| == 0 then
      []
    else
      GetSequenceOfRequestBatches(all_but_last(qs)) + [last(qs).v]
  }

  lemma /*{:_induction qs}*/ lemma_SequenceOfRequestBatchesNthElement(qs: seq<QuorumOf2bs>, n: int)
    requires 0 <= n < |qs|
    ensures GetSequenceOfRequestBatches(qs)[n] == qs[n].v
    decreases qs, n
  {
  }

  lemma lemma_GetUpperBoundOnQuorumOf2bsOperationNumber(b: Behavior<RslState>, c: LConstants, i: int)
      returns (bound: OperationNumber)
    requires IsValidBehaviorPrefix(b, c, i)
    ensures bound >= 0
    ensures !exists q: QuorumOf2bs {:trigger q.opn} {:trigger IsValidQuorumOf2bs(b[i], q)} :: IsValidQuorumOf2bs(b[i], q) && q.opn == bound
    decreases c, i
  {
  }

  lemma lemma_GetMaximalQuorumOf2bsSequenceWithinBound(b: Behavior<RslState>, c: LConstants, i: int, bound: OperationNumber)
      returns (qs: seq<QuorumOf2bs>)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= bound
    ensures IsValidQuorumOf2bsSequence(b[i], qs)
    ensures |qs| == bound || !exists q: QuorumOf2bs {:trigger q.opn} {:trigger IsValidQuorumOf2bs(b[i], q)} :: IsValidQuorumOf2bs(b[i], q) && q.opn == |qs|
    decreases c, i, bound
  {
  }

  lemma lemma_GetMaximalQuorumOf2bsSequence(b: Behavior<RslState>, c: LConstants, i: int)
      returns (qs: seq<QuorumOf2bs>)
    requires IsValidBehaviorPrefix(b, c, i)
    ensures IsMaximalQuorumOf2bsSequence(b[i], qs)
    decreases c, i
  {
  }

  lemma lemma_IfValidQuorumOf2bsSequenceNowThenNext(b: Behavior<RslState>, c: LConstants, i: int, qs: seq<QuorumOf2bs>)
    requires IsValidBehaviorPrefix(b, c, i + 1)
    requires 0 <= i
    requires IsValidQuorumOf2bsSequence(b[i], qs)
    ensures IsValidQuorumOf2bsSequence(b[i + 1], qs)
    decreases c, i, qs
  {
  }

  lemma /*{:_induction qs_regular, qs_maximal}*/ lemma_RegularQuorumOf2bSequenceIsPrefixOfMaximalQuorumOf2bSequence(b: Behavior<RslState>, c: LConstants, i: int, qs_regular: seq<QuorumOf2bs>, qs_maximal: seq<QuorumOf2bs>)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires IsValidQuorumOf2bsSequence(b[i], qs_regular)
    requires IsMaximalQuorumOf2bsSequence(b[i], qs_maximal)
    ensures |GetSequenceOfRequestBatches(qs_regular)| <= |GetSequenceOfRequestBatches(qs_maximal)|
    ensures GetSequenceOfRequestBatches(qs_regular) == GetSequenceOfRequestBatches(qs_maximal)[..|GetSequenceOfRequestBatches(qs_regular)|]
    decreases c, i, qs_regular, qs_maximal
  {
  }
}

module CommonProof__Constants_i {

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Constants_i

  import opened Temporal__Temporal_s

  import opened Temporal__Rules_i

  import opened Temporal__Heuristics_i

  import opened CommonProof__Assumptions_i
  predicate ConstantsAllConsistentInv(ps: RslState)
    decreases ps
  {
    |ps.constants.config.replica_ids| == |ps.replicas| &&
    forall idx: int {:trigger ps.replicas[idx]} :: 
      0 <= idx < |ps.constants.config.replica_ids| ==>
        ghost var s: LReplica := ps.replicas[idx].replica; s.constants.my_index == idx && s.constants.all == ps.constants && s.proposer.constants == s.constants && s.proposer.election_state.constants == s.constants && s.acceptor.constants == s.constants && s.learner.constants == s.constants && s.executor.constants == s.constants
  }

  lemma lemma_AssumptionsMakeValidTransition(b: Behavior<RslState>, c: LConstants, i: int)
    requires IsValidBehaviorPrefix(b, c, i + 1)
    requires 0 <= i
    ensures RslNext(b[i], b[i + 1])
    decreases c, i
  {
  }

  lemma lemma_ReplicasSize(b: Behavior<RslState>, c: LConstants, i: int)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    ensures |c.config.replica_ids| == |b[i].replicas|
    decreases c, i
  {
  }

  lemma lemma_ReplicaInState(b: Behavior<RslState>, c: LConstants, replica_index: int, i: int)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= replica_index < |c.config.replica_ids|
    ensures 0 <= replica_index < |b[i].replicas|
    decreases c, replica_index, i
  {
  }

  lemma lemma_ConstantsAllConsistent(b: Behavior<RslState>, c: LConstants, i: int)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    ensures b[i].constants == c
    ensures ConstantsAllConsistentInv(b[i])
    decreases c, i
  {
  }

  lemma lemma_ReplicaConstantsAllConsistent(b: Behavior<RslState>, c: LConstants, i: int, idx: int)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= idx < |b[i].replicas| || 0 <= idx < |c.config.replica_ids| || 0 <= idx < |b[i].constants.config.replica_ids|
    ensures b[i].constants == c
    ensures |b[i].constants.config.replica_ids| == |b[i].replicas|
    ensures ghost var s: LReplica := b[i].replicas[idx].replica; s.constants.my_index == idx && s.constants.all == b[i].constants && s.proposer.constants == s.constants && s.proposer.election_state.constants == s.constants && s.acceptor.constants == s.constants && s.learner.constants == s.constants && s.executor.constants == s.constants
    decreases c, i, idx
  {
  }
}

module Temporal__Rules_i {

  import opened Temporal__Heuristics_i

  import opened Temporal__Temporal_s

  import opened Collections__Maps2_i
  function {:opaque} {:fuel 0, 0} eventualStep(start: int, x: temporal): (step: int)
    requires sat(start, eventual(x))
    ensures sat(step, x)
    ensures TLe(start, step)
    decreases start
  {
    TemporalAssist();
    ghost var end: int :| TLe(start, end) && sat(end, x);
    end
  }

  function {:opaque} {:fuel 0, 0} earliestStepBetween(start: int, end: int, x: temporal): (pos: int)
    requires sat(end, x)
    requires TLe(start, end)
    ensures sat(pos, x)
    ensures TLe(start, pos)
    ensures TLe(pos, end)
    ensures forall i: int {:trigger sat(i, x)} :: start <= i < pos ==> !sat(i, x)
    decreases end - start
  {
    if sat(start, x) then
      start
    else
      earliestStepBetween(start + 1, end, x)
  }

  function {:opaque} {:fuel 0, 0} earliestStep(start: int, x: temporal): (step: int)
    requires sat(start, eventual(x))
    ensures sat(step, x)
    ensures TLe(start, step)
    ensures forall i: int {:trigger sat(i, x)} :: start <= i < step ==> !sat(i, x)
    decreases start
  {
    earliestStepBetween(start, eventualStep(start, x), x)
  }

  lemma /*{:_induction x}*/ TemporalNow(i: int, x: temporal)
    ensures sat(i, always(x)) ==> sat(i, x)
    ensures sat(i, eventual(x)) <== sat(i, x)
    decreases i
  {
  }

  lemma /*{:_induction x}*/ TemporalIdempotent(i: int, x: temporal)
    ensures sat(i, always(always(x))) == sat(i, always(x))
    ensures sat(i, eventual(eventual(x))) == sat(i, eventual(x))
    decreases i
  {
  }

  lemma /*{:_induction x}*/ TemporalEventuallyAlwaysImpliesAlwaysEventually(i: int, x: temporal)
    ensures sat(i, eventual(always(x))) ==> sat(i, always(eventual(x)))
    decreases i
  {
  }

  lemma /*{:_induction x}*/ TemporalNot(i: int, x: temporal)
    ensures sat(i, eventual(not(x))) <==> !sat(i, always(x))
    ensures sat(i, always(not(x))) <==> !sat(i, eventual(x))
    decreases i
  {
  }

  lemma /*{:_induction x, y}*/ TemporalAnd(i: int, x: temporal, y: temporal)
    ensures sat(i, always(and(x, y))) <==> sat(i, always(x)) && sat(i, always(y))
    ensures sat(i, eventual(and(x, y))) ==> sat(i, eventual(x)) && sat(i, eventual(y))
    ensures sat(i, eventual(and(x, y))) <== sat(i, always(x)) && sat(i, eventual(y))
    ensures sat(i, eventual(and(x, y))) <== sat(i, eventual(x)) && sat(i, always(y))
    decreases i
  {
  }

  lemma /*{:_induction x, y}*/ TemporalOr(i: int, x: temporal, y: temporal)
    ensures sat(i, always(or(x, y))) <== sat(i, always(x)) || sat(i, always(y))
    ensures sat(i, always(or(x, y))) ==> sat(i, always(x)) || sat(i, eventual(y))
    ensures sat(i, always(or(x, y))) ==> sat(i, eventual(x)) || sat(i, always(y))
    ensures sat(i, eventual(or(x, y))) <==> sat(i, eventual(x)) || sat(i, eventual(y))
    decreases i
  {
  }

  lemma /*{:_induction x, y}*/ TemporalImply(i: int, x: temporal, y: temporal)
    ensures sat(i, always(imply(x, y))) ==> sat(i, always(x)) ==> sat(i, always(y))
    ensures sat(i, always(imply(x, y))) ==> sat(i, eventual(x)) ==> sat(i, eventual(y))
    ensures sat(i, always(imply(x, y))) <== (sat(i, eventual(x)) ==> sat(i, always(y)))
    ensures sat(i, eventual(imply(x, y))) <==> sat(i, always(x)) ==> sat(i, eventual(y))
    decreases i
  {
  }

  lemma /*{:_induction x}*/ TemporalAlways(i: int, x: temporal)
    requires forall j: int {:trigger sat(j, x)} :: i <= j ==> sat(j, x)
    ensures sat(i, always(x))
    decreases i
  {
  }

  lemma /*{:_induction x}*/ TemporalEventually(i1: int, i2: int, x: temporal)
    requires i1 <= i2
    requires sat(i2, x)
    ensures sat(i1, eventual(x))
    decreases i1, i2
  {
  }

  lemma /*{:_induction x}*/ ValidAlways(i: int, x: temporal)
    requires forall j: int {:trigger sat(j, x)} :: sat(j, x)
    ensures sat(i, always(x))
    decreases i
  {
  }

  lemma /*{:_induction x, y}*/ ValidImply(i: int, x: temporal, y: temporal)
    requires forall j: int {:trigger sat(j, y)} {:trigger sat(j, x)} :: sat(j, x) ==> sat(j, y)
    ensures sat(i, always(x)) ==> sat(i, always(y))
    ensures sat(i, eventual(x)) ==> sat(i, eventual(y))
    decreases i
  {
  }

  lemma /*{:_induction x, y}*/ ValidEquiv(i: int, x: temporal, y: temporal)
    requires forall j: int {:trigger sat(j, y)} {:trigger sat(j, x)} :: sat(j, x) <==> sat(j, y)
    ensures sat(i, always(x)) <==> sat(i, always(y))
    ensures sat(i, eventual(x)) <==> sat(i, eventual(y))
    decreases i
  {
  }

  lemma /*{:_induction x}*/ TemporalDeduceFromAlways(i: int, j: int, x: temporal)
    requires i <= j
    requires sat(i, always(x))
    ensures sat(j, x)
    decreases i, j
  {
  }

  lemma TemporalDeduceFromEventual(i: int, x: temporal) returns (j: int)
    requires sat(i, eventual(x))
    ensures i <= j
    ensures sat(j, x)
    decreases i
  {
  }

  lemma /*{:_induction x}*/ Lemma_EventuallyAlwaysImpliesLaterEventuallyAlways(i: int, j: int, x: temporal)
    requires i <= j
    requires sat(i, eventual(always(x)))
    ensures sat(j, eventual(always(x)))
    decreases i, j
  {
  }

  lemma /*{:_induction x}*/ Lemma_AlwaysImpliesLaterAlways(i: int, j: int, x: temporal)
    requires i <= j
    ensures sat(i, always(x)) ==> sat(j, always(x))
    decreases i, j
  {
  }

  lemma /*{:_induction x}*/ Lemma_EventuallyNowButNotNextMeansNow(x: temporal, i: int)
    ensures sat(i, eventual(x)) && !sat(i + 1, eventual(x)) ==> sat(i, x)
    decreases i
  {
  }

  lemma /*{:_induction x}*/ Lemma_EventuallyImpliesEarlierEventually(i: int, j: int, x: temporal)
    requires i <= j
    ensures sat(j, eventual(x)) ==> sat(i, eventual(x))
    decreases i, j
  {
  }

  lemma /*{:_induction x}*/ TemporalAlwaysEventualImpliesAlwaysEventualWithDifferentStartPoint(i: int, j: int, x: temporal)
    ensures sat(i, always(eventual(x))) ==> sat(j, always(eventual(x)))
    decreases i, j
  {
  }
}

module Temporal__Heuristics_i {

  import opened Temporal__Temporal_s

  import opened Collections__Maps2_i
  function TBlast(i: int): bool
    decreases i
  {
    true
  }

  lemma TemporalAssist()
    ensures forall i: int, x: temporal {:trigger sat(i, always(x))} :: sat(i, always(x)) == forall j: int {:trigger sat(j, x)} {:trigger TLe(i, j)} :: TLe(i, j) ==> sat(j, x)
    ensures forall i: int, x: temporal {:trigger sat(i, eventual(x))} :: sat(i, eventual(x)) == exists j: int {:trigger sat(j, x)} {:trigger TLe(i, j)} :: TLe(i, j) && sat(j, x)
    ensures TLe(0, 0)
  {
  }

  lemma TemporalBlast()
    ensures forall i: int, x: temporal {:trigger sat(i, always(x))} :: sat(i, always(x)) == forall j: int {:trigger sat(j, x)} {:trigger TLe(i, j)} :: TLe(i, j) ==> sat(j, x)
    ensures forall i: int, x: temporal {:trigger sat(i, eventual(x))} :: sat(i, eventual(x)) == exists j: int {:trigger sat(j, x)} {:trigger TLe(i, j)} :: TLe(i, j) && sat(j, x)
    ensures forall i: int, j1: int, j2: int {:trigger TLe(i, j1), TLe(i, j2)} :: TLe(j1, j2) || TLe(j2, j1)
    ensures TLe(0, 0)
  {
  }

  lemma TemporalFullBlast()
    ensures forall i: int, x: temporal {:trigger sat(i, always(x))} :: sat(i, always(x)) == forall j: int {:trigger sat(j, x)} {:trigger TBlast(j)} :: TBlast(j) ==> i <= j ==> sat(j, x)
    ensures forall i: int, x: temporal {:trigger sat(i, eventual(x))} :: sat(i, eventual(x)) == exists j: int {:trigger sat(j, x)} {:trigger TBlast(j)} :: TBlast(j) && i <= j && sat(j, x)
    ensures TBlast(0)
  {
  }
}

module CommonProof__Assumptions_i {

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__Constants_i

  import opened Temporal__Temporal_s

  import opened Concrete_NodeIdentity_i

  import opened Environment_s

  import opened Collections__Maps2_s
  function {:opaque} {:fuel 0, 0} RestrictBehaviorToEnvironment(b: Behavior<RslState>): Behavior<LEnvironment<NodeIdentity, RslMessage>>
    requires imaptotal(b)
    ensures imaptotal(RestrictBehaviorToEnvironment(b))
    ensures forall i: int {:trigger RestrictBehaviorToEnvironment(b)[i]} :: RestrictBehaviorToEnvironment(b)[i] == b[i].environment
  {
    imap i: int {:trigger b[i]} | true :: b[i].environment
  }

  predicate IsValidBehaviorPrefix(b: Behavior<RslState>, c: LConstants, i: int)
    decreases c, i
  {
    imaptotal(b) &&
    RslInit(c, b[0]) &&
    forall j: int {:trigger RslNext(b[j], b[j + 1])} :: 
      0 <= j < i ==>
        RslNext(b[j], b[j + 1])
  }

  predicate IsValidBehavior(b: Behavior<RslState>, c: LConstants)
    decreases c
  {
    imaptotal(b) &&
    RslInit(c, b[0]) &&
    forall i: int {:trigger RslNext(b[i], b[i + 1])} :: 
      i >= 0 ==>
        RslNext(b[i], b[i + 1])
  }
}

module CommonProof__Chosen_i {

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Executor_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__Proposer_i

  import opened LiveByzRSL__Learner_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__CheckValSafety_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Constants_i

  import opened CommonProof__Actions_i

  import opened CommonProof__PacketSending_i

  import opened CommonProof__Environment_i

  import opened CommonProof__LearnerState_i

  import opened CommonProof__Quorum_i

  import opened CommonProof__QuorumOf2avs_i

  import opened CommonProof__Message1b_i

  import opened CommonProof__Message1c_i

  import opened CommonProof__Received2b_i

  import opened CommonProof__Message2av_i

  import opened CommonProof__Message2b_i

  import opened Concrete_NodeIdentity_i

  import opened Temporal__Temporal_s

  import opened Collections__Sets_i

  import opened Environment_s

  import opened Collections__CountMatches_i
  datatype QuorumOf2bs = QuorumOf2bs(c: LConstants, indices: set<int>, packets: seq<RslPacket>, bal: Ballot, opn: OperationNumber, v: RequestBatch)

  predicate IsValidQuorumOf2bs(ps: RslState, q: QuorumOf2bs)
    decreases ps, q
  {
    |q.indices| >= LMinQuorumSize(ps.constants.config) &&
    |q.packets| == |ps.constants.config.replica_ids| &&
    forall idx: int {:trigger ps.constants.config.replica_ids[idx]} {:trigger q.packets[idx]} {:trigger idx in q.indices} :: 
      (idx in q.indices ==>
        0 <= idx) &&
      (idx in q.indices ==>
        idx < |ps.constants.config.replica_ids|) &&
      (idx in q.indices ==>
        ghost var p: LPacket<NodeIdentity, RslMessage> := q.packets[idx]; p.src == ps.constants.config.replica_ids[idx] && p.msg.RslMessage_2b? && p.msg.opn_2b == q.opn && p.msg.val_2b == q.v && p.msg.bal_2b == q.bal && p in ps.environment.sentPackets)
  }

  lemma lemma_QuorumOf2bsStaysValid(b: Behavior<RslState>, c: LConstants, i: int, j: int, q: QuorumOf2bs)
    requires IsValidBehaviorPrefix(b, c, j)
    requires IsValidQuorumOf2bs(b[i], q)
    requires 0 <= i <= j
    ensures IsValidQuorumOf2bs(b[j], q)
    decreases c, i, j, q
  {
  }

  function ConvertSeqToSet<X(!new)>(xs: seq<X>): set<X>
    requires forall i: int, j: int {:trigger xs[j], xs[i]} :: 0 <= i < j < |xs| ==> xs[i] != xs[j]
    ensures forall x: X {:trigger x in ConvertSeqToSet(xs)} {:trigger x in xs} :: x in xs <==> x in ConvertSeqToSet(xs)
    decreases xs
  {
    set x: X {:trigger x in xs} | x in xs :: x
  }

  lemma lemma_SeqToSetLengthNotChange<X(!new)>(xs: seq<X>)
    requires forall i: int, j: int {:trigger xs[j], xs[i]} :: 0 <= i < j < |xs| ==> xs[i] != xs[j]
    ensures |xs| == |ConvertSeqToSet(xs)|
    decreases xs
  {
  }

  lemma /*{:_induction q1bs}*/ lemma_Convert1bPacketsSeqToMsgSeqIsConsistent(q1bs: seq<RslPacket>, q1bmsgs: seq<RslMessage>)
    requires LSeqOfMessage1b(q1bs)
    requires forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in q1bs} :: p in q1bs ==> p.msg.RslMessage_1b?
    requires q1bmsgs == Convert1bPacketsSeqToMsgSeq(q1bs)
    ensures forall i: int {:trigger q1bs[i]} {:trigger q1bmsgs[i]} :: 0 <= i < |q1bs| ==> q1bmsgs[i] == q1bs[i].msg
    decreases q1bs, q1bmsgs
  {
  }

  lemma lemma_LValIsSafeAtImpliesLValIsHighestNumberedProposalAtBallot(v: RequestBatch, msg1bs: seq<RslPacket>, opn: OperationNumber, byzq: int, wq: int)
    requires forall m: LPacket<NodeIdentity, RslMessage> {:trigger m.msg} {:trigger m in msg1bs} :: m in msg1bs ==> m.msg.RslMessage_1b?
    requires LValIsSafeAt(v, msg1bs, opn, byzq, wq)
    requires wq > 0
    ensures exists p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in msg1bs} :: p in msg1bs && opn in p.msg.votes && LValIsHighestNumberedProposalAtBallot(v, p.msg.votes[opn].max_value_bal, msg1bs, opn)
    decreases v, msg1bs, opn, byzq, wq
  {
  }

  lemma lemma_ChosenQuorumAnd1cFromLaterBallotMatchValues(b: Behavior<RslState>, c: LConstants, i: int, quorum_of_2bs: QuorumOf2bs, packet1c: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires IsValidQuorumOf2bs(b[i], quorum_of_2bs)
    requires packet1c in b[i].environment.sentPackets
    requires packet1c.src in c.config.replica_ids
    requires packet1c.msg.RslMessage_1c?
    requires quorum_of_2bs.opn == packet1c.msg.opn_1c
    requires BalLt(quorum_of_2bs.bal, packet1c.msg.bal_1c)
    ensures quorum_of_2bs.v == packet1c.msg.val_1c
    decreases packet1c.msg.bal_1c.seqno, packet1c.msg.bal_1c.proposer_id
  {
  }

  lemma lemma_ChosenQuorumsMatchValue(b: Behavior<RslState>, c: LConstants, i: int, q1: QuorumOf2bs, q2: QuorumOf2bs)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires IsValidQuorumOf2bs(b[i], q1)
    requires IsValidQuorumOf2bs(b[i], q2)
    requires q1.opn == q2.opn
    ensures q1.v == q2.v
    decreases c, i, q1, q2
  {
  }

  lemma /*{:_induction s}*/ lemma_CountMatchesInSeqOfDiffValNotExceedTheSeqSize(s: seq<RequestBatch>, v1: RequestBatch, v2: RequestBatch)
    requires v1 != v2
    ensures CountMatchesInSeq(s, (x: seq<Request>) => x == v1) + CountMatchesInSeq(s, (x: seq<Request>) => x == v2) <= |s|
    decreases s, v1, v2
  {
  }

  lemma /*{:_induction s, v1, v2}*/ lemma_CountMatchedValInReceived2bsOfDiffValNotExceedTheSeqSize(s: seq<RslPacket>, v1: RequestBatch, v2: RequestBatch)
    requires v1 != v2
    requires forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in s} :: p in s ==> p.msg.RslMessage_2b?
    ensures CountMatchedValInReceived2bs(s, v1) + CountMatchedValInReceived2bs(s, v2) <= |s|
    decreases s, v1, v2
  {
  }

  lemma /*{:_induction v1, v2}*/ lemma_ChoseExecuteValFromMinQuorumIsUnique(b: Behavior<RslState>, c: LConstants, i: int, idx: int, v1: RequestBatch, v2: RequestBatch)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= idx < |b[i].replicas|
    requires ghost var s: LReplica := b[i].replicas[idx].replica; s.executor.ops_complete in s.learner.unexecuted_learner_state
    requires ghost var s: LReplica := b[i].replicas[idx].replica; ghost var opn: int := s.executor.ops_complete; LearnerStateCorrect(s.learner.unexecuted_learner_state, s.learner.max_ballot_seen, s.learner.constants.all.config) && CountMatchedValInReceived2bs(s.learner.unexecuted_learner_state[opn].received_2bs, v1) >= LMinQuorumSize(s.constants.all.config)
    requires ghost var s: LReplica := b[i].replicas[idx].replica; ghost var opn: int := s.executor.ops_complete; true && CountMatchedValInReceived2bs(s.learner.unexecuted_learner_state[opn].received_2bs, v2) >= LMinQuorumSize(s.constants.all.config)
    ensures v1 == v2
    decreases c, i, idx, v1, v2
  {
  }

  lemma {:opaque} lemma_DecidedOperationWasChosen(b: Behavior<RslState>, c: LConstants, i: int, idx: int)
      returns (q: QuorumOf2bs)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= idx < |b[i].replicas|
    requires b[i].replicas[idx].replica.executor.next_op_to_execute.OutstandingOpKnown?
    ensures IsValidQuorumOf2bs(b[i], q)
    ensures ghost var s: LExecutor := b[i].replicas[idx].replica.executor; q.bal == s.next_op_to_execute.bal && q.opn == s.ops_complete && q.v == s.next_op_to_execute.v
    decreases c, i, idx
  {
  }

  lemma /*{:_induction v}*/ lemma_CountMatchedValInReceived2bs_append_one(s: seq<RslPacket>, v: RequestBatch, i: int)
    requires 0 <= i < |s|
    requires forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in s} :: p in s ==> p.msg.RslMessage_2b?
    ensures CountMatchedValInReceived2bs(s[..i + 1], v) == CountMatchedValInReceived2bs(s[..i], v) + if s[i].msg.val_2b == v then 1 else 0
    decreases s, v, i
  {
  }
}

module CommonProof__Actions_i {

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Replica_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Constants_i

  import opened Temporal__Temporal_s

  import opened Environment_s

  import opened Collections__Maps2_s
  predicate PacketProcessedViaIos(ps: RslState, ps': RslState, p: RslPacket, idx: int, ios: seq<RslIo>)
    decreases ps, ps', p, idx, ios
  {
    |ios| > 0 &&
    LIoOpReceive(p) == ios[0] &&
    0 <= idx < |ps.constants.config.replica_ids| &&
    p.dst == ps.constants.config.replica_ids[idx] &&
    ps.environment.nextStep == LEnvStepHostIos(p.dst, ios) &&
    RslNextOneReplica(ps, ps', idx, ios) &&
    LReplicaNextProcessPacket(ps.replicas[idx].replica, ps'.replicas[idx].replica, ios)
  }

  predicate PacketProcessedDuringAction(ps: RslState, p: RslPacket)
    decreases ps, p
  {
    ps.environment.nextStep.LEnvStepHostIos? &&
    LIoOpReceive(p) in ps.environment.nextStep.ios
  }

  function {:opaque} {:fuel 0, 0} PacketProcessedTemporal(b: Behavior<RslState>, p: RslPacket): temporal
    requires imaptotal(b)
    ensures forall i: int {:trigger sat(i, PacketProcessedTemporal(b, p))} :: sat(i, PacketProcessedTemporal(b, p)) <==> PacketProcessedDuringAction(b[i], p)
    decreases p
  {
    stepmap(imap i: int {:trigger b[i]} | true :: PacketProcessedDuringAction(b[i], p))
  }

  predicate PacketSentDuringAction(ps: RslState, p: RslPacket)
    decreases ps, p
  {
    ps.environment.nextStep.LEnvStepHostIos? &&
    LIoOpSend(p) in ps.environment.nextStep.ios
  }

  function {:opaque} {:fuel 0, 0} PacketSentTemporal(b: Behavior<RslState>, p: RslPacket): temporal
    requires imaptotal(b)
    ensures forall i: int {:trigger sat(i, PacketSentTemporal(b, p))} :: sat(i, PacketSentTemporal(b, p)) <==> PacketSentDuringAction(b[i], p)
    decreases p
  {
    stepmap(imap i: int {:trigger b[i]} | true :: PacketSentDuringAction(b[i], p))
  }

  lemma lemma_ActionThatChangesReplicaIsThatReplicasAction(b: Behavior<RslState>, c: LConstants, i: int, host_index: int)
      returns (ios: seq<RslIo>)
    requires IsValidBehaviorPrefix(b, c, i + 1)
    requires 0 <= i
    requires 0 <= host_index < |b[i].replicas|
    requires 0 <= host_index < |b[i + 1].replicas|
    requires b[i + 1].replicas[host_index] != b[i].replicas[host_index]
    ensures b[i].environment.nextStep.LEnvStepHostIos?
    ensures 0 <= host_index < |c.config.replica_ids|
    ensures b[i].environment.nextStep.actor == c.config.replica_ids[host_index]
    ensures ios == b[i].environment.nextStep.ios
    ensures RslNext(b[i], b[i + 1])
    ensures RslNextOneReplica(b[i], b[i + 1], host_index, ios)
    decreases c, i, host_index
  {
  }

  lemma lemma_PacketProcessedImpliesPacketSent(ps: RslState, ps': RslState, idx: int, ios: seq<RslIo>, inp: RslPacket)
    requires RslNextOneReplica(ps, ps', idx, ios)
    requires LIoOpReceive(inp) in ios
    ensures inp in ps.environment.sentPackets
    decreases ps, ps', idx, ios, inp
  {
  }

  lemma lemma_PacketProcessedImpliesPacketSentAlt(b: Behavior<RslState>, c: LConstants, i: int, idx: int, inp: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i + 1)
    requires 0 <= i
    requires 0 <= idx < |c.config.replica_ids|
    requires b[i].environment.nextStep.LEnvStepHostIos?
    requires b[i].environment.nextStep.actor == c.config.replica_ids[idx]
    requires LIoOpReceive(inp) in b[i].environment.nextStep.ios
    ensures inp in b[i].environment.sentPackets
    decreases c, i, idx, inp
  {
  }
}

module CommonProof__PacketSending_i {

  import opened LiveByzRSL__Acceptor_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Executor_i

  import opened LiveByzRSL__Replica_i

  import opened Environment_s
  lemma lemma_ActionThatSends1bIsProcess1a(ps: RslState, ps': RslState, p: RslPacket)
      returns (idx: int, ios: seq<RslIo>)
    requires p.src in ps.constants.config.replica_ids
    requires p.msg.RslMessage_1b?
    requires p in ps'.environment.sentPackets
    requires p !in ps.environment.sentPackets
    requires RslNext(ps, ps')
    ensures 0 <= idx < |ps.constants.config.replica_ids|
    ensures 0 <= idx < |ps'.constants.config.replica_ids|
    ensures p.src == ps.constants.config.replica_ids[idx]
    ensures RslNextOneReplica(ps, ps', idx, ios)
    ensures |ios| > 0
    ensures ios[0].LIoOpReceive?
    ensures ios[0].r.msg.RslMessage_1a?
    ensures LIoOpSend(p) in ios
    ensures LReplicaNextProcessPacketWithoutReadingClock(ps.replicas[idx].replica, ps'.replicas[idx].replica, ios)
    ensures LAcceptorProcess1a(ps.replicas[idx].replica.acceptor, ps'.replicas[idx].replica.acceptor, ios[0].r, ExtractSentPacketsFromIos(ios))
    decreases ps, ps', p
  {
  }

  lemma lemma_ActionThatSends1cIsMaybeNominateValueAndSend1c(ps: RslState, ps': RslState, p: RslPacket)
      returns (idx: int, ios: seq<RslIo>)
    requires p.src in ps.constants.config.replica_ids
    requires p.msg.RslMessage_1c?
    requires p in ps'.environment.sentPackets
    requires p !in ps.environment.sentPackets
    requires RslNext(ps, ps')
    ensures 0 <= idx < |ps.constants.config.replica_ids|
    ensures 0 <= idx < |ps'.constants.config.replica_ids|
    ensures p.src == ps.constants.config.replica_ids[idx]
    ensures RslNextOneReplica(ps, ps', idx, ios)
    ensures LIoOpSend(p) in ios
    ensures SpontaneousIos(ios, 1)
    ensures LReplicaNextReadClockMaybeNominateValueAndSend1c(ps.replicas[idx].replica, ps'.replicas[idx].replica, SpontaneousClock(ios), ExtractSentPacketsFromIos(ios))
    decreases ps, ps', p
  {
  }

  lemma lemma_ActionThatSends2avIsProcess1c(ps: RslState, ps': RslState, p: RslPacket)
      returns (idx: int, ios: seq<RslIo>)
    requires p.src in ps.constants.config.replica_ids
    requires p.msg.RslMessage_2av?
    requires p in ps'.environment.sentPackets
    requires p !in ps.environment.sentPackets
    requires RslNext(ps, ps')
    ensures 0 <= idx < |ps.constants.config.replica_ids|
    ensures 0 <= idx < |ps'.constants.config.replica_ids|
    ensures p.src == ps.constants.config.replica_ids[idx]
    ensures RslNextOneReplica(ps, ps', idx, ios)
    ensures |ios| > 0
    ensures ios[0].LIoOpReceive?
    ensures LIoOpSend(p) in ios
    ensures LReplicaNextProcess1c(ps.replicas[idx].replica, ps'.replicas[idx].replica, ios[0].r, ExtractSentPacketsFromIos(ios))
    decreases ps, ps', p
  {
  }

  lemma lemma_ActionThatSends2bIsMaybeSend2b(ps: RslState, ps': RslState, p: RslPacket)
      returns (idx: int, ios: seq<RslIo>)
    requires p.src in ps.constants.config.replica_ids
    requires p.msg.RslMessage_2b?
    requires p in ps'.environment.sentPackets
    requires p !in ps.environment.sentPackets
    requires RslNext(ps, ps')
    ensures 0 <= idx < |ps.constants.config.replica_ids|
    ensures 0 <= idx < |ps'.constants.config.replica_ids|
    ensures p.src == ps.constants.config.replica_ids[idx]
    ensures RslNextOneReplica(ps, ps', idx, ios)
    ensures LIoOpSend(p) in ios
    ensures LReplicaNextSpontaneousMaybeSend2b(ps.replicas[idx].replica, ps'.replicas[idx].replica, ExtractSentPacketsFromIos(ios))
    ensures ps.replicas[idx].replica.acceptor.val_to_be_sent_2b.ValToBeSent2bKnown?
    ensures p.msg.bal_2b == ps.replicas[idx].replica.acceptor.val_to_be_sent_2b.bal
    ensures ps.replicas[idx].replica.acceptor.val_to_be_sent_2b.bal == ps.replicas[idx].replica.acceptor.max_bal
    decreases ps, ps', p
  {
  }
}

module CommonProof__Environment_i {

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened Temporal__Temporal_s

  import opened Temporal__Heuristics_i

  import opened Temporal__Rules_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Constants_i

  import opened Environment_s
  lemma lemma_PacketStaysInSentPackets(b: Behavior<RslState>, c: LConstants, i: int, j: int, p: RslPacket)
    requires IsValidBehaviorPrefix(b, c, j)
    requires 0 <= i <= j
    requires p in b[i].environment.sentPackets
    ensures p in b[j].environment.sentPackets
    decreases c, i, j, p
  {
  }

  lemma lemma_PacketSetStaysInSentPackets(b: Behavior<RslState>, c: LConstants, i: int, j: int, packets: set<RslPacket>)
    requires IsValidBehaviorPrefix(b, c, j)
    requires 0 <= i <= j
    requires packets <= b[i].environment.sentPackets
    ensures packets <= b[j].environment.sentPackets
    decreases c, i, j, packets
  {
  }

  lemma lemma_PacketSeqStaysInSentPackets(b: Behavior<RslState>, c: LConstants, i: int, j: int, packets: seq<RslPacket>)
    requires IsValidBehaviorPrefix(b, c, j)
    requires 0 <= i <= j
    requires forall p: LPacket<NodeIdentity, RslMessage> {:trigger p in b[i].environment.sentPackets} {:trigger p in packets} :: p in packets ==> p in b[i].environment.sentPackets
    ensures forall p: LPacket<NodeIdentity, RslMessage> {:trigger p in b[j].environment.sentPackets} {:trigger p in packets} :: p in packets ==> p in b[j].environment.sentPackets
    decreases c, i, j, packets
  {
  }
}

module CommonProof__LearnerState_i {

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__Learner_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Constants_i

  import opened CommonProof__Actions_i

  import opened CommonProof__PacketSending_i

  import opened CommonProof__Environment_i

  import opened CommonProof__Message2b_i

  import opened Temporal__Temporal_s

  import opened Concrete_NodeIdentity_i
  lemma lemma_Received2bMessageSendersAlwaysValidReplicas(b: Behavior<RslState>, c: LConstants, i: int, learner_idx: int, opn: OperationNumber)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= learner_idx < |b[i].replicas|
    requires opn in b[i].replicas[learner_idx].replica.learner.unexecuted_learner_state
    ensures forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.src} {:trigger p in b[i].replicas[learner_idx].replica.learner.unexecuted_learner_state[opn].received_2bs} :: p in b[i].replicas[learner_idx].replica.learner.unexecuted_learner_state[opn].received_2bs ==> p.src in c.config.replica_ids
    decreases i
  {
  }
}

module CommonProof__Message2b_i {

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Acceptor_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__Message_i

  import opened CommonProof__AcceptorState_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Constants_i

  import opened CommonProof__Actions_i

  import opened CommonProof__PacketSending_i

  import opened CommonProof__Environment_i

  import opened CommonProof__QuorumOf2avs_i

  import opened CommonProof__Quorum_i

  import opened CommonProof__Received2av_i

  import opened CommonProof__Message2av_i

  import opened Concrete_NodeIdentity_i

  import opened Temporal__Temporal_s

  import opened Environment_s

  import opened Collections__CountMatches_i

  import opened Collections__Sets_i
  lemma lemma_IfValidQuorumOf2avsSequenceNowThenNext(b: Behavior<RslState>, c: LConstants, i: int, qs: seq<QuorumOf2avs>)
    requires IsValidBehaviorPrefix(b, c, i + 1)
    requires 0 <= i
    requires IsValidQuorumOf2avsSequence(b[i], qs)
    ensures IsValidQuorumOf2avsSequence(b[i + 1], qs)
    decreases c, i, qs
  {
  }

  lemma lemma_IfValidQuorumOf2avsNowThenNext(b: Behavior<RslState>, c: LConstants, i: int, q: QuorumOf2avs)
    requires IsValidBehaviorPrefix(b, c, i + 1)
    requires 0 <= i
    requires IsValidQuorumOf2avs(b[i], q)
    ensures IsValidQuorumOf2avs(b[i + 1], q)
    decreases c, i, q
  {
  }

  lemma /*{:_induction s, v1, v2}*/ lemma_CountMatchedValInReceived2avsOfDiffValNotExceedTheSeqSize(s: seq<RslPacket>, v1: RequestBatch, v2: RequestBatch)
    requires v1 != v2
    requires forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in s} :: p in s ==> p.msg.RslMessage_2av?
    ensures CountMatchedValInReceived2avs(s, v1) + CountMatchedValInReceived2avs(s, v2) <= |s|
    decreases s, v1, v2
  {
  }

  lemma /*{:_induction v1, v2}*/ lemma_Chose2bValFromByzQuorumIsUnique(b: Behavior<RslState>, c: LConstants, i: int, idx: int, v1: RequestBatch, v2: RequestBatch)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= idx < |b[i].replicas|
    requires ghost var s: LReplica := b[i].replicas[idx].replica; s.acceptor.opn_to_be_send_2b in s.acceptor.received_2avs
    requires ghost var s: LReplica := b[i].replicas[idx].replica; ghost var opn: OperationNumber := s.acceptor.opn_to_be_send_2b; AcceptorStateCorrect(s.acceptor.received_2avs, s.acceptor.max_bal, s.acceptor.constants.all.config) && CountMatchedValInReceived2avs(s.acceptor.received_2avs[opn].received_2av_packets, v1) >= LByzQuorumSize(s.constants.all.config)
    requires ghost var s: LReplica := b[i].replicas[idx].replica; ghost var opn: OperationNumber := s.acceptor.opn_to_be_send_2b; true && CountMatchedValInReceived2avs(s.acceptor.received_2avs[opn].received_2av_packets, v2) >= LByzQuorumSize(s.constants.all.config)
    ensures v1 == v2
    decreases c, i, idx, v1, v2
  {
  }

  lemma lemma_2bSentHasReceivedByzQuorum2avs(b: Behavior<RslState>, c: LConstants, i: int, idx: int)
      returns (q: QuorumOf2avs)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= idx < |b[i].replicas|
    requires ghost var s: LAcceptor := b[i].replicas[idx].replica.acceptor; true && s.val_to_be_sent_2b.ValToBeSent2bKnown?
    ensures IsValidQuorumOf2avs(b[i], q)
    ensures ghost var s: LAcceptor := b[i].replicas[idx].replica.acceptor; q.v == s.val_to_be_sent_2b.v && q.opn == s.opn_to_be_send_2b && q.bal == s.val_to_be_sent_2b.bal
    decreases c, i, idx
  {
  }

  lemma /*{:_induction v}*/ lemma_CountMatchedValInReceived2avs_append_one(s: seq<RslPacket>, v: RequestBatch, i: int)
    requires 0 <= i < |s|
    requires forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.msg} {:trigger p in s} :: p in s ==> p.msg.RslMessage_2av?
    ensures CountMatchedValInReceived2avs(s[..i + 1], v) == CountMatchedValInReceived2avs(s[..i], v) + if s[i].msg.val_2av == v then 1 else 0
    decreases s, v, i
  {
  }

  lemma /*{:_induction s}*/ lemma_CountMatchesInSeqOfDiffValNotExceedTheSeqSize(s: seq<RequestBatch>, v1: RequestBatch, v2: RequestBatch)
    requires v1 != v2
    ensures CountMatchesInSeq(s, (x: seq<Request>) => x == v1) + CountMatchesInSeq(s, (x: seq<Request>) => x == v2) <= |s|
    decreases s, v1, v2
  {
  }

  lemma lemma_2bSentIsMaybeSend2b(b: Behavior<RslState>, c: LConstants, i: int, p: RslPacket, idx: int, ios: seq<RslIo>)
      returns (q: QuorumOf2avs)
    requires IsValidBehaviorPrefix(b, c, i + 1)
    requires 0 <= i
    requires 0 <= idx < |c.config.replica_ids|
    requires 0 <= idx < |b[i].replicas|
    requires LIoOpSend(p) in ios
    requires RslNext(b[i], b[i + 1])
    requires b[i].environment.nextStep == LEnvStepHostIos(c.config.replica_ids[idx], ios)
    requires p.msg.RslMessage_2b?
    requires ghost var s: LAcceptor := b[i].replicas[idx].replica.acceptor; s.val_to_be_sent_2b.ValToBeSent2bKnown? && s.val_to_be_sent_2b.bal == s.max_bal
    requires LAcceptorSent2b(b[i].replicas[idx].replica.acceptor, b[i + 1].replicas[idx].replica.acceptor, ExtractSentPacketsFromIos(ios))
    ensures IsValidQuorumOf2avs(b[i], q)
    ensures q.opn == p.msg.opn_2b
    ensures q.v == p.msg.val_2b
    ensures q.bal == p.msg.bal_2b
    decreases c, i, p, idx, ios
  {
  }

  lemma lemma_2bSentIsAllowed(b: Behavior<RslState>, c: LConstants, i: int, p: RslPacket)
      returns (q: QuorumOf2avs)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires p in b[i].environment.sentPackets
    requires p.src in c.config.replica_ids
    requires p.msg.RslMessage_2b?
    ensures IsValidQuorumOf2avs(b[i], q)
    ensures q.opn == p.msg.opn_2b
    ensures q.v == p.msg.val_2b
    ensures q.bal == p.msg.bal_2b
    decreases c, i, p
  {
  }

  lemma lemma_CurrentVoteDoesNotExceedMaxBal(b: Behavior<RslState>, c: LConstants, i: int, opn: OperationNumber, idx: int)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= idx < |b[i].replicas|
    requires opn in b[i].replicas[idx].replica.acceptor.votes
    ensures BalLeq(b[i].replicas[idx].replica.acceptor.votes[opn].max_value_bal, b[i].replicas[idx].replica.acceptor.max_bal)
    decreases c, i, opn, idx
  {
  }
}

module CommonProof__Quorum_i {

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Environment_i

  import opened Concrete_NodeIdentity_i

  import opened Collections__Sets_i
  lemma lemma_SetOfElementsOfRangeNoBiggerThanRange(Q: set<int>, n: int)
    requires forall idx: int {:trigger idx in Q} :: (idx in Q ==> 0 <= idx) && (idx in Q ==> idx < n)
    requires 0 <= n
    ensures |Q| <= n
    decreases n
  {
  }

  lemma lemma_QuorumIndexOverlap(Q1: set<int>, Q2: set<int>, n: int)
      returns (common: int)
    requires forall idx: int {:trigger idx in Q1} :: (idx in Q1 ==> 0 <= idx) && (idx in Q1 ==> idx < n)
    requires forall idx: int {:trigger idx in Q2} :: (idx in Q2 ==> 0 <= idx) && (idx in Q2 ==> idx < n)
    requires |Q1| + |Q2| > n >= 0
    ensures common in Q1
    ensures common in Q2
    ensures 0 <= common < n
    decreases Q1, Q2, n
  {
  }

  lemma lemma_GetIndicesFromNodes(nodes: set<NodeIdentity>, config: LConfiguration) returns (indices: set<int>)
    requires WellFormedLConfiguration(config)
    requires forall node: EndPoint {:trigger node in config.replica_ids} {:trigger node in nodes} :: node in nodes ==> node in config.replica_ids
    ensures forall idx: int {:trigger config.replica_ids[idx]} {:trigger idx in indices} :: (idx in indices ==> 0 <= idx) && (idx in indices ==> idx < |config.replica_ids|) && (idx in indices ==> config.replica_ids[idx] in nodes)
    ensures forall node: NodeIdentity {:trigger GetReplicaIndex(node, config)} {:trigger node in nodes} :: node in nodes ==> GetReplicaIndex(node, config) in indices
    ensures |indices| == |nodes|
    decreases nodes, config
  {
  }

  lemma lemma_GetIndicesFromPackets(packets: set<RslPacket>, config: LConfiguration) returns (indices: set<int>)
    requires WellFormedLConfiguration(config)
    requires forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.src} {:trigger p in packets} :: p in packets ==> p.src in config.replica_ids
    requires forall p1: LPacket<NodeIdentity, RslMessage>, p2: LPacket<NodeIdentity, RslMessage> {:trigger p2.src, p1.src} {:trigger p2.src, p1 in packets} {:trigger p1.src, p2 in packets} {:trigger p2 in packets, p1 in packets} :: p1 in packets && p2 in packets && p1 != p2 ==> p1.src != p2.src
    ensures forall idx: int {:trigger config.replica_ids[idx]} {:trigger idx in indices} :: (idx in indices ==> 0 <= idx) && (idx in indices ==> idx < |config.replica_ids|) && (idx in indices ==> exists p: LPacket<NodeIdentity, RslMessage> {:trigger p.src} {:trigger p in packets} :: p in packets && config.replica_ids[idx] == p.src)
    ensures forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.src} {:trigger p in packets} :: p in packets ==> GetReplicaIndex(p.src, config) in indices
    ensures |indices| == |packets|
    decreases packets, config
  {
  }
}

module CommonProof__Message2av_i {

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Proposer_i

  import opened LiveByzRSL__Types_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Constants_i

  import opened CommonProof__Actions_i

  import opened CommonProof__PacketSending_i

  import opened CommonProof__Environment_i

  import opened Temporal__Temporal_s

  import opened Environment_s
  lemma lemma_2avMessageHasCorresponding1cMessage(b: Behavior<RslState>, c: LConstants, i: int, p_2av: RslPacket)
      returns (p_1c: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires p_2av in b[i].environment.sentPackets
    requires p_2av.src in c.config.replica_ids
    requires p_2av.msg.RslMessage_2av?
    ensures p_1c in b[i].environment.sentPackets
    ensures p_1c.src in c.config.replica_ids
    ensures p_1c.msg.RslMessage_1c?
    ensures p_1c.msg.opn_1c == p_2av.msg.opn_2av
    ensures p_1c.msg.bal_1c == p_2av.msg.bal_2av
    ensures p_1c.msg.val_1c == p_2av.msg.val_2av
    decreases i
  {
  }
}

module CommonProof__QuorumOf2avs_i {

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Executor_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__Proposer_i

  import opened LiveByzRSL__Types_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Constants_i

  import opened CommonProof__Actions_i

  import opened CommonProof__PacketSending_i

  import opened CommonProof__Environment_i

  import opened Concrete_NodeIdentity_i

  import opened Temporal__Temporal_s

  import opened Collections__Sets_i

  import opened Environment_s
  datatype QuorumOf2avs = QuorumOf2avs(c: LConstants, indices: set<int>, packets: seq<RslPacket>, bal: Ballot, opn: OperationNumber, v: RequestBatch)

  predicate IsValidQuorumOf2avs(ps: RslState, q: QuorumOf2avs)
    decreases ps, q
  {
    |q.indices| >= LByzQuorumSize(ps.constants.config) &&
    |q.packets| == |ps.constants.config.replica_ids| &&
    forall idx: int {:trigger ps.constants.config.replica_ids[idx]} {:trigger q.packets[idx]} {:trigger idx in q.indices} :: 
      (idx in q.indices ==>
        0 <= idx) &&
      (idx in q.indices ==>
        idx < |ps.constants.config.replica_ids|) &&
      (idx in q.indices ==>
        ghost var p: LPacket<NodeIdentity, RslMessage> := q.packets[idx]; p.src == ps.constants.config.replica_ids[idx] && p.msg.RslMessage_2av? && p.msg.opn_2av == q.opn && p.msg.val_2av == q.v && p.msg.bal_2av == q.bal && p in ps.environment.sentPackets)
  }

  predicate IsValidQuorumOf2avsSequence(ps: RslState, qs: seq<QuorumOf2avs>)
    decreases ps, qs
  {
    forall opn: int {:trigger qs[opn]} :: 
      (0 <= opn < |qs| ==>
        qs[opn].opn == opn) &&
      (0 <= opn < |qs| ==>
        IsValidQuorumOf2avs(ps, qs[opn]))
  }

  lemma lemma_QuorumOf2avsStaysValid(b: Behavior<RslState>, c: LConstants, i: int, j: int, q: QuorumOf2avs)
    requires IsValidBehaviorPrefix(b, c, j)
    requires IsValidQuorumOf2avs(b[i], q)
    requires 0 <= i <= j
    ensures IsValidQuorumOf2avs(b[j], q)
    decreases c, i, j, q
  {
  }
}

module CommonProof__AcceptorState_i {

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Types_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Constants_i

  import opened CommonProof__Actions_i

  import opened CommonProof__PacketSending_i

  import opened CommonProof__Environment_i

  import opened Temporal__Temporal_s

  import opened Concrete_NodeIdentity_i
  lemma lemma_Received2avMessageSendersAlwaysValidReplicas(b: Behavior<RslState>, c: LConstants, i: int, acceptor_idx: int, opn: OperationNumber)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= acceptor_idx < |b[i].replicas|
    requires opn in b[i].replicas[acceptor_idx].replica.acceptor.received_2avs
    ensures forall p: LPacket<NodeIdentity, RslMessage> {:trigger p.src} {:trigger p in b[i].replicas[acceptor_idx].replica.acceptor.received_2avs[opn].received_2av_packets} :: p in b[i].replicas[acceptor_idx].replica.acceptor.received_2avs[opn].received_2av_packets ==> p.src in c.config.replica_ids
    decreases i
  {
  }
}

module CommonProof__Received2av_i {

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Types_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Actions_i

  import opened CommonProof__Constants_i

  import opened CommonProof__PacketSending_i

  import opened Temporal__Temporal_s
  lemma lemma_PacketInReceived2avWasSent(b: Behavior<RslState>, c: LConstants, i: int, replica_idx: int, opn: OperationNumber, p: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= replica_idx < |b[i].replicas|
    requires opn in b[i].replicas[replica_idx].replica.acceptor.received_2avs
    requires p in b[i].replicas[replica_idx].replica.acceptor.received_2avs[opn].received_2av_packets
    ensures p in b[i].environment.sentPackets
    ensures p.src in c.config.replica_ids
    decreases c, i, replica_idx, opn, p
  {
  }
}

module CommonProof__Message1b_i {

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Types_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Constants_i

  import opened CommonProof__Actions_i

  import opened CommonProof__PacketSending_i

  import opened CommonProof__Environment_i

  import opened CommonProof__Message2b_i

  import opened CommonProof__max_bal_i

  import opened CommonProof__Votes_i

  import opened CommonProof__Message1c_i

  import opened Environment_s

  import opened Temporal__Temporal_s
  lemma lemma_1bMessageImplicationsForCAcceptor(b: Behavior<RslState>, c: LConstants, i: int, opn: OperationNumber, p: RslPacket)
      returns (acceptor_idx: int)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires p in b[i].environment.sentPackets
    requires p.src in c.config.replica_ids
    requires p.msg.RslMessage_1b?
    ensures 0 <= acceptor_idx < |c.config.replica_ids|
    ensures 0 <= acceptor_idx < |b[i].replicas|
    ensures p.src == c.config.replica_ids[acceptor_idx]
    ensures BalLeq(p.msg.bal_1b, b[i].replicas[acceptor_idx].replica.acceptor.max_bal)
    ensures ghost var s: LAcceptor := b[i].replicas[acceptor_idx].replica.acceptor; opn in p.msg.votes && opn >= s.log_truncation_point ==> opn in s.votes && (BalLeq(p.msg.bal_1b, s.votes[opn].max_value_bal) || s.votes[opn] == Vote(p.msg.votes[opn].max_value_bal, p.msg.votes[opn].max_val))
    ensures ghost var s: LAcceptor := b[i].replicas[acceptor_idx].replica.acceptor; opn !in p.msg.votes && opn >= s.log_truncation_point ==> opn !in s.votes || (opn in s.votes && BalLeq(p.msg.bal_1b, s.votes[opn].max_value_bal))
    decreases i
  {
  }

  lemma lemma_1bMessageWithoutOpnImplicationsFor2b(b: Behavior<RslState>, c: LConstants, i: int, opn: OperationNumber, p_1b: RslPacket, p_2b: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires p_1b in b[i].environment.sentPackets
    requires p_2b in b[i].environment.sentPackets
    requires p_1b.src in c.config.replica_ids
    requires p_1b.src == p_2b.src
    requires p_1b.msg.RslMessage_1b?
    requires p_2b.msg.RslMessage_2b?
    requires opn !in p_1b.msg.votes
    requires opn >= p_1b.msg.log_truncation_point
    requires p_2b.msg.opn_2b == opn
    ensures BalLeq(p_1b.msg.bal_1b, p_2b.msg.bal_2b)
    decreases i
  {
  }

  lemma lemma_1bMessageWithOpnImplicationsFor2b(b: Behavior<RslState>, c: LConstants, i: int, opn: OperationNumber, p_1b: RslPacket, p_2b: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires p_1b in b[i].environment.sentPackets
    requires p_2b in b[i].environment.sentPackets
    requires p_1b.src in c.config.replica_ids
    requires p_1b.src == p_2b.src
    requires p_1b.msg.RslMessage_1b?
    requires p_2b.msg.RslMessage_2b?
    requires opn in p_1b.msg.votes
    requires opn >= p_1b.msg.log_truncation_point
    requires p_2b.msg.opn_2b == opn
    ensures BalLeq(p_1b.msg.bal_1b, p_2b.msg.bal_2b) || (p_2b.msg.bal_2b == p_1b.msg.votes[opn].max_value_bal && p_2b.msg.val_2b == p_1b.msg.votes[opn].max_val) || BalLt(p_2b.msg.bal_2b, p_1b.msg.votes[opn].max_value_bal)
    decreases i
  {
  }

  lemma lemma_Vote1bMessageIsFromEarlierBallot(b: Behavior<RslState>, c: LConstants, i: int, opn: OperationNumber, p: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires p in b[i].environment.sentPackets
    requires p.src in c.config.replica_ids
    requires p.msg.RslMessage_1b?
    requires opn in p.msg.votes
    ensures BalLt(p.msg.votes[opn].max_value_bal, p.msg.bal_1b)
    decreases i
  {
  }

  lemma lemma_1bMessageWithOpnImplies1cSent(b: Behavior<RslState>, c: LConstants, i: int, opn: OperationNumber, p_1b: RslPacket)
      returns (p_1c: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires p_1b in b[i].environment.sentPackets
    requires p_1b.src in c.config.replica_ids
    requires p_1b.msg.RslMessage_1b?
    requires opn in p_1b.msg.votes
    ensures p_1c in b[i].environment.sentPackets
    ensures p_1c.src in c.config.replica_ids
    ensures p_1c.msg.RslMessage_1c?
    ensures p_1c.msg.opn_1c == opn
    ensures p_1c.msg.bal_1c == p_1b.msg.votes[opn].max_value_bal
    ensures p_1c.msg.val_1c == p_1b.msg.votes[opn].max_val
    decreases i
  {
  }
}

module CommonProof__Message1c_i {

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Proposer_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__CheckValSafety_i

  import opened LiveByzRSL__Replica_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Constants_i

  import opened CommonProof__Actions_i

  import opened CommonProof__PacketSending_i

  import opened CommonProof__Environment_i

  import opened CommonProof__max_balISent1a_i

  import opened CommonProof__Received1b_i

  import opened CommonProof__Message2b_i

  import opened CommonProof__Message2av_i

  import opened CommonProof__QuorumOf2avs_i

  import opened Temporal__Temporal_s

  import opened Environment_s
  lemma lemma_1cMessageImplicationsForProposerState(b: Behavior<RslState>, c: LConstants, i: int, p: RslPacket)
      returns (proposer_idx: int)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires p in b[i].environment.sentPackets
    requires p.src in c.config.replica_ids
    requires p.msg.RslMessage_1c?
    ensures 0 <= proposer_idx < |c.config.replica_ids|
    ensures 0 <= proposer_idx < |b[i].replicas|
    ensures p.src == c.config.replica_ids[proposer_idx]
    ensures p.msg.bal_1c.proposer_id == proposer_idx
    ensures ghost var s: LProposer := b[i].replicas[proposer_idx].replica.proposer; BalLt(p.msg.bal_1c, s.max_ballot_i_sent_1a) || (s.max_ballot_i_sent_1a == p.msg.bal_1c && s.current_state != 1 && s.next_operation_number_to_propose > p.msg.opn_1c)
    decreases i
  {
  }

  lemma lemma_1cMessagesFromSameBallotAndOperationMatchWithoutLossOfGenerality(b: Behavior<RslState>, c: LConstants, i: int, p1: RslPacket, p2: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 < i
    requires p1 in b[i].environment.sentPackets
    requires p2 in b[i].environment.sentPackets
    requires p1.src in c.config.replica_ids
    requires p2.src in c.config.replica_ids
    requires p1.msg.RslMessage_1c?
    requires p2.msg.RslMessage_1c?
    requires p1.msg.opn_1c == p2.msg.opn_1c
    requires p1.msg.bal_1c == p2.msg.bal_1c
    requires p2 in b[i - 1].environment.sentPackets ==> p1 in b[i - 1].environment.sentPackets
    ensures p1.msg.val_1c == p2.msg.val_1c
    decreases 2 * i
  {
  }

  lemma lemma_1cMessagesFromSameBallotAndOperationMatch(b: Behavior<RslState>, c: LConstants, i: int, p1: RslPacket, p2: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires p1 in b[i].environment.sentPackets
    requires p2 in b[i].environment.sentPackets
    requires p1.src in c.config.replica_ids
    requires p2.src in c.config.replica_ids
    requires p1.msg.RslMessage_1c?
    requires p2.msg.RslMessage_1c?
    requires p1.msg.opn_1c == p2.msg.opn_1c
    requires p1.msg.bal_1c == p2.msg.bal_1c
    ensures p1.msg.val_1c == p2.msg.val_1c
    decreases 2 * i + 1
  {
  }

  lemma lemma_1cMessageHas1bQuorumPermittingIt(b: Behavior<RslState>, c: LConstants, i: int, p: RslPacket)
      returns (q: seq<RslPacket>)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires p in b[i].environment.sentPackets
    requires p.src in c.config.replica_ids
    requires p.msg.RslMessage_1c?
    ensures forall p: LPacket<NodeIdentity, RslMessage> {:trigger p in b[i].environment.sentPackets} {:trigger p in q} :: p in q ==> p in b[i].environment.sentPackets
    ensures |q| >= LByzQuorumSize(c.config)
    ensures LIsAfterLogTruncationPoint(p.msg.opn_1c, q)
    ensures LSetOfMessage1bAboutBallot(q, p.msg.bal_1c)
    ensures ghost var byzq: int := LByzQuorumSize(c.config); ghost var wq: int := LMinQuorumSize(c.config); LAllAcceptorsHadNoProposal(q, p.msg.opn_1c) || LValIsSafeAt(p.msg.val_1c, q, p.msg.opn_1c, byzq, wq)
    ensures forall i: int, j: int {:trigger q[j], q[i]} :: 0 <= i < j < |q| ==> q[i] != q[j]
    ensures forall p1: LPacket<NodeIdentity, RslMessage>, p2: LPacket<NodeIdentity, RslMessage> {:trigger p2.src, p1.src} {:trigger p2.src, p1 in q} {:trigger p1.src, p2 in q} {:trigger p2 in q, p1 in q} :: p1 in q && p2 in q && p1 != p2 ==> p1.src != p2.src
    ensures forall p1: LPacket<NodeIdentity, RslMessage> {:trigger p1.src} {:trigger p1 in q} :: p1 in q ==> p1.src in c.config.replica_ids
    decreases c, i, p
  {
  }

  lemma lemma_1cMessageHasValidBallot(b: Behavior<RslState>, c: LConstants, i: int, p: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires p in b[i].environment.sentPackets
    requires p.src in c.config.replica_ids
    requires p.msg.RslMessage_1c?
    ensures p.msg.bal_1c.seqno >= 0
    ensures 0 <= p.msg.bal_1c.proposer_id < |c.config.replica_ids|
    decreases c, i, p
  {
  }

  lemma lemma_Find1cThatCausedVote(b: Behavior<RslState>, c: LConstants, i: int, idx: int, opn: OperationNumber)
      returns (p: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= idx < |b[i].replicas|
    requires opn in b[i].replicas[idx].replica.acceptor.votes
    ensures p in b[i].environment.sentPackets
    ensures p.src in c.config.replica_ids
    ensures p.msg.RslMessage_1c?
    ensures p.msg.opn_1c == opn
    ensures p.msg.val_1c == b[i].replicas[idx].replica.acceptor.votes[opn].max_val
    ensures p.msg.bal_1c == b[i].replicas[idx].replica.acceptor.votes[opn].max_value_bal
    decreases i
  {
  }
}

module CommonProof__max_balISent1a_i {

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Types_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Constants_i

  import opened CommonProof__Actions_i

  import opened CommonProof__PacketSending_i

  import opened Temporal__Temporal_s
  lemma lemma_max_balISent1aHasMeAsProposer(b: Behavior<RslState>, c: LConstants, i: int, idx: int)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= idx < |b[i].replicas|
    ensures b[i].replicas[idx].replica.proposer.max_ballot_i_sent_1a.proposer_id == idx
    ensures b[i].replicas[idx].replica.proposer.max_ballot_i_sent_1a.seqno >= 0
    decreases i
  {
  }

  lemma lemma_Received1bPacketsAreFrommax_balISent1a(b: Behavior<RslState>, c: LConstants, i: int, idx: int)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= idx < |b[i].replicas|
    ensures ghost var s: LProposer := b[i].replicas[idx].replica.proposer; forall p: LPacket<NodeIdentity, RslMessage> {:trigger p in b[i].environment.sentPackets} {:trigger p.src} {:trigger p.msg} {:trigger p in s.received_1b_packets} :: (p in s.received_1b_packets ==> p.msg.RslMessage_1b?) && (p in s.received_1b_packets ==> p.msg.bal_1b == s.max_ballot_i_sent_1a) && (p in s.received_1b_packets ==> p.src in c.config.replica_ids) && (p in s.received_1b_packets ==> p in b[i].environment.sentPackets)
    ensures ghost var s: LProposer := b[i].replicas[idx].replica.proposer; forall p1: LPacket<NodeIdentity, RslMessage>, p2: LPacket<NodeIdentity, RslMessage> {:trigger p2.src, p1.src} {:trigger p2.src, p1 in s.received_1b_packets} {:trigger p1.src, p2 in s.received_1b_packets} {:trigger p2 in s.received_1b_packets, p1 in s.received_1b_packets} :: p1 in s.received_1b_packets && p2 in s.received_1b_packets ==> p1 == p2 || p1.src != p2.src
    ensures ghost var s: LProposer := b[i].replicas[idx].replica.proposer; ghost var msg1bs: seq<RslPacket> := s.received_1b_packets; forall i: int, j: int {:trigger msg1bs[j], msg1bs[i]} :: 0 <= i < j < |msg1bs| ==> msg1bs[i] != msg1bs[j]
    decreases c, i, idx
  {
  }
}

module CommonProof__Received1b_i {

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Actions_i

  import opened CommonProof__Constants_i

  import opened CommonProof__PacketSending_i

  import opened Temporal__Temporal_s
  lemma lemma_PacketInReceived1bWasSent(b: Behavior<RslState>, c: LConstants, i: int, replica_idx: int, p: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= replica_idx < |b[i].replicas|
    requires p in b[i].replicas[replica_idx].replica.proposer.received_1b_packets
    ensures p in b[i].environment.sentPackets
    ensures p.src in c.config.replica_ids
    decreases c, i, replica_idx, p
  {
  }
}

module CommonProof__max_bal_i {

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__Types_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Constants_i

  import opened CommonProof__Actions_i

  import opened CommonProof__PacketSending_i

  import opened Temporal__Temporal_s
  lemma lemma_VotePrecedesMaxBal(b: Behavior<RslState>, c: LConstants, i: int, idx: int, opn: OperationNumber)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= idx < |b[i].replicas|
    requires opn in b[i].replicas[idx].replica.acceptor.votes
    ensures BalLeq(b[i].replicas[idx].replica.acceptor.votes[opn].max_value_bal, b[i].replicas[idx].replica.acceptor.max_bal)
    decreases i
  {
  }
}

module CommonProof__Votes_i {

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Acceptor_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__Message_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Constants_i

  import opened CommonProof__Actions_i

  import opened CommonProof__PacketSending_i

  import opened CommonProof__Environment_i

  import opened CommonProof__Quorum_i

  import opened CommonProof__Message1c_i

  import opened CommonProof__Message2av_i

  import opened CommonProof__Message2b_i

  import opened Concrete_NodeIdentity_i

  import opened Temporal__Temporal_s

  import opened Environment_s

  import opened Collections__CountMatches_i

  import opened Collections__Sets_i
  lemma lemma_ActionThatOverwritesVoteWithSameBallotDoesntChangeValue(b: Behavior<RslState>, c: LConstants, i: int, opn: OperationNumber, bal: Ballot, idx: int)
    requires IsValidBehaviorPrefix(b, c, i + 1)
    requires 0 <= i
    requires 0 <= idx < |b[i].replicas|
    requires 0 <= idx < |b[i + 1].replicas|
    requires opn in b[i].replicas[idx].replica.acceptor.votes
    requires opn in b[i + 1].replicas[idx].replica.acceptor.votes
    requires b[i].replicas[idx].replica.acceptor.votes[opn].max_value_bal == b[i + 1].replicas[idx].replica.acceptor.votes[opn].max_value_bal
    ensures b[i].replicas[idx].replica.acceptor.votes[opn].max_val == b[i + 1].replicas[idx].replica.acceptor.votes[opn].max_val
    decreases c, i, opn, bal, idx
  {
  }

  lemma lemma_2bMessageImplicationsForCAcceptor(b: Behavior<RslState>, c: LConstants, i: int, p: RslPacket)
      returns (acceptor_idx: int)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires p in b[i].environment.sentPackets
    requires p.src in c.config.replica_ids
    requires p.msg.RslMessage_2b?
    ensures 0 <= acceptor_idx < |c.config.replica_ids|
    ensures 0 <= acceptor_idx < |b[i].replicas|
    ensures p.src == c.config.replica_ids[acceptor_idx]
    ensures BalLeq(p.msg.bal_2b, b[i].replicas[acceptor_idx].replica.acceptor.max_bal)
    ensures ghost var s: LAcceptor := b[i].replicas[acceptor_idx].replica.acceptor; p.msg.opn_2b >= s.log_truncation_point ==> p.msg.opn_2b in s.votes && BalLeq(p.msg.bal_2b, s.votes[p.msg.opn_2b].max_value_bal) && (s.votes[p.msg.opn_2b].max_value_bal == p.msg.bal_2b ==> s.votes[p.msg.opn_2b].max_val == p.msg.val_2b)
    decreases i
  {
  }
}

module CommonProof__Received2b_i {

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Types_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Actions_i

  import opened CommonProof__Constants_i

  import opened CommonProof__PacketSending_i

  import opened Temporal__Temporal_s
  lemma lemma_PacketInReceived2bWasSent(b: Behavior<RslState>, c: LConstants, i: int, replica_idx: int, opn: OperationNumber, p: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= replica_idx < |b[i].replicas|
    requires opn in b[i].replicas[replica_idx].replica.learner.unexecuted_learner_state
    requires p in b[i].replicas[replica_idx].replica.learner.unexecuted_learner_state[opn].received_2bs
    ensures p in b[i].environment.sentPackets
    ensures p.src in c.config.replica_ids
    decreases c, i, replica_idx, opn, p
  {
  }
}

module DirectRefinement__Execution_i {

  import opened LiveByzRSL__Configuration_i

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__Executor_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__StateMachine_i

  import opened LiveByzRSL__Types_i

  import opened Concrete_NodeIdentity_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Actions_i

  import opened CommonProof__Chosen_i

  import opened CommonProof__Constants_i

  import opened CommonProof__Environment_i

  import opened CommonProof__PacketSending_i

  import opened DirectRefinement__Chosen_i

  import opened DirectRefinement__HandleRequestBatch_i

  import opened Environment_s

  import opened Temporal__Temporal_s

  import opened Common__UpperBound_s

  import opened Collections__Seqs_s
  lemma {:opaque} lemma_AppStateAlwaysValid(b: Behavior<RslState>, c: LConstants, i: int, idx: int)
      returns (qs: seq<QuorumOf2bs>)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= idx < |b[i].replicas|
    ensures IsValidQuorumOf2bsSequence(b[i], qs)
    ensures |qs| == b[i].replicas[idx].replica.executor.ops_complete
    ensures b[i].replicas[idx].replica.executor.app == GetAppStateFromRequestBatches(GetSequenceOfRequestBatches(qs))
    decreases i
  {
  }

  lemma lemma_ReplyInReplyCacheIsAllowed(b: Behavior<RslState>, c: LConstants, i: int, client: NodeIdentity, idx: int)
      returns (qs: seq<QuorumOf2bs>, batches: seq<RequestBatch>, batch_num: int, req_num: int)
    requires IsValidBehaviorPrefix(b, c, i + 1)
    requires 0 <= i
    requires 0 <= idx < |c.config.replica_ids|
    requires 0 <= idx < |b[i].replicas|
    requires client in b[i].replicas[idx].replica.executor.reply_cache
    ensures IsValidQuorumOf2bsSequence(b[i], qs)
    ensures batches == GetSequenceOfRequestBatches(qs)
    ensures 0 <= batch_num < |batches|
    ensures 0 <= req_num < |batches[batch_num]|
    ensures b[i].replicas[idx].replica.executor.reply_cache[client] == GetReplyFromRequestBatches(batches, batch_num, req_num)
    decreases i
  {
  }

  lemma lemma_GetRequestIndexCorrespondingToPacketInGetPacketsFromReplies(p: RslPacket, me: NodeIdentity, requests: seq<Request>, replies: seq<Reply>)
      returns (i: int)
    requires |requests| == |replies|
    requires forall r: Reply {:trigger r.Reply?} {:trigger r in replies} :: r in replies ==> r.Reply?
    requires p in GetPacketsFromReplies(me, requests, replies)
    ensures 0 <= i < |requests|
    ensures p.src == me
    ensures p.dst == requests[i].client
    ensures p.msg.RslMessage_Reply?
    ensures p.msg.seqno_reply == requests[i].seqno
    ensures p.msg.reply == replies[i].reply
    decreases p, me, requests, replies
  {
  }

  lemma lemma_ReplySentViaExecutionIsAllowed(b: Behavior<RslState>, c: LConstants, i: int, p: RslPacket, idx: int, ios: seq<RslIo>)
      returns (qs: seq<QuorumOf2bs>, batches: seq<RequestBatch>, batch_num: int, req_num: int)
    requires IsValidBehaviorPrefix(b, c, i + 1)
    requires 0 <= i
    requires 0 <= idx < |c.config.replica_ids|
    requires 0 <= idx < |b[i].replicas|
    requires LIoOpSend(p) in ios
    requires RslNext(b[i], b[i + 1])
    requires b[i].environment.nextStep == LEnvStepHostIos(c.config.replica_ids[idx], ios)
    requires b[i].replicas[idx].replica.executor.next_op_to_execute.OutstandingOpKnown?
    requires LtUpperBound(b[i].replicas[idx].replica.executor.ops_complete, b[i].replicas[idx].replica.executor.constants.all.params.max_integer_val)
    requires LReplicaConstantsValid(b[i].replicas[idx].replica.executor.constants)
    requires LExecutorExecute(b[i].replicas[idx].replica.executor, b[i + 1].replicas[idx].replica.executor, ExtractSentPacketsFromIos(ios))
    ensures IsValidQuorumOf2bsSequence(b[i], qs)
    ensures batches == GetSequenceOfRequestBatches(qs)
    ensures 0 <= batch_num < |batches|
    ensures 0 <= req_num < |batches[batch_num]|
    ensures Reply(p.dst, p.msg.seqno_reply, p.msg.reply) == GetReplyFromRequestBatches(batches, batch_num, req_num)
    decreases c, i, p, idx, ios
  {
  }

  lemma lemma_ReplySentIsAllowed(b: Behavior<RslState>, c: LConstants, i: int, p: RslPacket)
      returns (qs: seq<QuorumOf2bs>, batches: seq<RequestBatch>, batch_num: int, req_num: int)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires p in b[i].environment.sentPackets
    requires p.src in c.config.replica_ids
    requires p.msg.RslMessage_Reply?
    ensures IsValidQuorumOf2bsSequence(b[i], qs)
    ensures batches == GetSequenceOfRequestBatches(qs)
    ensures 0 <= batch_num < |batches|
    ensures 0 <= req_num < |batches[batch_num]|
    ensures Reply(p.dst, p.msg.seqno_reply, p.msg.reply) == GetReplyFromRequestBatches(batches, batch_num, req_num)
    decreases i
  {
  }
}

module DirectRefinement__Requests_i {

  import opened LiveByzRSL__Constants_i

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Election_i

  import opened LiveByzRSL__Environment_i

  import opened LiveByzRSL__Proposer_i

  import opened LiveByzRSL__Replica_i

  import opened LiveByzRSL__Types_i

  import opened LiveByzRSL__CheckValSafety_i

  import opened CommonProof__Actions_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Chosen_i

  import opened CommonProof__Constants_i

  import opened CommonProof__Environment_i

  import opened CommonProof__QuorumOf2avs_i

  import opened CommonProof__Message1b_i

  import opened CommonProof__Message2av_i

  import opened CommonProof__Message2b_i

  import opened CommonProof__PacketSending_i

  import opened CommonProof__Received1b_i

  import opened CommonProof__Requests_i

  import opened DirectRefinement__Chosen_i

  import opened Temporal__Temporal_s

  import opened Environment_s
  lemma lemma_RequestInRequestsReceivedThisEpochHasCorrespondingRequestMessage(b: Behavior<RslState>, c: LConstants, i: int, idx: int, req: Request)
      returns (p: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= idx < |b[i].replicas|
    requires req in b[i].replicas[idx].replica.proposer.election_state.requests_received_this_epoch
    ensures p in b[i].environment.sentPackets
    ensures p.dst in c.config.replica_ids
    ensures p.msg.RslMessage_Request?
    ensures req == Request(p.src, p.msg.seqno_req, p.msg.val)
    decreases i
  {
  }

  lemma lemma_RequestInRequestsReceivedPrevEpochsHasCorrespondingRequestMessage(b: Behavior<RslState>, c: LConstants, i: int, idx: int, req: Request)
      returns (p: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= idx < |b[i].replicas|
    requires req in b[i].replicas[idx].replica.proposer.election_state.requests_received_prev_epochs
    ensures p in b[i].environment.sentPackets
    ensures p.dst in c.config.replica_ids
    ensures p.msg.RslMessage_Request?
    ensures req == Request(p.src, p.msg.seqno_req, p.msg.val)
    decreases i
  {
  }

  lemma lemma_RequestInRequestQueueHasCorrespondingRequestMessage(b: Behavior<RslState>, c: LConstants, i: int, idx: int, req: Request)
      returns (p: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires 0 <= idx < |b[i].replicas|
    requires req in b[i].replicas[idx].replica.proposer.request_queue
    ensures p in b[i].environment.sentPackets
    ensures p.dst in c.config.replica_ids
    ensures p.msg.RslMessage_Request?
    ensures req == Request(p.src, p.msg.seqno_req, p.msg.val)
    decreases i
  {
  }

  lemma lemma_RequestIn1bMessageHasCorrespondingRequestMessage(b: Behavior<RslState>, c: LConstants, i: int, p_1b: RslPacket, opn: OperationNumber, req_num: int)
      returns (p_req: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires p_1b in b[i].environment.sentPackets
    requires p_1b.src in c.config.replica_ids
    requires p_1b.msg.RslMessage_1b?
    requires opn in p_1b.msg.votes
    requires 0 <= req_num < |p_1b.msg.votes[opn].max_val|
    ensures p_req in b[i].environment.sentPackets
    ensures p_req.dst in c.config.replica_ids
    ensures p_req.msg.RslMessage_Request?
    ensures p_1b.msg.votes[opn].max_val[req_num] == Request(p_req.src, p_req.msg.seqno_req, p_req.msg.val)
    decreases i, 1
  {
  }

  lemma lemma_RequestIn1cMessageHasCorrespondingRequestMessage(b: Behavior<RslState>, c: LConstants, i: int, p_1c: RslPacket, req_num: int)
      returns (p_req: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires p_1c in b[i].environment.sentPackets
    requires p_1c.src in c.config.replica_ids
    requires p_1c.msg.RslMessage_1c?
    requires 0 <= req_num < |p_1c.msg.val_1c|
    ensures p_req in b[i].environment.sentPackets
    ensures p_req.dst in c.config.replica_ids
    ensures p_req.msg.RslMessage_Request?
    ensures p_1c.msg.val_1c[req_num] == Request(p_req.src, p_req.msg.seqno_req, p_req.msg.val)
    decreases i, 0
  {
  }

  lemma lemma_DecidedRequestWasSentByClient(b: Behavior<RslState>, c: LConstants, i: int, qs: seq<QuorumOf2bs>, batches: seq<RequestBatch>, batch_num: int, req_num: int)
      returns (p: RslPacket)
    requires IsValidBehaviorPrefix(b, c, i)
    requires 0 <= i
    requires IsValidQuorumOf2bsSequence(b[i], qs)
    requires batches == GetSequenceOfRequestBatches(qs)
    requires 0 <= batch_num < |batches|
    requires 0 <= req_num < |batches[batch_num]|
    ensures p in b[i].environment.sentPackets
    ensures p.dst in c.config.replica_ids
    ensures p.msg.RslMessage_Request?
    ensures batches[batch_num][req_num] == Request(p.src, p.msg.seqno_req, p.msg.val)
    decreases i
  {
  }
}

module CommonProof__Requests_i {

  import opened LiveByzRSL__DistributedSystem_i

  import opened LiveByzRSL__Election_i

  import opened LiveByzRSL__Types_i

  import opened CommonProof__Assumptions_i

  import opened CommonProof__Constants_i

  import opened CommonProof__Actions_i

  import opened CommonProof__Environment_i

  import opened CommonProof__PacketSending_i

  import opened CommonProof__Chosen_i
  lemma /*{:_induction s, r}*/ lemma_RemoveAllSatisfiedRequestsInSequenceProducesSubsequence(s': seq<Request>, s: seq<Request>, r: Request)
    requires s' == RemoveAllSatisfiedRequestsInSequence(s, r)
    ensures forall x: Request {:trigger x in s} {:trigger x in s'} :: x in s' ==> x in s
    decreases s, 1
  {
  }

  lemma /*{:_induction s, batch}*/ lemma_RemoveExecutedRequestBatchProducesSubsequence(s': seq<Request>, s: seq<Request>, batch: RequestBatch)
    requires s' == RemoveExecutedRequestBatch(s, batch)
    ensures forall x: Request {:trigger x in s} {:trigger x in s'} :: x in s' ==> x in s
    decreases |batch|
  {
  }
}

module RSL_DistributedSystem_i refines DistributedSystem_s {

  import H_s = Host_i
  predicate ValidPhysicalAddress(endPoint: EndPoint)
    decreases endPoint
  {
    |endPoint.addr| == 4 &&
    0 <= endPoint.port <= 65535
  }

  predicate ValidPhysicalPacket(p: LPacket<EndPoint, seq<byte>>)
    decreases p
  {
    ValidPhysicalAddress(p.src) &&
    ValidPhysicalAddress(p.dst) &&
    |p.msg| < 18446744073709551616
  }

  predicate ValidPhysicalIo(io: LIoOp<EndPoint, seq<byte>>)
    decreases io
  {
    (io.LIoOpReceive? ==>
      ValidPhysicalPacket(io.r)) &&
    (io.LIoOpSend? ==>
      ValidPhysicalPacket(io.s))
  }

  predicate ValidPhysicalEnvironmentStep(step: LEnvStep<EndPoint, seq<byte>>)
    decreases step
  {
    step.LEnvStepHostIos? ==>
      forall io: LIoOp<EndPoint, seq<byte>> {:trigger io in step.ios} {:trigger ValidPhysicalIo(io)} :: 
        io in step.ios ==>
          ValidPhysicalIo(io)
  }

  predicate DS_Init(s: DS_State, config: H_s.ConcreteConfiguration)
    reads *
    decreases {}, s, config
  {
    s.config == config &&
    H_s.ConcreteConfigInit(s.config, mapdomain(s.servers), s.clients) &&
    LEnvironment_Init(s.environment) &&
    forall id: EndPoint {:trigger s.servers[id]} {:trigger id in s.servers} :: 
      id in s.servers ==>
        _default.HostInit(s.servers[id], config, id)
  }

  predicate DS_NextOneServer(s: DS_State, s': DS_State, id: EndPoint, ios: seq<LIoOp<EndPoint, seq<byte>>>)
    requires id in s.servers
    reads *
    decreases {}, s, s', id, ios
  {
    id in s'.servers &&
    H_s.HostNext(s.servers[id], s'.servers[id], ios) &&
    s'.servers == s.servers[id := s'.servers[id]]
  }

  predicate DS_Next(s: DS_State, s': DS_State)
    reads *
    decreases {}, s, s'
  {
    s'.config == s.config &&
    s'.clients == s.clients &&
    LEnvironment_Next(s.environment, s'.environment) &&
    ValidPhysicalEnvironmentStep(s.environment.nextStep) &&
    if s.environment.nextStep.LEnvStepHostIos? && s.environment.nextStep.actor in s.servers then DS_NextOneServer(s, s', s.environment.nextStep.actor, s.environment.nextStep.ios) else s'.servers == s.servers
  }

  import opened Collections__Maps2_s

  import opened Native__Io_s

  import opened Environment_s

  import opened Native__NativeTypes_s

  datatype DS_State = DS_State(config: H_s.ConcreteConfiguration, environment: LEnvironment<EndPoint, seq<byte>>, servers: map<EndPoint, H_s.HostState>, clients: set<EndPoint>)
}

module AbstractServiceRSL_s refines AbstractService_s {

  import opened AppStateMachine_i

  import opened Collections__Seqs_s
  datatype AppRequest = AppRequest(client: EndPoint, seqno: int, request: AppMessage)

  datatype AppReply = AppReply(client: EndPoint, seqno: int, reply: AppMessage)

  datatype ServiceState' = ServiceState'(serverAddresses: set<EndPoint>, app: AppState, requests: set<AppRequest>, replies: set<AppReply>)

  type ServiceState = ServiceState'

  predicate Service_Init(s: ServiceState, serverAddresses: set<EndPoint>)
    decreases s, serverAddresses
  {
    s.serverAddresses == serverAddresses &&
    s.app == AppInitialize() &&
    s.requests == {} &&
    s.replies == {}
  }

  predicate ServiceExecutesAppRequest(s: ServiceState, s': ServiceState, req: AppRequest)
    decreases s, s', req
  {
    s'.serverAddresses == s.serverAddresses &&
    s'.requests == s.requests + {req} &&
    s'.app == AppHandleRequest(s.app, req.request).0 &&
    s'.replies == s.replies + {AppReply(req.client, req.seqno, AppHandleRequest(s.app, req.request).1)}
  }

  predicate StateSequenceReflectsBatchExecution(s: ServiceState, s': ServiceState, intermediate_states: seq<ServiceState>, batch: seq<AppRequest>)
    decreases s, s', intermediate_states, batch
  {
    |intermediate_states| == |batch| + 1 &&
    intermediate_states[0] == s &&
    last(intermediate_states) == s' &&
    forall i: int, _t#0: int {:trigger batch[i], intermediate_states[_t#0]} {:trigger intermediate_states[_t#0], intermediate_states[i]} | _t#0 == i + 1 :: 
      0 <= i &&
      i < |batch| ==>
        ServiceExecutesAppRequest(intermediate_states[i], intermediate_states[_t#0], batch[i])
  }

  predicate Service_Next(s: ServiceState, s': ServiceState)
    decreases s, s'
  {
    exists intermediate_states: seq<ServiceState>, batch: seq<AppRequest> {:trigger StateSequenceReflectsBatchExecution(s, s', intermediate_states, batch)} :: 
      StateSequenceReflectsBatchExecution(s, s', intermediate_states, batch)
  }

  function Uint64ToBytes(u: uint64): seq<byte>
    decreases u
  {
    [(u / 72057594037927936) as byte, (u / 281474976710656 % 256) as byte, (u / 1099511627776 % 256) as byte, (u / 4294967296 % 256) as byte, (u / 16777216 % 256) as byte, (u / 65536 % 256) as byte, (u / 256 % 256) as byte, (u % 256) as byte]
  }

  function MarshallServiceRequest(seqno: int, request: AppMessage): seq<byte>
    decreases seqno, request
  {
    if 0 <= seqno < 18446744073709551616 then
      [0, 0, 0, 0, 0, 0, 0, 0] + Uint64ToBytes(seqno as uint64) + MarshallAppMessage(request)
    else
      [1]
  }

  function MarshallServiceReply(seqno: int, reply: AppMessage): seq<byte>
    decreases seqno, reply
  {
    if 0 <= seqno < 18446744073709551616 then
      [0, 0, 0, 0, 0, 0, 0, 7] + Uint64ToBytes(seqno as uint64) + MarshallAppMessage(reply)
    else
      [1]
  }

  predicate Service_Correspondence(concretePkts: set<LPacket<EndPoint, seq<byte>>>, serviceState: ServiceState)
    decreases concretePkts, serviceState
  {
    (forall p: LPacket<EndPoint, seq<byte>>, seqno: int, reply: AppMessage {:trigger p.dst, MarshallServiceReply(seqno, reply)} {:trigger MarshallServiceReply(seqno, reply), p.msg} {:trigger MarshallServiceReply(seqno, reply), p.src} {:trigger MarshallServiceReply(seqno, reply), p in concretePkts} :: 
      p in concretePkts &&
      p.src in serviceState.serverAddresses &&
      p.msg == MarshallServiceReply(seqno, reply) ==>
        AppReply(p.dst, seqno, reply) in serviceState.replies) &&
    forall req: AppRequest {:trigger req.client} {:trigger req.request} {:trigger req.seqno} {:trigger req in serviceState.requests} :: 
      req in serviceState.requests ==>
        exists p: LPacket<EndPoint, seq<byte>> {:trigger p.src} {:trigger p.msg} {:trigger p.dst} {:trigger p in concretePkts} :: 
          p in concretePkts &&
          p.dst in serviceState.serverAddresses &&
          p.msg == MarshallServiceRequest(req.seqno, req.request) &&
          p.src == req.client
  }

  import opened Native__Io_s

  import opened Environment_s

  import opened Native__NativeTypes_s
}

module MarshallProof_i {

  import opened Native__NativeTypes_s

  import opened AppStateMachine_i

  import opened AbstractServiceRSL_s

  import opened LiveByzRSL__AppInterface_i

  import opened LiveByzRSL__CMessage_i

  import opened LiveByzRSL__CMessageRefinements_i

  import opened LiveByzRSL__Message_i

  import opened LiveByzRSL__PacketParsing_i

  import opened Common__GenericMarshalling_i

  import opened Common__Util_i

  import opened Math__power2_i
  lemma lemma_ParseValCorrectVCase(data: seq<byte>, v: V, g: G)
      returns (caseId: uint64, val: V, rest: seq<byte>)
    requires ValInGrammar(v, g)
    requires |data| < 18446744073709551616
    requires ValidGrammar(g)
    requires parse_Val(data, g).0.Some?
    requires parse_Val(data, g).0.v == v
    requires g.GTaggedUnion?
    ensures parse_Uint64(data).0.Some?
    ensures caseId == parse_Uint64(data).0.v.u
    ensures 0 <= caseId as int < |g.cases|
    ensures rest == parse_Uint64(data).1
    ensures parse_Val(rest, g.cases[caseId]).0.Some?
    ensures val == parse_Val(rest, g.cases[caseId]).0.v
    ensures v == VCase(caseId, val)
    ensures ValInGrammar(val, g.cases[caseId])
    decreases data, v, g
  {
  }

  lemma {:fuel ValInGrammar, 3} lemma_ParseValCorrectTuple2(data: seq<byte>, v: V, g: G)
      returns (val0: V, val1: V, rest: seq<byte>)
    requires ValInGrammar(v, g)
    requires |data| < 18446744073709551616
    requires ValidGrammar(g)
    requires parse_Val(data, g).0.Some?
    requires parse_Val(data, g).0.v == v
    requires g.GTuple?
    requires |g.t| == 2
    ensures parse_Val(data, g.t[0]).0.Some?
    ensures val0 == parse_Val(data, g.t[0]).0.v
    ensures ValInGrammar(val0, g.t[0])
    ensures rest == parse_Val(data, g.t[0]).1
    ensures parse_Val(rest, g.t[1]).0.Some?
    ensures val1 == parse_Val(rest, g.t[1]).0.v
    ensures ValInGrammar(val1, g.t[1])
    ensures v == VTuple([val0, val1])
    decreases data, v, g
  {
  }

  lemma lemma_ParseValCorrectVUint64(data: seq<byte>, v: V, g: G)
      returns (u: uint64, rest: seq<byte>)
    requires ValInGrammar(v, g)
    requires |data| < 18446744073709551616
    requires ValidGrammar(g)
    requires parse_Val(data, g).0.Some?
    requires parse_Val(data, g).0.v == v
    requires g.GUint64?
    ensures parse_Uint64(data).0.Some?
    ensures u == parse_Uint64(data).0.v.u
    ensures v == VUint64(u)
    ensures rest == parse_Val(data, g).1
    decreases data, v, g
  {
  }

  lemma {:fuel ValInGrammar, 3} {:fuel SizeOfV, 3} /*{:_induction v}*/ lemma_SizeOfCMessageRequest1(v: V)
    requires ValInGrammar(v, CMessage_grammar())
    requires ValInGrammar(v.val, CMessage_Request_grammar())
    requires v.val.t[1].c == 1
    ensures SizeOfV(v) == 32
    decreases v
  {
  }

  lemma {:fuel ValInGrammar, 3} {:fuel SizeOfV, 3} /*{:_induction v}*/ lemma_SizeOfCMessageRequest(v: V)
    requires ValInGrammar(v, CMessage_grammar())
    requires ValInGrammar(v.val, CMessage_Request_grammar())
    requires v.val.t[1].c == 0 || v.val.t[1].c == 2
    ensures SizeOfV(v) == 24
    decreases v
  {
  }

  lemma ByteArrayOf8(bytes: seq<byte>, b: byte)
    requires |bytes| == 8
    requires SeqByteToUint64(bytes) == b as uint64
    ensures bytes == [0, 0, 0, 0, 0, 0, 0, b]
    decreases bytes, b
  {
  }

  lemma ByteConcat24(bytes: seq<byte>)
    requires |bytes| >= 24
    ensures bytes[0 .. 24] == bytes[0 .. 8] + bytes[8 .. 16] + bytes[16 .. 24]
    decreases bytes
  {
  }

  lemma ByteConcat32(bytes: seq<byte>)
    requires |bytes| >= 32
    ensures bytes[0 .. 32] == bytes[0 .. 8] + bytes[8 .. 16] + bytes[16 .. 24] + bytes[24 .. 32]
    decreases bytes
  {
  }

  lemma {:timeLimitMultiplier 5} {:fuel ValInGrammar, 3} /*{:_timeLimit 50}*/ lemma_ParseMarshallRequest(bytes: seq<byte>, msg: RslMessage)
    requires msg.RslMessage_Request?
    requires CMessageIsAbstractable(PaxosDemarshallData(bytes))
    requires AbstractifyCMessageToRslMessage(PaxosDemarshallData(bytes)) == msg
    ensures bytes == MarshallServiceRequest(msg.seqno_req, msg.val)
    decreases bytes, msg
  {
  }

  lemma {:timeLimitMultiplier 5} {:fuel ValInGrammar, 3} /*{:_timeLimit 50}*/ lemma_ParseMarshallReply(bytes: seq<byte>, seqno: int, reply: AppMessage, msg: RslMessage)
    requires CMessageIsAbstractable(PaxosDemarshallData(bytes))
    requires AbstractifyCMessageToRslMessage(PaxosDemarshallData(bytes)) == msg
    requires Marshallable(PaxosDemarshallData(bytes))
    requires bytes == MarshallServiceReply(seqno, reply)
    ensures msg.RslMessage_Reply?
    ensures msg.seqno_reply == seqno
    ensures msg.reply == reply
    decreases bytes, seqno, reply, msg
  {
  }
}
")]

//-----------------------------------------------------------------------------
//
// Copyright by the contributors to the Dafny Project
// SPDX-License-Identifier: MIT
//
//-----------------------------------------------------------------------------

#if ISDAFNYRUNTIMELIB
using System; // for Func
using System.Numerics;
using System.Collections;
#endif

namespace DafnyAssembly {
  [AttributeUsage(AttributeTargets.Assembly)]
  public class DafnySourceAttribute : Attribute {
    public readonly string dafnySourceText;
    public DafnySourceAttribute(string txt) { dafnySourceText = txt; }
  }
}

namespace Dafny {
  using System.Collections.Generic;
  using System.Collections.Immutable;
  using System.Linq;

  // Similar to System.Text.Rune, which would be perfect to use
  // except that it isn't available in the platforms we support
  // (.NET Standard 2.0 and .NET Framework 4.5.2)
  public readonly struct Rune : IComparable, IComparable<Rune>, IEquatable<Rune> {

    private readonly uint _value;

    public Rune(int value)
      : this((uint)value) {
    }

    public Rune(uint value) {
      if (!(value < 0xD800 || (0xE000 <= value && value < 0x11_0000))) {
        throw new ArgumentException();
      }

      _value = value;
    }

    public int Value => (int)_value;

    public bool Equals(Rune other) => this == other;

    public override bool Equals(object obj) => (obj is Rune other) && Equals(other);

    public override int GetHashCode() => Value;

    // Values are always between 0 and 0x11_0000, so overflow isn't possible
    public int CompareTo(Rune other) => this.Value - other.Value;

    int IComparable.CompareTo(object obj) {
      switch (obj) {
        case null:
          return 1; // non-null ("this") always sorts after null
        case Rune other:
          return CompareTo(other);
        default:
          throw new ArgumentException();
      }
    }

    public static bool operator ==(Rune left, Rune right) => left._value == right._value;

    public static bool operator !=(Rune left, Rune right) => left._value != right._value;

    public static bool operator <(Rune left, Rune right) => left._value < right._value;

    public static bool operator <=(Rune left, Rune right) => left._value <= right._value;

    public static bool operator >(Rune left, Rune right) => left._value > right._value;

    public static bool operator >=(Rune left, Rune right) => left._value >= right._value;

    public static explicit operator Rune(int value) => new Rune(value);
    public static explicit operator Rune(BigInteger value) => new Rune((uint)value);

    // Defined this way to be consistent with System.Text.Rune,
    // but note that Dafny will use Helpers.ToString(rune),
    // which will print in the style of a character literal instead.
    public override string ToString() {
      return char.ConvertFromUtf32(Value);
    }

    // Replacement for String.EnumerateRunes() from newer platforms
    public static IEnumerable<Rune> Enumerate(string s) {
      var sLength = s.Length;
      for (var i = 0; i < sLength; i++) {
        if (char.IsHighSurrogate(s[i])) {
          if (char.IsLowSurrogate(s[i + 1])) {
            yield return (Rune)char.ConvertToUtf32(s[i], s[i + 1]);
            i++;
          } else {
            throw new ArgumentException();
          }
        } else if (char.IsLowSurrogate(s[i])) {
          throw new ArgumentException();
        } else {
          yield return (Rune)s[i];
        }
      }
    }
  }

  public interface ISet<out T> {
    int Count { get; }
    long LongCount { get; }
    IEnumerable<T> Elements { get; }
    IEnumerable<ISet<T>> AllSubsets { get; }
    bool Contains<G>(G t);
    bool EqualsAux(ISet<object> other);
    ISet<U> DowncastClone<U>(Func<T, U> converter);
  }

  public class Set<T> : ISet<T> {
    readonly ImmutableHashSet<T> setImpl;
    readonly bool containsNull;
    Set(ImmutableHashSet<T> d, bool containsNull) {
      this.setImpl = d;
      this.containsNull = containsNull;
    }

    public static readonly ISet<T> Empty = new Set<T>(ImmutableHashSet<T>.Empty, false);

    private static readonly TypeDescriptor<ISet<T>> _TYPE = new Dafny.TypeDescriptor<ISet<T>>(Empty);
    public static TypeDescriptor<ISet<T>> _TypeDescriptor() {
      return _TYPE;
    }

    public static ISet<T> FromElements(params T[] values) {
      return FromCollection(values);
    }

    public static Set<T> FromISet(ISet<T> s) {
      return s as Set<T> ?? FromCollection(s.Elements);
    }

    public static Set<T> FromCollection(IEnumerable<T> values) {
      var d = ImmutableHashSet<T>.Empty.ToBuilder();
      var containsNull = false;
      foreach (T t in values) {
        if (t == null) {
          containsNull = true;
        } else {
          d.Add(t);
        }
      }

      return new Set<T>(d.ToImmutable(), containsNull);
    }

    public static ISet<T> FromCollectionPlusOne(IEnumerable<T> values, T oneMoreValue) {
      var d = ImmutableHashSet<T>.Empty.ToBuilder();
      var containsNull = false;
      if (oneMoreValue == null) {
        containsNull = true;
      } else {
        d.Add(oneMoreValue);
      }

      foreach (T t in values) {
        if (t == null) {
          containsNull = true;
        } else {
          d.Add(t);
        }
      }

      return new Set<T>(d.ToImmutable(), containsNull);
    }

    public ISet<U> DowncastClone<U>(Func<T, U> converter) {
      if (this is ISet<U> th) {
        return th;
      } else {
        var d = ImmutableHashSet<U>.Empty.ToBuilder();
        foreach (var t in this.setImpl) {
          var u = converter(t);
          d.Add(u);
        }

        return new Set<U>(d.ToImmutable(), this.containsNull);
      }
    }

    public int Count {
      get { return this.setImpl.Count + (containsNull ? 1 : 0); }
    }

    public long LongCount {
      get { return this.setImpl.Count + (containsNull ? 1 : 0); }
    }

    public IEnumerable<T> Elements {
      get {
        if (containsNull) {
          yield return default(T);
        }

        foreach (var t in this.setImpl) {
          yield return t;
        }
      }
    }

    /// <summary>
    /// This is an inefficient iterator for producing all subsets of "this".
    /// </summary>
    public IEnumerable<ISet<T>> AllSubsets {
      get {
        // Start by putting all set elements into a list, but don't include null
        var elmts = new List<T>();
        elmts.AddRange(this.setImpl);
        var n = elmts.Count;
        var which = new bool[n];
        var s = ImmutableHashSet<T>.Empty.ToBuilder();
        while (true) {
          // yield both the subset without null and, if null is in the original set, the subset with null included
          var ihs = s.ToImmutable();
          yield return new Set<T>(ihs, false);
          if (containsNull) {
            yield return new Set<T>(ihs, true);
          }

          // "add 1" to "which", as if doing a carry chain.  For every digit changed, change the membership of the corresponding element in "s".
          int i = 0;
          for (; i < n && which[i]; i++) {
            which[i] = false;
            s.Remove(elmts[i]);
          }

          if (i == n) {
            // we have cycled through all the subsets
            break;
          }

          which[i] = true;
          s.Add(elmts[i]);
        }
      }
    }

    public bool Equals(ISet<T> other) {
      if (ReferenceEquals(this, other)) {
        return true;
      }

      if (other == null || Count != other.Count) {
        return false;
      }

      foreach (var elmt in Elements) {
        if (!other.Contains(elmt)) {
          return false;
        }
      }

      return true;
    }

    public override bool Equals(object other) {
      if (other is ISet<T>) {
        return Equals((ISet<T>)other);
      }

      var th = this as ISet<object>;
      var oth = other as ISet<object>;
      if (th != null && oth != null) {
        // We'd like to obtain the more specific type parameter U for oth's type ISet<U>.
        // We do that by making a dynamically dispatched call, like:
        //     oth.Equals(this)
        // The hope is then that its comparison "this is ISet<U>" (that is, the first "if" test
        // above, but in the call "oth.Equals(this)") will be true and the non-virtual Equals
        // can be called. However, such a recursive call to "oth.Equals(this)" could turn
        // into infinite recursion. Therefore, we instead call "oth.EqualsAux(this)", which
        // performs the desired type test, but doesn't recurse any further.
        return oth.EqualsAux(th);
      } else {
        return false;
      }
    }

    public bool EqualsAux(ISet<object> other) {
      var s = other as ISet<T>;
      if (s != null) {
        return Equals(s);
      } else {
        return false;
      }
    }

    public override int GetHashCode() {
      var hashCode = 1;
      if (containsNull) {
        hashCode = hashCode * (Dafny.Helpers.GetHashCode(default(T)) + 3);
      }

      foreach (var t in this.setImpl) {
        hashCode = hashCode * (Dafny.Helpers.GetHashCode(t) + 3);
      }

      return hashCode;
    }

    public override string ToString() {
      var s = "{";
      var sep = "";
      if (containsNull) {
        s += sep + Dafny.Helpers.ToString(default(T));
        sep = ", ";
      }

      foreach (var t in this.setImpl) {
        s += sep + Dafny.Helpers.ToString(t);
        sep = ", ";
      }

      return s + "}";
    }
    public static bool IsProperSubsetOf(ISet<T> th, ISet<T> other) {
      return th.Count < other.Count && IsSubsetOf(th, other);
    }
    public static bool IsSubsetOf(ISet<T> th, ISet<T> other) {
      if (other.Count < th.Count) {
        return false;
      }
      foreach (T t in th.Elements) {
        if (!other.Contains(t)) {
          return false;
        }
      }
      return true;
    }
    public static bool IsDisjointFrom(ISet<T> th, ISet<T> other) {
      ISet<T> a, b;
      if (th.Count < other.Count) {
        a = th; b = other;
      } else {
        a = other; b = th;
      }
      foreach (T t in a.Elements) {
        if (b.Contains(t)) {
          return false;
        }
      }
      return true;
    }
    public bool Contains<G>(G t) {
      return t == null ? containsNull : t is T && this.setImpl.Contains((T)(object)t);
    }
    public static ISet<T> Union(ISet<T> th, ISet<T> other) {
      var a = FromISet(th);
      var b = FromISet(other);
      return new Set<T>(a.setImpl.Union(b.setImpl), a.containsNull || b.containsNull);
    }
    public static ISet<T> Intersect(ISet<T> th, ISet<T> other) {
      var a = FromISet(th);
      var b = FromISet(other);
      return new Set<T>(a.setImpl.Intersect(b.setImpl), a.containsNull && b.containsNull);
    }
    public static ISet<T> Difference(ISet<T> th, ISet<T> other) {
      var a = FromISet(th);
      var b = FromISet(other);
      return new Set<T>(a.setImpl.Except(b.setImpl), a.containsNull && !b.containsNull);
    }
  }

  public interface IMultiSet<out T> {
    bool IsEmpty { get; }
    int Count { get; }
    long LongCount { get; }
    IEnumerable<T> Elements { get; }
    IEnumerable<T> UniqueElements { get; }
    bool Contains<G>(G t);
    BigInteger Select<G>(G t);
    IMultiSet<T> Update<G>(G t, BigInteger i);
    bool EqualsAux(IMultiSet<object> other);
    IMultiSet<U> DowncastClone<U>(Func<T, U> converter);
  }

  public class MultiSet<T> : IMultiSet<T> {
    readonly ImmutableDictionary<T, BigInteger> dict;
    readonly BigInteger occurrencesOfNull;  // stupidly, a Dictionary in .NET cannot use "null" as a key
    MultiSet(ImmutableDictionary<T, BigInteger>.Builder d, BigInteger occurrencesOfNull) {
      dict = d.ToImmutable();
      this.occurrencesOfNull = occurrencesOfNull;
    }
    public static readonly MultiSet<T> Empty = new MultiSet<T>(ImmutableDictionary<T, BigInteger>.Empty.ToBuilder(), BigInteger.Zero);

    private static readonly TypeDescriptor<IMultiSet<T>> _TYPE = new Dafny.TypeDescriptor<IMultiSet<T>>(Empty);
    public static TypeDescriptor<IMultiSet<T>> _TypeDescriptor() {
      return _TYPE;
    }

    public static MultiSet<T> FromIMultiSet(IMultiSet<T> s) {
      return s as MultiSet<T> ?? FromCollection(s.Elements);
    }
    public static MultiSet<T> FromElements(params T[] values) {
      var d = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      var occurrencesOfNull = BigInteger.Zero;
      foreach (T t in values) {
        if (t == null) {
          occurrencesOfNull++;
        } else {
          BigInteger i;
          if (!d.TryGetValue(t, out i)) {
            i = BigInteger.Zero;
          }
          d[t] = i + 1;
        }
      }
      return new MultiSet<T>(d, occurrencesOfNull);
    }

    public static MultiSet<T> FromCollection(IEnumerable<T> values) {
      var d = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      var occurrencesOfNull = BigInteger.Zero;
      foreach (T t in values) {
        if (t == null) {
          occurrencesOfNull++;
        } else {
          BigInteger i;
          if (!d.TryGetValue(t,
            out i)) {
            i = BigInteger.Zero;
          }

          d[t] = i + 1;
        }
      }

      return new MultiSet<T>(d,
        occurrencesOfNull);
    }

    public static MultiSet<T> FromSeq(ISequence<T> values) {
      var d = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      var occurrencesOfNull = BigInteger.Zero;
      foreach (var t in values) {
        if (t == null) {
          occurrencesOfNull++;
        } else {
          BigInteger i;
          if (!d.TryGetValue(t,
            out i)) {
            i = BigInteger.Zero;
          }

          d[t] = i + 1;
        }
      }

      return new MultiSet<T>(d,
        occurrencesOfNull);
    }
    public static MultiSet<T> FromSet(ISet<T> values) {
      var d = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      var containsNull = false;
      foreach (T t in values.Elements) {
        if (t == null) {
          containsNull = true;
        } else {
          d[t] = BigInteger.One;
        }
      }
      return new MultiSet<T>(d, containsNull ? BigInteger.One : BigInteger.Zero);
    }
    public IMultiSet<U> DowncastClone<U>(Func<T, U> converter) {
      if (this is IMultiSet<U> th) {
        return th;
      } else {
        var d = ImmutableDictionary<U, BigInteger>.Empty.ToBuilder();
        foreach (var item in this.dict) {
          var k = converter(item.Key);
          d.Add(k, item.Value);
        }
        return new MultiSet<U>(d, this.occurrencesOfNull);
      }
    }

    public bool Equals(IMultiSet<T> other) {
      return IsSubsetOf(this, other) && IsSubsetOf(other, this);
    }
    public override bool Equals(object other) {
      if (other is IMultiSet<T>) {
        return Equals((IMultiSet<T>)other);
      }
      var th = this as IMultiSet<object>;
      var oth = other as IMultiSet<object>;
      if (th != null && oth != null) {
        // See comment in Set.Equals
        return oth.EqualsAux(th);
      } else {
        return false;
      }
    }

    public bool EqualsAux(IMultiSet<object> other) {
      var s = other as IMultiSet<T>;
      if (s != null) {
        return Equals(s);
      } else {
        return false;
      }
    }

    public override int GetHashCode() {
      var hashCode = 1;
      if (occurrencesOfNull > 0) {
        var key = Dafny.Helpers.GetHashCode(default(T));
        key = (key << 3) | (key >> 29) ^ occurrencesOfNull.GetHashCode();
        hashCode = hashCode * (key + 3);
      }
      foreach (var kv in dict) {
        var key = Dafny.Helpers.GetHashCode(kv.Key);
        key = (key << 3) | (key >> 29) ^ kv.Value.GetHashCode();
        hashCode = hashCode * (key + 3);
      }
      return hashCode;
    }
    public override string ToString() {
      var s = "multiset{";
      var sep = "";
      for (var i = BigInteger.Zero; i < occurrencesOfNull; i++) {
        s += sep + Dafny.Helpers.ToString(default(T));
        sep = ", ";
      }
      foreach (var kv in dict) {
        var t = Dafny.Helpers.ToString(kv.Key);
        for (var i = BigInteger.Zero; i < kv.Value; i++) {
          s += sep + t;
          sep = ", ";
        }
      }
      return s + "}";
    }
    public static bool IsProperSubsetOf(IMultiSet<T> th, IMultiSet<T> other) {
      return th.Count < other.Count && IsSubsetOf(th, other);
    }
    public static bool IsSubsetOf(IMultiSet<T> th, IMultiSet<T> other) {
      var a = FromIMultiSet(th);
      var b = FromIMultiSet(other);
      if (b.occurrencesOfNull < a.occurrencesOfNull) {
        return false;
      }
      foreach (T t in a.dict.Keys) {
        if (b.dict.ContainsKey(t)) {
          if (b.dict[t] < a.dict[t]) {
            return false;
          }
        } else {
          if (a.dict[t] != BigInteger.Zero) {
            return false;
          }
        }
      }
      return true;
    }
    public static bool IsDisjointFrom(IMultiSet<T> th, IMultiSet<T> other) {
      foreach (T t in th.UniqueElements) {
        if (other.Contains(t)) {
          return false;
        }
      }
      return true;
    }

    public bool Contains<G>(G t) {
      return Select(t) != 0;
    }
    public BigInteger Select<G>(G t) {
      if (t == null) {
        return occurrencesOfNull;
      }
      BigInteger m;
      if (t is T && dict.TryGetValue((T)(object)t, out m)) {
        return m;
      } else {
        return BigInteger.Zero;
      }
    }
    public IMultiSet<T> Update<G>(G t, BigInteger i) {
      if (Select(t) == i) {
        return this;
      } else if (t == null) {
        var r = dict.ToBuilder();
        return new MultiSet<T>(r, i);
      } else {
        var r = dict.ToBuilder();
        r[(T)(object)t] = i;
        return new MultiSet<T>(r, occurrencesOfNull);
      }
    }
    public static IMultiSet<T> Union(IMultiSet<T> th, IMultiSet<T> other) {
      if (th.IsEmpty) {
        return other;
      } else if (other.IsEmpty) {
        return th;
      }
      var a = FromIMultiSet(th);
      var b = FromIMultiSet(other);
      var r = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      foreach (T t in a.dict.Keys) {
        BigInteger i;
        if (!r.TryGetValue(t, out i)) {
          i = BigInteger.Zero;
        }
        r[t] = i + a.dict[t];
      }
      foreach (T t in b.dict.Keys) {
        BigInteger i;
        if (!r.TryGetValue(t, out i)) {
          i = BigInteger.Zero;
        }
        r[t] = i + b.dict[t];
      }
      return new MultiSet<T>(r, a.occurrencesOfNull + b.occurrencesOfNull);
    }
    public static IMultiSet<T> Intersect(IMultiSet<T> th, IMultiSet<T> other) {
      if (th.IsEmpty) {
        return th;
      } else if (other.IsEmpty) {
        return other;
      }
      var a = FromIMultiSet(th);
      var b = FromIMultiSet(other);
      var r = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      foreach (T t in a.dict.Keys) {
        if (b.dict.ContainsKey(t)) {
          r.Add(t, a.dict[t] < b.dict[t] ? a.dict[t] : b.dict[t]);
        }
      }
      return new MultiSet<T>(r, a.occurrencesOfNull < b.occurrencesOfNull ? a.occurrencesOfNull : b.occurrencesOfNull);
    }
    public static IMultiSet<T> Difference(IMultiSet<T> th, IMultiSet<T> other) { // \result == this - other
      if (other.IsEmpty) {
        return th;
      }
      var a = FromIMultiSet(th);
      var b = FromIMultiSet(other);
      var r = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      foreach (T t in a.dict.Keys) {
        if (!b.dict.ContainsKey(t)) {
          r.Add(t, a.dict[t]);
        } else if (b.dict[t] < a.dict[t]) {
          r.Add(t, a.dict[t] - b.dict[t]);
        }
      }
      return new MultiSet<T>(r, b.occurrencesOfNull < a.occurrencesOfNull ? a.occurrencesOfNull - b.occurrencesOfNull : BigInteger.Zero);
    }

    public bool IsEmpty { get { return occurrencesOfNull == 0 && dict.IsEmpty; } }

    public int Count {
      get { return (int)ElementCount(); }
    }
    public long LongCount {
      get { return (long)ElementCount(); }
    }
    private BigInteger ElementCount() {
      // This is inefficient
      var c = occurrencesOfNull;
      foreach (var item in dict) {
        c += item.Value;
      }
      return c;
    }

    public IEnumerable<T> Elements {
      get {
        for (var i = BigInteger.Zero; i < occurrencesOfNull; i++) {
          yield return default(T);
        }
        foreach (var item in dict) {
          for (var i = BigInteger.Zero; i < item.Value; i++) {
            yield return item.Key;
          }
        }
      }
    }

    public IEnumerable<T> UniqueElements {
      get {
        if (!occurrencesOfNull.IsZero) {
          yield return default(T);
        }
        foreach (var key in dict.Keys) {
          if (dict[key] != 0) {
            yield return key;
          }
        }
      }
    }
  }

  public interface IMap<out U, out V> {
    int Count { get; }
    long LongCount { get; }
    ISet<U> Keys { get; }
    ISet<V> Values { get; }
    IEnumerable<IPair<U, V>> ItemEnumerable { get; }
    bool Contains<G>(G t);
    /// <summary>
    /// Returns "true" iff "this is IMap<object, object>" and "this" equals "other".
    /// </summary>
    bool EqualsObjObj(IMap<object, object> other);
    IMap<UU, VV> DowncastClone<UU, VV>(Func<U, UU> keyConverter, Func<V, VV> valueConverter);
  }

  public class Map<U, V> : IMap<U, V> {
    readonly ImmutableDictionary<U, V> dict;
    readonly bool hasNullKey;  // true when "null" is a key of the Map
    readonly V nullValue;  // if "hasNullKey", the value that "null" maps to

    private Map(ImmutableDictionary<U, V>.Builder d, bool hasNullKey, V nullValue) {
      dict = d.ToImmutable();
      this.hasNullKey = hasNullKey;
      this.nullValue = nullValue;
    }
    public static readonly Map<U, V> Empty = new Map<U, V>(ImmutableDictionary<U, V>.Empty.ToBuilder(), false, default(V));

    private Map(ImmutableDictionary<U, V> d, bool hasNullKey, V nullValue) {
      dict = d;
      this.hasNullKey = hasNullKey;
      this.nullValue = nullValue;
    }

    private static readonly TypeDescriptor<IMap<U, V>> _TYPE = new Dafny.TypeDescriptor<IMap<U, V>>(Empty);
    public static TypeDescriptor<IMap<U, V>> _TypeDescriptor() {
      return _TYPE;
    }

    public static Map<U, V> FromElements(params IPair<U, V>[] values) {
      var d = ImmutableDictionary<U, V>.Empty.ToBuilder();
      var hasNullKey = false;
      var nullValue = default(V);
      foreach (var p in values) {
        if (p.Car == null) {
          hasNullKey = true;
          nullValue = p.Cdr;
        } else {
          d[p.Car] = p.Cdr;
        }
      }
      return new Map<U, V>(d, hasNullKey, nullValue);
    }
    public static Map<U, V> FromCollection(IEnumerable<IPair<U, V>> values) {
      var d = ImmutableDictionary<U, V>.Empty.ToBuilder();
      var hasNullKey = false;
      var nullValue = default(V);
      foreach (var p in values) {
        if (p.Car == null) {
          hasNullKey = true;
          nullValue = p.Cdr;
        } else {
          d[p.Car] = p.Cdr;
        }
      }
      return new Map<U, V>(d, hasNullKey, nullValue);
    }
    public static Map<U, V> FromIMap(IMap<U, V> m) {
      return m as Map<U, V> ?? FromCollection(m.ItemEnumerable);
    }
    public IMap<UU, VV> DowncastClone<UU, VV>(Func<U, UU> keyConverter, Func<V, VV> valueConverter) {
      if (this is IMap<UU, VV> th) {
        return th;
      } else {
        var d = ImmutableDictionary<UU, VV>.Empty.ToBuilder();
        foreach (var item in this.dict) {
          var k = keyConverter(item.Key);
          var v = valueConverter(item.Value);
          d.Add(k, v);
        }
        return new Map<UU, VV>(d, this.hasNullKey, (VV)(object)this.nullValue);
      }
    }
    public int Count {
      get { return dict.Count + (hasNullKey ? 1 : 0); }
    }
    public long LongCount {
      get { return dict.Count + (hasNullKey ? 1 : 0); }
    }

    public bool Equals(IMap<U, V> other) {
      if (ReferenceEquals(this, other)) {
        return true;
      }

      if (other == null || LongCount != other.LongCount) {
        return false;
      }

      if (hasNullKey) {
        if (!other.Contains(default(U)) || !object.Equals(nullValue, Select(other, default(U)))) {
          return false;
        }
      }

      foreach (var item in dict) {
        if (!other.Contains(item.Key) || !object.Equals(item.Value, Select(other, item.Key))) {
          return false;
        }
      }
      return true;
    }
    public bool EqualsObjObj(IMap<object, object> other) {
      if (ReferenceEquals(this, other)) {
        return true;
      }
      if (!(this is IMap<object, object>) || other == null || LongCount != other.LongCount) {
        return false;
      }
      var oth = Map<object, object>.FromIMap(other);
      if (hasNullKey) {
        if (!oth.Contains(default(U)) || !object.Equals(nullValue, Map<object, object>.Select(oth, default(U)))) {
          return false;
        }
      }
      foreach (var item in dict) {
        if (!other.Contains(item.Key) || !object.Equals(item.Value, Map<object, object>.Select(oth, item.Key))) {
          return false;
        }
      }
      return true;
    }
    public override bool Equals(object other) {
      // See comment in Set.Equals
      var m = other as IMap<U, V>;
      if (m != null) {
        return Equals(m);
      }
      var imapoo = other as IMap<object, object>;
      if (imapoo != null) {
        return EqualsObjObj(imapoo);
      } else {
        return false;
      }
    }

    public override int GetHashCode() {
      var hashCode = 1;
      if (hasNullKey) {
        var key = Dafny.Helpers.GetHashCode(default(U));
        key = (key << 3) | (key >> 29) ^ Dafny.Helpers.GetHashCode(nullValue);
        hashCode = hashCode * (key + 3);
      }
      foreach (var kv in dict) {
        var key = Dafny.Helpers.GetHashCode(kv.Key);
        key = (key << 3) | (key >> 29) ^ Dafny.Helpers.GetHashCode(kv.Value);
        hashCode = hashCode * (key + 3);
      }
      return hashCode;
    }
    public override string ToString() {
      var s = "map[";
      var sep = "";
      if (hasNullKey) {
        s += sep + Dafny.Helpers.ToString(default(U)) + " := " + Dafny.Helpers.ToString(nullValue);
        sep = ", ";
      }
      foreach (var kv in dict) {
        s += sep + Dafny.Helpers.ToString(kv.Key) + " := " + Dafny.Helpers.ToString(kv.Value);
        sep = ", ";
      }
      return s + "]";
    }
    public bool Contains<G>(G u) {
      return u == null ? hasNullKey : u is U && dict.ContainsKey((U)(object)u);
    }
    public static V Select(IMap<U, V> th, U index) {
      // the following will throw an exception if "index" in not a key of the map
      var m = FromIMap(th);
      return index == null && m.hasNullKey ? m.nullValue : m.dict[index];
    }
    public static IMap<U, V> Update(IMap<U, V> th, U index, V val) {
      var m = FromIMap(th);
      var d = m.dict.ToBuilder();
      if (index == null) {
        return new Map<U, V>(d, true, val);
      } else {
        d[index] = val;
        return new Map<U, V>(d, m.hasNullKey, m.nullValue);
      }
    }

    public static IMap<U, V> Merge(IMap<U, V> th, IMap<U, V> other) {
      var a = FromIMap(th);
      var b = FromIMap(other);
      ImmutableDictionary<U, V> d = a.dict.SetItems(b.dict);
      return new Map<U, V>(d, a.hasNullKey || b.hasNullKey, b.hasNullKey ? b.nullValue : a.nullValue);
    }

    public static IMap<U, V> Subtract(IMap<U, V> th, ISet<U> keys) {
      var a = FromIMap(th);
      ImmutableDictionary<U, V> d = a.dict.RemoveRange(keys.Elements);
      return new Map<U, V>(d, a.hasNullKey && !keys.Contains<object>(null), a.nullValue);
    }

    public ISet<U> Keys {
      get {
        if (hasNullKey) {
          return Dafny.Set<U>.FromCollectionPlusOne(dict.Keys, default(U));
        } else {
          return Dafny.Set<U>.FromCollection(dict.Keys);
        }
      }
    }
    public ISet<V> Values {
      get {
        if (hasNullKey) {
          return Dafny.Set<V>.FromCollectionPlusOne(dict.Values, nullValue);
        } else {
          return Dafny.Set<V>.FromCollection(dict.Values);
        }
      }
    }

    public IEnumerable<IPair<U, V>> ItemEnumerable {
      get {
        if (hasNullKey) {
          yield return new Pair<U, V>(default(U), nullValue);
        }
        foreach (KeyValuePair<U, V> kvp in dict) {
          yield return new Pair<U, V>(kvp.Key, kvp.Value);
        }
      }
    }

    public static ISet<_System._ITuple2<U, V>> Items(IMap<U, V> m) {
      var result = new HashSet<_System._ITuple2<U, V>>();
      foreach (var item in m.ItemEnumerable) {
        result.Add(_System.Tuple2<U, V>.create(item.Car, item.Cdr));
      }
      return Dafny.Set<_System._ITuple2<U, V>>.FromCollection(result);
    }
  }

  public interface ISequence<out T> : IEnumerable<T> {
    long LongCount { get; }
    int Count { get; }
    [Obsolete("Use CloneAsArray() instead of Elements (both perform a copy).")]
    T[] Elements { get; }
    T[] CloneAsArray();
    IEnumerable<T> UniqueElements { get; }
    T Select(ulong index);
    T Select(long index);
    T Select(uint index);
    T Select(int index);
    T Select(BigInteger index);
    bool Contains<G>(G g);
    ISequence<T> Take(long m);
    ISequence<T> Take(ulong n);
    ISequence<T> Take(BigInteger n);
    ISequence<T> Drop(long m);
    ISequence<T> Drop(ulong n);
    ISequence<T> Drop(BigInteger n);
    ISequence<T> Subsequence(long lo, long hi);
    ISequence<T> Subsequence(long lo, ulong hi);
    ISequence<T> Subsequence(long lo, BigInteger hi);
    ISequence<T> Subsequence(ulong lo, long hi);
    ISequence<T> Subsequence(ulong lo, ulong hi);
    ISequence<T> Subsequence(ulong lo, BigInteger hi);
    ISequence<T> Subsequence(BigInteger lo, long hi);
    ISequence<T> Subsequence(BigInteger lo, ulong hi);
    ISequence<T> Subsequence(BigInteger lo, BigInteger hi);
    bool EqualsAux(ISequence<object> other);
    ISequence<U> DowncastClone<U>(Func<T, U> converter);
    string ToVerbatimString(bool asLiteral);
  }

  public abstract class Sequence<T> : ISequence<T> {
    public static readonly ISequence<T> Empty = new ArraySequence<T>(new T[0]);

    private static readonly TypeDescriptor<ISequence<T>> _TYPE = new Dafny.TypeDescriptor<ISequence<T>>(Empty);
    public static TypeDescriptor<ISequence<T>> _TypeDescriptor() {
      return _TYPE;
    }

    public static ISequence<T> Create(BigInteger length, System.Func<BigInteger, T> init) {
      var len = (int)length;
      var builder = ImmutableArray.CreateBuilder<T>(len);
      for (int i = 0; i < len; i++) {
        builder.Add(init(new BigInteger(i)));
      }
      return new ArraySequence<T>(builder.MoveToImmutable());
    }
    public static ISequence<T> FromArray(T[] values) {
      return new ArraySequence<T>(values);
    }
    public static ISequence<T> FromElements(params T[] values) {
      return new ArraySequence<T>(values);
    }
    public static ISequence<char> FromString(string s) {
      return new ArraySequence<char>(s.ToCharArray());
    }
    public static ISequence<Rune> UnicodeFromString(string s) {
      var runes = new List<Rune>();

      foreach (var rune in Rune.Enumerate(s)) {
        runes.Add(rune);
      }
      return new ArraySequence<Rune>(runes.ToArray());
    }

    public static ISequence<ISequence<char>> FromMainArguments(string[] args) {
      Dafny.ISequence<char>[] dafnyArgs = new Dafny.ISequence<char>[args.Length + 1];
      dafnyArgs[0] = Dafny.Sequence<char>.FromString("dotnet");
      for (var i = 0; i < args.Length; i++) {
        dafnyArgs[i + 1] = Dafny.Sequence<char>.FromString(args[i]);
      }

      return Sequence<ISequence<char>>.FromArray(dafnyArgs);
    }
    public static ISequence<ISequence<Rune>> UnicodeFromMainArguments(string[] args) {
      Dafny.ISequence<Rune>[] dafnyArgs = new Dafny.ISequence<Rune>[args.Length + 1];
      dafnyArgs[0] = Dafny.Sequence<Rune>.UnicodeFromString("dotnet");
      for (var i = 0; i < args.Length; i++) {
        dafnyArgs[i + 1] = Dafny.Sequence<Rune>.UnicodeFromString(args[i]);
      }

      return Sequence<ISequence<Rune>>.FromArray(dafnyArgs);
    }

    public ISequence<U> DowncastClone<U>(Func<T, U> converter) {
      if (this is ISequence<U> th) {
        return th;
      } else {
        var values = new U[this.LongCount];
        for (long i = 0; i < this.LongCount; i++) {
          var val = converter(this.Select(i));
          values[i] = val;
        }
        return new ArraySequence<U>(values);
      }
    }
    public static ISequence<T> Update(ISequence<T> sequence, long index, T t) {
      T[] tmp = sequence.CloneAsArray();
      tmp[index] = t;
      return new ArraySequence<T>(tmp);
    }
    public static ISequence<T> Update(ISequence<T> sequence, ulong index, T t) {
      return Update(sequence, (long)index, t);
    }
    public static ISequence<T> Update(ISequence<T> sequence, BigInteger index, T t) {
      return Update(sequence, (long)index, t);
    }
    public static bool EqualUntil(ISequence<T> left, ISequence<T> right, int n) {
      for (int i = 0; i < n; i++) {
        if (!Equals(left.Select(i), right.Select(i))) {
          return false;
        }
      }
      return true;
    }
    public static bool IsPrefixOf(ISequence<T> left, ISequence<T> right) {
      int n = left.Count;
      return n <= right.Count && EqualUntil(left, right, n);
    }
    public static bool IsProperPrefixOf(ISequence<T> left, ISequence<T> right) {
      int n = left.Count;
      return n < right.Count && EqualUntil(left, right, n);
    }
    public static ISequence<T> Concat(ISequence<T> left, ISequence<T> right) {
      if (left.Count == 0) {
        return right;
      }
      if (right.Count == 0) {
        return left;
      }
      return new ConcatSequence<T>(left, right);
    }
    // Make Count a public abstract instead of LongCount, since the "array size is limited to a total of 4 billion
    // elements, and to a maximum index of 0X7FEFFFFF". Therefore, as a protection, limit this to int32.
    // https://docs.microsoft.com/en-us/dotnet/api/system.array
    public abstract int Count { get; }
    public long LongCount {
      get { return Count; }
    }
    // ImmutableElements cannot be public in the interface since ImmutableArray<T> leads to a
    // "covariant type T occurs in invariant position" error. There do not appear to be interfaces for ImmutableArray<T>
    // that resolve this.
    internal abstract ImmutableArray<T> ImmutableElements { get; }

    public T[] Elements { get { return CloneAsArray(); } }

    public T[] CloneAsArray() {
      return ImmutableElements.ToArray();
    }

    public IEnumerable<T> UniqueElements {
      get {
        return Set<T>.FromCollection(ImmutableElements).Elements;
      }
    }

    public IEnumerator<T> GetEnumerator() {
      foreach (var el in ImmutableElements) {
        yield return el;
      }
    }

    IEnumerator IEnumerable.GetEnumerator() {
      return GetEnumerator();
    }

    public T Select(ulong index) {
      return ImmutableElements[checked((int)index)];
    }
    public T Select(long index) {
      return ImmutableElements[checked((int)index)];
    }
    public T Select(uint index) {
      return ImmutableElements[checked((int)index)];
    }
    public T Select(int index) {
      return ImmutableElements[index];
    }
    public T Select(BigInteger index) {
      return ImmutableElements[(int)index];
    }
    public bool Equals(ISequence<T> other) {
      return ReferenceEquals(this, other) || (Count == other.Count && EqualUntil(this, other, Count));
    }
    public override bool Equals(object other) {
      if (other is ISequence<T>) {
        return Equals((ISequence<T>)other);
      }
      var th = this as ISequence<object>;
      var oth = other as ISequence<object>;
      if (th != null && oth != null) {
        // see explanation in Set.Equals
        return oth.EqualsAux(th);
      } else {
        return false;
      }
    }
    public bool EqualsAux(ISequence<object> other) {
      var s = other as ISequence<T>;
      if (s != null) {
        return Equals(s);
      } else {
        return false;
      }
    }
    public override int GetHashCode() {
      ImmutableArray<T> elmts = ImmutableElements;
      // https://devblogs.microsoft.com/dotnet/please-welcome-immutablearrayt/
      if (elmts.IsDefaultOrEmpty) {
        return 0;
      }

      var hashCode = 0;
      for (var i = 0; i < elmts.Length; i++) {
        hashCode = (hashCode << 3) | (hashCode >> 29) ^ Dafny.Helpers.GetHashCode(elmts[i]);
      }
      return hashCode;
    }
    public override string ToString() {
      if (typeof(T) == typeof(char)) {
        return string.Concat(this);
      } else {
        return "[" + string.Join(", ", ImmutableElements.Select(Dafny.Helpers.ToString)) + "]";
      }
    }

    public string ToVerbatimString(bool asLiteral) {
      var builder = new System.Text.StringBuilder();
      if (asLiteral) {
        builder.Append('"');
      }
      foreach (var c in this) {
        var rune = (Rune)(object)c;
        if (asLiteral) {
          builder.Append(Helpers.EscapeCharacter(rune));
        } else {
          builder.Append(char.ConvertFromUtf32(rune.Value));
        }
      }
      if (asLiteral) {
        builder.Append('"');
      }
      return builder.ToString();
    }

    public bool Contains<G>(G g) {
      if (g == null || g is T) {
        var t = (T)(object)g;
        return ImmutableElements.Contains(t);
      }
      return false;
    }
    public ISequence<T> Take(long m) {
      return Subsequence(0, m);
    }
    public ISequence<T> Take(ulong n) {
      return Take((long)n);
    }
    public ISequence<T> Take(BigInteger n) {
      return Take((long)n);
    }
    public ISequence<T> Drop(long m) {
      return Subsequence(m, Count);
    }
    public ISequence<T> Drop(ulong n) {
      return Drop((long)n);
    }
    public ISequence<T> Drop(BigInteger n) {
      return Drop((long)n);
    }
    public ISequence<T> Subsequence(long lo, long hi) {
      if (lo == 0 && hi == Count) {
        return this;
      }
      int startingIndex = checked((int)lo);
      var length = checked((int)hi) - startingIndex;
      return new ArraySequence<T>(ImmutableArray.Create<T>(ImmutableElements, startingIndex, length));
    }
    public ISequence<T> Subsequence(long lo, ulong hi) {
      return Subsequence(lo, (long)hi);
    }
    public ISequence<T> Subsequence(long lo, BigInteger hi) {
      return Subsequence(lo, (long)hi);
    }
    public ISequence<T> Subsequence(ulong lo, long hi) {
      return Subsequence((long)lo, hi);
    }
    public ISequence<T> Subsequence(ulong lo, ulong hi) {
      return Subsequence((long)lo, (long)hi);
    }
    public ISequence<T> Subsequence(ulong lo, BigInteger hi) {
      return Subsequence((long)lo, (long)hi);
    }
    public ISequence<T> Subsequence(BigInteger lo, long hi) {
      return Subsequence((long)lo, hi);
    }
    public ISequence<T> Subsequence(BigInteger lo, ulong hi) {
      return Subsequence((long)lo, (long)hi);
    }
    public ISequence<T> Subsequence(BigInteger lo, BigInteger hi) {
      return Subsequence((long)lo, (long)hi);
    }
  }

  internal class ArraySequence<T> : Sequence<T> {
    private readonly ImmutableArray<T> elmts;

    internal ArraySequence(ImmutableArray<T> ee) {
      elmts = ee;
    }
    internal ArraySequence(T[] ee) {
      elmts = ImmutableArray.Create<T>(ee);
    }

    internal override ImmutableArray<T> ImmutableElements {
      get {
        return elmts;
      }
    }

    public override int Count {
      get {
        return elmts.Length;
      }
    }
  }

  internal class ConcatSequence<T> : Sequence<T> {
    // INVARIANT: Either left != null, right != null, and elmts's underlying array == null or
    // left == null, right == null, and elmts's underlying array != null
    private volatile ISequence<T> left, right;
    private ImmutableArray<T> elmts;
    private readonly int count;

    internal ConcatSequence(ISequence<T> left, ISequence<T> right) {
      this.left = left;
      this.right = right;
      this.count = left.Count + right.Count;
    }

    internal override ImmutableArray<T> ImmutableElements {
      get {
        // IsDefault returns true if the underlying array is a null reference
        // https://devblogs.microsoft.com/dotnet/please-welcome-immutablearrayt/
        if (elmts.IsDefault) {
          elmts = ComputeElements();
          // We don't need the original sequences anymore; let them be
          // garbage-collected
          left = null;
          right = null;
        }
        return elmts;
      }
    }

    public override int Count {
      get {
        return count;
      }
    }

    private ImmutableArray<T> ComputeElements() {
      // Traverse the tree formed by all descendants which are ConcatSequences
      var ansBuilder = ImmutableArray.CreateBuilder<T>(count);
      var toVisit = new Stack<ISequence<T>>();
      var leftBuffer = left;
      var rightBuffer = right;
      if (left == null || right == null) {
        // elmts can't be .IsDefault while either left, or right are null
        return elmts;
      }
      toVisit.Push(rightBuffer);
      toVisit.Push(leftBuffer);

      while (toVisit.Count != 0) {
        var seq = toVisit.Pop();
        if (seq is ConcatSequence<T> cs && cs.elmts.IsDefault) {
          leftBuffer = cs.left;
          rightBuffer = cs.right;
          if (cs.left == null || cs.right == null) {
            // !cs.elmts.IsDefault, due to concurrent enumeration
            toVisit.Push(cs);
          } else {
            toVisit.Push(rightBuffer);
            toVisit.Push(leftBuffer);
          }
        } else {
          if (seq is Sequence<T> sq) {
            ansBuilder.AddRange(sq.ImmutableElements); // Optimized path for ImmutableArray
          } else {
            ansBuilder.AddRange(seq); // Slower path using IEnumerable
          }
        }
      }
      return ansBuilder.MoveToImmutable();
    }
  }

  public interface IPair<out A, out B> {
    A Car { get; }
    B Cdr { get; }
  }

  public class Pair<A, B> : IPair<A, B> {
    private A car;
    private B cdr;
    public A Car { get { return car; } }
    public B Cdr { get { return cdr; } }
    public Pair(A a, B b) {
      this.car = a;
      this.cdr = b;
    }
  }

  public class TypeDescriptor<T> {
    private readonly T initValue;
    public TypeDescriptor(T initValue) {
      this.initValue = initValue;
    }
    public T Default() {
      return initValue;
    }
  }

  public partial class Helpers {
    public static int GetHashCode<G>(G g) {
      return g == null ? 1001 : g.GetHashCode();
    }

    public static int ToIntChecked(BigInteger i, string msg) {
      if (i > Int32.MaxValue || i < Int32.MinValue) {
        if (msg == null) {
          msg = "value out of range for a 32-bit int";
        }

        throw new HaltException(msg + ": " + i);
      }
      return (int)i;
    }
    public static int ToIntChecked(long i, string msg) {
      if (i > Int32.MaxValue || i < Int32.MinValue) {
        if (msg == null) {
          msg = "value out of range for a 32-bit int";
        }

        throw new HaltException(msg + ": " + i);
      }
      return (int)i;
    }
    public static int ToIntChecked(int i, string msg) {
      return i;
    }

    public static string ToString<G>(G g) {
      if (g == null) {
        return "null";
      } else if (g is bool) {
        return (bool)(object)g ? "true" : "false";  // capitalize boolean literals like in Dafny
      } else if (g is Rune) {
        return "'" + EscapeCharacter((Rune)(object)g) + "'";
      } else {
        return g.ToString();
      }
    }

    public static string EscapeCharacter(Rune r) {
      switch (r.Value) {
        case '\n': return "\\n";
        case '\r': return "\\r";
        case '\t': return "\\t";
        case '\0': return "\\0";
        case '\'': return "\\'";
        case '\"': return "\\\"";
        case '\\': return "\\\\";
        default: return r.ToString();
      };
    }

    public static void Print<G>(G g) {
      System.Console.Write(ToString(g));
    }

    public static readonly TypeDescriptor<bool> BOOL = new TypeDescriptor<bool>(false);
    public static readonly TypeDescriptor<char> CHAR = new TypeDescriptor<char>('D');  // See CharType.DefaultValue in Dafny source code
    public static readonly TypeDescriptor<Rune> RUNE = new TypeDescriptor<Rune>(new Rune('D'));  // See CharType.DefaultValue in Dafny source code
    public static readonly TypeDescriptor<BigInteger> INT = new TypeDescriptor<BigInteger>(BigInteger.Zero);
    public static readonly TypeDescriptor<BigRational> REAL = new TypeDescriptor<BigRational>(BigRational.ZERO);
    public static readonly TypeDescriptor<byte> UINT8 = new TypeDescriptor<byte>(0);
    public static readonly TypeDescriptor<ushort> UINT16 = new TypeDescriptor<ushort>(0);
    public static readonly TypeDescriptor<uint> UINT32 = new TypeDescriptor<uint>(0);
    public static readonly TypeDescriptor<ulong> UINT64 = new TypeDescriptor<ulong>(0);

    public static TypeDescriptor<T> NULL<T>() where T : class {
      return new TypeDescriptor<T>(null);
    }

    public static TypeDescriptor<A[]> ARRAY<A>() {
      return new TypeDescriptor<A[]>(new A[0]);
    }

    public static bool Quantifier<T>(IEnumerable<T> vals, bool frall, System.Predicate<T> pred) {
      foreach (var u in vals) {
        if (pred(u) != frall) { return !frall; }
      }
      return frall;
    }
    // Enumerating other collections
    public static IEnumerable<bool> AllBooleans() {
      yield return false;
      yield return true;
    }
    public static IEnumerable<char> AllChars() {
      for (int i = 0; i < 0x1_0000; i++) {
        yield return (char)i;
      }
    }
    public static IEnumerable<Rune> AllUnicodeChars() {
      for (int i = 0; i < 0xD800; i++) {
        yield return new Rune(i);
      }
      for (int i = 0xE000; i < 0x11_0000; i++) {
        yield return new Rune(i);
      }
    }
    public static IEnumerable<BigInteger> AllIntegers() {
      yield return new BigInteger(0);
      for (var j = new BigInteger(1); ; j++) {
        yield return j;
        yield return -j;
      }
    }
    public static IEnumerable<BigInteger> IntegerRange(Nullable<BigInteger> lo, Nullable<BigInteger> hi) {
      if (lo == null) {
        for (var j = (BigInteger)hi; true;) {
          j--;
          yield return j;
        }
      } else if (hi == null) {
        for (var j = (BigInteger)lo; true; j++) {
          yield return j;
        }
      } else {
        for (var j = (BigInteger)lo; j < hi; j++) {
          yield return j;
        }
      }
    }
    public static IEnumerable<T> SingleValue<T>(T e) {
      yield return e;
    }
    // pre: b != 0
    // post: result == a/b, as defined by Euclidean Division (http://en.wikipedia.org/wiki/Modulo_operation)
    public static sbyte EuclideanDivision_sbyte(sbyte a, sbyte b) {
      return (sbyte)EuclideanDivision_int(a, b);
    }
    public static short EuclideanDivision_short(short a, short b) {
      return (short)EuclideanDivision_int(a, b);
    }
    public static int EuclideanDivision_int(int a, int b) {
      if (0 <= a) {
        if (0 <= b) {
          // +a +b: a/b
          return (int)(((uint)(a)) / ((uint)(b)));
        } else {
          // +a -b: -(a/(-b))
          return -((int)(((uint)(a)) / ((uint)(unchecked(-b)))));
        }
      } else {
        if (0 <= b) {
          // -a +b: -((-a-1)/b) - 1
          return -((int)(((uint)(-(a + 1))) / ((uint)(b)))) - 1;
        } else {
          // -a -b: ((-a-1)/(-b)) + 1
          return ((int)(((uint)(-(a + 1))) / ((uint)(unchecked(-b))))) + 1;
        }
      }
    }
    public static long EuclideanDivision_long(long a, long b) {
      if (0 <= a) {
        if (0 <= b) {
          // +a +b: a/b
          return (long)(((ulong)(a)) / ((ulong)(b)));
        } else {
          // +a -b: -(a/(-b))
          return -((long)(((ulong)(a)) / ((ulong)(unchecked(-b)))));
        }
      } else {
        if (0 <= b) {
          // -a +b: -((-a-1)/b) - 1
          return -((long)(((ulong)(-(a + 1))) / ((ulong)(b)))) - 1;
        } else {
          // -a -b: ((-a-1)/(-b)) + 1
          return ((long)(((ulong)(-(a + 1))) / ((ulong)(unchecked(-b))))) + 1;
        }
      }
    }
    public static BigInteger EuclideanDivision(BigInteger a, BigInteger b) {
      if (0 <= a.Sign) {
        if (0 <= b.Sign) {
          // +a +b: a/b
          return BigInteger.Divide(a, b);
        } else {
          // +a -b: -(a/(-b))
          return BigInteger.Negate(BigInteger.Divide(a, BigInteger.Negate(b)));
        }
      } else {
        if (0 <= b.Sign) {
          // -a +b: -((-a-1)/b) - 1
          return BigInteger.Negate(BigInteger.Divide(BigInteger.Negate(a) - 1, b)) - 1;
        } else {
          // -a -b: ((-a-1)/(-b)) + 1
          return BigInteger.Divide(BigInteger.Negate(a) - 1, BigInteger.Negate(b)) + 1;
        }
      }
    }
    // pre: b != 0
    // post: result == a%b, as defined by Euclidean Division (http://en.wikipedia.org/wiki/Modulo_operation)
    public static sbyte EuclideanModulus_sbyte(sbyte a, sbyte b) {
      return (sbyte)EuclideanModulus_int(a, b);
    }
    public static short EuclideanModulus_short(short a, short b) {
      return (short)EuclideanModulus_int(a, b);
    }
    public static int EuclideanModulus_int(int a, int b) {
      uint bp = (0 <= b) ? (uint)b : (uint)(unchecked(-b));
      if (0 <= a) {
        // +a: a % b'
        return (int)(((uint)a) % bp);
      } else {
        // c = ((-a) % b')
        // -a: b' - c if c > 0
        // -a: 0 if c == 0
        uint c = ((uint)(unchecked(-a))) % bp;
        return (int)(c == 0 ? c : bp - c);
      }
    }
    public static long EuclideanModulus_long(long a, long b) {
      ulong bp = (0 <= b) ? (ulong)b : (ulong)(unchecked(-b));
      if (0 <= a) {
        // +a: a % b'
        return (long)(((ulong)a) % bp);
      } else {
        // c = ((-a) % b')
        // -a: b' - c if c > 0
        // -a: 0 if c == 0
        ulong c = ((ulong)(unchecked(-a))) % bp;
        return (long)(c == 0 ? c : bp - c);
      }
    }
    public static BigInteger EuclideanModulus(BigInteger a, BigInteger b) {
      var bp = BigInteger.Abs(b);
      if (0 <= a.Sign) {
        // +a: a % b'
        return BigInteger.Remainder(a, bp);
      } else {
        // c = ((-a) % b')
        // -a: b' - c if c > 0
        // -a: 0 if c == 0
        var c = BigInteger.Remainder(BigInteger.Negate(a), bp);
        return c.IsZero ? c : BigInteger.Subtract(bp, c);
      }
    }

    public static U CastConverter<T, U>(T t) {
      return (U)(object)t;
    }

    public static Sequence<T> SeqFromArray<T>(T[] array) {
      return new ArraySequence<T>(array);
    }
    // In .NET version 4.5, it is possible to mark a method with "AggressiveInlining", which says to inline the
    // method if possible.  Method "ExpressionSequence" would be a good candidate for it:
    // [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    public static U ExpressionSequence<T, U>(T t, U u) {
      return u;
    }

    public static U Let<T, U>(T t, Func<T, U> f) {
      return f(t);
    }

    public static A Id<A>(A a) {
      return a;
    }

    public static void WithHaltHandling(Action action) {
      try {
        action();
      } catch (HaltException e) {
        Console.WriteLine("[Program halted] " + e.Message);
        // This is unfriendly given that Dafny's C# compiler will
        // invoke the compiled main method directly,
        // so we might be exiting the whole Dafny process here.
        // That's the best we can do until Dafny main methods support
        // a return value though (https://github.com/dafny-lang/dafny/issues/2699).
        // If we just set Environment.ExitCode here, the Dafny CLI
        // will just override that with 0.
        Environment.Exit(1);
      }
    }

    public static Rune AddRunes(Rune left, Rune right) {
      return (Rune)(left.Value + right.Value);
    }

    public static Rune SubtractRunes(Rune left, Rune right) {
      return (Rune)(left.Value - right.Value);
    }
  }

  public class BigOrdinal {
    public static bool IsLimit(BigInteger ord) {
      return ord == 0;
    }
    public static bool IsSucc(BigInteger ord) {
      return 0 < ord;
    }
    public static BigInteger Offset(BigInteger ord) {
      return ord;
    }
    public static bool IsNat(BigInteger ord) {
      return true;  // at run time, every ORDINAL is a natural number
    }
  }

  public struct BigRational {
    public static readonly BigRational ZERO = new BigRational(0);

    // We need to deal with the special case "num == 0 && den == 0", because
    // that's what C#'s default struct constructor will produce for BigRational. :(
    // To deal with it, we ignore "den" when "num" is 0.
    public readonly BigInteger num, den;  // invariant 1 <= den || (num == 0 && den == 0)

    public override string ToString() {
      int log10;
      if (num.IsZero || den.IsOne) {
        return string.Format("{0}.0", num);
      } else if (IsPowerOf10(den, out log10)) {
        string sign;
        string digits;
        if (num.Sign < 0) {
          sign = "-"; digits = (-num).ToString();
        } else {
          sign = ""; digits = num.ToString();
        }
        if (log10 < digits.Length) {
          var n = digits.Length - log10;
          return string.Format("{0}{1}.{2}", sign, digits.Substring(0, n), digits.Substring(n));
        } else {
          return string.Format("{0}0.{1}{2}", sign, new string('0', log10 - digits.Length), digits);
        }
      } else {
        return string.Format("({0}.0 / {1}.0)", num, den);
      }
    }
    public bool IsPowerOf10(BigInteger x, out int log10) {
      log10 = 0;
      if (x.IsZero) {
        return false;
      }
      while (true) {  // invariant: x != 0 && x * 10^log10 == old(x)
        if (x.IsOne) {
          return true;
        } else if (x % 10 == 0) {
          log10++;
          x /= 10;
        } else {
          return false;
        }
      }
    }
    public BigRational(int n) {
      num = new BigInteger(n);
      den = BigInteger.One;
    }
    public BigRational(uint n) {
      num = new BigInteger(n);
      den = BigInteger.One;
    }
    public BigRational(long n) {
      num = new BigInteger(n);
      den = BigInteger.One;
    }
    public BigRational(ulong n) {
      num = new BigInteger(n);
      den = BigInteger.One;
    }
    public BigRational(BigInteger n, BigInteger d) {
      // requires 1 <= d
      num = n;
      den = d;
    }
    /// <summary>
    /// Construct an exact rational representation of a double value.
    /// Throw an exception on NaN or infinite values. Does not support
    /// subnormal values, though it would be possible to extend it to.
    /// </summary>
    public BigRational(double n) {
      if (Double.IsNaN(n)) {
        throw new ArgumentException("Can't convert NaN to a rational.");
      }
      if (Double.IsInfinity(n)) {
        throw new ArgumentException(
          "Can't convert +/- infinity to a rational.");
      }

      // Double-specific values
      const int exptBias = 1023;
      const ulong signMask = 0x8000000000000000;
      const ulong exptMask = 0x7FF0000000000000;
      const ulong mantMask = 0x000FFFFFFFFFFFFF;
      const int mantBits = 52;
      ulong bits = BitConverter.ToUInt64(BitConverter.GetBytes(n), 0);

      // Generic conversion
      bool isNeg = (bits & signMask) != 0;
      int expt = ((int)((bits & exptMask) >> mantBits)) - exptBias;
      var mant = (bits & mantMask);

      if (expt == -exptBias && mant != 0) {
        throw new ArgumentException(
          "Can't convert a subnormal value to a rational (yet).");
      }

      var one = BigInteger.One;
      var negFactor = isNeg ? BigInteger.Negate(one) : one;
      var two = new BigInteger(2);
      var exptBI = BigInteger.Pow(two, Math.Abs(expt));
      var twoToMantBits = BigInteger.Pow(two, mantBits);
      var mantNum = negFactor * (twoToMantBits + new BigInteger(mant));
      if (expt == -exptBias && mant == 0) {
        num = den = 0;
      } else if (expt < 0) {
        num = mantNum;
        den = twoToMantBits * exptBI;
      } else {
        num = exptBI * mantNum;
        den = twoToMantBits;
      }
    }
    public BigInteger ToBigInteger() {
      if (num.IsZero || den.IsOne) {
        return num;
      } else if (0 < num.Sign) {
        return num / den;
      } else {
        return (num - den + 1) / den;
      }
    }
    /// <summary>
    /// Returns values such that aa/dd == a and bb/dd == b.
    /// </summary>
    private static void Normalize(BigRational a, BigRational b, out BigInteger aa, out BigInteger bb, out BigInteger dd) {
      if (a.num.IsZero) {
        aa = a.num;
        bb = b.num;
        dd = b.den;
      } else if (b.num.IsZero) {
        aa = a.num;
        dd = a.den;
        bb = b.num;
      } else {
        var gcd = BigInteger.GreatestCommonDivisor(a.den, b.den);
        var xx = a.den / gcd;
        var yy = b.den / gcd;
        // We now have a == a.num / (xx * gcd) and b == b.num / (yy * gcd).
        aa = a.num * yy;
        bb = b.num * xx;
        dd = a.den * yy;
      }
    }
    public int CompareTo(BigRational that) {
      // simple things first
      int asign = this.num.Sign;
      int bsign = that.num.Sign;
      if (asign < 0 && 0 <= bsign) {
        return -1;
      } else if (asign <= 0 && 0 < bsign) {
        return -1;
      } else if (bsign < 0 && 0 <= asign) {
        return 1;
      } else if (bsign <= 0 && 0 < asign) {
        return 1;
      }
      BigInteger aa, bb, dd;
      Normalize(this, that, out aa, out bb, out dd);
      return aa.CompareTo(bb);
    }
    public int Sign {
      get {
        return num.Sign;
      }
    }
    public override int GetHashCode() {
      return num.GetHashCode() + 29 * den.GetHashCode();
    }
    public override bool Equals(object obj) {
      if (obj is BigRational) {
        return this == (BigRational)obj;
      } else {
        return false;
      }
    }
    public static bool operator ==(BigRational a, BigRational b) {
      return a.CompareTo(b) == 0;
    }
    public static bool operator !=(BigRational a, BigRational b) {
      return a.CompareTo(b) != 0;
    }
    public static bool operator >(BigRational a, BigRational b) {
      return a.CompareTo(b) > 0;
    }
    public static bool operator >=(BigRational a, BigRational b) {
      return a.CompareTo(b) >= 0;
    }
    public static bool operator <(BigRational a, BigRational b) {
      return a.CompareTo(b) < 0;
    }
    public static bool operator <=(BigRational a, BigRational b) {
      return a.CompareTo(b) <= 0;
    }
    public static BigRational operator +(BigRational a, BigRational b) {
      BigInteger aa, bb, dd;
      Normalize(a, b, out aa, out bb, out dd);
      return new BigRational(aa + bb, dd);
    }
    public static BigRational operator -(BigRational a, BigRational b) {
      BigInteger aa, bb, dd;
      Normalize(a, b, out aa, out bb, out dd);
      return new BigRational(aa - bb, dd);
    }
    public static BigRational operator -(BigRational a) {
      return new BigRational(-a.num, a.den);
    }
    public static BigRational operator *(BigRational a, BigRational b) {
      return new BigRational(a.num * b.num, a.den * b.den);
    }
    public static BigRational operator /(BigRational a, BigRational b) {
      // Compute the reciprocal of b
      BigRational bReciprocal;
      if (0 < b.num.Sign) {
        bReciprocal = new BigRational(b.den, b.num);
      } else {
        // this is the case b.num < 0
        bReciprocal = new BigRational(-b.den, -b.num);
      }
      return a * bReciprocal;
    }
  }

  public class HaltException : Exception {
    public HaltException(object message) : base(message.ToString()) {
    }
  }
}

namespace @_System {

  public interface _ITuple0 {
    _ITuple0 DowncastClone();
  }
  public class Tuple0 : _ITuple0 {
    public Tuple0() {
    }
    public _ITuple0 DowncastClone() {
      if (this is _ITuple0 dt) { return dt; }
      return new Tuple0();
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple0;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += ")";
      return s;
    }
    private static readonly _ITuple0 theDefault = create();
    public static _ITuple0 Default() {
      return theDefault;
    }
    public static Dafny.TypeDescriptor<_System._ITuple0> _TypeDescriptor() {
      return new Dafny.TypeDescriptor<_System._ITuple0>(_System.Tuple0.Default());
    }
    public static _ITuple0 create() {
      return new Tuple0();
    }
  }

  public interface _ITuple1<out T1> {
    T1 dtor__0 { get; }
    _ITuple1<__T1> DowncastClone<__T1>(Func<T1, __T1> converter0);
  }
  public class Tuple1<T1> : _ITuple1<T1> {
    public readonly T1 _0;
    public Tuple1(T1 _0) {
      this._0 = _0;
    }
    public _ITuple1<__T1> DowncastClone<__T1>(Func<T1, __T1> converter0) {
      if (this is _ITuple1<__T1> dt) { return dt; }
      return new Tuple1<__T1>(converter0(_0));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple1<T1>;
      return oth != null && object.Equals(this._0, oth._0);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ")";
      return s;
    }
    public static _ITuple1<T1> Default(T1 _default_T1) {
      return create(_default_T1);
    }
    public static Dafny.TypeDescriptor<_System._ITuple1<T1>> _TypeDescriptor(Dafny.TypeDescriptor<T1> _td_T1) {
      return new Dafny.TypeDescriptor<_System._ITuple1<T1>>(_System.Tuple1<T1>.Default(_td_T1.Default()));
    }
    public static _ITuple1<T1> create(T1 _0) {
      return new Tuple1<T1>(_0);
    }
    public T1 dtor__0 {
      get {
        return this._0;
      }
    }
  }

  public interface _ITuple2<out T0, out T1> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
  }

  public class Tuple2<T0, T1> : _ITuple2<T0, T1> {
    public readonly T0 _0;
    public readonly T1 _1;
    public Tuple2(T0 _0, T1 _1) {
      this._0 = _0;
      this._1 = _1;
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple2<T0, T1>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ")";
      return s;
    }
    public static _ITuple2<T0, T1> Default(T0 _default_T0, T1 _default_T1) {
      return create(_default_T0, _default_T1);
    }
    public static Dafny.TypeDescriptor<_System._ITuple2<T0, T1>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1) {
      return new Dafny.TypeDescriptor<_System._ITuple2<T0, T1>>(_System.Tuple2<T0, T1>.Default(_td_T0.Default(), _td_T1.Default()));
    }
    public static _ITuple2<T0, T1> create(T0 _0, T1 _1) {
      return new Tuple2<T0, T1>(_0, _1);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
  }

  public interface _ITuple3<out T0, out T1, out T2> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    _ITuple3<__T0, __T1, __T2> DowncastClone<__T0, __T1, __T2>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2);
  }
  public class Tuple3<T0, T1, T2> : _ITuple3<T0, T1, T2> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public Tuple3(T0 _0, T1 _1, T2 _2) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
    }
    public _ITuple3<__T0, __T1, __T2> DowncastClone<__T0, __T1, __T2>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2) {
      if (this is _ITuple3<__T0, __T1, __T2> dt) { return dt; }
      return new Tuple3<__T0, __T1, __T2>(converter0(_0), converter1(_1), converter2(_2));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple3<T0, T1, T2>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ")";
      return s;
    }
    public static _ITuple3<T0, T1, T2> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2) {
      return create(_default_T0, _default_T1, _default_T2);
    }
    public static Dafny.TypeDescriptor<_System._ITuple3<T0, T1, T2>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2) {
      return new Dafny.TypeDescriptor<_System._ITuple3<T0, T1, T2>>(_System.Tuple3<T0, T1, T2>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default()));
    }
    public static _ITuple3<T0, T1, T2> create(T0 _0, T1 _1, T2 _2) {
      return new Tuple3<T0, T1, T2>(_0, _1, _2);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
  }

  public interface _ITuple4<out T0, out T1, out T2, out T3> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    _ITuple4<__T0, __T1, __T2, __T3> DowncastClone<__T0, __T1, __T2, __T3>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3);
  }
  public class Tuple4<T0, T1, T2, T3> : _ITuple4<T0, T1, T2, T3> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public Tuple4(T0 _0, T1 _1, T2 _2, T3 _3) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
    }
    public _ITuple4<__T0, __T1, __T2, __T3> DowncastClone<__T0, __T1, __T2, __T3>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3) {
      if (this is _ITuple4<__T0, __T1, __T2, __T3> dt) { return dt; }
      return new Tuple4<__T0, __T1, __T2, __T3>(converter0(_0), converter1(_1), converter2(_2), converter3(_3));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple4<T0, T1, T2, T3>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ")";
      return s;
    }
    public static _ITuple4<T0, T1, T2, T3> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3);
    }
    public static Dafny.TypeDescriptor<_System._ITuple4<T0, T1, T2, T3>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3) {
      return new Dafny.TypeDescriptor<_System._ITuple4<T0, T1, T2, T3>>(_System.Tuple4<T0, T1, T2, T3>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default()));
    }
    public static _ITuple4<T0, T1, T2, T3> create(T0 _0, T1 _1, T2 _2, T3 _3) {
      return new Tuple4<T0, T1, T2, T3>(_0, _1, _2, _3);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
  }

  public interface _ITuple5<out T0, out T1, out T2, out T3, out T4> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    T4 dtor__4 { get; }
    _ITuple5<__T0, __T1, __T2, __T3, __T4> DowncastClone<__T0, __T1, __T2, __T3, __T4>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4);
  }
  public class Tuple5<T0, T1, T2, T3, T4> : _ITuple5<T0, T1, T2, T3, T4> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public readonly T4 _4;
    public Tuple5(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
      this._4 = _4;
    }
    public _ITuple5<__T0, __T1, __T2, __T3, __T4> DowncastClone<__T0, __T1, __T2, __T3, __T4>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4) {
      if (this is _ITuple5<__T0, __T1, __T2, __T3, __T4> dt) { return dt; }
      return new Tuple5<__T0, __T1, __T2, __T3, __T4>(converter0(_0), converter1(_1), converter2(_2), converter3(_3), converter4(_4));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple5<T0, T1, T2, T3, T4>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3) && object.Equals(this._4, oth._4);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._4));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ", ";
      s += Dafny.Helpers.ToString(this._4);
      s += ")";
      return s;
    }
    public static _ITuple5<T0, T1, T2, T3, T4> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3, T4 _default_T4) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3, _default_T4);
    }
    public static Dafny.TypeDescriptor<_System._ITuple5<T0, T1, T2, T3, T4>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3, Dafny.TypeDescriptor<T4> _td_T4) {
      return new Dafny.TypeDescriptor<_System._ITuple5<T0, T1, T2, T3, T4>>(_System.Tuple5<T0, T1, T2, T3, T4>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default(), _td_T4.Default()));
    }
    public static _ITuple5<T0, T1, T2, T3, T4> create(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4) {
      return new Tuple5<T0, T1, T2, T3, T4>(_0, _1, _2, _3, _4);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
    public T4 dtor__4 {
      get {
        return this._4;
      }
    }
  }

  public interface _ITuple6<out T0, out T1, out T2, out T3, out T4, out T5> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    T4 dtor__4 { get; }
    T5 dtor__5 { get; }
    _ITuple6<__T0, __T1, __T2, __T3, __T4, __T5> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5);
  }
  public class Tuple6<T0, T1, T2, T3, T4, T5> : _ITuple6<T0, T1, T2, T3, T4, T5> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public readonly T4 _4;
    public readonly T5 _5;
    public Tuple6(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
      this._4 = _4;
      this._5 = _5;
    }
    public _ITuple6<__T0, __T1, __T2, __T3, __T4, __T5> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5) {
      if (this is _ITuple6<__T0, __T1, __T2, __T3, __T4, __T5> dt) { return dt; }
      return new Tuple6<__T0, __T1, __T2, __T3, __T4, __T5>(converter0(_0), converter1(_1), converter2(_2), converter3(_3), converter4(_4), converter5(_5));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple6<T0, T1, T2, T3, T4, T5>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3) && object.Equals(this._4, oth._4) && object.Equals(this._5, oth._5);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._4));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._5));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ", ";
      s += Dafny.Helpers.ToString(this._4);
      s += ", ";
      s += Dafny.Helpers.ToString(this._5);
      s += ")";
      return s;
    }
    public static _ITuple6<T0, T1, T2, T3, T4, T5> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3, T4 _default_T4, T5 _default_T5) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3, _default_T4, _default_T5);
    }
    public static Dafny.TypeDescriptor<_System._ITuple6<T0, T1, T2, T3, T4, T5>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3, Dafny.TypeDescriptor<T4> _td_T4, Dafny.TypeDescriptor<T5> _td_T5) {
      return new Dafny.TypeDescriptor<_System._ITuple6<T0, T1, T2, T3, T4, T5>>(_System.Tuple6<T0, T1, T2, T3, T4, T5>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default(), _td_T4.Default(), _td_T5.Default()));
    }
    public static _ITuple6<T0, T1, T2, T3, T4, T5> create(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5) {
      return new Tuple6<T0, T1, T2, T3, T4, T5>(_0, _1, _2, _3, _4, _5);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
    public T4 dtor__4 {
      get {
        return this._4;
      }
    }
    public T5 dtor__5 {
      get {
        return this._5;
      }
    }
  }

  public interface _ITuple7<out T0, out T1, out T2, out T3, out T4, out T5, out T6> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    T4 dtor__4 { get; }
    T5 dtor__5 { get; }
    T6 dtor__6 { get; }
    _ITuple7<__T0, __T1, __T2, __T3, __T4, __T5, __T6> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6);
  }
  public class Tuple7<T0, T1, T2, T3, T4, T5, T6> : _ITuple7<T0, T1, T2, T3, T4, T5, T6> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public readonly T4 _4;
    public readonly T5 _5;
    public readonly T6 _6;
    public Tuple7(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
      this._4 = _4;
      this._5 = _5;
      this._6 = _6;
    }
    public _ITuple7<__T0, __T1, __T2, __T3, __T4, __T5, __T6> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6) {
      if (this is _ITuple7<__T0, __T1, __T2, __T3, __T4, __T5, __T6> dt) { return dt; }
      return new Tuple7<__T0, __T1, __T2, __T3, __T4, __T5, __T6>(converter0(_0), converter1(_1), converter2(_2), converter3(_3), converter4(_4), converter5(_5), converter6(_6));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple7<T0, T1, T2, T3, T4, T5, T6>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3) && object.Equals(this._4, oth._4) && object.Equals(this._5, oth._5) && object.Equals(this._6, oth._6);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._4));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._5));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._6));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ", ";
      s += Dafny.Helpers.ToString(this._4);
      s += ", ";
      s += Dafny.Helpers.ToString(this._5);
      s += ", ";
      s += Dafny.Helpers.ToString(this._6);
      s += ")";
      return s;
    }
    public static _ITuple7<T0, T1, T2, T3, T4, T5, T6> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3, T4 _default_T4, T5 _default_T5, T6 _default_T6) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3, _default_T4, _default_T5, _default_T6);
    }
    public static Dafny.TypeDescriptor<_System._ITuple7<T0, T1, T2, T3, T4, T5, T6>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3, Dafny.TypeDescriptor<T4> _td_T4, Dafny.TypeDescriptor<T5> _td_T5, Dafny.TypeDescriptor<T6> _td_T6) {
      return new Dafny.TypeDescriptor<_System._ITuple7<T0, T1, T2, T3, T4, T5, T6>>(_System.Tuple7<T0, T1, T2, T3, T4, T5, T6>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default(), _td_T4.Default(), _td_T5.Default(), _td_T6.Default()));
    }
    public static _ITuple7<T0, T1, T2, T3, T4, T5, T6> create(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6) {
      return new Tuple7<T0, T1, T2, T3, T4, T5, T6>(_0, _1, _2, _3, _4, _5, _6);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
    public T4 dtor__4 {
      get {
        return this._4;
      }
    }
    public T5 dtor__5 {
      get {
        return this._5;
      }
    }
    public T6 dtor__6 {
      get {
        return this._6;
      }
    }
  }

  public interface _ITuple8<out T0, out T1, out T2, out T3, out T4, out T5, out T6, out T7> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    T4 dtor__4 { get; }
    T5 dtor__5 { get; }
    T6 dtor__6 { get; }
    T7 dtor__7 { get; }
    _ITuple8<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7);
  }
  public class Tuple8<T0, T1, T2, T3, T4, T5, T6, T7> : _ITuple8<T0, T1, T2, T3, T4, T5, T6, T7> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public readonly T4 _4;
    public readonly T5 _5;
    public readonly T6 _6;
    public readonly T7 _7;
    public Tuple8(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
      this._4 = _4;
      this._5 = _5;
      this._6 = _6;
      this._7 = _7;
    }
    public _ITuple8<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7) {
      if (this is _ITuple8<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7> dt) { return dt; }
      return new Tuple8<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7>(converter0(_0), converter1(_1), converter2(_2), converter3(_3), converter4(_4), converter5(_5), converter6(_6), converter7(_7));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple8<T0, T1, T2, T3, T4, T5, T6, T7>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3) && object.Equals(this._4, oth._4) && object.Equals(this._5, oth._5) && object.Equals(this._6, oth._6) && object.Equals(this._7, oth._7);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._4));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._5));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._6));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._7));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ", ";
      s += Dafny.Helpers.ToString(this._4);
      s += ", ";
      s += Dafny.Helpers.ToString(this._5);
      s += ", ";
      s += Dafny.Helpers.ToString(this._6);
      s += ", ";
      s += Dafny.Helpers.ToString(this._7);
      s += ")";
      return s;
    }
    public static _ITuple8<T0, T1, T2, T3, T4, T5, T6, T7> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3, T4 _default_T4, T5 _default_T5, T6 _default_T6, T7 _default_T7) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3, _default_T4, _default_T5, _default_T6, _default_T7);
    }
    public static Dafny.TypeDescriptor<_System._ITuple8<T0, T1, T2, T3, T4, T5, T6, T7>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3, Dafny.TypeDescriptor<T4> _td_T4, Dafny.TypeDescriptor<T5> _td_T5, Dafny.TypeDescriptor<T6> _td_T6, Dafny.TypeDescriptor<T7> _td_T7) {
      return new Dafny.TypeDescriptor<_System._ITuple8<T0, T1, T2, T3, T4, T5, T6, T7>>(_System.Tuple8<T0, T1, T2, T3, T4, T5, T6, T7>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default(), _td_T4.Default(), _td_T5.Default(), _td_T6.Default(), _td_T7.Default()));
    }
    public static _ITuple8<T0, T1, T2, T3, T4, T5, T6, T7> create(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7) {
      return new Tuple8<T0, T1, T2, T3, T4, T5, T6, T7>(_0, _1, _2, _3, _4, _5, _6, _7);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
    public T4 dtor__4 {
      get {
        return this._4;
      }
    }
    public T5 dtor__5 {
      get {
        return this._5;
      }
    }
    public T6 dtor__6 {
      get {
        return this._6;
      }
    }
    public T7 dtor__7 {
      get {
        return this._7;
      }
    }
  }

  public interface _ITuple9<out T0, out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    T4 dtor__4 { get; }
    T5 dtor__5 { get; }
    T6 dtor__6 { get; }
    T7 dtor__7 { get; }
    T8 dtor__8 { get; }
    _ITuple9<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8);
  }
  public class Tuple9<T0, T1, T2, T3, T4, T5, T6, T7, T8> : _ITuple9<T0, T1, T2, T3, T4, T5, T6, T7, T8> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public readonly T4 _4;
    public readonly T5 _5;
    public readonly T6 _6;
    public readonly T7 _7;
    public readonly T8 _8;
    public Tuple9(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
      this._4 = _4;
      this._5 = _5;
      this._6 = _6;
      this._7 = _7;
      this._8 = _8;
    }
    public _ITuple9<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8) {
      if (this is _ITuple9<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8> dt) { return dt; }
      return new Tuple9<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8>(converter0(_0), converter1(_1), converter2(_2), converter3(_3), converter4(_4), converter5(_5), converter6(_6), converter7(_7), converter8(_8));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple9<T0, T1, T2, T3, T4, T5, T6, T7, T8>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3) && object.Equals(this._4, oth._4) && object.Equals(this._5, oth._5) && object.Equals(this._6, oth._6) && object.Equals(this._7, oth._7) && object.Equals(this._8, oth._8);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._4));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._5));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._6));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._7));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._8));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ", ";
      s += Dafny.Helpers.ToString(this._4);
      s += ", ";
      s += Dafny.Helpers.ToString(this._5);
      s += ", ";
      s += Dafny.Helpers.ToString(this._6);
      s += ", ";
      s += Dafny.Helpers.ToString(this._7);
      s += ", ";
      s += Dafny.Helpers.ToString(this._8);
      s += ")";
      return s;
    }
    public static _ITuple9<T0, T1, T2, T3, T4, T5, T6, T7, T8> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3, T4 _default_T4, T5 _default_T5, T6 _default_T6, T7 _default_T7, T8 _default_T8) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3, _default_T4, _default_T5, _default_T6, _default_T7, _default_T8);
    }
    public static Dafny.TypeDescriptor<_System._ITuple9<T0, T1, T2, T3, T4, T5, T6, T7, T8>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3, Dafny.TypeDescriptor<T4> _td_T4, Dafny.TypeDescriptor<T5> _td_T5, Dafny.TypeDescriptor<T6> _td_T6, Dafny.TypeDescriptor<T7> _td_T7, Dafny.TypeDescriptor<T8> _td_T8) {
      return new Dafny.TypeDescriptor<_System._ITuple9<T0, T1, T2, T3, T4, T5, T6, T7, T8>>(_System.Tuple9<T0, T1, T2, T3, T4, T5, T6, T7, T8>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default(), _td_T4.Default(), _td_T5.Default(), _td_T6.Default(), _td_T7.Default(), _td_T8.Default()));
    }
    public static _ITuple9<T0, T1, T2, T3, T4, T5, T6, T7, T8> create(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8) {
      return new Tuple9<T0, T1, T2, T3, T4, T5, T6, T7, T8>(_0, _1, _2, _3, _4, _5, _6, _7, _8);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
    public T4 dtor__4 {
      get {
        return this._4;
      }
    }
    public T5 dtor__5 {
      get {
        return this._5;
      }
    }
    public T6 dtor__6 {
      get {
        return this._6;
      }
    }
    public T7 dtor__7 {
      get {
        return this._7;
      }
    }
    public T8 dtor__8 {
      get {
        return this._8;
      }
    }
  }

  public interface _ITuple10<out T0, out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    T4 dtor__4 { get; }
    T5 dtor__5 { get; }
    T6 dtor__6 { get; }
    T7 dtor__7 { get; }
    T8 dtor__8 { get; }
    T9 dtor__9 { get; }
    _ITuple10<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9);
  }
  public class Tuple10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> : _ITuple10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public readonly T4 _4;
    public readonly T5 _5;
    public readonly T6 _6;
    public readonly T7 _7;
    public readonly T8 _8;
    public readonly T9 _9;
    public Tuple10(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
      this._4 = _4;
      this._5 = _5;
      this._6 = _6;
      this._7 = _7;
      this._8 = _8;
      this._9 = _9;
    }
    public _ITuple10<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9) {
      if (this is _ITuple10<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9> dt) { return dt; }
      return new Tuple10<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9>(converter0(_0), converter1(_1), converter2(_2), converter3(_3), converter4(_4), converter5(_5), converter6(_6), converter7(_7), converter8(_8), converter9(_9));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3) && object.Equals(this._4, oth._4) && object.Equals(this._5, oth._5) && object.Equals(this._6, oth._6) && object.Equals(this._7, oth._7) && object.Equals(this._8, oth._8) && object.Equals(this._9, oth._9);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._4));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._5));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._6));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._7));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._8));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._9));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ", ";
      s += Dafny.Helpers.ToString(this._4);
      s += ", ";
      s += Dafny.Helpers.ToString(this._5);
      s += ", ";
      s += Dafny.Helpers.ToString(this._6);
      s += ", ";
      s += Dafny.Helpers.ToString(this._7);
      s += ", ";
      s += Dafny.Helpers.ToString(this._8);
      s += ", ";
      s += Dafny.Helpers.ToString(this._9);
      s += ")";
      return s;
    }
    public static _ITuple10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3, T4 _default_T4, T5 _default_T5, T6 _default_T6, T7 _default_T7, T8 _default_T8, T9 _default_T9) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3, _default_T4, _default_T5, _default_T6, _default_T7, _default_T8, _default_T9);
    }
    public static Dafny.TypeDescriptor<_System._ITuple10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3, Dafny.TypeDescriptor<T4> _td_T4, Dafny.TypeDescriptor<T5> _td_T5, Dafny.TypeDescriptor<T6> _td_T6, Dafny.TypeDescriptor<T7> _td_T7, Dafny.TypeDescriptor<T8> _td_T8, Dafny.TypeDescriptor<T9> _td_T9) {
      return new Dafny.TypeDescriptor<_System._ITuple10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>(_System.Tuple10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default(), _td_T4.Default(), _td_T5.Default(), _td_T6.Default(), _td_T7.Default(), _td_T8.Default(), _td_T9.Default()));
    }
    public static _ITuple10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> create(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9) {
      return new Tuple10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
    public T4 dtor__4 {
      get {
        return this._4;
      }
    }
    public T5 dtor__5 {
      get {
        return this._5;
      }
    }
    public T6 dtor__6 {
      get {
        return this._6;
      }
    }
    public T7 dtor__7 {
      get {
        return this._7;
      }
    }
    public T8 dtor__8 {
      get {
        return this._8;
      }
    }
    public T9 dtor__9 {
      get {
        return this._9;
      }
    }
  }

  public interface _ITuple11<out T0, out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    T4 dtor__4 { get; }
    T5 dtor__5 { get; }
    T6 dtor__6 { get; }
    T7 dtor__7 { get; }
    T8 dtor__8 { get; }
    T9 dtor__9 { get; }
    T10 dtor__10 { get; }
    _ITuple11<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10);
  }
  public class Tuple11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> : _ITuple11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public readonly T4 _4;
    public readonly T5 _5;
    public readonly T6 _6;
    public readonly T7 _7;
    public readonly T8 _8;
    public readonly T9 _9;
    public readonly T10 _10;
    public Tuple11(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
      this._4 = _4;
      this._5 = _5;
      this._6 = _6;
      this._7 = _7;
      this._8 = _8;
      this._9 = _9;
      this._10 = _10;
    }
    public _ITuple11<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10) {
      if (this is _ITuple11<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10> dt) { return dt; }
      return new Tuple11<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10>(converter0(_0), converter1(_1), converter2(_2), converter3(_3), converter4(_4), converter5(_5), converter6(_6), converter7(_7), converter8(_8), converter9(_9), converter10(_10));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3) && object.Equals(this._4, oth._4) && object.Equals(this._5, oth._5) && object.Equals(this._6, oth._6) && object.Equals(this._7, oth._7) && object.Equals(this._8, oth._8) && object.Equals(this._9, oth._9) && object.Equals(this._10, oth._10);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._4));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._5));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._6));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._7));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._8));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._9));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._10));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ", ";
      s += Dafny.Helpers.ToString(this._4);
      s += ", ";
      s += Dafny.Helpers.ToString(this._5);
      s += ", ";
      s += Dafny.Helpers.ToString(this._6);
      s += ", ";
      s += Dafny.Helpers.ToString(this._7);
      s += ", ";
      s += Dafny.Helpers.ToString(this._8);
      s += ", ";
      s += Dafny.Helpers.ToString(this._9);
      s += ", ";
      s += Dafny.Helpers.ToString(this._10);
      s += ")";
      return s;
    }
    public static _ITuple11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3, T4 _default_T4, T5 _default_T5, T6 _default_T6, T7 _default_T7, T8 _default_T8, T9 _default_T9, T10 _default_T10) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3, _default_T4, _default_T5, _default_T6, _default_T7, _default_T8, _default_T9, _default_T10);
    }
    public static Dafny.TypeDescriptor<_System._ITuple11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3, Dafny.TypeDescriptor<T4> _td_T4, Dafny.TypeDescriptor<T5> _td_T5, Dafny.TypeDescriptor<T6> _td_T6, Dafny.TypeDescriptor<T7> _td_T7, Dafny.TypeDescriptor<T8> _td_T8, Dafny.TypeDescriptor<T9> _td_T9, Dafny.TypeDescriptor<T10> _td_T10) {
      return new Dafny.TypeDescriptor<_System._ITuple11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>>(_System.Tuple11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default(), _td_T4.Default(), _td_T5.Default(), _td_T6.Default(), _td_T7.Default(), _td_T8.Default(), _td_T9.Default(), _td_T10.Default()));
    }
    public static _ITuple11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> create(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10) {
      return new Tuple11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
    public T4 dtor__4 {
      get {
        return this._4;
      }
    }
    public T5 dtor__5 {
      get {
        return this._5;
      }
    }
    public T6 dtor__6 {
      get {
        return this._6;
      }
    }
    public T7 dtor__7 {
      get {
        return this._7;
      }
    }
    public T8 dtor__8 {
      get {
        return this._8;
      }
    }
    public T9 dtor__9 {
      get {
        return this._9;
      }
    }
    public T10 dtor__10 {
      get {
        return this._10;
      }
    }
  }

  public interface _ITuple12<out T0, out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10, out T11> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    T4 dtor__4 { get; }
    T5 dtor__5 { get; }
    T6 dtor__6 { get; }
    T7 dtor__7 { get; }
    T8 dtor__8 { get; }
    T9 dtor__9 { get; }
    T10 dtor__10 { get; }
    T11 dtor__11 { get; }
    _ITuple12<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11);
  }
  public class Tuple12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> : _ITuple12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public readonly T4 _4;
    public readonly T5 _5;
    public readonly T6 _6;
    public readonly T7 _7;
    public readonly T8 _8;
    public readonly T9 _9;
    public readonly T10 _10;
    public readonly T11 _11;
    public Tuple12(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
      this._4 = _4;
      this._5 = _5;
      this._6 = _6;
      this._7 = _7;
      this._8 = _8;
      this._9 = _9;
      this._10 = _10;
      this._11 = _11;
    }
    public _ITuple12<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11) {
      if (this is _ITuple12<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11> dt) { return dt; }
      return new Tuple12<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11>(converter0(_0), converter1(_1), converter2(_2), converter3(_3), converter4(_4), converter5(_5), converter6(_6), converter7(_7), converter8(_8), converter9(_9), converter10(_10), converter11(_11));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3) && object.Equals(this._4, oth._4) && object.Equals(this._5, oth._5) && object.Equals(this._6, oth._6) && object.Equals(this._7, oth._7) && object.Equals(this._8, oth._8) && object.Equals(this._9, oth._9) && object.Equals(this._10, oth._10) && object.Equals(this._11, oth._11);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._4));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._5));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._6));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._7));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._8));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._9));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._10));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._11));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ", ";
      s += Dafny.Helpers.ToString(this._4);
      s += ", ";
      s += Dafny.Helpers.ToString(this._5);
      s += ", ";
      s += Dafny.Helpers.ToString(this._6);
      s += ", ";
      s += Dafny.Helpers.ToString(this._7);
      s += ", ";
      s += Dafny.Helpers.ToString(this._8);
      s += ", ";
      s += Dafny.Helpers.ToString(this._9);
      s += ", ";
      s += Dafny.Helpers.ToString(this._10);
      s += ", ";
      s += Dafny.Helpers.ToString(this._11);
      s += ")";
      return s;
    }
    public static _ITuple12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3, T4 _default_T4, T5 _default_T5, T6 _default_T6, T7 _default_T7, T8 _default_T8, T9 _default_T9, T10 _default_T10, T11 _default_T11) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3, _default_T4, _default_T5, _default_T6, _default_T7, _default_T8, _default_T9, _default_T10, _default_T11);
    }
    public static Dafny.TypeDescriptor<_System._ITuple12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3, Dafny.TypeDescriptor<T4> _td_T4, Dafny.TypeDescriptor<T5> _td_T5, Dafny.TypeDescriptor<T6> _td_T6, Dafny.TypeDescriptor<T7> _td_T7, Dafny.TypeDescriptor<T8> _td_T8, Dafny.TypeDescriptor<T9> _td_T9, Dafny.TypeDescriptor<T10> _td_T10, Dafny.TypeDescriptor<T11> _td_T11) {
      return new Dafny.TypeDescriptor<_System._ITuple12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>>(_System.Tuple12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default(), _td_T4.Default(), _td_T5.Default(), _td_T6.Default(), _td_T7.Default(), _td_T8.Default(), _td_T9.Default(), _td_T10.Default(), _td_T11.Default()));
    }
    public static _ITuple12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> create(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11) {
      return new Tuple12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
    public T4 dtor__4 {
      get {
        return this._4;
      }
    }
    public T5 dtor__5 {
      get {
        return this._5;
      }
    }
    public T6 dtor__6 {
      get {
        return this._6;
      }
    }
    public T7 dtor__7 {
      get {
        return this._7;
      }
    }
    public T8 dtor__8 {
      get {
        return this._8;
      }
    }
    public T9 dtor__9 {
      get {
        return this._9;
      }
    }
    public T10 dtor__10 {
      get {
        return this._10;
      }
    }
    public T11 dtor__11 {
      get {
        return this._11;
      }
    }
  }

  public interface _ITuple13<out T0, out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10, out T11, out T12> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    T4 dtor__4 { get; }
    T5 dtor__5 { get; }
    T6 dtor__6 { get; }
    T7 dtor__7 { get; }
    T8 dtor__8 { get; }
    T9 dtor__9 { get; }
    T10 dtor__10 { get; }
    T11 dtor__11 { get; }
    T12 dtor__12 { get; }
    _ITuple13<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11, Func<T12, __T12> converter12);
  }
  public class Tuple13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> : _ITuple13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public readonly T4 _4;
    public readonly T5 _5;
    public readonly T6 _6;
    public readonly T7 _7;
    public readonly T8 _8;
    public readonly T9 _9;
    public readonly T10 _10;
    public readonly T11 _11;
    public readonly T12 _12;
    public Tuple13(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
      this._4 = _4;
      this._5 = _5;
      this._6 = _6;
      this._7 = _7;
      this._8 = _8;
      this._9 = _9;
      this._10 = _10;
      this._11 = _11;
      this._12 = _12;
    }
    public _ITuple13<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11, Func<T12, __T12> converter12) {
      if (this is _ITuple13<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12> dt) { return dt; }
      return new Tuple13<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12>(converter0(_0), converter1(_1), converter2(_2), converter3(_3), converter4(_4), converter5(_5), converter6(_6), converter7(_7), converter8(_8), converter9(_9), converter10(_10), converter11(_11), converter12(_12));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3) && object.Equals(this._4, oth._4) && object.Equals(this._5, oth._5) && object.Equals(this._6, oth._6) && object.Equals(this._7, oth._7) && object.Equals(this._8, oth._8) && object.Equals(this._9, oth._9) && object.Equals(this._10, oth._10) && object.Equals(this._11, oth._11) && object.Equals(this._12, oth._12);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._4));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._5));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._6));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._7));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._8));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._9));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._10));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._11));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._12));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ", ";
      s += Dafny.Helpers.ToString(this._4);
      s += ", ";
      s += Dafny.Helpers.ToString(this._5);
      s += ", ";
      s += Dafny.Helpers.ToString(this._6);
      s += ", ";
      s += Dafny.Helpers.ToString(this._7);
      s += ", ";
      s += Dafny.Helpers.ToString(this._8);
      s += ", ";
      s += Dafny.Helpers.ToString(this._9);
      s += ", ";
      s += Dafny.Helpers.ToString(this._10);
      s += ", ";
      s += Dafny.Helpers.ToString(this._11);
      s += ", ";
      s += Dafny.Helpers.ToString(this._12);
      s += ")";
      return s;
    }
    public static _ITuple13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3, T4 _default_T4, T5 _default_T5, T6 _default_T6, T7 _default_T7, T8 _default_T8, T9 _default_T9, T10 _default_T10, T11 _default_T11, T12 _default_T12) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3, _default_T4, _default_T5, _default_T6, _default_T7, _default_T8, _default_T9, _default_T10, _default_T11, _default_T12);
    }
    public static Dafny.TypeDescriptor<_System._ITuple13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3, Dafny.TypeDescriptor<T4> _td_T4, Dafny.TypeDescriptor<T5> _td_T5, Dafny.TypeDescriptor<T6> _td_T6, Dafny.TypeDescriptor<T7> _td_T7, Dafny.TypeDescriptor<T8> _td_T8, Dafny.TypeDescriptor<T9> _td_T9, Dafny.TypeDescriptor<T10> _td_T10, Dafny.TypeDescriptor<T11> _td_T11, Dafny.TypeDescriptor<T12> _td_T12) {
      return new Dafny.TypeDescriptor<_System._ITuple13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>>(_System.Tuple13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default(), _td_T4.Default(), _td_T5.Default(), _td_T6.Default(), _td_T7.Default(), _td_T8.Default(), _td_T9.Default(), _td_T10.Default(), _td_T11.Default(), _td_T12.Default()));
    }
    public static _ITuple13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> create(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12) {
      return new Tuple13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
    public T4 dtor__4 {
      get {
        return this._4;
      }
    }
    public T5 dtor__5 {
      get {
        return this._5;
      }
    }
    public T6 dtor__6 {
      get {
        return this._6;
      }
    }
    public T7 dtor__7 {
      get {
        return this._7;
      }
    }
    public T8 dtor__8 {
      get {
        return this._8;
      }
    }
    public T9 dtor__9 {
      get {
        return this._9;
      }
    }
    public T10 dtor__10 {
      get {
        return this._10;
      }
    }
    public T11 dtor__11 {
      get {
        return this._11;
      }
    }
    public T12 dtor__12 {
      get {
        return this._12;
      }
    }
  }

  public interface _ITuple14<out T0, out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10, out T11, out T12, out T13> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    T4 dtor__4 { get; }
    T5 dtor__5 { get; }
    T6 dtor__6 { get; }
    T7 dtor__7 { get; }
    T8 dtor__8 { get; }
    T9 dtor__9 { get; }
    T10 dtor__10 { get; }
    T11 dtor__11 { get; }
    T12 dtor__12 { get; }
    T13 dtor__13 { get; }
    _ITuple14<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11, Func<T12, __T12> converter12, Func<T13, __T13> converter13);
  }
  public class Tuple14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> : _ITuple14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public readonly T4 _4;
    public readonly T5 _5;
    public readonly T6 _6;
    public readonly T7 _7;
    public readonly T8 _8;
    public readonly T9 _9;
    public readonly T10 _10;
    public readonly T11 _11;
    public readonly T12 _12;
    public readonly T13 _13;
    public Tuple14(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
      this._4 = _4;
      this._5 = _5;
      this._6 = _6;
      this._7 = _7;
      this._8 = _8;
      this._9 = _9;
      this._10 = _10;
      this._11 = _11;
      this._12 = _12;
      this._13 = _13;
    }
    public _ITuple14<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11, Func<T12, __T12> converter12, Func<T13, __T13> converter13) {
      if (this is _ITuple14<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13> dt) { return dt; }
      return new Tuple14<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13>(converter0(_0), converter1(_1), converter2(_2), converter3(_3), converter4(_4), converter5(_5), converter6(_6), converter7(_7), converter8(_8), converter9(_9), converter10(_10), converter11(_11), converter12(_12), converter13(_13));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3) && object.Equals(this._4, oth._4) && object.Equals(this._5, oth._5) && object.Equals(this._6, oth._6) && object.Equals(this._7, oth._7) && object.Equals(this._8, oth._8) && object.Equals(this._9, oth._9) && object.Equals(this._10, oth._10) && object.Equals(this._11, oth._11) && object.Equals(this._12, oth._12) && object.Equals(this._13, oth._13);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._4));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._5));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._6));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._7));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._8));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._9));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._10));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._11));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._12));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._13));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ", ";
      s += Dafny.Helpers.ToString(this._4);
      s += ", ";
      s += Dafny.Helpers.ToString(this._5);
      s += ", ";
      s += Dafny.Helpers.ToString(this._6);
      s += ", ";
      s += Dafny.Helpers.ToString(this._7);
      s += ", ";
      s += Dafny.Helpers.ToString(this._8);
      s += ", ";
      s += Dafny.Helpers.ToString(this._9);
      s += ", ";
      s += Dafny.Helpers.ToString(this._10);
      s += ", ";
      s += Dafny.Helpers.ToString(this._11);
      s += ", ";
      s += Dafny.Helpers.ToString(this._12);
      s += ", ";
      s += Dafny.Helpers.ToString(this._13);
      s += ")";
      return s;
    }
    public static _ITuple14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3, T4 _default_T4, T5 _default_T5, T6 _default_T6, T7 _default_T7, T8 _default_T8, T9 _default_T9, T10 _default_T10, T11 _default_T11, T12 _default_T12, T13 _default_T13) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3, _default_T4, _default_T5, _default_T6, _default_T7, _default_T8, _default_T9, _default_T10, _default_T11, _default_T12, _default_T13);
    }
    public static Dafny.TypeDescriptor<_System._ITuple14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3, Dafny.TypeDescriptor<T4> _td_T4, Dafny.TypeDescriptor<T5> _td_T5, Dafny.TypeDescriptor<T6> _td_T6, Dafny.TypeDescriptor<T7> _td_T7, Dafny.TypeDescriptor<T8> _td_T8, Dafny.TypeDescriptor<T9> _td_T9, Dafny.TypeDescriptor<T10> _td_T10, Dafny.TypeDescriptor<T11> _td_T11, Dafny.TypeDescriptor<T12> _td_T12, Dafny.TypeDescriptor<T13> _td_T13) {
      return new Dafny.TypeDescriptor<_System._ITuple14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>>(_System.Tuple14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default(), _td_T4.Default(), _td_T5.Default(), _td_T6.Default(), _td_T7.Default(), _td_T8.Default(), _td_T9.Default(), _td_T10.Default(), _td_T11.Default(), _td_T12.Default(), _td_T13.Default()));
    }
    public static _ITuple14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> create(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13) {
      return new Tuple14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
    public T4 dtor__4 {
      get {
        return this._4;
      }
    }
    public T5 dtor__5 {
      get {
        return this._5;
      }
    }
    public T6 dtor__6 {
      get {
        return this._6;
      }
    }
    public T7 dtor__7 {
      get {
        return this._7;
      }
    }
    public T8 dtor__8 {
      get {
        return this._8;
      }
    }
    public T9 dtor__9 {
      get {
        return this._9;
      }
    }
    public T10 dtor__10 {
      get {
        return this._10;
      }
    }
    public T11 dtor__11 {
      get {
        return this._11;
      }
    }
    public T12 dtor__12 {
      get {
        return this._12;
      }
    }
    public T13 dtor__13 {
      get {
        return this._13;
      }
    }
  }

  public interface _ITuple15<out T0, out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10, out T11, out T12, out T13, out T14> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    T4 dtor__4 { get; }
    T5 dtor__5 { get; }
    T6 dtor__6 { get; }
    T7 dtor__7 { get; }
    T8 dtor__8 { get; }
    T9 dtor__9 { get; }
    T10 dtor__10 { get; }
    T11 dtor__11 { get; }
    T12 dtor__12 { get; }
    T13 dtor__13 { get; }
    T14 dtor__14 { get; }
    _ITuple15<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11, Func<T12, __T12> converter12, Func<T13, __T13> converter13, Func<T14, __T14> converter14);
  }
  public class Tuple15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> : _ITuple15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public readonly T4 _4;
    public readonly T5 _5;
    public readonly T6 _6;
    public readonly T7 _7;
    public readonly T8 _8;
    public readonly T9 _9;
    public readonly T10 _10;
    public readonly T11 _11;
    public readonly T12 _12;
    public readonly T13 _13;
    public readonly T14 _14;
    public Tuple15(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
      this._4 = _4;
      this._5 = _5;
      this._6 = _6;
      this._7 = _7;
      this._8 = _8;
      this._9 = _9;
      this._10 = _10;
      this._11 = _11;
      this._12 = _12;
      this._13 = _13;
      this._14 = _14;
    }
    public _ITuple15<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11, Func<T12, __T12> converter12, Func<T13, __T13> converter13, Func<T14, __T14> converter14) {
      if (this is _ITuple15<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14> dt) { return dt; }
      return new Tuple15<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14>(converter0(_0), converter1(_1), converter2(_2), converter3(_3), converter4(_4), converter5(_5), converter6(_6), converter7(_7), converter8(_8), converter9(_9), converter10(_10), converter11(_11), converter12(_12), converter13(_13), converter14(_14));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3) && object.Equals(this._4, oth._4) && object.Equals(this._5, oth._5) && object.Equals(this._6, oth._6) && object.Equals(this._7, oth._7) && object.Equals(this._8, oth._8) && object.Equals(this._9, oth._9) && object.Equals(this._10, oth._10) && object.Equals(this._11, oth._11) && object.Equals(this._12, oth._12) && object.Equals(this._13, oth._13) && object.Equals(this._14, oth._14);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._4));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._5));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._6));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._7));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._8));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._9));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._10));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._11));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._12));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._13));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._14));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ", ";
      s += Dafny.Helpers.ToString(this._4);
      s += ", ";
      s += Dafny.Helpers.ToString(this._5);
      s += ", ";
      s += Dafny.Helpers.ToString(this._6);
      s += ", ";
      s += Dafny.Helpers.ToString(this._7);
      s += ", ";
      s += Dafny.Helpers.ToString(this._8);
      s += ", ";
      s += Dafny.Helpers.ToString(this._9);
      s += ", ";
      s += Dafny.Helpers.ToString(this._10);
      s += ", ";
      s += Dafny.Helpers.ToString(this._11);
      s += ", ";
      s += Dafny.Helpers.ToString(this._12);
      s += ", ";
      s += Dafny.Helpers.ToString(this._13);
      s += ", ";
      s += Dafny.Helpers.ToString(this._14);
      s += ")";
      return s;
    }
    public static _ITuple15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3, T4 _default_T4, T5 _default_T5, T6 _default_T6, T7 _default_T7, T8 _default_T8, T9 _default_T9, T10 _default_T10, T11 _default_T11, T12 _default_T12, T13 _default_T13, T14 _default_T14) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3, _default_T4, _default_T5, _default_T6, _default_T7, _default_T8, _default_T9, _default_T10, _default_T11, _default_T12, _default_T13, _default_T14);
    }
    public static Dafny.TypeDescriptor<_System._ITuple15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3, Dafny.TypeDescriptor<T4> _td_T4, Dafny.TypeDescriptor<T5> _td_T5, Dafny.TypeDescriptor<T6> _td_T6, Dafny.TypeDescriptor<T7> _td_T7, Dafny.TypeDescriptor<T8> _td_T8, Dafny.TypeDescriptor<T9> _td_T9, Dafny.TypeDescriptor<T10> _td_T10, Dafny.TypeDescriptor<T11> _td_T11, Dafny.TypeDescriptor<T12> _td_T12, Dafny.TypeDescriptor<T13> _td_T13, Dafny.TypeDescriptor<T14> _td_T14) {
      return new Dafny.TypeDescriptor<_System._ITuple15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>>(_System.Tuple15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default(), _td_T4.Default(), _td_T5.Default(), _td_T6.Default(), _td_T7.Default(), _td_T8.Default(), _td_T9.Default(), _td_T10.Default(), _td_T11.Default(), _td_T12.Default(), _td_T13.Default(), _td_T14.Default()));
    }
    public static _ITuple15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> create(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14) {
      return new Tuple15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
    public T4 dtor__4 {
      get {
        return this._4;
      }
    }
    public T5 dtor__5 {
      get {
        return this._5;
      }
    }
    public T6 dtor__6 {
      get {
        return this._6;
      }
    }
    public T7 dtor__7 {
      get {
        return this._7;
      }
    }
    public T8 dtor__8 {
      get {
        return this._8;
      }
    }
    public T9 dtor__9 {
      get {
        return this._9;
      }
    }
    public T10 dtor__10 {
      get {
        return this._10;
      }
    }
    public T11 dtor__11 {
      get {
        return this._11;
      }
    }
    public T12 dtor__12 {
      get {
        return this._12;
      }
    }
    public T13 dtor__13 {
      get {
        return this._13;
      }
    }
    public T14 dtor__14 {
      get {
        return this._14;
      }
    }
  }

  public interface _ITuple16<out T0, out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10, out T11, out T12, out T13, out T14, out T15> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    T4 dtor__4 { get; }
    T5 dtor__5 { get; }
    T6 dtor__6 { get; }
    T7 dtor__7 { get; }
    T8 dtor__8 { get; }
    T9 dtor__9 { get; }
    T10 dtor__10 { get; }
    T11 dtor__11 { get; }
    T12 dtor__12 { get; }
    T13 dtor__13 { get; }
    T14 dtor__14 { get; }
    T15 dtor__15 { get; }
    _ITuple16<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11, Func<T12, __T12> converter12, Func<T13, __T13> converter13, Func<T14, __T14> converter14, Func<T15, __T15> converter15);
  }
  public class Tuple16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> : _ITuple16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public readonly T4 _4;
    public readonly T5 _5;
    public readonly T6 _6;
    public readonly T7 _7;
    public readonly T8 _8;
    public readonly T9 _9;
    public readonly T10 _10;
    public readonly T11 _11;
    public readonly T12 _12;
    public readonly T13 _13;
    public readonly T14 _14;
    public readonly T15 _15;
    public Tuple16(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
      this._4 = _4;
      this._5 = _5;
      this._6 = _6;
      this._7 = _7;
      this._8 = _8;
      this._9 = _9;
      this._10 = _10;
      this._11 = _11;
      this._12 = _12;
      this._13 = _13;
      this._14 = _14;
      this._15 = _15;
    }
    public _ITuple16<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11, Func<T12, __T12> converter12, Func<T13, __T13> converter13, Func<T14, __T14> converter14, Func<T15, __T15> converter15) {
      if (this is _ITuple16<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15> dt) { return dt; }
      return new Tuple16<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15>(converter0(_0), converter1(_1), converter2(_2), converter3(_3), converter4(_4), converter5(_5), converter6(_6), converter7(_7), converter8(_8), converter9(_9), converter10(_10), converter11(_11), converter12(_12), converter13(_13), converter14(_14), converter15(_15));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3) && object.Equals(this._4, oth._4) && object.Equals(this._5, oth._5) && object.Equals(this._6, oth._6) && object.Equals(this._7, oth._7) && object.Equals(this._8, oth._8) && object.Equals(this._9, oth._9) && object.Equals(this._10, oth._10) && object.Equals(this._11, oth._11) && object.Equals(this._12, oth._12) && object.Equals(this._13, oth._13) && object.Equals(this._14, oth._14) && object.Equals(this._15, oth._15);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._4));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._5));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._6));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._7));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._8));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._9));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._10));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._11));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._12));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._13));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._14));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._15));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ", ";
      s += Dafny.Helpers.ToString(this._4);
      s += ", ";
      s += Dafny.Helpers.ToString(this._5);
      s += ", ";
      s += Dafny.Helpers.ToString(this._6);
      s += ", ";
      s += Dafny.Helpers.ToString(this._7);
      s += ", ";
      s += Dafny.Helpers.ToString(this._8);
      s += ", ";
      s += Dafny.Helpers.ToString(this._9);
      s += ", ";
      s += Dafny.Helpers.ToString(this._10);
      s += ", ";
      s += Dafny.Helpers.ToString(this._11);
      s += ", ";
      s += Dafny.Helpers.ToString(this._12);
      s += ", ";
      s += Dafny.Helpers.ToString(this._13);
      s += ", ";
      s += Dafny.Helpers.ToString(this._14);
      s += ", ";
      s += Dafny.Helpers.ToString(this._15);
      s += ")";
      return s;
    }
    public static _ITuple16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3, T4 _default_T4, T5 _default_T5, T6 _default_T6, T7 _default_T7, T8 _default_T8, T9 _default_T9, T10 _default_T10, T11 _default_T11, T12 _default_T12, T13 _default_T13, T14 _default_T14, T15 _default_T15) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3, _default_T4, _default_T5, _default_T6, _default_T7, _default_T8, _default_T9, _default_T10, _default_T11, _default_T12, _default_T13, _default_T14, _default_T15);
    }
    public static Dafny.TypeDescriptor<_System._ITuple16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3, Dafny.TypeDescriptor<T4> _td_T4, Dafny.TypeDescriptor<T5> _td_T5, Dafny.TypeDescriptor<T6> _td_T6, Dafny.TypeDescriptor<T7> _td_T7, Dafny.TypeDescriptor<T8> _td_T8, Dafny.TypeDescriptor<T9> _td_T9, Dafny.TypeDescriptor<T10> _td_T10, Dafny.TypeDescriptor<T11> _td_T11, Dafny.TypeDescriptor<T12> _td_T12, Dafny.TypeDescriptor<T13> _td_T13, Dafny.TypeDescriptor<T14> _td_T14, Dafny.TypeDescriptor<T15> _td_T15) {
      return new Dafny.TypeDescriptor<_System._ITuple16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>>(_System.Tuple16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default(), _td_T4.Default(), _td_T5.Default(), _td_T6.Default(), _td_T7.Default(), _td_T8.Default(), _td_T9.Default(), _td_T10.Default(), _td_T11.Default(), _td_T12.Default(), _td_T13.Default(), _td_T14.Default(), _td_T15.Default()));
    }
    public static _ITuple16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> create(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15) {
      return new Tuple16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
    public T4 dtor__4 {
      get {
        return this._4;
      }
    }
    public T5 dtor__5 {
      get {
        return this._5;
      }
    }
    public T6 dtor__6 {
      get {
        return this._6;
      }
    }
    public T7 dtor__7 {
      get {
        return this._7;
      }
    }
    public T8 dtor__8 {
      get {
        return this._8;
      }
    }
    public T9 dtor__9 {
      get {
        return this._9;
      }
    }
    public T10 dtor__10 {
      get {
        return this._10;
      }
    }
    public T11 dtor__11 {
      get {
        return this._11;
      }
    }
    public T12 dtor__12 {
      get {
        return this._12;
      }
    }
    public T13 dtor__13 {
      get {
        return this._13;
      }
    }
    public T14 dtor__14 {
      get {
        return this._14;
      }
    }
    public T15 dtor__15 {
      get {
        return this._15;
      }
    }
  }

  public interface _ITuple17<out T0, out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10, out T11, out T12, out T13, out T14, out T15, out T16> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    T4 dtor__4 { get; }
    T5 dtor__5 { get; }
    T6 dtor__6 { get; }
    T7 dtor__7 { get; }
    T8 dtor__8 { get; }
    T9 dtor__9 { get; }
    T10 dtor__10 { get; }
    T11 dtor__11 { get; }
    T12 dtor__12 { get; }
    T13 dtor__13 { get; }
    T14 dtor__14 { get; }
    T15 dtor__15 { get; }
    T16 dtor__16 { get; }
    _ITuple17<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11, Func<T12, __T12> converter12, Func<T13, __T13> converter13, Func<T14, __T14> converter14, Func<T15, __T15> converter15, Func<T16, __T16> converter16);
  }
  public class Tuple17<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> : _ITuple17<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public readonly T4 _4;
    public readonly T5 _5;
    public readonly T6 _6;
    public readonly T7 _7;
    public readonly T8 _8;
    public readonly T9 _9;
    public readonly T10 _10;
    public readonly T11 _11;
    public readonly T12 _12;
    public readonly T13 _13;
    public readonly T14 _14;
    public readonly T15 _15;
    public readonly T16 _16;
    public Tuple17(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, T16 _16) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
      this._4 = _4;
      this._5 = _5;
      this._6 = _6;
      this._7 = _7;
      this._8 = _8;
      this._9 = _9;
      this._10 = _10;
      this._11 = _11;
      this._12 = _12;
      this._13 = _13;
      this._14 = _14;
      this._15 = _15;
      this._16 = _16;
    }
    public _ITuple17<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11, Func<T12, __T12> converter12, Func<T13, __T13> converter13, Func<T14, __T14> converter14, Func<T15, __T15> converter15, Func<T16, __T16> converter16) {
      if (this is _ITuple17<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16> dt) { return dt; }
      return new Tuple17<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16>(converter0(_0), converter1(_1), converter2(_2), converter3(_3), converter4(_4), converter5(_5), converter6(_6), converter7(_7), converter8(_8), converter9(_9), converter10(_10), converter11(_11), converter12(_12), converter13(_13), converter14(_14), converter15(_15), converter16(_16));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple17<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3) && object.Equals(this._4, oth._4) && object.Equals(this._5, oth._5) && object.Equals(this._6, oth._6) && object.Equals(this._7, oth._7) && object.Equals(this._8, oth._8) && object.Equals(this._9, oth._9) && object.Equals(this._10, oth._10) && object.Equals(this._11, oth._11) && object.Equals(this._12, oth._12) && object.Equals(this._13, oth._13) && object.Equals(this._14, oth._14) && object.Equals(this._15, oth._15) && object.Equals(this._16, oth._16);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._4));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._5));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._6));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._7));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._8));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._9));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._10));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._11));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._12));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._13));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._14));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._15));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._16));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ", ";
      s += Dafny.Helpers.ToString(this._4);
      s += ", ";
      s += Dafny.Helpers.ToString(this._5);
      s += ", ";
      s += Dafny.Helpers.ToString(this._6);
      s += ", ";
      s += Dafny.Helpers.ToString(this._7);
      s += ", ";
      s += Dafny.Helpers.ToString(this._8);
      s += ", ";
      s += Dafny.Helpers.ToString(this._9);
      s += ", ";
      s += Dafny.Helpers.ToString(this._10);
      s += ", ";
      s += Dafny.Helpers.ToString(this._11);
      s += ", ";
      s += Dafny.Helpers.ToString(this._12);
      s += ", ";
      s += Dafny.Helpers.ToString(this._13);
      s += ", ";
      s += Dafny.Helpers.ToString(this._14);
      s += ", ";
      s += Dafny.Helpers.ToString(this._15);
      s += ", ";
      s += Dafny.Helpers.ToString(this._16);
      s += ")";
      return s;
    }
    public static _ITuple17<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3, T4 _default_T4, T5 _default_T5, T6 _default_T6, T7 _default_T7, T8 _default_T8, T9 _default_T9, T10 _default_T10, T11 _default_T11, T12 _default_T12, T13 _default_T13, T14 _default_T14, T15 _default_T15, T16 _default_T16) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3, _default_T4, _default_T5, _default_T6, _default_T7, _default_T8, _default_T9, _default_T10, _default_T11, _default_T12, _default_T13, _default_T14, _default_T15, _default_T16);
    }
    public static Dafny.TypeDescriptor<_System._ITuple17<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3, Dafny.TypeDescriptor<T4> _td_T4, Dafny.TypeDescriptor<T5> _td_T5, Dafny.TypeDescriptor<T6> _td_T6, Dafny.TypeDescriptor<T7> _td_T7, Dafny.TypeDescriptor<T8> _td_T8, Dafny.TypeDescriptor<T9> _td_T9, Dafny.TypeDescriptor<T10> _td_T10, Dafny.TypeDescriptor<T11> _td_T11, Dafny.TypeDescriptor<T12> _td_T12, Dafny.TypeDescriptor<T13> _td_T13, Dafny.TypeDescriptor<T14> _td_T14, Dafny.TypeDescriptor<T15> _td_T15, Dafny.TypeDescriptor<T16> _td_T16) {
      return new Dafny.TypeDescriptor<_System._ITuple17<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>>(_System.Tuple17<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default(), _td_T4.Default(), _td_T5.Default(), _td_T6.Default(), _td_T7.Default(), _td_T8.Default(), _td_T9.Default(), _td_T10.Default(), _td_T11.Default(), _td_T12.Default(), _td_T13.Default(), _td_T14.Default(), _td_T15.Default(), _td_T16.Default()));
    }
    public static _ITuple17<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> create(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, T16 _16) {
      return new Tuple17<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
    public T4 dtor__4 {
      get {
        return this._4;
      }
    }
    public T5 dtor__5 {
      get {
        return this._5;
      }
    }
    public T6 dtor__6 {
      get {
        return this._6;
      }
    }
    public T7 dtor__7 {
      get {
        return this._7;
      }
    }
    public T8 dtor__8 {
      get {
        return this._8;
      }
    }
    public T9 dtor__9 {
      get {
        return this._9;
      }
    }
    public T10 dtor__10 {
      get {
        return this._10;
      }
    }
    public T11 dtor__11 {
      get {
        return this._11;
      }
    }
    public T12 dtor__12 {
      get {
        return this._12;
      }
    }
    public T13 dtor__13 {
      get {
        return this._13;
      }
    }
    public T14 dtor__14 {
      get {
        return this._14;
      }
    }
    public T15 dtor__15 {
      get {
        return this._15;
      }
    }
    public T16 dtor__16 {
      get {
        return this._16;
      }
    }
  }

  public interface _ITuple18<out T0, out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10, out T11, out T12, out T13, out T14, out T15, out T16, out T17> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    T4 dtor__4 { get; }
    T5 dtor__5 { get; }
    T6 dtor__6 { get; }
    T7 dtor__7 { get; }
    T8 dtor__8 { get; }
    T9 dtor__9 { get; }
    T10 dtor__10 { get; }
    T11 dtor__11 { get; }
    T12 dtor__12 { get; }
    T13 dtor__13 { get; }
    T14 dtor__14 { get; }
    T15 dtor__15 { get; }
    T16 dtor__16 { get; }
    T17 dtor__17 { get; }
    _ITuple18<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11, Func<T12, __T12> converter12, Func<T13, __T13> converter13, Func<T14, __T14> converter14, Func<T15, __T15> converter15, Func<T16, __T16> converter16, Func<T17, __T17> converter17);
  }
  public class Tuple18<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> : _ITuple18<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public readonly T4 _4;
    public readonly T5 _5;
    public readonly T6 _6;
    public readonly T7 _7;
    public readonly T8 _8;
    public readonly T9 _9;
    public readonly T10 _10;
    public readonly T11 _11;
    public readonly T12 _12;
    public readonly T13 _13;
    public readonly T14 _14;
    public readonly T15 _15;
    public readonly T16 _16;
    public readonly T17 _17;
    public Tuple18(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, T16 _16, T17 _17) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
      this._4 = _4;
      this._5 = _5;
      this._6 = _6;
      this._7 = _7;
      this._8 = _8;
      this._9 = _9;
      this._10 = _10;
      this._11 = _11;
      this._12 = _12;
      this._13 = _13;
      this._14 = _14;
      this._15 = _15;
      this._16 = _16;
      this._17 = _17;
    }
    public _ITuple18<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11, Func<T12, __T12> converter12, Func<T13, __T13> converter13, Func<T14, __T14> converter14, Func<T15, __T15> converter15, Func<T16, __T16> converter16, Func<T17, __T17> converter17) {
      if (this is _ITuple18<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17> dt) { return dt; }
      return new Tuple18<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17>(converter0(_0), converter1(_1), converter2(_2), converter3(_3), converter4(_4), converter5(_5), converter6(_6), converter7(_7), converter8(_8), converter9(_9), converter10(_10), converter11(_11), converter12(_12), converter13(_13), converter14(_14), converter15(_15), converter16(_16), converter17(_17));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple18<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3) && object.Equals(this._4, oth._4) && object.Equals(this._5, oth._5) && object.Equals(this._6, oth._6) && object.Equals(this._7, oth._7) && object.Equals(this._8, oth._8) && object.Equals(this._9, oth._9) && object.Equals(this._10, oth._10) && object.Equals(this._11, oth._11) && object.Equals(this._12, oth._12) && object.Equals(this._13, oth._13) && object.Equals(this._14, oth._14) && object.Equals(this._15, oth._15) && object.Equals(this._16, oth._16) && object.Equals(this._17, oth._17);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._4));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._5));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._6));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._7));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._8));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._9));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._10));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._11));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._12));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._13));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._14));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._15));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._16));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._17));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ", ";
      s += Dafny.Helpers.ToString(this._4);
      s += ", ";
      s += Dafny.Helpers.ToString(this._5);
      s += ", ";
      s += Dafny.Helpers.ToString(this._6);
      s += ", ";
      s += Dafny.Helpers.ToString(this._7);
      s += ", ";
      s += Dafny.Helpers.ToString(this._8);
      s += ", ";
      s += Dafny.Helpers.ToString(this._9);
      s += ", ";
      s += Dafny.Helpers.ToString(this._10);
      s += ", ";
      s += Dafny.Helpers.ToString(this._11);
      s += ", ";
      s += Dafny.Helpers.ToString(this._12);
      s += ", ";
      s += Dafny.Helpers.ToString(this._13);
      s += ", ";
      s += Dafny.Helpers.ToString(this._14);
      s += ", ";
      s += Dafny.Helpers.ToString(this._15);
      s += ", ";
      s += Dafny.Helpers.ToString(this._16);
      s += ", ";
      s += Dafny.Helpers.ToString(this._17);
      s += ")";
      return s;
    }
    public static _ITuple18<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3, T4 _default_T4, T5 _default_T5, T6 _default_T6, T7 _default_T7, T8 _default_T8, T9 _default_T9, T10 _default_T10, T11 _default_T11, T12 _default_T12, T13 _default_T13, T14 _default_T14, T15 _default_T15, T16 _default_T16, T17 _default_T17) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3, _default_T4, _default_T5, _default_T6, _default_T7, _default_T8, _default_T9, _default_T10, _default_T11, _default_T12, _default_T13, _default_T14, _default_T15, _default_T16, _default_T17);
    }
    public static Dafny.TypeDescriptor<_System._ITuple18<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3, Dafny.TypeDescriptor<T4> _td_T4, Dafny.TypeDescriptor<T5> _td_T5, Dafny.TypeDescriptor<T6> _td_T6, Dafny.TypeDescriptor<T7> _td_T7, Dafny.TypeDescriptor<T8> _td_T8, Dafny.TypeDescriptor<T9> _td_T9, Dafny.TypeDescriptor<T10> _td_T10, Dafny.TypeDescriptor<T11> _td_T11, Dafny.TypeDescriptor<T12> _td_T12, Dafny.TypeDescriptor<T13> _td_T13, Dafny.TypeDescriptor<T14> _td_T14, Dafny.TypeDescriptor<T15> _td_T15, Dafny.TypeDescriptor<T16> _td_T16, Dafny.TypeDescriptor<T17> _td_T17) {
      return new Dafny.TypeDescriptor<_System._ITuple18<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>>(_System.Tuple18<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default(), _td_T4.Default(), _td_T5.Default(), _td_T6.Default(), _td_T7.Default(), _td_T8.Default(), _td_T9.Default(), _td_T10.Default(), _td_T11.Default(), _td_T12.Default(), _td_T13.Default(), _td_T14.Default(), _td_T15.Default(), _td_T16.Default(), _td_T17.Default()));
    }
    public static _ITuple18<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> create(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, T16 _16, T17 _17) {
      return new Tuple18<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
    public T4 dtor__4 {
      get {
        return this._4;
      }
    }
    public T5 dtor__5 {
      get {
        return this._5;
      }
    }
    public T6 dtor__6 {
      get {
        return this._6;
      }
    }
    public T7 dtor__7 {
      get {
        return this._7;
      }
    }
    public T8 dtor__8 {
      get {
        return this._8;
      }
    }
    public T9 dtor__9 {
      get {
        return this._9;
      }
    }
    public T10 dtor__10 {
      get {
        return this._10;
      }
    }
    public T11 dtor__11 {
      get {
        return this._11;
      }
    }
    public T12 dtor__12 {
      get {
        return this._12;
      }
    }
    public T13 dtor__13 {
      get {
        return this._13;
      }
    }
    public T14 dtor__14 {
      get {
        return this._14;
      }
    }
    public T15 dtor__15 {
      get {
        return this._15;
      }
    }
    public T16 dtor__16 {
      get {
        return this._16;
      }
    }
    public T17 dtor__17 {
      get {
        return this._17;
      }
    }
  }

  public interface _ITuple19<out T0, out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10, out T11, out T12, out T13, out T14, out T15, out T16, out T17, out T18> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    T4 dtor__4 { get; }
    T5 dtor__5 { get; }
    T6 dtor__6 { get; }
    T7 dtor__7 { get; }
    T8 dtor__8 { get; }
    T9 dtor__9 { get; }
    T10 dtor__10 { get; }
    T11 dtor__11 { get; }
    T12 dtor__12 { get; }
    T13 dtor__13 { get; }
    T14 dtor__14 { get; }
    T15 dtor__15 { get; }
    T16 dtor__16 { get; }
    T17 dtor__17 { get; }
    T18 dtor__18 { get; }
    _ITuple19<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17, __T18> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17, __T18>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11, Func<T12, __T12> converter12, Func<T13, __T13> converter13, Func<T14, __T14> converter14, Func<T15, __T15> converter15, Func<T16, __T16> converter16, Func<T17, __T17> converter17, Func<T18, __T18> converter18);
  }
  public class Tuple19<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> : _ITuple19<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public readonly T4 _4;
    public readonly T5 _5;
    public readonly T6 _6;
    public readonly T7 _7;
    public readonly T8 _8;
    public readonly T9 _9;
    public readonly T10 _10;
    public readonly T11 _11;
    public readonly T12 _12;
    public readonly T13 _13;
    public readonly T14 _14;
    public readonly T15 _15;
    public readonly T16 _16;
    public readonly T17 _17;
    public readonly T18 _18;
    public Tuple19(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, T16 _16, T17 _17, T18 _18) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
      this._4 = _4;
      this._5 = _5;
      this._6 = _6;
      this._7 = _7;
      this._8 = _8;
      this._9 = _9;
      this._10 = _10;
      this._11 = _11;
      this._12 = _12;
      this._13 = _13;
      this._14 = _14;
      this._15 = _15;
      this._16 = _16;
      this._17 = _17;
      this._18 = _18;
    }
    public _ITuple19<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17, __T18> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17, __T18>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11, Func<T12, __T12> converter12, Func<T13, __T13> converter13, Func<T14, __T14> converter14, Func<T15, __T15> converter15, Func<T16, __T16> converter16, Func<T17, __T17> converter17, Func<T18, __T18> converter18) {
      if (this is _ITuple19<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17, __T18> dt) { return dt; }
      return new Tuple19<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17, __T18>(converter0(_0), converter1(_1), converter2(_2), converter3(_3), converter4(_4), converter5(_5), converter6(_6), converter7(_7), converter8(_8), converter9(_9), converter10(_10), converter11(_11), converter12(_12), converter13(_13), converter14(_14), converter15(_15), converter16(_16), converter17(_17), converter18(_18));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple19<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3) && object.Equals(this._4, oth._4) && object.Equals(this._5, oth._5) && object.Equals(this._6, oth._6) && object.Equals(this._7, oth._7) && object.Equals(this._8, oth._8) && object.Equals(this._9, oth._9) && object.Equals(this._10, oth._10) && object.Equals(this._11, oth._11) && object.Equals(this._12, oth._12) && object.Equals(this._13, oth._13) && object.Equals(this._14, oth._14) && object.Equals(this._15, oth._15) && object.Equals(this._16, oth._16) && object.Equals(this._17, oth._17) && object.Equals(this._18, oth._18);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._4));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._5));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._6));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._7));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._8));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._9));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._10));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._11));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._12));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._13));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._14));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._15));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._16));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._17));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._18));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ", ";
      s += Dafny.Helpers.ToString(this._4);
      s += ", ";
      s += Dafny.Helpers.ToString(this._5);
      s += ", ";
      s += Dafny.Helpers.ToString(this._6);
      s += ", ";
      s += Dafny.Helpers.ToString(this._7);
      s += ", ";
      s += Dafny.Helpers.ToString(this._8);
      s += ", ";
      s += Dafny.Helpers.ToString(this._9);
      s += ", ";
      s += Dafny.Helpers.ToString(this._10);
      s += ", ";
      s += Dafny.Helpers.ToString(this._11);
      s += ", ";
      s += Dafny.Helpers.ToString(this._12);
      s += ", ";
      s += Dafny.Helpers.ToString(this._13);
      s += ", ";
      s += Dafny.Helpers.ToString(this._14);
      s += ", ";
      s += Dafny.Helpers.ToString(this._15);
      s += ", ";
      s += Dafny.Helpers.ToString(this._16);
      s += ", ";
      s += Dafny.Helpers.ToString(this._17);
      s += ", ";
      s += Dafny.Helpers.ToString(this._18);
      s += ")";
      return s;
    }
    public static _ITuple19<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3, T4 _default_T4, T5 _default_T5, T6 _default_T6, T7 _default_T7, T8 _default_T8, T9 _default_T9, T10 _default_T10, T11 _default_T11, T12 _default_T12, T13 _default_T13, T14 _default_T14, T15 _default_T15, T16 _default_T16, T17 _default_T17, T18 _default_T18) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3, _default_T4, _default_T5, _default_T6, _default_T7, _default_T8, _default_T9, _default_T10, _default_T11, _default_T12, _default_T13, _default_T14, _default_T15, _default_T16, _default_T17, _default_T18);
    }
    public static Dafny.TypeDescriptor<_System._ITuple19<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3, Dafny.TypeDescriptor<T4> _td_T4, Dafny.TypeDescriptor<T5> _td_T5, Dafny.TypeDescriptor<T6> _td_T6, Dafny.TypeDescriptor<T7> _td_T7, Dafny.TypeDescriptor<T8> _td_T8, Dafny.TypeDescriptor<T9> _td_T9, Dafny.TypeDescriptor<T10> _td_T10, Dafny.TypeDescriptor<T11> _td_T11, Dafny.TypeDescriptor<T12> _td_T12, Dafny.TypeDescriptor<T13> _td_T13, Dafny.TypeDescriptor<T14> _td_T14, Dafny.TypeDescriptor<T15> _td_T15, Dafny.TypeDescriptor<T16> _td_T16, Dafny.TypeDescriptor<T17> _td_T17, Dafny.TypeDescriptor<T18> _td_T18) {
      return new Dafny.TypeDescriptor<_System._ITuple19<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>>(_System.Tuple19<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default(), _td_T4.Default(), _td_T5.Default(), _td_T6.Default(), _td_T7.Default(), _td_T8.Default(), _td_T9.Default(), _td_T10.Default(), _td_T11.Default(), _td_T12.Default(), _td_T13.Default(), _td_T14.Default(), _td_T15.Default(), _td_T16.Default(), _td_T17.Default(), _td_T18.Default()));
    }
    public static _ITuple19<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> create(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, T16 _16, T17 _17, T18 _18) {
      return new Tuple19<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
    public T4 dtor__4 {
      get {
        return this._4;
      }
    }
    public T5 dtor__5 {
      get {
        return this._5;
      }
    }
    public T6 dtor__6 {
      get {
        return this._6;
      }
    }
    public T7 dtor__7 {
      get {
        return this._7;
      }
    }
    public T8 dtor__8 {
      get {
        return this._8;
      }
    }
    public T9 dtor__9 {
      get {
        return this._9;
      }
    }
    public T10 dtor__10 {
      get {
        return this._10;
      }
    }
    public T11 dtor__11 {
      get {
        return this._11;
      }
    }
    public T12 dtor__12 {
      get {
        return this._12;
      }
    }
    public T13 dtor__13 {
      get {
        return this._13;
      }
    }
    public T14 dtor__14 {
      get {
        return this._14;
      }
    }
    public T15 dtor__15 {
      get {
        return this._15;
      }
    }
    public T16 dtor__16 {
      get {
        return this._16;
      }
    }
    public T17 dtor__17 {
      get {
        return this._17;
      }
    }
    public T18 dtor__18 {
      get {
        return this._18;
      }
    }
  }

  public interface _ITuple20<out T0, out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10, out T11, out T12, out T13, out T14, out T15, out T16, out T17, out T18, out T19> {
    T0 dtor__0 { get; }
    T1 dtor__1 { get; }
    T2 dtor__2 { get; }
    T3 dtor__3 { get; }
    T4 dtor__4 { get; }
    T5 dtor__5 { get; }
    T6 dtor__6 { get; }
    T7 dtor__7 { get; }
    T8 dtor__8 { get; }
    T9 dtor__9 { get; }
    T10 dtor__10 { get; }
    T11 dtor__11 { get; }
    T12 dtor__12 { get; }
    T13 dtor__13 { get; }
    T14 dtor__14 { get; }
    T15 dtor__15 { get; }
    T16 dtor__16 { get; }
    T17 dtor__17 { get; }
    T18 dtor__18 { get; }
    T19 dtor__19 { get; }
    _ITuple20<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17, __T18, __T19> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17, __T18, __T19>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11, Func<T12, __T12> converter12, Func<T13, __T13> converter13, Func<T14, __T14> converter14, Func<T15, __T15> converter15, Func<T16, __T16> converter16, Func<T17, __T17> converter17, Func<T18, __T18> converter18, Func<T19, __T19> converter19);
  }
  public class Tuple20<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> : _ITuple20<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public readonly T3 _3;
    public readonly T4 _4;
    public readonly T5 _5;
    public readonly T6 _6;
    public readonly T7 _7;
    public readonly T8 _8;
    public readonly T9 _9;
    public readonly T10 _10;
    public readonly T11 _11;
    public readonly T12 _12;
    public readonly T13 _13;
    public readonly T14 _14;
    public readonly T15 _15;
    public readonly T16 _16;
    public readonly T17 _17;
    public readonly T18 _18;
    public readonly T19 _19;
    public Tuple20(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, T16 _16, T17 _17, T18 _18, T19 _19) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
      this._4 = _4;
      this._5 = _5;
      this._6 = _6;
      this._7 = _7;
      this._8 = _8;
      this._9 = _9;
      this._10 = _10;
      this._11 = _11;
      this._12 = _12;
      this._13 = _13;
      this._14 = _14;
      this._15 = _15;
      this._16 = _16;
      this._17 = _17;
      this._18 = _18;
      this._19 = _19;
    }
    public _ITuple20<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17, __T18, __T19> DowncastClone<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17, __T18, __T19>(Func<T0, __T0> converter0, Func<T1, __T1> converter1, Func<T2, __T2> converter2, Func<T3, __T3> converter3, Func<T4, __T4> converter4, Func<T5, __T5> converter5, Func<T6, __T6> converter6, Func<T7, __T7> converter7, Func<T8, __T8> converter8, Func<T9, __T9> converter9, Func<T10, __T10> converter10, Func<T11, __T11> converter11, Func<T12, __T12> converter12, Func<T13, __T13> converter13, Func<T14, __T14> converter14, Func<T15, __T15> converter15, Func<T16, __T16> converter16, Func<T17, __T17> converter17, Func<T18, __T18> converter18, Func<T19, __T19> converter19) {
      if (this is _ITuple20<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17, __T18, __T19> dt) { return dt; }
      return new Tuple20<__T0, __T1, __T2, __T3, __T4, __T5, __T6, __T7, __T8, __T9, __T10, __T11, __T12, __T13, __T14, __T15, __T16, __T17, __T18, __T19>(converter0(_0), converter1(_1), converter2(_2), converter3(_3), converter4(_4), converter5(_5), converter6(_6), converter7(_7), converter8(_8), converter9(_9), converter10(_10), converter11(_11), converter12(_12), converter13(_13), converter14(_14), converter15(_15), converter16(_16), converter17(_17), converter18(_18), converter19(_19));
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple20<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2) && object.Equals(this._3, oth._3) && object.Equals(this._4, oth._4) && object.Equals(this._5, oth._5) && object.Equals(this._6, oth._6) && object.Equals(this._7, oth._7) && object.Equals(this._8, oth._8) && object.Equals(this._9, oth._9) && object.Equals(this._10, oth._10) && object.Equals(this._11, oth._11) && object.Equals(this._12, oth._12) && object.Equals(this._13, oth._13) && object.Equals(this._14, oth._14) && object.Equals(this._15, oth._15) && object.Equals(this._16, oth._16) && object.Equals(this._17, oth._17) && object.Equals(this._18, oth._18) && object.Equals(this._19, oth._19);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._3));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._4));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._5));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._6));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._7));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._8));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._9));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._10));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._11));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._12));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._13));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._14));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._15));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._16));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._17));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._18));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._19));
      return (int)hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._3);
      s += ", ";
      s += Dafny.Helpers.ToString(this._4);
      s += ", ";
      s += Dafny.Helpers.ToString(this._5);
      s += ", ";
      s += Dafny.Helpers.ToString(this._6);
      s += ", ";
      s += Dafny.Helpers.ToString(this._7);
      s += ", ";
      s += Dafny.Helpers.ToString(this._8);
      s += ", ";
      s += Dafny.Helpers.ToString(this._9);
      s += ", ";
      s += Dafny.Helpers.ToString(this._10);
      s += ", ";
      s += Dafny.Helpers.ToString(this._11);
      s += ", ";
      s += Dafny.Helpers.ToString(this._12);
      s += ", ";
      s += Dafny.Helpers.ToString(this._13);
      s += ", ";
      s += Dafny.Helpers.ToString(this._14);
      s += ", ";
      s += Dafny.Helpers.ToString(this._15);
      s += ", ";
      s += Dafny.Helpers.ToString(this._16);
      s += ", ";
      s += Dafny.Helpers.ToString(this._17);
      s += ", ";
      s += Dafny.Helpers.ToString(this._18);
      s += ", ";
      s += Dafny.Helpers.ToString(this._19);
      s += ")";
      return s;
    }
    public static _ITuple20<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2, T3 _default_T3, T4 _default_T4, T5 _default_T5, T6 _default_T6, T7 _default_T7, T8 _default_T8, T9 _default_T9, T10 _default_T10, T11 _default_T11, T12 _default_T12, T13 _default_T13, T14 _default_T14, T15 _default_T15, T16 _default_T16, T17 _default_T17, T18 _default_T18, T19 _default_T19) {
      return create(_default_T0, _default_T1, _default_T2, _default_T3, _default_T4, _default_T5, _default_T6, _default_T7, _default_T8, _default_T9, _default_T10, _default_T11, _default_T12, _default_T13, _default_T14, _default_T15, _default_T16, _default_T17, _default_T18, _default_T19);
    }
    public static Dafny.TypeDescriptor<_System._ITuple20<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2, Dafny.TypeDescriptor<T3> _td_T3, Dafny.TypeDescriptor<T4> _td_T4, Dafny.TypeDescriptor<T5> _td_T5, Dafny.TypeDescriptor<T6> _td_T6, Dafny.TypeDescriptor<T7> _td_T7, Dafny.TypeDescriptor<T8> _td_T8, Dafny.TypeDescriptor<T9> _td_T9, Dafny.TypeDescriptor<T10> _td_T10, Dafny.TypeDescriptor<T11> _td_T11, Dafny.TypeDescriptor<T12> _td_T12, Dafny.TypeDescriptor<T13> _td_T13, Dafny.TypeDescriptor<T14> _td_T14, Dafny.TypeDescriptor<T15> _td_T15, Dafny.TypeDescriptor<T16> _td_T16, Dafny.TypeDescriptor<T17> _td_T17, Dafny.TypeDescriptor<T18> _td_T18, Dafny.TypeDescriptor<T19> _td_T19) {
      return new Dafny.TypeDescriptor<_System._ITuple20<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>>(_System.Tuple20<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default(), _td_T3.Default(), _td_T4.Default(), _td_T5.Default(), _td_T6.Default(), _td_T7.Default(), _td_T8.Default(), _td_T9.Default(), _td_T10.Default(), _td_T11.Default(), _td_T12.Default(), _td_T13.Default(), _td_T14.Default(), _td_T15.Default(), _td_T16.Default(), _td_T17.Default(), _td_T18.Default(), _td_T19.Default()));
    }
    public static _ITuple20<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> create(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, T16 _16, T17 _17, T18 _18, T19 _19) {
      return new Tuple20<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
    public T3 dtor__3 {
      get {
        return this._3;
      }
    }
    public T4 dtor__4 {
      get {
        return this._4;
      }
    }
    public T5 dtor__5 {
      get {
        return this._5;
      }
    }
    public T6 dtor__6 {
      get {
        return this._6;
      }
    }
    public T7 dtor__7 {
      get {
        return this._7;
      }
    }
    public T8 dtor__8 {
      get {
        return this._8;
      }
    }
    public T9 dtor__9 {
      get {
        return this._9;
      }
    }
    public T10 dtor__10 {
      get {
        return this._10;
      }
    }
    public T11 dtor__11 {
      get {
        return this._11;
      }
    }
    public T12 dtor__12 {
      get {
        return this._12;
      }
    }
    public T13 dtor__13 {
      get {
        return this._13;
      }
    }
    public T14 dtor__14 {
      get {
        return this._14;
      }
    }
    public T15 dtor__15 {
      get {
        return this._15;
      }
    }
    public T16 dtor__16 {
      get {
        return this._16;
      }
    }
    public T17 dtor__17 {
      get {
        return this._17;
      }
    }
    public T18 dtor__18 {
      get {
        return this._18;
      }
    }
    public T19 dtor__19 {
      get {
        return this._19;
      }
    }
  }
} // end of namespace _System
namespace Dafny {
  internal class ArrayHelpers {
    public static T[] InitNewArray1<T>(T z, BigInteger size0) {
      int s0 = (int)size0;
      T[] a = new T[s0];
      for (int i0 = 0; i0 < s0; i0++) {
        a[i0] = z;
      }
      return a;
    }
  }
} // end of namespace Dafny
internal static class FuncExtensions {
  public static Func<U, UResult> DowncastClone<T, TResult, U, UResult>(this Func<T, TResult> F, Func<U, T> ArgConv, Func<TResult, UResult> ResConv) {
    return arg => ResConv(F(ArgConv(arg)));
  }
  public static Func<UResult> DowncastClone<TResult, UResult>(this Func<TResult> F, Func<TResult, UResult> ResConv) {
    return () => ResConv(F());
  }
  public static Func<U1, U2, U3, UResult> DowncastClone<T1, T2, T3, TResult, U1, U2, U3, UResult>(this Func<T1, T2, T3, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<U3, T3> ArgConv3, Func<TResult, UResult> ResConv) {
    return (arg1, arg2, arg3) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2), ArgConv3(arg3)));
  }
  public static Func<U1, U2, UResult> DowncastClone<T1, T2, TResult, U1, U2, UResult>(this Func<T1, T2, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<TResult, UResult> ResConv) {
    return (arg1, arg2) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2)));
  }
  public static Func<U1, U2, U3, U4, UResult> DowncastClone<T1, T2, T3, T4, TResult, U1, U2, U3, U4, UResult>(this Func<T1, T2, T3, T4, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<U3, T3> ArgConv3, Func<U4, T4> ArgConv4, Func<TResult, UResult> ResConv) {
    return (arg1, arg2, arg3, arg4) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2), ArgConv3(arg3), ArgConv4(arg4)));
  }
  public static Func<U1, U2, U3, U4, U5, UResult> DowncastClone<T1, T2, T3, T4, T5, TResult, U1, U2, U3, U4, U5, UResult>(this Func<T1, T2, T3, T4, T5, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<U3, T3> ArgConv3, Func<U4, T4> ArgConv4, Func<U5, T5> ArgConv5, Func<TResult, UResult> ResConv) {
    return (arg1, arg2, arg3, arg4, arg5) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2), ArgConv3(arg3), ArgConv4(arg4), ArgConv5(arg5)));
  }
  public static Func<U1, U2, U3, U4, U5, U6, UResult> DowncastClone<T1, T2, T3, T4, T5, T6, TResult, U1, U2, U3, U4, U5, U6, UResult>(this Func<T1, T2, T3, T4, T5, T6, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<U3, T3> ArgConv3, Func<U4, T4> ArgConv4, Func<U5, T5> ArgConv5, Func<U6, T6> ArgConv6, Func<TResult, UResult> ResConv) {
    return (arg1, arg2, arg3, arg4, arg5, arg6) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2), ArgConv3(arg3), ArgConv4(arg4), ArgConv5(arg5), ArgConv6(arg6)));
  }
}
namespace _System {

  public partial class nat {
    private static readonly Dafny.TypeDescriptor<BigInteger> _TYPE = new Dafny.TypeDescriptor<BigInteger>(BigInteger.Zero);
    public static Dafny.TypeDescriptor<BigInteger> _TypeDescriptor() {
      return _TYPE;
    }
  }
} // end of namespace _System
namespace Native____NativeTypes__s_Compile {

  public partial class @sbyte {
    public static System.Collections.Generic.IEnumerable<sbyte> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (sbyte)j; }
    }
    private static readonly Dafny.TypeDescriptor<sbyte> _TYPE = new Dafny.TypeDescriptor<sbyte>(0);
    public static Dafny.TypeDescriptor<sbyte> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class @byte {
    public static System.Collections.Generic.IEnumerable<byte> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (byte)j; }
    }
    private static readonly Dafny.TypeDescriptor<byte> _TYPE = new Dafny.TypeDescriptor<byte>(0);
    public static Dafny.TypeDescriptor<byte> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class int16 {
    public static System.Collections.Generic.IEnumerable<short> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (short)j; }
    }
    private static readonly Dafny.TypeDescriptor<short> _TYPE = new Dafny.TypeDescriptor<short>(0);
    public static Dafny.TypeDescriptor<short> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class uint16 {
    public static System.Collections.Generic.IEnumerable<ushort> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (ushort)j; }
    }
    private static readonly Dafny.TypeDescriptor<ushort> _TYPE = new Dafny.TypeDescriptor<ushort>(0);
    public static Dafny.TypeDescriptor<ushort> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class int32 {
    public static System.Collections.Generic.IEnumerable<int> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (int)j; }
    }
    private static readonly Dafny.TypeDescriptor<int> _TYPE = new Dafny.TypeDescriptor<int>(0);
    public static Dafny.TypeDescriptor<int> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class uint32 {
    public static System.Collections.Generic.IEnumerable<uint> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (uint)j; }
    }
    private static readonly Dafny.TypeDescriptor<uint> _TYPE = new Dafny.TypeDescriptor<uint>(0);
    public static Dafny.TypeDescriptor<uint> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class int64 {
    public static System.Collections.Generic.IEnumerable<long> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (long)j; }
    }
    private static readonly Dafny.TypeDescriptor<long> _TYPE = new Dafny.TypeDescriptor<long>(0);
    public static Dafny.TypeDescriptor<long> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class uint64 {
    public static System.Collections.Generic.IEnumerable<ulong> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (ulong)j; }
    }
    private static readonly Dafny.TypeDescriptor<ulong> _TYPE = new Dafny.TypeDescriptor<ulong>(0);
    public static Dafny.TypeDescriptor<ulong> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class nat8 {
    public static System.Collections.Generic.IEnumerable<sbyte> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (sbyte)j; }
    }
    private static readonly Dafny.TypeDescriptor<sbyte> _TYPE = new Dafny.TypeDescriptor<sbyte>(0);
    public static Dafny.TypeDescriptor<sbyte> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class nat16 {
    public static System.Collections.Generic.IEnumerable<short> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (short)j; }
    }
    private static readonly Dafny.TypeDescriptor<short> _TYPE = new Dafny.TypeDescriptor<short>(0);
    public static Dafny.TypeDescriptor<short> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class nat32 {
    public static System.Collections.Generic.IEnumerable<int> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (int)j; }
    }
    private static readonly Dafny.TypeDescriptor<int> _TYPE = new Dafny.TypeDescriptor<int>(0);
    public static Dafny.TypeDescriptor<int> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class nat64 {
    public static System.Collections.Generic.IEnumerable<long> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (long)j; }
    }
    private static readonly Dafny.TypeDescriptor<long> _TYPE = new Dafny.TypeDescriptor<long>(0);
    public static Dafny.TypeDescriptor<long> _TypeDescriptor() {
      return _TYPE;
    }
  }

} // end of namespace Native____NativeTypes__s_Compile
namespace Collections____Maps2__s_Compile {

  public partial class __default {
    public static Dafny.ISet<__KT> mapdomain<__KT, __VT>(Dafny.IMap<__KT,__VT> m) {
      return Dafny.Helpers.Id<Func<Dafny.IMap<__KT,__VT>, Dafny.ISet<__KT>>>((_0_m) => ((System.Func<Dafny.ISet<__KT>>)(() => {
        var _coll0 = new System.Collections.Generic.List<__KT>();
        foreach (__KT _compr_0 in (_0_m).Keys.Elements) {
          __KT _1_k = (__KT)_compr_0;
          if ((_0_m).Contains((_1_k))) {
            _coll0.Add(_1_k);
          }
        }
        return Dafny.Set<__KT>.FromCollection(_coll0);
      }))())(m);
    }
    public static Dafny.IMap<__KT,__VT> mapremove<__KT, __VT>(Dafny.IMap<__KT,__VT> m, __KT k)
    {
      return Dafny.Helpers.Id<Func<Dafny.IMap<__KT,__VT>, __KT, Dafny.IMap<__KT,__VT>>>((_2_m, _3_k) => ((System.Func<Dafny.IMap<__KT,__VT>>)(() => {
        var _coll1 = new System.Collections.Generic.List<Dafny.Pair<__KT,__VT>>();
        foreach (__KT _compr_1 in (_2_m).Keys.Elements) {
          __KT _4_ki = (__KT)_compr_1;
          if (((_2_m).Contains((_4_ki))) && (!object.Equals(_4_ki, _3_k))) {
            _coll1.Add(new Dafny.Pair<__KT,__VT>(_4_ki, Dafny.Map<__KT, __VT>.Select(_2_m,_4_ki)));
          }
        }
        return Dafny.Map<__KT,__VT>.FromCollection(_coll1);
      }))())(m, k);
    }
  }
} // end of namespace Collections____Maps2__s_Compile
namespace Temporal____Temporal__s_Compile {

} // end of namespace Temporal____Temporal__s_Compile
namespace Environment__s_Compile {

  public interface _ILPacket<IdType, MessageType> {
    bool is_LPacket { get; }
    IdType dtor_dst { get; }
    IdType dtor_src { get; }
    MessageType dtor_msg { get; }
    _ILPacket<__IdType, __MessageType> DowncastClone<__IdType, __MessageType>(Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1);
  }
  public class LPacket<IdType, MessageType> : _ILPacket<IdType, MessageType> {
    public readonly IdType _dst;
    public readonly IdType _src;
    public readonly MessageType _msg;
    public LPacket(IdType dst, IdType src, MessageType msg) {
      this._dst = dst;
      this._src = src;
      this._msg = msg;
    }
    public _ILPacket<__IdType, __MessageType> DowncastClone<__IdType, __MessageType>(Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1) {
      if (this is _ILPacket<__IdType, __MessageType> dt) { return dt; }
      return new LPacket<__IdType, __MessageType>(converter0(_dst), converter0(_src), converter1(_msg));
    }
    public override bool Equals(object other) {
      var oth = other as Environment__s_Compile.LPacket<IdType, MessageType>;
      return oth != null && object.Equals(this._dst, oth._dst) && object.Equals(this._src, oth._src) && object.Equals(this._msg, oth._msg);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._dst));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._src));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._msg));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Environment__s_Compile.LPacket.LPacket";
      s += "(";
      s += Dafny.Helpers.ToString(this._dst);
      s += ", ";
      s += Dafny.Helpers.ToString(this._src);
      s += ", ";
      s += Dafny.Helpers.ToString(this._msg);
      s += ")";
      return s;
    }
    public static Environment__s_Compile._ILPacket<IdType, MessageType> Default(IdType _default_IdType, MessageType _default_MessageType) {
      return create(_default_IdType, _default_IdType, _default_MessageType);
    }
    public static Dafny.TypeDescriptor<Environment__s_Compile._ILPacket<IdType, MessageType>> _TypeDescriptor(Dafny.TypeDescriptor<IdType> _td_IdType, Dafny.TypeDescriptor<MessageType> _td_MessageType) {
      return new Dafny.TypeDescriptor<Environment__s_Compile._ILPacket<IdType, MessageType>>(Environment__s_Compile.LPacket<IdType, MessageType>.Default(_td_IdType.Default(), _td_MessageType.Default()));
    }
    public static _ILPacket<IdType, MessageType> create(IdType dst, IdType src, MessageType msg) {
      return new LPacket<IdType, MessageType>(dst, src, msg);
    }
    public static _ILPacket<IdType, MessageType> create_LPacket(IdType dst, IdType src, MessageType msg) {
      return create(dst, src, msg);
    }
    public bool is_LPacket { get { return true; } }
    public IdType dtor_dst {
      get {
        return this._dst;
      }
    }
    public IdType dtor_src {
      get {
        return this._src;
      }
    }
    public MessageType dtor_msg {
      get {
        return this._msg;
      }
    }
  }

  public interface _ILIoOp<IdType, MessageType> {
    bool is_LIoOpSend { get; }
    bool is_LIoOpReceive { get; }
    bool is_LIoOpTimeoutReceive { get; }
    bool is_LIoOpReadClock { get; }
    Environment__s_Compile._ILPacket<IdType, MessageType> dtor_s { get; }
    Environment__s_Compile._ILPacket<IdType, MessageType> dtor_r { get; }
    BigInteger dtor_t { get; }
    _ILIoOp<__IdType, __MessageType> DowncastClone<__IdType, __MessageType>(Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1);
  }
  public abstract class LIoOp<IdType, MessageType> : _ILIoOp<IdType, MessageType> {
    public LIoOp() { }
    public static Environment__s_Compile._ILIoOp<IdType, MessageType> Default() {
      return create_LIoOpTimeoutReceive();
    }
    public static Dafny.TypeDescriptor<Environment__s_Compile._ILIoOp<IdType, MessageType>> _TypeDescriptor() {
      return new Dafny.TypeDescriptor<Environment__s_Compile._ILIoOp<IdType, MessageType>>(Environment__s_Compile.LIoOp<IdType, MessageType>.Default());
    }
    public static _ILIoOp<IdType, MessageType> create_LIoOpSend(Environment__s_Compile._ILPacket<IdType, MessageType> s) {
      return new LIoOp_LIoOpSend<IdType, MessageType>(s);
    }
    public static _ILIoOp<IdType, MessageType> create_LIoOpReceive(Environment__s_Compile._ILPacket<IdType, MessageType> r) {
      return new LIoOp_LIoOpReceive<IdType, MessageType>(r);
    }
    public static _ILIoOp<IdType, MessageType> create_LIoOpTimeoutReceive() {
      return new LIoOp_LIoOpTimeoutReceive<IdType, MessageType>();
    }
    public static _ILIoOp<IdType, MessageType> create_LIoOpReadClock(BigInteger t) {
      return new LIoOp_LIoOpReadClock<IdType, MessageType>(t);
    }
    public bool is_LIoOpSend { get { return this is LIoOp_LIoOpSend<IdType, MessageType>; } }
    public bool is_LIoOpReceive { get { return this is LIoOp_LIoOpReceive<IdType, MessageType>; } }
    public bool is_LIoOpTimeoutReceive { get { return this is LIoOp_LIoOpTimeoutReceive<IdType, MessageType>; } }
    public bool is_LIoOpReadClock { get { return this is LIoOp_LIoOpReadClock<IdType, MessageType>; } }
    public Environment__s_Compile._ILPacket<IdType, MessageType> dtor_s {
      get {
        var d = this;
        return ((LIoOp_LIoOpSend<IdType, MessageType>)d)._s;
      }
    }
    public Environment__s_Compile._ILPacket<IdType, MessageType> dtor_r {
      get {
        var d = this;
        return ((LIoOp_LIoOpReceive<IdType, MessageType>)d)._r;
      }
    }
    public BigInteger dtor_t {
      get {
        var d = this;
        return ((LIoOp_LIoOpReadClock<IdType, MessageType>)d)._t;
      }
    }
    public abstract _ILIoOp<__IdType, __MessageType> DowncastClone<__IdType, __MessageType>(Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1);
  }
  public class LIoOp_LIoOpSend<IdType, MessageType> : LIoOp<IdType, MessageType> {
    public readonly Environment__s_Compile._ILPacket<IdType, MessageType> _s;
    public LIoOp_LIoOpSend(Environment__s_Compile._ILPacket<IdType, MessageType> s) {
      this._s = s;
    }
    public override _ILIoOp<__IdType, __MessageType> DowncastClone<__IdType, __MessageType>(Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1) {
      if (this is _ILIoOp<__IdType, __MessageType> dt) { return dt; }
      return new LIoOp_LIoOpSend<__IdType, __MessageType>((_s).DowncastClone<__IdType, __MessageType>(Dafny.Helpers.CastConverter<IdType, __IdType>, Dafny.Helpers.CastConverter<MessageType, __MessageType>));
    }
    public override bool Equals(object other) {
      var oth = other as Environment__s_Compile.LIoOp_LIoOpSend<IdType, MessageType>;
      return oth != null && object.Equals(this._s, oth._s);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._s));
      return (int) hash;
    }
    public override string ToString() {
      string ss = "Environment__s_Compile.LIoOp.LIoOpSend";
      ss += "(";
      ss += Dafny.Helpers.ToString(this._s);
      ss += ")";
      return ss;
    }
  }
  public class LIoOp_LIoOpReceive<IdType, MessageType> : LIoOp<IdType, MessageType> {
    public readonly Environment__s_Compile._ILPacket<IdType, MessageType> _r;
    public LIoOp_LIoOpReceive(Environment__s_Compile._ILPacket<IdType, MessageType> r) {
      this._r = r;
    }
    public override _ILIoOp<__IdType, __MessageType> DowncastClone<__IdType, __MessageType>(Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1) {
      if (this is _ILIoOp<__IdType, __MessageType> dt) { return dt; }
      return new LIoOp_LIoOpReceive<__IdType, __MessageType>((_r).DowncastClone<__IdType, __MessageType>(Dafny.Helpers.CastConverter<IdType, __IdType>, Dafny.Helpers.CastConverter<MessageType, __MessageType>));
    }
    public override bool Equals(object other) {
      var oth = other as Environment__s_Compile.LIoOp_LIoOpReceive<IdType, MessageType>;
      return oth != null && object.Equals(this._r, oth._r);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._r));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Environment__s_Compile.LIoOp.LIoOpReceive";
      s += "(";
      s += Dafny.Helpers.ToString(this._r);
      s += ")";
      return s;
    }
  }
  public class LIoOp_LIoOpTimeoutReceive<IdType, MessageType> : LIoOp<IdType, MessageType> {
    public LIoOp_LIoOpTimeoutReceive() {
    }
    public override _ILIoOp<__IdType, __MessageType> DowncastClone<__IdType, __MessageType>(Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1) {
      if (this is _ILIoOp<__IdType, __MessageType> dt) { return dt; }
      return new LIoOp_LIoOpTimeoutReceive<__IdType, __MessageType>();
    }
    public override bool Equals(object other) {
      var oth = other as Environment__s_Compile.LIoOp_LIoOpTimeoutReceive<IdType, MessageType>;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Environment__s_Compile.LIoOp.LIoOpTimeoutReceive";
      return s;
    }
  }
  public class LIoOp_LIoOpReadClock<IdType, MessageType> : LIoOp<IdType, MessageType> {
    public readonly BigInteger _t;
    public LIoOp_LIoOpReadClock(BigInteger t) {
      this._t = t;
    }
    public override _ILIoOp<__IdType, __MessageType> DowncastClone<__IdType, __MessageType>(Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1) {
      if (this is _ILIoOp<__IdType, __MessageType> dt) { return dt; }
      return new LIoOp_LIoOpReadClock<__IdType, __MessageType>(_t);
    }
    public override bool Equals(object other) {
      var oth = other as Environment__s_Compile.LIoOp_LIoOpReadClock<IdType, MessageType>;
      return oth != null && this._t == oth._t;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._t));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Environment__s_Compile.LIoOp.LIoOpReadClock";
      s += "(";
      s += Dafny.Helpers.ToString(this._t);
      s += ")";
      return s;
    }
  }

  public interface _ILEnvStep<IdType, MessageType> {
    bool is_LEnvStepHostIos { get; }
    bool is_LEnvStepDeliverPacket { get; }
    bool is_LEnvStepAdvanceTime { get; }
    bool is_LEnvStepStutter { get; }
    IdType dtor_actor { get; }
    Dafny.ISequence<Environment__s_Compile._ILIoOp<IdType, MessageType>> dtor_ios { get; }
    Environment__s_Compile._ILPacket<IdType, MessageType> dtor_p { get; }
    _ILEnvStep<__IdType, __MessageType> DowncastClone<__IdType, __MessageType>(Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1);
  }
  public abstract class LEnvStep<IdType, MessageType> : _ILEnvStep<IdType, MessageType> {
    public LEnvStep() { }
    public static Environment__s_Compile._ILEnvStep<IdType, MessageType> Default() {
      return create_LEnvStepAdvanceTime();
    }
    public static Dafny.TypeDescriptor<Environment__s_Compile._ILEnvStep<IdType, MessageType>> _TypeDescriptor() {
      return new Dafny.TypeDescriptor<Environment__s_Compile._ILEnvStep<IdType, MessageType>>(Environment__s_Compile.LEnvStep<IdType, MessageType>.Default());
    }
    public static _ILEnvStep<IdType, MessageType> create_LEnvStepHostIos(IdType actor, Dafny.ISequence<Environment__s_Compile._ILIoOp<IdType, MessageType>> ios) {
      return new LEnvStep_LEnvStepHostIos<IdType, MessageType>(actor, ios);
    }
    public static _ILEnvStep<IdType, MessageType> create_LEnvStepDeliverPacket(Environment__s_Compile._ILPacket<IdType, MessageType> p) {
      return new LEnvStep_LEnvStepDeliverPacket<IdType, MessageType>(p);
    }
    public static _ILEnvStep<IdType, MessageType> create_LEnvStepAdvanceTime() {
      return new LEnvStep_LEnvStepAdvanceTime<IdType, MessageType>();
    }
    public static _ILEnvStep<IdType, MessageType> create_LEnvStepStutter() {
      return new LEnvStep_LEnvStepStutter<IdType, MessageType>();
    }
    public bool is_LEnvStepHostIos { get { return this is LEnvStep_LEnvStepHostIos<IdType, MessageType>; } }
    public bool is_LEnvStepDeliverPacket { get { return this is LEnvStep_LEnvStepDeliverPacket<IdType, MessageType>; } }
    public bool is_LEnvStepAdvanceTime { get { return this is LEnvStep_LEnvStepAdvanceTime<IdType, MessageType>; } }
    public bool is_LEnvStepStutter { get { return this is LEnvStep_LEnvStepStutter<IdType, MessageType>; } }
    public IdType dtor_actor {
      get {
        var d = this;
        return ((LEnvStep_LEnvStepHostIos<IdType, MessageType>)d)._actor;
      }
    }
    public Dafny.ISequence<Environment__s_Compile._ILIoOp<IdType, MessageType>> dtor_ios {
      get {
        var d = this;
        return ((LEnvStep_LEnvStepHostIos<IdType, MessageType>)d)._ios;
      }
    }
    public Environment__s_Compile._ILPacket<IdType, MessageType> dtor_p {
      get {
        var d = this;
        return ((LEnvStep_LEnvStepDeliverPacket<IdType, MessageType>)d)._p;
      }
    }
    public abstract _ILEnvStep<__IdType, __MessageType> DowncastClone<__IdType, __MessageType>(Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1);
  }
  public class LEnvStep_LEnvStepHostIos<IdType, MessageType> : LEnvStep<IdType, MessageType> {
    public readonly IdType _actor;
    public readonly Dafny.ISequence<Environment__s_Compile._ILIoOp<IdType, MessageType>> _ios;
    public LEnvStep_LEnvStepHostIos(IdType actor, Dafny.ISequence<Environment__s_Compile._ILIoOp<IdType, MessageType>> ios) {
      this._actor = actor;
      this._ios = ios;
    }
    public override _ILEnvStep<__IdType, __MessageType> DowncastClone<__IdType, __MessageType>(Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1) {
      if (this is _ILEnvStep<__IdType, __MessageType> dt) { return dt; }
      return new LEnvStep_LEnvStepHostIos<__IdType, __MessageType>(converter0(_actor), (_ios).DowncastClone<Environment__s_Compile._ILIoOp<__IdType, __MessageType>>(Dafny.Helpers.CastConverter<Environment__s_Compile._ILIoOp<IdType, MessageType>, Environment__s_Compile._ILIoOp<__IdType, __MessageType>>));
    }
    public override bool Equals(object other) {
      var oth = other as Environment__s_Compile.LEnvStep_LEnvStepHostIos<IdType, MessageType>;
      return oth != null && object.Equals(this._actor, oth._actor) && object.Equals(this._ios, oth._ios);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._actor));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ios));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Environment__s_Compile.LEnvStep.LEnvStepHostIos";
      s += "(";
      s += Dafny.Helpers.ToString(this._actor);
      s += ", ";
      s += Dafny.Helpers.ToString(this._ios);
      s += ")";
      return s;
    }
  }
  public class LEnvStep_LEnvStepDeliverPacket<IdType, MessageType> : LEnvStep<IdType, MessageType> {
    public readonly Environment__s_Compile._ILPacket<IdType, MessageType> _p;
    public LEnvStep_LEnvStepDeliverPacket(Environment__s_Compile._ILPacket<IdType, MessageType> p) {
      this._p = p;
    }
    public override _ILEnvStep<__IdType, __MessageType> DowncastClone<__IdType, __MessageType>(Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1) {
      if (this is _ILEnvStep<__IdType, __MessageType> dt) { return dt; }
      return new LEnvStep_LEnvStepDeliverPacket<__IdType, __MessageType>((_p).DowncastClone<__IdType, __MessageType>(Dafny.Helpers.CastConverter<IdType, __IdType>, Dafny.Helpers.CastConverter<MessageType, __MessageType>));
    }
    public override bool Equals(object other) {
      var oth = other as Environment__s_Compile.LEnvStep_LEnvStepDeliverPacket<IdType, MessageType>;
      return oth != null && object.Equals(this._p, oth._p);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._p));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Environment__s_Compile.LEnvStep.LEnvStepDeliverPacket";
      s += "(";
      s += Dafny.Helpers.ToString(this._p);
      s += ")";
      return s;
    }
  }
  public class LEnvStep_LEnvStepAdvanceTime<IdType, MessageType> : LEnvStep<IdType, MessageType> {
    public LEnvStep_LEnvStepAdvanceTime() {
    }
    public override _ILEnvStep<__IdType, __MessageType> DowncastClone<__IdType, __MessageType>(Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1) {
      if (this is _ILEnvStep<__IdType, __MessageType> dt) { return dt; }
      return new LEnvStep_LEnvStepAdvanceTime<__IdType, __MessageType>();
    }
    public override bool Equals(object other) {
      var oth = other as Environment__s_Compile.LEnvStep_LEnvStepAdvanceTime<IdType, MessageType>;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Environment__s_Compile.LEnvStep.LEnvStepAdvanceTime";
      return s;
    }
  }
  public class LEnvStep_LEnvStepStutter<IdType, MessageType> : LEnvStep<IdType, MessageType> {
    public LEnvStep_LEnvStepStutter() {
    }
    public override _ILEnvStep<__IdType, __MessageType> DowncastClone<__IdType, __MessageType>(Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1) {
      if (this is _ILEnvStep<__IdType, __MessageType> dt) { return dt; }
      return new LEnvStep_LEnvStepStutter<__IdType, __MessageType>();
    }
    public override bool Equals(object other) {
      var oth = other as Environment__s_Compile.LEnvStep_LEnvStepStutter<IdType, MessageType>;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Environment__s_Compile.LEnvStep.LEnvStepStutter";
      return s;
    }
  }

  public interface _ILHostInfo<IdType, MessageType> {
    bool is_LHostInfo { get; }
    Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>> dtor_queue { get; }
  }
  public class LHostInfo<IdType, MessageType> : _ILHostInfo<IdType, MessageType> {
    public readonly Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>> _queue;
    public LHostInfo(Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>> queue) {
      this._queue = queue;
    }
    public static Dafny.ISequence<Environment__s_Compile._ILPacket<__IdType, __MessageType>> DowncastClone<__IdType, __MessageType>(Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>> _this, Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1) {
      return (_this).DowncastClone<Environment__s_Compile._ILPacket<__IdType, __MessageType>>(Dafny.Helpers.CastConverter<Environment__s_Compile._ILPacket<IdType, MessageType>, Environment__s_Compile._ILPacket<__IdType, __MessageType>>);
    }
    public override bool Equals(object other) {
      var oth = other as Environment__s_Compile.LHostInfo<IdType, MessageType>;
      return oth != null && object.Equals(this._queue, oth._queue);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._queue));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Environment__s_Compile.LHostInfo.LHostInfo";
      s += "(";
      s += Dafny.Helpers.ToString(this._queue);
      s += ")";
      return s;
    }
    public static Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>> Default() {
      return Dafny.Sequence<Environment__s_Compile._ILPacket<IdType, MessageType>>.Empty;
    }
    public static Dafny.TypeDescriptor<Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>>> _TypeDescriptor() {
      return new Dafny.TypeDescriptor<Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>>>(Dafny.Sequence<Environment__s_Compile._ILPacket<IdType, MessageType>>.Empty);
    }
    public static _ILHostInfo<IdType, MessageType> create(Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>> queue) {
      return new LHostInfo<IdType, MessageType>(queue);
    }
    public static _ILHostInfo<IdType, MessageType> create_LHostInfo(Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>> queue) {
      return create(queue);
    }
    public bool is_LHostInfo { get { return true; } }
    public Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>> dtor_queue {
      get {
        return this._queue;
      }
    }
  }

  public interface _ILEnvironment<IdType, MessageType> {
    bool is_LEnvironment { get; }
    BigInteger dtor_time { get; }
    Dafny.ISet<Environment__s_Compile._ILPacket<IdType, MessageType>> dtor_sentPackets { get; }
    Dafny.IMap<IdType,Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>>> dtor_hostInfo { get; }
    Environment__s_Compile._ILEnvStep<IdType, MessageType> dtor_nextStep { get; }
    _ILEnvironment<__IdType, __MessageType> DowncastClone<__IdType, __MessageType>(Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1);
  }
  public class LEnvironment<IdType, MessageType> : _ILEnvironment<IdType, MessageType> {
    public readonly BigInteger _time;
    public readonly Dafny.ISet<Environment__s_Compile._ILPacket<IdType, MessageType>> _sentPackets;
    public readonly Dafny.IMap<IdType,Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>>> _hostInfo;
    public readonly Environment__s_Compile._ILEnvStep<IdType, MessageType> _nextStep;
    public LEnvironment(BigInteger time, Dafny.ISet<Environment__s_Compile._ILPacket<IdType, MessageType>> sentPackets, Dafny.IMap<IdType,Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>>> hostInfo, Environment__s_Compile._ILEnvStep<IdType, MessageType> nextStep) {
      this._time = time;
      this._sentPackets = sentPackets;
      this._hostInfo = hostInfo;
      this._nextStep = nextStep;
    }
    public _ILEnvironment<__IdType, __MessageType> DowncastClone<__IdType, __MessageType>(Func<IdType, __IdType> converter0, Func<MessageType, __MessageType> converter1) {
      if (this is _ILEnvironment<__IdType, __MessageType> dt) { return dt; }
      return new LEnvironment<__IdType, __MessageType>(_time, (_sentPackets).DowncastClone<Environment__s_Compile._ILPacket<__IdType, __MessageType>>(Dafny.Helpers.CastConverter<Environment__s_Compile._ILPacket<IdType, MessageType>, Environment__s_Compile._ILPacket<__IdType, __MessageType>>), (_hostInfo).DowncastClone<__IdType, Dafny.ISequence<Environment__s_Compile._ILPacket<__IdType, __MessageType>>>(Dafny.Helpers.CastConverter<IdType, __IdType>, Dafny.Helpers.CastConverter<Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>>, Dafny.ISequence<Environment__s_Compile._ILPacket<__IdType, __MessageType>>>), (_nextStep).DowncastClone<__IdType, __MessageType>(Dafny.Helpers.CastConverter<IdType, __IdType>, Dafny.Helpers.CastConverter<MessageType, __MessageType>));
    }
    public override bool Equals(object other) {
      var oth = other as Environment__s_Compile.LEnvironment<IdType, MessageType>;
      return oth != null && this._time == oth._time && object.Equals(this._sentPackets, oth._sentPackets) && object.Equals(this._hostInfo, oth._hostInfo) && object.Equals(this._nextStep, oth._nextStep);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._time));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sentPackets));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._hostInfo));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._nextStep));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Environment__s_Compile.LEnvironment.LEnvironment";
      s += "(";
      s += Dafny.Helpers.ToString(this._time);
      s += ", ";
      s += Dafny.Helpers.ToString(this._sentPackets);
      s += ", ";
      s += Dafny.Helpers.ToString(this._hostInfo);
      s += ", ";
      s += Dafny.Helpers.ToString(this._nextStep);
      s += ")";
      return s;
    }
    public static Environment__s_Compile._ILEnvironment<IdType, MessageType> Default() {
      return create(BigInteger.Zero, Dafny.Set<Environment__s_Compile._ILPacket<IdType, MessageType>>.Empty, Dafny.Map<IdType, Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>>>.Empty, Environment__s_Compile.LEnvStep<IdType, MessageType>.Default());
    }
    public static Dafny.TypeDescriptor<Environment__s_Compile._ILEnvironment<IdType, MessageType>> _TypeDescriptor() {
      return new Dafny.TypeDescriptor<Environment__s_Compile._ILEnvironment<IdType, MessageType>>(Environment__s_Compile.LEnvironment<IdType, MessageType>.Default());
    }
    public static _ILEnvironment<IdType, MessageType> create(BigInteger time, Dafny.ISet<Environment__s_Compile._ILPacket<IdType, MessageType>> sentPackets, Dafny.IMap<IdType,Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>>> hostInfo, Environment__s_Compile._ILEnvStep<IdType, MessageType> nextStep) {
      return new LEnvironment<IdType, MessageType>(time, sentPackets, hostInfo, nextStep);
    }
    public static _ILEnvironment<IdType, MessageType> create_LEnvironment(BigInteger time, Dafny.ISet<Environment__s_Compile._ILPacket<IdType, MessageType>> sentPackets, Dafny.IMap<IdType,Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>>> hostInfo, Environment__s_Compile._ILEnvStep<IdType, MessageType> nextStep) {
      return create(time, sentPackets, hostInfo, nextStep);
    }
    public bool is_LEnvironment { get { return true; } }
    public BigInteger dtor_time {
      get {
        return this._time;
      }
    }
    public Dafny.ISet<Environment__s_Compile._ILPacket<IdType, MessageType>> dtor_sentPackets {
      get {
        return this._sentPackets;
      }
    }
    public Dafny.IMap<IdType,Dafny.ISequence<Environment__s_Compile._ILPacket<IdType, MessageType>>> dtor_hostInfo {
      get {
        return this._hostInfo;
      }
    }
    public Environment__s_Compile._ILEnvStep<IdType, MessageType> dtor_nextStep {
      get {
        return this._nextStep;
      }
    }
  }

} // end of namespace Environment__s_Compile
namespace Native____Io__s_Compile {

  public partial class HostEnvironment {
    public HostEnvironment() {
    }
  }

  public partial class HostConstants {
    public HostConstants() {
    }
  }

  public partial class OkState {
    public OkState() {
    }
  }

  public partial class NowState {
    public NowState() {
    }
  }

  public partial class Time {
    public Time() {
    }
  }

  public interface _IEndPoint {
    bool is_EndPoint { get; }
    Dafny.ISequence<byte> dtor_addr { get; }
    ushort dtor_port { get; }
    _IEndPoint DowncastClone();
  }
  public class EndPoint : _IEndPoint {
    public readonly Dafny.ISequence<byte> _addr;
    public readonly ushort _port;
    public EndPoint(Dafny.ISequence<byte> addr, ushort port) {
      this._addr = addr;
      this._port = port;
    }
    public _IEndPoint DowncastClone() {
      if (this is _IEndPoint dt) { return dt; }
      return new EndPoint(_addr, _port);
    }
    public override bool Equals(object other) {
      var oth = other as Native____Io__s_Compile.EndPoint;
      return oth != null && object.Equals(this._addr, oth._addr) && this._port == oth._port;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._addr));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._port));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Native____Io__s_Compile.EndPoint.EndPoint";
      s += "(";
      s += Dafny.Helpers.ToString(this._addr);
      s += ", ";
      s += Dafny.Helpers.ToString(this._port);
      s += ")";
      return s;
    }
    private static readonly Native____Io__s_Compile._IEndPoint theDefault = create(Dafny.Sequence<byte>.Empty, 0);
    public static Native____Io__s_Compile._IEndPoint Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Native____Io__s_Compile._IEndPoint> _TYPE = new Dafny.TypeDescriptor<Native____Io__s_Compile._IEndPoint>(Native____Io__s_Compile.EndPoint.Default());
    public static Dafny.TypeDescriptor<Native____Io__s_Compile._IEndPoint> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IEndPoint create(Dafny.ISequence<byte> addr, ushort port) {
      return new EndPoint(addr, port);
    }
    public static _IEndPoint create_EndPoint(Dafny.ISequence<byte> addr, ushort port) {
      return create(addr, port);
    }
    public bool is_EndPoint { get { return true; } }
    public Dafny.ISequence<byte> dtor_addr {
      get {
        return this._addr;
      }
    }
    public ushort dtor_port {
      get {
        return this._port;
      }
    }
  }

  public partial class UdpState {
    public UdpState() {
    }
  }

  public partial class IPEndPoint {
    public IPEndPoint() {
    }
  }

  public partial class UdpClient {
    public UdpClient() {
    }
  }

  public partial class FileSystemState {
    public FileSystemState() {
    }
  }

  public partial class MutableSet<T> {
    private Dafny.TypeDescriptor<T> _td_T;
    public MutableSet(Dafny.TypeDescriptor<T> _td_T) {
      this._td_T = _td_T;
    }
  }

  public partial class MutableMap<K, V> {
    public MutableMap() {
    }
  }

  public partial class Arrays {
    public Arrays() {
    }
  }

} // end of namespace Native____Io__s_Compile
namespace Collections____Seqs__s_Compile {

} // end of namespace Collections____Seqs__s_Compile
namespace AppStateMachine__i_Compile {

  public interface _IAppMessage_k {
    bool is_AppIncrementRequest { get; }
    bool is_AppIncrementReply { get; }
    bool is_AppInvalidReply { get; }
    ulong dtor_response { get; }
    _IAppMessage_k DowncastClone();
  }
  public abstract class AppMessage_k : _IAppMessage_k {
    public AppMessage_k() { }
    private static readonly AppStateMachine__i_Compile._IAppMessage_k theDefault = create_AppIncrementRequest();
    public static AppStateMachine__i_Compile._IAppMessage_k Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AppStateMachine__i_Compile._IAppMessage_k> _TYPE = new Dafny.TypeDescriptor<AppStateMachine__i_Compile._IAppMessage_k>(AppStateMachine__i_Compile.AppMessage_k.Default());
    public static Dafny.TypeDescriptor<AppStateMachine__i_Compile._IAppMessage_k> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAppMessage_k create_AppIncrementRequest() {
      return new AppMessage_k_AppIncrementRequest();
    }
    public static _IAppMessage_k create_AppIncrementReply(ulong response) {
      return new AppMessage_k_AppIncrementReply(response);
    }
    public static _IAppMessage_k create_AppInvalidReply() {
      return new AppMessage_k_AppInvalidReply();
    }
    public bool is_AppIncrementRequest { get { return this is AppMessage_k_AppIncrementRequest; } }
    public bool is_AppIncrementReply { get { return this is AppMessage_k_AppIncrementReply; } }
    public bool is_AppInvalidReply { get { return this is AppMessage_k_AppInvalidReply; } }
    public ulong dtor_response {
      get {
        var d = this;
        return ((AppMessage_k_AppIncrementReply)d)._response;
      }
    }
    public abstract _IAppMessage_k DowncastClone();
  }
  public class AppMessage_k_AppIncrementRequest : AppMessage_k {
    public AppMessage_k_AppIncrementRequest() {
    }
    public override _IAppMessage_k DowncastClone() {
      if (this is _IAppMessage_k dt) { return dt; }
      return new AppMessage_k_AppIncrementRequest();
    }
    public override bool Equals(object other) {
      var oth = other as AppStateMachine__i_Compile.AppMessage_k_AppIncrementRequest;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AppStateMachine__i_Compile.AppMessage'.AppIncrementRequest";
      return s;
    }
  }
  public class AppMessage_k_AppIncrementReply : AppMessage_k {
    public readonly ulong _response;
    public AppMessage_k_AppIncrementReply(ulong response) {
      this._response = response;
    }
    public override _IAppMessage_k DowncastClone() {
      if (this is _IAppMessage_k dt) { return dt; }
      return new AppMessage_k_AppIncrementReply(_response);
    }
    public override bool Equals(object other) {
      var oth = other as AppStateMachine__i_Compile.AppMessage_k_AppIncrementReply;
      return oth != null && this._response == oth._response;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._response));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AppStateMachine__i_Compile.AppMessage'.AppIncrementReply";
      s += "(";
      s += Dafny.Helpers.ToString(this._response);
      s += ")";
      return s;
    }
  }
  public class AppMessage_k_AppInvalidReply : AppMessage_k {
    public AppMessage_k_AppInvalidReply() {
    }
    public override _IAppMessage_k DowncastClone() {
      if (this is _IAppMessage_k dt) { return dt; }
      return new AppMessage_k_AppInvalidReply();
    }
    public override bool Equals(object other) {
      var oth = other as AppStateMachine__i_Compile.AppMessage_k_AppInvalidReply;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AppStateMachine__i_Compile.AppMessage'.AppInvalidReply";
      return s;
    }
  }

} // end of namespace AppStateMachine__i_Compile
namespace Concrete__NodeIdentity__i_Compile {

} // end of namespace Concrete__NodeIdentity__i_Compile
namespace LiveByzRSL____Types__i_Compile {

  public interface _IBallot {
    bool is_Ballot { get; }
    BigInteger dtor_seqno { get; }
    BigInteger dtor_proposer__id { get; }
    _IBallot DowncastClone();
  }
  public class Ballot : _IBallot {
    public readonly BigInteger _seqno;
    public readonly BigInteger _proposer__id;
    public Ballot(BigInteger seqno, BigInteger proposer__id) {
      this._seqno = seqno;
      this._proposer__id = proposer__id;
    }
    public _IBallot DowncastClone() {
      if (this is _IBallot dt) { return dt; }
      return new Ballot(_seqno, _proposer__id);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Types__i_Compile.Ballot;
      return oth != null && this._seqno == oth._seqno && this._proposer__id == oth._proposer__id;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._seqno));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._proposer__id));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Types__i_Compile.Ballot.Ballot";
      s += "(";
      s += Dafny.Helpers.ToString(this._seqno);
      s += ", ";
      s += Dafny.Helpers.ToString(this._proposer__id);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____Types__i_Compile._IBallot theDefault = create(BigInteger.Zero, BigInteger.Zero);
    public static LiveByzRSL____Types__i_Compile._IBallot Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Types__i_Compile._IBallot> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Types__i_Compile._IBallot>(LiveByzRSL____Types__i_Compile.Ballot.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Types__i_Compile._IBallot> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBallot create(BigInteger seqno, BigInteger proposer__id) {
      return new Ballot(seqno, proposer__id);
    }
    public static _IBallot create_Ballot(BigInteger seqno, BigInteger proposer__id) {
      return create(seqno, proposer__id);
    }
    public bool is_Ballot { get { return true; } }
    public BigInteger dtor_seqno {
      get {
        return this._seqno;
      }
    }
    public BigInteger dtor_proposer__id {
      get {
        return this._proposer__id;
      }
    }
  }

  public interface _IRequest {
    bool is_Request { get; }
    Native____Io__s_Compile._IEndPoint dtor_client { get; }
    BigInteger dtor_seqno { get; }
    AppStateMachine__i_Compile._IAppMessage_k dtor_request { get; }
    _IRequest DowncastClone();
  }
  public class Request : _IRequest {
    public readonly Native____Io__s_Compile._IEndPoint _client;
    public readonly BigInteger _seqno;
    public readonly AppStateMachine__i_Compile._IAppMessage_k _request;
    public Request(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, AppStateMachine__i_Compile._IAppMessage_k request) {
      this._client = client;
      this._seqno = seqno;
      this._request = request;
    }
    public _IRequest DowncastClone() {
      if (this is _IRequest dt) { return dt; }
      return new Request(_client, _seqno, _request);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Types__i_Compile.Request;
      return oth != null && object.Equals(this._client, oth._client) && this._seqno == oth._seqno && object.Equals(this._request, oth._request);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._client));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._seqno));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._request));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Types__i_Compile.Request.Request";
      s += "(";
      s += Dafny.Helpers.ToString(this._client);
      s += ", ";
      s += Dafny.Helpers.ToString(this._seqno);
      s += ", ";
      s += Dafny.Helpers.ToString(this._request);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____Types__i_Compile._IRequest theDefault = create(Native____Io__s_Compile.EndPoint.Default(), BigInteger.Zero, AppStateMachine__i_Compile.AppMessage_k.Default());
    public static LiveByzRSL____Types__i_Compile._IRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Types__i_Compile._IRequest> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Types__i_Compile._IRequest>(LiveByzRSL____Types__i_Compile.Request.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Types__i_Compile._IRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IRequest create(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, AppStateMachine__i_Compile._IAppMessage_k request) {
      return new Request(client, seqno, request);
    }
    public static _IRequest create_Request(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, AppStateMachine__i_Compile._IAppMessage_k request) {
      return create(client, seqno, request);
    }
    public bool is_Request { get { return true; } }
    public Native____Io__s_Compile._IEndPoint dtor_client {
      get {
        return this._client;
      }
    }
    public BigInteger dtor_seqno {
      get {
        return this._seqno;
      }
    }
    public AppStateMachine__i_Compile._IAppMessage_k dtor_request {
      get {
        return this._request;
      }
    }
  }

  public interface _IReply {
    bool is_Reply { get; }
    Native____Io__s_Compile._IEndPoint dtor_client { get; }
    BigInteger dtor_seqno { get; }
    AppStateMachine__i_Compile._IAppMessage_k dtor_reply { get; }
    _IReply DowncastClone();
  }
  public class Reply : _IReply {
    public readonly Native____Io__s_Compile._IEndPoint _client;
    public readonly BigInteger _seqno;
    public readonly AppStateMachine__i_Compile._IAppMessage_k _reply;
    public Reply(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, AppStateMachine__i_Compile._IAppMessage_k reply) {
      this._client = client;
      this._seqno = seqno;
      this._reply = reply;
    }
    public _IReply DowncastClone() {
      if (this is _IReply dt) { return dt; }
      return new Reply(_client, _seqno, _reply);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Types__i_Compile.Reply;
      return oth != null && object.Equals(this._client, oth._client) && this._seqno == oth._seqno && object.Equals(this._reply, oth._reply);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._client));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._seqno));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._reply));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Types__i_Compile.Reply.Reply";
      s += "(";
      s += Dafny.Helpers.ToString(this._client);
      s += ", ";
      s += Dafny.Helpers.ToString(this._seqno);
      s += ", ";
      s += Dafny.Helpers.ToString(this._reply);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____Types__i_Compile._IReply theDefault = create(Native____Io__s_Compile.EndPoint.Default(), BigInteger.Zero, AppStateMachine__i_Compile.AppMessage_k.Default());
    public static LiveByzRSL____Types__i_Compile._IReply Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Types__i_Compile._IReply> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Types__i_Compile._IReply>(LiveByzRSL____Types__i_Compile.Reply.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Types__i_Compile._IReply> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IReply create(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, AppStateMachine__i_Compile._IAppMessage_k reply) {
      return new Reply(client, seqno, reply);
    }
    public static _IReply create_Reply(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, AppStateMachine__i_Compile._IAppMessage_k reply) {
      return create(client, seqno, reply);
    }
    public bool is_Reply { get { return true; } }
    public Native____Io__s_Compile._IEndPoint dtor_client {
      get {
        return this._client;
      }
    }
    public BigInteger dtor_seqno {
      get {
        return this._seqno;
      }
    }
    public AppStateMachine__i_Compile._IAppMessage_k dtor_reply {
      get {
        return this._reply;
      }
    }
  }

  public interface _IVote {
    bool is_Vote { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_max__value__bal { get; }
  }
  public class Vote : _IVote {
    public readonly LiveByzRSL____Types__i_Compile._IBallot _max__value__bal;
    public Vote(LiveByzRSL____Types__i_Compile._IBallot max__value__bal) {
      this._max__value__bal = max__value__bal;
    }
    public static LiveByzRSL____Types__i_Compile._IBallot DowncastClone(LiveByzRSL____Types__i_Compile._IBallot _this) {
      return _this;
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Types__i_Compile.Vote;
      return oth != null && object.Equals(this._max__value__bal, oth._max__value__bal);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__value__bal));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Types__i_Compile.Vote.Vote";
      s += "(";
      s += Dafny.Helpers.ToString(this._max__value__bal);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____Types__i_Compile._IBallot theDefault = LiveByzRSL____Types__i_Compile.Ballot.Default();
    public static LiveByzRSL____Types__i_Compile._IBallot Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Types__i_Compile._IBallot> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Types__i_Compile._IBallot>(LiveByzRSL____Types__i_Compile.Ballot.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Types__i_Compile._IBallot> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IVote create(LiveByzRSL____Types__i_Compile._IBallot max__value__bal) {
      return new Vote(max__value__bal);
    }
    public static _IVote create_Vote(LiveByzRSL____Types__i_Compile._IBallot max__value__bal) {
      return create(max__value__bal);
    }
    public bool is_Vote { get { return true; } }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_max__value__bal {
      get {
        return this._max__value__bal;
      }
    }
  }

} // end of namespace LiveByzRSL____Types__i_Compile
namespace Collections____Sets__i_Compile {

} // end of namespace Collections____Sets__i_Compile
namespace Collections____Multisets__s_Compile {

} // end of namespace Collections____Multisets__s_Compile
namespace Collections____Seqs__i_Compile {

  public partial class __default {
    public static bool CItemAtPositionInSeq<__T>(Dafny.ISequence<__T> s, __T v, BigInteger idx)
    {
      return (((idx).Sign != -1) && ((idx) < (new BigInteger((s).Count)))) && (object.Equals((s).Select(idx), v));
    }
    public static BigInteger FindIndexInSeq<__T>(Dafny.ISequence<__T> s, __T v)
    {
      if ((new BigInteger((s).Count)).Sign == 0) {
        return new BigInteger(-1);
      } else if (object.Equals((s).Select(BigInteger.Zero), v)) {
        return BigInteger.Zero;
      } else {
        BigInteger _5_r = Collections____Seqs__i_Compile.__default.FindIndexInSeq<__T>((s).Drop(BigInteger.One), v);
        if ((_5_r) == (new BigInteger(-1))) {
          return new BigInteger(-1);
        } else {
          return (_5_r) + (BigInteger.One);
        }
      }
    }
    public static Dafny.ISequence<BigInteger> InsertSort(Dafny.ISequence<BigInteger> a)
    {
      Dafny.ISequence<BigInteger> sorted = Dafny.Sequence<BigInteger>.Empty;
      if ((new BigInteger((a).Count)) <= (BigInteger.One)) {
        sorted = a;
      } else {
        BigInteger _6_last;
        _6_last = (a).Select((new BigInteger((a).Count)) - (BigInteger.One));
        Dafny.ISequence<BigInteger> _7_rest;
        _7_rest = (a).Take((new BigInteger((a).Count)) - (BigInteger.One));
        Dafny.ISequence<BigInteger> _8_sortedRest;
        Dafny.ISequence<BigInteger> _out0;
        _out0 = Collections____Seqs__i_Compile.__default.InsertSort(_7_rest);
        _8_sortedRest = _out0;
        Dafny.ISequence<BigInteger> _out1;
        _out1 = Collections____Seqs__i_Compile.__default.Insert(_8_sortedRest, _6_last);
        sorted = _out1;
      }
      return sorted;
    }
    public static Dafny.ISequence<BigInteger> Insert(Dafny.ISequence<BigInteger> sortedSeq, BigInteger @value)
    {
      Dafny.ISequence<BigInteger> newSeq = Dafny.Sequence<BigInteger>.Empty;
      if ((new BigInteger((sortedSeq).Count)).Sign == 0) {
        newSeq = Dafny.Sequence<BigInteger>.FromElements(@value);
      } else {
        if ((@value) <= ((sortedSeq).Select(BigInteger.Zero))) {
          newSeq = Dafny.Sequence<BigInteger>.Concat(Dafny.Sequence<BigInteger>.FromElements(@value), sortedSeq);
        } else {
          Dafny.ISequence<BigInteger> _9_res;
          Dafny.ISequence<BigInteger> _out2;
          _out2 = Collections____Seqs__i_Compile.__default.Insert((sortedSeq).Drop(BigInteger.One), @value);
          _9_res = _out2;
          newSeq = Dafny.Sequence<BigInteger>.Concat(Dafny.Sequence<BigInteger>.FromElements((sortedSeq).Select(BigInteger.Zero)), _9_res);
        }
      }
      return newSeq;
    }
  }
} // end of namespace Collections____Seqs__i_Compile
namespace LiveByzRSL____Configuration__i_Compile {

  public interface _ILConfiguration {
    bool is_LConfiguration { get; }
    Dafny.ISet<Native____Io__s_Compile._IEndPoint> dtor_clientIds { get; }
    Dafny.ISequence<Native____Io__s_Compile._IEndPoint> dtor_replica__ids { get; }
    _ILConfiguration DowncastClone();
  }
  public class LConfiguration : _ILConfiguration {
    public readonly Dafny.ISet<Native____Io__s_Compile._IEndPoint> _clientIds;
    public readonly Dafny.ISequence<Native____Io__s_Compile._IEndPoint> _replica__ids;
    public LConfiguration(Dafny.ISet<Native____Io__s_Compile._IEndPoint> clientIds, Dafny.ISequence<Native____Io__s_Compile._IEndPoint> replica__ids) {
      this._clientIds = clientIds;
      this._replica__ids = replica__ids;
    }
    public _ILConfiguration DowncastClone() {
      if (this is _ILConfiguration dt) { return dt; }
      return new LConfiguration(_clientIds, _replica__ids);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Configuration__i_Compile.LConfiguration;
      return oth != null && object.Equals(this._clientIds, oth._clientIds) && object.Equals(this._replica__ids, oth._replica__ids);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._clientIds));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._replica__ids));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Configuration__i_Compile.LConfiguration.LConfiguration";
      s += "(";
      s += Dafny.Helpers.ToString(this._clientIds);
      s += ", ";
      s += Dafny.Helpers.ToString(this._replica__ids);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____Configuration__i_Compile._ILConfiguration theDefault = create(Dafny.Set<Native____Io__s_Compile._IEndPoint>.Empty, Dafny.Sequence<Native____Io__s_Compile._IEndPoint>.Empty);
    public static LiveByzRSL____Configuration__i_Compile._ILConfiguration Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Configuration__i_Compile._ILConfiguration> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Configuration__i_Compile._ILConfiguration>(LiveByzRSL____Configuration__i_Compile.LConfiguration.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Configuration__i_Compile._ILConfiguration> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ILConfiguration create(Dafny.ISet<Native____Io__s_Compile._IEndPoint> clientIds, Dafny.ISequence<Native____Io__s_Compile._IEndPoint> replica__ids) {
      return new LConfiguration(clientIds, replica__ids);
    }
    public static _ILConfiguration create_LConfiguration(Dafny.ISet<Native____Io__s_Compile._IEndPoint> clientIds, Dafny.ISequence<Native____Io__s_Compile._IEndPoint> replica__ids) {
      return create(clientIds, replica__ids);
    }
    public bool is_LConfiguration { get { return true; } }
    public Dafny.ISet<Native____Io__s_Compile._IEndPoint> dtor_clientIds {
      get {
        return this._clientIds;
      }
    }
    public Dafny.ISequence<Native____Io__s_Compile._IEndPoint> dtor_replica__ids {
      get {
        return this._replica__ids;
      }
    }
  }

} // end of namespace LiveByzRSL____Configuration__i_Compile
namespace Common____UpperBound__s_Compile {

  public interface _IUpperBound {
    bool is_UpperBoundFinite { get; }
    bool is_UpperBoundInfinite { get; }
    BigInteger dtor_n { get; }
    _IUpperBound DowncastClone();
  }
  public abstract class UpperBound : _IUpperBound {
    public UpperBound() { }
    private static readonly Common____UpperBound__s_Compile._IUpperBound theDefault = create_UpperBoundFinite(BigInteger.Zero);
    public static Common____UpperBound__s_Compile._IUpperBound Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Common____UpperBound__s_Compile._IUpperBound> _TYPE = new Dafny.TypeDescriptor<Common____UpperBound__s_Compile._IUpperBound>(Common____UpperBound__s_Compile.UpperBound.Default());
    public static Dafny.TypeDescriptor<Common____UpperBound__s_Compile._IUpperBound> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IUpperBound create_UpperBoundFinite(BigInteger n) {
      return new UpperBound_UpperBoundFinite(n);
    }
    public static _IUpperBound create_UpperBoundInfinite() {
      return new UpperBound_UpperBoundInfinite();
    }
    public bool is_UpperBoundFinite { get { return this is UpperBound_UpperBoundFinite; } }
    public bool is_UpperBoundInfinite { get { return this is UpperBound_UpperBoundInfinite; } }
    public BigInteger dtor_n {
      get {
        var d = this;
        return ((UpperBound_UpperBoundFinite)d)._n;
      }
    }
    public abstract _IUpperBound DowncastClone();
  }
  public class UpperBound_UpperBoundFinite : UpperBound {
    public readonly BigInteger _n;
    public UpperBound_UpperBoundFinite(BigInteger n) {
      this._n = n;
    }
    public override _IUpperBound DowncastClone() {
      if (this is _IUpperBound dt) { return dt; }
      return new UpperBound_UpperBoundFinite(_n);
    }
    public override bool Equals(object other) {
      var oth = other as Common____UpperBound__s_Compile.UpperBound_UpperBoundFinite;
      return oth != null && this._n == oth._n;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._n));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Common____UpperBound__s_Compile.UpperBound.UpperBoundFinite";
      s += "(";
      s += Dafny.Helpers.ToString(this._n);
      s += ")";
      return s;
    }
  }
  public class UpperBound_UpperBoundInfinite : UpperBound {
    public UpperBound_UpperBoundInfinite() {
    }
    public override _IUpperBound DowncastClone() {
      if (this is _IUpperBound dt) { return dt; }
      return new UpperBound_UpperBoundInfinite();
    }
    public override bool Equals(object other) {
      var oth = other as Common____UpperBound__s_Compile.UpperBound_UpperBoundInfinite;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Common____UpperBound__s_Compile.UpperBound.UpperBoundInfinite";
      return s;
    }
  }

} // end of namespace Common____UpperBound__s_Compile
namespace LiveByzRSL____Parameters__i_Compile {

  public interface _ILParameters {
    bool is_LParameters { get; }
    BigInteger dtor_max__log__length { get; }
    BigInteger dtor_baseline__view__timeout__period { get; }
    BigInteger dtor_heartbeat__period { get; }
    Common____UpperBound__s_Compile._IUpperBound dtor_max__integer__val { get; }
    BigInteger dtor_max__batch__size { get; }
    BigInteger dtor_max__batch__delay { get; }
    _ILParameters DowncastClone();
  }
  public class LParameters : _ILParameters {
    public readonly BigInteger _max__log__length;
    public readonly BigInteger _baseline__view__timeout__period;
    public readonly BigInteger _heartbeat__period;
    public readonly Common____UpperBound__s_Compile._IUpperBound _max__integer__val;
    public readonly BigInteger _max__batch__size;
    public readonly BigInteger _max__batch__delay;
    public LParameters(BigInteger max__log__length, BigInteger baseline__view__timeout__period, BigInteger heartbeat__period, Common____UpperBound__s_Compile._IUpperBound max__integer__val, BigInteger max__batch__size, BigInteger max__batch__delay) {
      this._max__log__length = max__log__length;
      this._baseline__view__timeout__period = baseline__view__timeout__period;
      this._heartbeat__period = heartbeat__period;
      this._max__integer__val = max__integer__val;
      this._max__batch__size = max__batch__size;
      this._max__batch__delay = max__batch__delay;
    }
    public _ILParameters DowncastClone() {
      if (this is _ILParameters dt) { return dt; }
      return new LParameters(_max__log__length, _baseline__view__timeout__period, _heartbeat__period, _max__integer__val, _max__batch__size, _max__batch__delay);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Parameters__i_Compile.LParameters;
      return oth != null && this._max__log__length == oth._max__log__length && this._baseline__view__timeout__period == oth._baseline__view__timeout__period && this._heartbeat__period == oth._heartbeat__period && object.Equals(this._max__integer__val, oth._max__integer__val) && this._max__batch__size == oth._max__batch__size && this._max__batch__delay == oth._max__batch__delay;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__log__length));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._baseline__view__timeout__period));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._heartbeat__period));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__integer__val));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__batch__size));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__batch__delay));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Parameters__i_Compile.LParameters.LParameters";
      s += "(";
      s += Dafny.Helpers.ToString(this._max__log__length);
      s += ", ";
      s += Dafny.Helpers.ToString(this._baseline__view__timeout__period);
      s += ", ";
      s += Dafny.Helpers.ToString(this._heartbeat__period);
      s += ", ";
      s += Dafny.Helpers.ToString(this._max__integer__val);
      s += ", ";
      s += Dafny.Helpers.ToString(this._max__batch__size);
      s += ", ";
      s += Dafny.Helpers.ToString(this._max__batch__delay);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____Parameters__i_Compile._ILParameters theDefault = create(BigInteger.Zero, BigInteger.Zero, BigInteger.Zero, Common____UpperBound__s_Compile.UpperBound.Default(), BigInteger.Zero, BigInteger.Zero);
    public static LiveByzRSL____Parameters__i_Compile._ILParameters Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Parameters__i_Compile._ILParameters> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Parameters__i_Compile._ILParameters>(LiveByzRSL____Parameters__i_Compile.LParameters.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Parameters__i_Compile._ILParameters> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ILParameters create(BigInteger max__log__length, BigInteger baseline__view__timeout__period, BigInteger heartbeat__period, Common____UpperBound__s_Compile._IUpperBound max__integer__val, BigInteger max__batch__size, BigInteger max__batch__delay) {
      return new LParameters(max__log__length, baseline__view__timeout__period, heartbeat__period, max__integer__val, max__batch__size, max__batch__delay);
    }
    public static _ILParameters create_LParameters(BigInteger max__log__length, BigInteger baseline__view__timeout__period, BigInteger heartbeat__period, Common____UpperBound__s_Compile._IUpperBound max__integer__val, BigInteger max__batch__size, BigInteger max__batch__delay) {
      return create(max__log__length, baseline__view__timeout__period, heartbeat__period, max__integer__val, max__batch__size, max__batch__delay);
    }
    public bool is_LParameters { get { return true; } }
    public BigInteger dtor_max__log__length {
      get {
        return this._max__log__length;
      }
    }
    public BigInteger dtor_baseline__view__timeout__period {
      get {
        return this._baseline__view__timeout__period;
      }
    }
    public BigInteger dtor_heartbeat__period {
      get {
        return this._heartbeat__period;
      }
    }
    public Common____UpperBound__s_Compile._IUpperBound dtor_max__integer__val {
      get {
        return this._max__integer__val;
      }
    }
    public BigInteger dtor_max__batch__size {
      get {
        return this._max__batch__size;
      }
    }
    public BigInteger dtor_max__batch__delay {
      get {
        return this._max__batch__delay;
      }
    }
  }

} // end of namespace LiveByzRSL____Parameters__i_Compile
namespace LiveByzRSL____Constants__i_Compile {

  public interface _ILConstants {
    bool is_LConstants { get; }
    LiveByzRSL____Configuration__i_Compile._ILConfiguration dtor_config { get; }
    LiveByzRSL____Parameters__i_Compile._ILParameters dtor_params { get; }
    _ILConstants DowncastClone();
  }
  public class LConstants : _ILConstants {
    public readonly LiveByzRSL____Configuration__i_Compile._ILConfiguration _config;
    public readonly LiveByzRSL____Parameters__i_Compile._ILParameters _params;
    public LConstants(LiveByzRSL____Configuration__i_Compile._ILConfiguration config, LiveByzRSL____Parameters__i_Compile._ILParameters @params) {
      this._config = config;
      this._params = @params;
    }
    public _ILConstants DowncastClone() {
      if (this is _ILConstants dt) { return dt; }
      return new LConstants(_config, _params);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Constants__i_Compile.LConstants;
      return oth != null && object.Equals(this._config, oth._config) && object.Equals(this._params, oth._params);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._config));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._params));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Constants__i_Compile.LConstants.LConstants";
      s += "(";
      s += Dafny.Helpers.ToString(this._config);
      s += ", ";
      s += Dafny.Helpers.ToString(this._params);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____Constants__i_Compile._ILConstants theDefault = create(LiveByzRSL____Configuration__i_Compile.LConfiguration.Default(), LiveByzRSL____Parameters__i_Compile.LParameters.Default());
    public static LiveByzRSL____Constants__i_Compile._ILConstants Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Constants__i_Compile._ILConstants> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Constants__i_Compile._ILConstants>(LiveByzRSL____Constants__i_Compile.LConstants.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Constants__i_Compile._ILConstants> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ILConstants create(LiveByzRSL____Configuration__i_Compile._ILConfiguration config, LiveByzRSL____Parameters__i_Compile._ILParameters @params) {
      return new LConstants(config, @params);
    }
    public static _ILConstants create_LConstants(LiveByzRSL____Configuration__i_Compile._ILConfiguration config, LiveByzRSL____Parameters__i_Compile._ILParameters @params) {
      return create(config, @params);
    }
    public bool is_LConstants { get { return true; } }
    public LiveByzRSL____Configuration__i_Compile._ILConfiguration dtor_config {
      get {
        return this._config;
      }
    }
    public LiveByzRSL____Parameters__i_Compile._ILParameters dtor_params {
      get {
        return this._params;
      }
    }
  }

  public interface _ILReplicaConstants {
    bool is_LReplicaConstants { get; }
    BigInteger dtor_my__index { get; }
    LiveByzRSL____Constants__i_Compile._ILConstants dtor_all { get; }
    _ILReplicaConstants DowncastClone();
  }
  public class LReplicaConstants : _ILReplicaConstants {
    public readonly BigInteger _my__index;
    public readonly LiveByzRSL____Constants__i_Compile._ILConstants _all;
    public LReplicaConstants(BigInteger my__index, LiveByzRSL____Constants__i_Compile._ILConstants all) {
      this._my__index = my__index;
      this._all = all;
    }
    public _ILReplicaConstants DowncastClone() {
      if (this is _ILReplicaConstants dt) { return dt; }
      return new LReplicaConstants(_my__index, _all);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Constants__i_Compile.LReplicaConstants;
      return oth != null && this._my__index == oth._my__index && object.Equals(this._all, oth._all);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._my__index));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._all));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Constants__i_Compile.LReplicaConstants.LReplicaConstants";
      s += "(";
      s += Dafny.Helpers.ToString(this._my__index);
      s += ", ";
      s += Dafny.Helpers.ToString(this._all);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____Constants__i_Compile._ILReplicaConstants theDefault = create(BigInteger.Zero, LiveByzRSL____Constants__i_Compile.LConstants.Default());
    public static LiveByzRSL____Constants__i_Compile._ILReplicaConstants Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Constants__i_Compile._ILReplicaConstants> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Constants__i_Compile._ILReplicaConstants>(LiveByzRSL____Constants__i_Compile.LReplicaConstants.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Constants__i_Compile._ILReplicaConstants> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ILReplicaConstants create(BigInteger my__index, LiveByzRSL____Constants__i_Compile._ILConstants all) {
      return new LReplicaConstants(my__index, all);
    }
    public static _ILReplicaConstants create_LReplicaConstants(BigInteger my__index, LiveByzRSL____Constants__i_Compile._ILConstants all) {
      return create(my__index, all);
    }
    public bool is_LReplicaConstants { get { return true; } }
    public BigInteger dtor_my__index {
      get {
        return this._my__index;
      }
    }
    public LiveByzRSL____Constants__i_Compile._ILConstants dtor_all {
      get {
        return this._all;
      }
    }
  }

} // end of namespace LiveByzRSL____Constants__i_Compile
namespace Common____UpperBound__i_Compile {

  public interface _ICUpperBound {
    bool is_CUpperBoundFinite { get; }
    bool is_CUpperBoundInfinite { get; }
    BigInteger dtor_n { get; }
    _ICUpperBound DowncastClone();
  }
  public abstract class CUpperBound : _ICUpperBound {
    public CUpperBound() { }
    private static readonly Common____UpperBound__i_Compile._ICUpperBound theDefault = create_CUpperBoundFinite(BigInteger.Zero);
    public static Common____UpperBound__i_Compile._ICUpperBound Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Common____UpperBound__i_Compile._ICUpperBound> _TYPE = new Dafny.TypeDescriptor<Common____UpperBound__i_Compile._ICUpperBound>(Common____UpperBound__i_Compile.CUpperBound.Default());
    public static Dafny.TypeDescriptor<Common____UpperBound__i_Compile._ICUpperBound> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICUpperBound create_CUpperBoundFinite(BigInteger n) {
      return new CUpperBound_CUpperBoundFinite(n);
    }
    public static _ICUpperBound create_CUpperBoundInfinite() {
      return new CUpperBound_CUpperBoundInfinite();
    }
    public bool is_CUpperBoundFinite { get { return this is CUpperBound_CUpperBoundFinite; } }
    public bool is_CUpperBoundInfinite { get { return this is CUpperBound_CUpperBoundInfinite; } }
    public BigInteger dtor_n {
      get {
        var d = this;
        return ((CUpperBound_CUpperBoundFinite)d)._n;
      }
    }
    public abstract _ICUpperBound DowncastClone();
  }
  public class CUpperBound_CUpperBoundFinite : CUpperBound {
    public readonly BigInteger _n;
    public CUpperBound_CUpperBoundFinite(BigInteger n) {
      this._n = n;
    }
    public override _ICUpperBound DowncastClone() {
      if (this is _ICUpperBound dt) { return dt; }
      return new CUpperBound_CUpperBoundFinite(_n);
    }
    public override bool Equals(object other) {
      var oth = other as Common____UpperBound__i_Compile.CUpperBound_CUpperBoundFinite;
      return oth != null && this._n == oth._n;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._n));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Common____UpperBound__i_Compile.CUpperBound.CUpperBoundFinite";
      s += "(";
      s += Dafny.Helpers.ToString(this._n);
      s += ")";
      return s;
    }
  }
  public class CUpperBound_CUpperBoundInfinite : CUpperBound {
    public CUpperBound_CUpperBoundInfinite() {
    }
    public override _ICUpperBound DowncastClone() {
      if (this is _ICUpperBound dt) { return dt; }
      return new CUpperBound_CUpperBoundInfinite();
    }
    public override bool Equals(object other) {
      var oth = other as Common____UpperBound__i_Compile.CUpperBound_CUpperBoundInfinite;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Common____UpperBound__i_Compile.CUpperBound.CUpperBoundInfinite";
      return s;
    }
  }

  public partial class __default {
    public static bool CLeqUpperBound(BigInteger x, Common____UpperBound__i_Compile._ICUpperBound u)
    {
      Common____UpperBound__i_Compile._ICUpperBound _source0 = u;
      if (_source0.is_CUpperBoundFinite) {
        BigInteger _10___mcc_h0 = _source0.dtor_n;
        BigInteger _11_n = _10___mcc_h0;
        return (x) <= (_11_n);
      } else {
        return true;
      }
    }
    public static bool CLtUpperBound(BigInteger x, Common____UpperBound__i_Compile._ICUpperBound u)
    {
      Common____UpperBound__i_Compile._ICUpperBound _source1 = u;
      if (_source1.is_CUpperBoundFinite) {
        BigInteger _12___mcc_h0 = _source1.dtor_n;
        BigInteger _13_n = _12___mcc_h0;
        return (x) < (_13_n);
      } else {
        return true;
      }
    }
    public static BigInteger UpperBoundedAdditionImpl(BigInteger x, BigInteger y, Common____UpperBound__i_Compile._ICUpperBound u)
    {
      if (Common____UpperBound__i_Compile.__default.CLtUpperBound((x) + (y), u)) {
        return (x) + (y);
      } else {
        return (u).dtor_n;
      }
    }
  }
} // end of namespace Common____UpperBound__i_Compile
namespace LiveByzRSL____ParametersState__i_Compile {

  public interface _ICParameters {
    bool is_CParameters { get; }
    BigInteger dtor_max__log__length { get; }
    BigInteger dtor_baseline__view__timeout__period { get; }
    BigInteger dtor_heartbeat__period { get; }
    Common____UpperBound__i_Compile._ICUpperBound dtor_max__integer__val { get; }
    BigInteger dtor_max__batch__size { get; }
    BigInteger dtor_max__batch__delay { get; }
    _ICParameters DowncastClone();
  }
  public class CParameters : _ICParameters {
    public readonly BigInteger _max__log__length;
    public readonly BigInteger _baseline__view__timeout__period;
    public readonly BigInteger _heartbeat__period;
    public readonly Common____UpperBound__i_Compile._ICUpperBound _max__integer__val;
    public readonly BigInteger _max__batch__size;
    public readonly BigInteger _max__batch__delay;
    public CParameters(BigInteger max__log__length, BigInteger baseline__view__timeout__period, BigInteger heartbeat__period, Common____UpperBound__i_Compile._ICUpperBound max__integer__val, BigInteger max__batch__size, BigInteger max__batch__delay) {
      this._max__log__length = max__log__length;
      this._baseline__view__timeout__period = baseline__view__timeout__period;
      this._heartbeat__period = heartbeat__period;
      this._max__integer__val = max__integer__val;
      this._max__batch__size = max__batch__size;
      this._max__batch__delay = max__batch__delay;
    }
    public _ICParameters DowncastClone() {
      if (this is _ICParameters dt) { return dt; }
      return new CParameters(_max__log__length, _baseline__view__timeout__period, _heartbeat__period, _max__integer__val, _max__batch__size, _max__batch__delay);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____ParametersState__i_Compile.CParameters;
      return oth != null && this._max__log__length == oth._max__log__length && this._baseline__view__timeout__period == oth._baseline__view__timeout__period && this._heartbeat__period == oth._heartbeat__period && object.Equals(this._max__integer__val, oth._max__integer__val) && this._max__batch__size == oth._max__batch__size && this._max__batch__delay == oth._max__batch__delay;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__log__length));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._baseline__view__timeout__period));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._heartbeat__period));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__integer__val));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__batch__size));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__batch__delay));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____ParametersState__i_Compile.CParameters.CParameters";
      s += "(";
      s += Dafny.Helpers.ToString(this._max__log__length);
      s += ", ";
      s += Dafny.Helpers.ToString(this._baseline__view__timeout__period);
      s += ", ";
      s += Dafny.Helpers.ToString(this._heartbeat__period);
      s += ", ";
      s += Dafny.Helpers.ToString(this._max__integer__val);
      s += ", ";
      s += Dafny.Helpers.ToString(this._max__batch__size);
      s += ", ";
      s += Dafny.Helpers.ToString(this._max__batch__delay);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____ParametersState__i_Compile._ICParameters theDefault = create(BigInteger.Zero, BigInteger.Zero, BigInteger.Zero, Common____UpperBound__i_Compile.CUpperBound.Default(), BigInteger.Zero, BigInteger.Zero);
    public static LiveByzRSL____ParametersState__i_Compile._ICParameters Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____ParametersState__i_Compile._ICParameters> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____ParametersState__i_Compile._ICParameters>(LiveByzRSL____ParametersState__i_Compile.CParameters.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____ParametersState__i_Compile._ICParameters> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICParameters create(BigInteger max__log__length, BigInteger baseline__view__timeout__period, BigInteger heartbeat__period, Common____UpperBound__i_Compile._ICUpperBound max__integer__val, BigInteger max__batch__size, BigInteger max__batch__delay) {
      return new CParameters(max__log__length, baseline__view__timeout__period, heartbeat__period, max__integer__val, max__batch__size, max__batch__delay);
    }
    public static _ICParameters create_CParameters(BigInteger max__log__length, BigInteger baseline__view__timeout__period, BigInteger heartbeat__period, Common____UpperBound__i_Compile._ICUpperBound max__integer__val, BigInteger max__batch__size, BigInteger max__batch__delay) {
      return create(max__log__length, baseline__view__timeout__period, heartbeat__period, max__integer__val, max__batch__size, max__batch__delay);
    }
    public bool is_CParameters { get { return true; } }
    public BigInteger dtor_max__log__length {
      get {
        return this._max__log__length;
      }
    }
    public BigInteger dtor_baseline__view__timeout__period {
      get {
        return this._baseline__view__timeout__period;
      }
    }
    public BigInteger dtor_heartbeat__period {
      get {
        return this._heartbeat__period;
      }
    }
    public Common____UpperBound__i_Compile._ICUpperBound dtor_max__integer__val {
      get {
        return this._max__integer__val;
      }
    }
    public BigInteger dtor_max__batch__size {
      get {
        return this._max__batch__size;
      }
    }
    public BigInteger dtor_max__batch__delay {
      get {
        return this._max__batch__delay;
      }
    }
  }

  public partial class __default {
    public static LiveByzRSL____ParametersState__i_Compile._ICParameters StaticParams() {
      return LiveByzRSL____ParametersState__i_Compile.CParameters.create(new BigInteger(1000), new BigInteger(1000), new BigInteger(30), Common____UpperBound__i_Compile.CUpperBound.create_CUpperBoundInfinite(), BigInteger.One, new BigInteger(10));
    }
  }
} // end of namespace LiveByzRSL____ParametersState__i_Compile
namespace Native____NativeTypes__i_Compile {

  public partial class __default {
    public static ulong Uint64Size() {
      return 8UL;
    }
    public static ulong Uint32Size() {
      return 4UL;
    }
    public static ulong Uint16Size() {
      return 2UL;
    }
  }
} // end of namespace Native____NativeTypes__i_Compile
namespace Math____power2__s_Compile {

} // end of namespace Math____power2__s_Compile
namespace Math____power__s_Compile {

} // end of namespace Math____power__s_Compile
namespace Math____mul__nonlinear__i_Compile {

} // end of namespace Math____mul__nonlinear__i_Compile
namespace Math____mul__auto__proofs__i_Compile {

} // end of namespace Math____mul__auto__proofs__i_Compile
namespace Math____mul__auto__i_Compile {

} // end of namespace Math____mul__auto__i_Compile
namespace Math____mul__i_Compile {

} // end of namespace Math____mul__i_Compile
namespace Math____power__i_Compile {

} // end of namespace Math____power__i_Compile
namespace Math____div__nonlinear__i_Compile {

} // end of namespace Math____div__nonlinear__i_Compile
namespace Math____mod__auto__proofs__i_Compile {

} // end of namespace Math____mod__auto__proofs__i_Compile
namespace Math____mod__auto__i_Compile {

} // end of namespace Math____mod__auto__i_Compile
namespace Math____div__def__i_Compile {

} // end of namespace Math____div__def__i_Compile
namespace Math____div__auto__proofs__i_Compile {

} // end of namespace Math____div__auto__proofs__i_Compile
namespace Math____div__auto__i_Compile {

} // end of namespace Math____div__auto__i_Compile
namespace Math____div__i_Compile {

} // end of namespace Math____div__i_Compile
namespace Math____power2__i_Compile {

} // end of namespace Math____power2__i_Compile
namespace Common____Util__i_Compile {

  public partial class __default {
    public static bool ShouldPrintProfilingInfo() {
      return false;
    }
    public static bool ShouldPrintProgress() {
      return false;
    }
    public static __A[] seqToArray__slow<__A>(Dafny.TypeDescriptor<__A> _td___A, Dafny.ISequence<__A> s)
    {
      __A[] a = new __A[0];
      BigInteger _14_len;
      _14_len = new BigInteger((s).Count);
      __A[] _nw0 = Dafny.ArrayHelpers.InitNewArray1<__A>(_td___A.Default(), Dafny.Helpers.ToIntChecked(_14_len, "array size exceeds memory limit"));
      a = _nw0;
      BigInteger _15_i;
      _15_i = BigInteger.Zero;
      while ((_15_i) < (_14_len)) {
        (a)[(int)((_15_i))] = (s).Select(_15_i);
        _15_i = (_15_i) + (BigInteger.One);
      }
      return a;
    }
    public static void seqIntoArrayOpt<__A>(Dafny.ISequence<__A> s, __A[] a)
    {
      ulong _16_i;
      _16_i = 0UL;
      while ((_16_i) < ((ulong)(s).LongCount)) {
        (a)[(int)((_16_i))] = (s).Select(_16_i);
        _16_i = (_16_i) + (1UL);
      }
    }
    public static __A[] seqToArrayOpt<__A>(Dafny.TypeDescriptor<__A> _td___A, Dafny.ISequence<__A> s)
    {
      __A[] a = new __A[0];
      __A[] _nw1 = Dafny.ArrayHelpers.InitNewArray1<__A>(_td___A.Default(), Dafny.Helpers.ToIntChecked((ulong)(s).LongCount, "array size exceeds memory limit"));
      a = _nw1;
      Common____Util__i_Compile.__default.seqIntoArrayOpt<__A>(s, a);
      return a;
    }
    public static void seqIntoArrayChar(Dafny.ISequence<char> s, char[] a)
    {
      ulong _17_i;
      _17_i = 0UL;
      while ((_17_i) < ((ulong)(s).LongCount)) {
        (a)[(int)((_17_i))] = (s).Select(_17_i);
        _17_i = (_17_i) + (1UL);
      }
    }
    public static void RecordTimingSeq(Dafny.ISequence<char> name, ulong start, ulong end)
    {
      if (Common____Util__i_Compile.__default.ShouldPrintProfilingInfo()) {
        char[] _18_name__array;
        char[] _nw2 = Dafny.ArrayHelpers.InitNewArray1<char>('D', Dafny.Helpers.ToIntChecked(new BigInteger((name).Count), "array size exceeds memory limit"));
        _18_name__array = _nw2;
        Common____Util__i_Compile.__default.seqIntoArrayChar(name, _18_name__array);
        ulong _19_time = 0;
        if ((start) <= (end)) {
          _19_time = (end) - (start);
        } else {
          _19_time = 18446744073709551615UL;
        }
        Native____Io__s_Compile.Time.RecordTiming(_18_name__array, _19_time);
      }
    }
    public static ulong SeqByteToUint64(Dafny.ISequence<byte> bs) {
      return ((((((((((((ulong)((bs).Select(BigInteger.Zero))) * (256UL)) * (256UL)) * (256UL)) * (4294967296UL)) + (((((ulong)((bs).Select(BigInteger.One))) * (256UL)) * (256UL)) * (4294967296UL))) + ((((ulong)((bs).Select(new BigInteger(2)))) * (256UL)) * (4294967296UL))) + (((ulong)((bs).Select(new BigInteger(3)))) * (4294967296UL))) + (((((ulong)((bs).Select(new BigInteger(4)))) * (256UL)) * (256UL)) * (256UL))) + ((((ulong)((bs).Select(new BigInteger(5)))) * (256UL)) * (256UL))) + (((ulong)((bs).Select(new BigInteger(6)))) * (256UL))) + ((ulong)((bs).Select(new BigInteger(7))));
    }
    public static Dafny.ISequence<byte> Uint64ToSeqByte(ulong u) {
      Dafny.ISequence<byte> _20_bs = Dafny.Sequence<byte>.FromElements((byte)((u) / (72057594037927936UL)), (byte)(((u) / (281474976710656UL)) % (256UL)), (byte)(((u) / (1099511627776UL)) % (256UL)), (byte)(((u) / (4294967296UL)) % (256UL)), (byte)(((u) / (16777216UL)) % (256UL)), (byte)(((u) / (65536UL)) % (256UL)), (byte)(((u) / (256UL)) % (256UL)), (byte)((u) % (256UL)));
      BigInteger _21_u__int = new BigInteger(u);
      return _20_bs;
    }
    public static ushort SeqByteToUint16(Dafny.ISequence<byte> bs) {
      return (ushort)(((ushort)(((ushort)((bs).Select(BigInteger.Zero))) * ((ushort)(256)))) + ((ushort)((bs).Select(BigInteger.One))));
    }
    public static Dafny.ISequence<byte> Uint16ToSeqByte(ushort u) {
      Dafny.ISequence<byte> _22_s = Dafny.Sequence<byte>.FromElements((byte)((ushort)(((ushort)((u) / ((ushort)(256)))) % ((ushort)(256)))), (byte)((ushort)((u) % ((ushort)(256)))));
      BigInteger _23_u__int = new BigInteger(u);
      return _22_s;
    }
  }
} // end of namespace Common____Util__i_Compile
namespace Common____UdpClient__i_Compile {

  public partial class __default {
    public static bool EndPointIsValidIPV4(Native____Io__s_Compile._IEndPoint endPoint) {
      return ((new BigInteger(((endPoint).dtor_addr).Count)) == (new BigInteger(4))) && ((((ushort)(0)) <= ((endPoint).dtor_port)) && (((endPoint).dtor_port) <= ((ushort)(65535))));
    }
  }
} // end of namespace Common____UdpClient__i_Compile
namespace Common____SeqIsUniqueDef__i_Compile {

} // end of namespace Common____SeqIsUniqueDef__i_Compile
namespace Common____SeqIsUnique__i_Compile {

  public partial class __default {
    public static Dafny.ISet<__X> SeqToSetConstruct<__X>(Dafny.ISequence<__X> xs)
    {
      Dafny.ISet<__X> s = Dafny.Set<__X>.Empty;
      s = Dafny.Set<__X>.FromElements();
      BigInteger _24_i;
      _24_i = BigInteger.Zero;
      while ((_24_i) < (new BigInteger((xs).Count))) {
        s = Dafny.Set<__X>.Union(s, Dafny.Set<__X>.FromElements((xs).Select(_24_i)));
        _24_i = (_24_i) + (BigInteger.One);
      }
      return s;
    }
    public static Dafny.ISequence<__X> SetToUniqueSeqConstruct<__X>(Dafny.TypeDescriptor<__X> _td___X, Dafny.ISet<__X> s)
    {
      Dafny.ISequence<__X> xs = Dafny.Sequence<__X>.Empty;
      __X[] _25_arr;
      __X[] _nw3 = Dafny.ArrayHelpers.InitNewArray1<__X>(_td___X.Default(), Dafny.Helpers.ToIntChecked(new BigInteger((s).Count), "array size exceeds memory limit"));
      _25_arr = _nw3;
      Dafny.ISet<__X> _26_s1;
      _26_s1 = s;
      while ((new BigInteger((_26_s1).Count)).Sign != 0) {
        __X _27_x;
        foreach (__X _assign_such_that_0 in (_26_s1).Elements) {
          _27_x = (__X)_assign_such_that_0;
          if ((_26_s1).Contains((_27_x))) {
            goto after__ASSIGN_SUCH_THAT_0;
          }
        }
        throw new System.Exception("assign-such-that search produced no value (line 85)");
      after__ASSIGN_SUCH_THAT_0: ;
        var _index0 = (new BigInteger((s).Count)) - (new BigInteger((_26_s1).Count));
        (_25_arr)[(int)(_index0)] = _27_x;
        _26_s1 = Dafny.Set<__X>.Difference(_26_s1, Dafny.Set<__X>.FromElements(_27_x));
      }
      xs = Dafny.Helpers.SeqFromArray(_25_arr);
      return xs;
    }
    public static Dafny.ISequence<__X> SubsequenceConstruct<__X>(Dafny.TypeDescriptor<__X> _td___X, Dafny.ISequence<__X> xs, Func<__X, bool> f)
    {
      Dafny.ISequence<__X> xs_k = Dafny.Sequence<__X>.Empty;
      __X[] _28_arr;
      __X[] _nw4 = Dafny.ArrayHelpers.InitNewArray1<__X>(_td___X.Default(), Dafny.Helpers.ToIntChecked(new BigInteger((xs).Count), "array size exceeds memory limit"));
      _28_arr = _nw4;
      BigInteger _29_i;
      _29_i = BigInteger.Zero;
      BigInteger _30_j;
      _30_j = BigInteger.Zero;
      while ((_29_i) < (new BigInteger((xs).Count))) {
        if (Dafny.Helpers.Id<Func<__X, bool>>(f)((xs).Select(_29_i))) {
          (_28_arr)[(int)((_30_j))] = (xs).Select(_29_i);
          _30_j = (_30_j) + (BigInteger.One);
        }
        _29_i = (_29_i) + (BigInteger.One);
      }
      xs_k = Dafny.Helpers.SeqFromArray(_28_arr).Take(_30_j);
      return xs_k;
    }
    public static Dafny.ISequence<__X> UniqueSubsequenceConstruct<__X>(Dafny.TypeDescriptor<__X> _td___X, Dafny.ISequence<__X> xs, Func<__X, bool> f)
    {
      Dafny.ISequence<__X> xs_k = Dafny.Sequence<__X>.Empty;
      Dafny.ISet<__X> _31_s;
      _31_s = Dafny.Helpers.Id<Func<Dafny.ISequence<__X>, Func<__X, bool>, Dafny.ISet<__X>>>((_32_xs, _33_f) => ((System.Func<Dafny.ISet<__X>>)(() => {
        var _coll2 = new System.Collections.Generic.List<__X>();
        foreach (__X _compr_2 in (_32_xs).Elements) {
          __X _34_x = (__X)_compr_2;
          if (((_32_xs).Contains((_34_x))) && (Dafny.Helpers.Id<Func<__X, bool>>(_33_f)(_34_x))) {
            _coll2.Add(_34_x);
          }
        }
        return Dafny.Set<__X>.FromCollection(_coll2);
      }))())(xs, f);
      Dafny.ISequence<__X> _out3;
      _out3 = Common____SeqIsUnique__i_Compile.__default.SetToUniqueSeqConstruct<__X>(_td___X, _31_s);
      xs_k = _out3;
      return xs_k;
    }
    public static Dafny.ISequence<__X> AppendToUniqueSeq<__X>(Dafny.ISequence<__X> xs, __X x)
    {
      Dafny.ISequence<__X> _35_xs_k = Dafny.Sequence<__X>.Concat(xs, Dafny.Sequence<__X>.FromElements(x));
      return _35_xs_k;
    }
    public static Dafny.ISequence<__X> AppendToUniqueSeqMaybe<__X>(Dafny.ISequence<__X> xs, __X x)
    {
      if ((xs).Contains((x))) {
        return xs;
      } else {
        Dafny.ISequence<__X> _36_xs_k = Dafny.Sequence<__X>.Concat(xs, Dafny.Sequence<__X>.FromElements(x));
        return _36_xs_k;
      }
    }
  }
} // end of namespace Common____SeqIsUnique__i_Compile
namespace Collections____Maps__i_Compile {

  public partial class __default {
    public static Dafny.ISet<__U> domain<__U, __V>(Dafny.IMap<__U,__V> m) {
      return Dafny.Helpers.Id<Func<Dafny.IMap<__U,__V>, Dafny.ISet<__U>>>((_37_m) => ((System.Func<Dafny.ISet<__U>>)(() => {
        var _coll3 = new System.Collections.Generic.List<__U>();
        foreach (__U _compr_3 in (_37_m).Keys.Elements) {
          __U _38_s = (__U)_compr_3;
          if ((_37_m).Contains((_38_s))) {
            _coll3.Add(_38_s);
          }
        }
        return Dafny.Set<__U>.FromCollection(_coll3);
      }))())(m);
    }
    public static Dafny.IMap<__U,__V> RemoveElt<__U, __V>(Dafny.IMap<__U,__V> m, __U elt)
    {
      Dafny.IMap<__U,__V> _39_m_k = Dafny.Helpers.Id<Func<Dafny.IMap<__U,__V>, __U, Dafny.IMap<__U,__V>>>((_40_m, _41_elt) => ((System.Func<Dafny.IMap<__U,__V>>)(() => {
        var _coll4 = new System.Collections.Generic.List<Dafny.Pair<__U,__V>>();
        foreach (__U _compr_4 in (_40_m).Keys.Elements) {
          __U _42_elt_k = (__U)_compr_4;
          if (((_40_m).Contains((_42_elt_k))) && (!object.Equals(_42_elt_k, _41_elt))) {
            _coll4.Add(new Dafny.Pair<__U,__V>(_42_elt_k, Dafny.Map<__U, __V>.Select(_40_m,_42_elt_k)));
          }
        }
        return Dafny.Map<__U,__V>.FromCollection(_coll4);
      }))())(m, elt);
      return _39_m_k;
    }
  }
} // end of namespace Collections____Maps__i_Compile
namespace Logic____Option__i_Compile {

  public interface _IOption<T> {
    bool is_Some { get; }
    bool is_None { get; }
    T dtor_v { get; }
    _IOption<__T> DowncastClone<__T>(Func<T, __T> converter0);
  }
  public abstract class Option<T> : _IOption<T> {
    public Option() { }
    public static Logic____Option__i_Compile._IOption<T> Default() {
      return create_None();
    }
    public static Dafny.TypeDescriptor<Logic____Option__i_Compile._IOption<T>> _TypeDescriptor() {
      return new Dafny.TypeDescriptor<Logic____Option__i_Compile._IOption<T>>(Logic____Option__i_Compile.Option<T>.Default());
    }
    public static _IOption<T> create_Some(T v) {
      return new Option_Some<T>(v);
    }
    public static _IOption<T> create_None() {
      return new Option_None<T>();
    }
    public bool is_Some { get { return this is Option_Some<T>; } }
    public bool is_None { get { return this is Option_None<T>; } }
    public T dtor_v {
      get {
        var d = this;
        return ((Option_Some<T>)d)._v;
      }
    }
    public abstract _IOption<__T> DowncastClone<__T>(Func<T, __T> converter0);
  }
  public class Option_Some<T> : Option<T> {
    public readonly T _v;
    public Option_Some(T v) {
      this._v = v;
    }
    public override _IOption<__T> DowncastClone<__T>(Func<T, __T> converter0) {
      if (this is _IOption<__T> dt) { return dt; }
      return new Option_Some<__T>(converter0(_v));
    }
    public override bool Equals(object other) {
      var oth = other as Logic____Option__i_Compile.Option_Some<T>;
      return oth != null && object.Equals(this._v, oth._v);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._v));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Logic____Option__i_Compile.Option.Some";
      s += "(";
      s += Dafny.Helpers.ToString(this._v);
      s += ")";
      return s;
    }
  }
  public class Option_None<T> : Option<T> {
    public Option_None() {
    }
    public override _IOption<__T> DowncastClone<__T>(Func<T, __T> converter0) {
      if (this is _IOption<__T> dt) { return dt; }
      return new Option_None<__T>();
    }
    public override bool Equals(object other) {
      var oth = other as Logic____Option__i_Compile.Option_None<T>;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Logic____Option__i_Compile.Option.None";
      return s;
    }
  }

} // end of namespace Logic____Option__i_Compile
namespace GenericRefinement__i_Compile {

} // end of namespace GenericRefinement__i_Compile
namespace Common____NodeIdentity__i_Compile {

  public partial class __default {
    public static Dafny.ISequence<byte> ConvertEndPointToSeqByte(Native____Io__s_Compile._IEndPoint e) {
      return Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.FromElements((byte)(0), (byte)(0)), (e).dtor_addr), Common____Util__i_Compile.__default.Uint16ToSeqByte((e).dtor_port));
    }
    public static Native____Io__s_Compile._IEndPoint ConvertSeqByteToEndPoint(Dafny.ISequence<byte> s) {
      return Native____Io__s_Compile.EndPoint.create((s).Subsequence(new BigInteger(2), new BigInteger(6)), Common____Util__i_Compile.__default.SeqByteToUint16((s).Drop(new BigInteger(6))));
    }
    public static ulong ConvertEndPointToUint64(Native____Io__s_Compile._IEndPoint e) {
      return Common____Util__i_Compile.__default.SeqByteToUint64(Common____NodeIdentity__i_Compile.__default.ConvertEndPointToSeqByte(e));
    }
    public static Native____Io__s_Compile._IEndPoint ConvertUint64ToEndPoint(ulong u) {
      return Common____NodeIdentity__i_Compile.__default.ConvertSeqByteToEndPoint(Common____Util__i_Compile.__default.Uint64ToSeqByte(u));
    }
  }
} // end of namespace Common____NodeIdentity__i_Compile
namespace LiveByzRSL____CConfiguration__i_Compile {

  public interface _ICConfiguration {
    bool is_CConfiguration { get; }
    Dafny.ISequence<Native____Io__s_Compile._IEndPoint> dtor_replica__ids { get; }
  }
  public class CConfiguration : _ICConfiguration {
    public readonly Dafny.ISequence<Native____Io__s_Compile._IEndPoint> _replica__ids;
    public CConfiguration(Dafny.ISequence<Native____Io__s_Compile._IEndPoint> replica__ids) {
      this._replica__ids = replica__ids;
    }
    public static Dafny.ISequence<Native____Io__s_Compile._IEndPoint> DowncastClone(Dafny.ISequence<Native____Io__s_Compile._IEndPoint> _this) {
      return _this;
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CConfiguration__i_Compile.CConfiguration;
      return oth != null && object.Equals(this._replica__ids, oth._replica__ids);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._replica__ids));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CConfiguration__i_Compile.CConfiguration.CConfiguration";
      s += "(";
      s += Dafny.Helpers.ToString(this._replica__ids);
      s += ")";
      return s;
    }
    private static readonly Dafny.ISequence<Native____Io__s_Compile._IEndPoint> theDefault = Dafny.Sequence<Native____Io__s_Compile._IEndPoint>.Empty;
    public static Dafny.ISequence<Native____Io__s_Compile._IEndPoint> Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<Native____Io__s_Compile._IEndPoint>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<Native____Io__s_Compile._IEndPoint>>(Dafny.Sequence<Native____Io__s_Compile._IEndPoint>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<Native____Io__s_Compile._IEndPoint>> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICConfiguration create(Dafny.ISequence<Native____Io__s_Compile._IEndPoint> replica__ids) {
      return new CConfiguration(replica__ids);
    }
    public static _ICConfiguration create_CConfiguration(Dafny.ISequence<Native____Io__s_Compile._IEndPoint> replica__ids) {
      return create(replica__ids);
    }
    public bool is_CConfiguration { get { return true; } }
    public Dafny.ISequence<Native____Io__s_Compile._IEndPoint> dtor_replica__ids {
      get {
        return this._replica__ids;
      }
    }
  }

  public partial class __default {
    public static BigInteger CMinQuorumSize(Dafny.ISequence<Native____Io__s_Compile._IEndPoint> c) {
      return (Dafny.Helpers.EuclideanDivision(new BigInteger(((c)).Count), new BigInteger(2))) + (BigInteger.One);
    }
    public static BigInteger CByzQuorumSize(Dafny.ISequence<Native____Io__s_Compile._IEndPoint> c) {
      return (Dafny.Helpers.EuclideanDivision((new BigInteger(2)) * (new BigInteger(((c)).Count)), new BigInteger(3))) + (BigInteger.One);
    }
    public static bool CReplicasDistinct(Dafny.ISequence<Native____Io__s_Compile._IEndPoint> replica__ids, BigInteger i, BigInteger j)
    {
      return !((((((i).Sign != -1) && ((i) < (new BigInteger((replica__ids).Count)))) && ((j).Sign != -1)) && ((j) < (new BigInteger((replica__ids).Count)))) && (object.Equals((replica__ids).Select(i), (replica__ids).Select(j)))) || ((i) == (j));
    }
    public static bool CReplicasIsUnique(Dafny.ISequence<Native____Io__s_Compile._IEndPoint> replica__ids) {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<Native____Io__s_Compile._IEndPoint>, bool>>((_43_replica__ids) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((_43_replica__ids).Count)), true, (((_forall_var_0) => {
        BigInteger _44_i = (BigInteger)_forall_var_0;
        return Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((_43_replica__ids).Count)), true, (((_forall_var_1) => {
          BigInteger _45_j = (BigInteger)_forall_var_1;
          return !((((((_44_i).Sign != -1) && ((_44_i) < (new BigInteger((_43_replica__ids).Count)))) && ((_45_j).Sign != -1)) && ((_45_j) < (new BigInteger((_43_replica__ids).Count)))) && (object.Equals((_43_replica__ids).Select(_44_i), (_43_replica__ids).Select(_45_j)))) || ((_44_i) == (_45_j));
        })));
      }))))(replica__ids);
    }
    public static bool CIsReplicaIndex(BigInteger idx, Native____Io__s_Compile._IEndPoint id, Dafny.ISequence<Native____Io__s_Compile._IEndPoint> c)
    {
      return (((idx).Sign != -1) && ((idx) < (new BigInteger(((c)).Count)))) && (object.Equals(((c)).Select(idx), id));
    }
    public static BigInteger CGetReplicaIndex(Native____Io__s_Compile._IEndPoint id, Dafny.ISequence<Native____Io__s_Compile._IEndPoint> c)
    {
      return Collections____Seqs__i_Compile.__default.FindIndexInSeq<Native____Io__s_Compile._IEndPoint>((c), id);
    }
  }
} // end of namespace LiveByzRSL____CConfiguration__i_Compile
namespace LiveByzRSL____ConstantsState__i_Compile {

  public interface _ICConstants {
    bool is_CConstants { get; }
    Dafny.ISequence<Native____Io__s_Compile._IEndPoint> dtor_config { get; }
    LiveByzRSL____ParametersState__i_Compile._ICParameters dtor_params { get; }
    _ICConstants DowncastClone();
  }
  public class CConstants : _ICConstants {
    public readonly Dafny.ISequence<Native____Io__s_Compile._IEndPoint> _config;
    public readonly LiveByzRSL____ParametersState__i_Compile._ICParameters _params;
    public CConstants(Dafny.ISequence<Native____Io__s_Compile._IEndPoint> config, LiveByzRSL____ParametersState__i_Compile._ICParameters @params) {
      this._config = config;
      this._params = @params;
    }
    public _ICConstants DowncastClone() {
      if (this is _ICConstants dt) { return dt; }
      return new CConstants(_config, _params);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____ConstantsState__i_Compile.CConstants;
      return oth != null && object.Equals(this._config, oth._config) && object.Equals(this._params, oth._params);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._config));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._params));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____ConstantsState__i_Compile.CConstants.CConstants";
      s += "(";
      s += Dafny.Helpers.ToString(this._config);
      s += ", ";
      s += Dafny.Helpers.ToString(this._params);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____ConstantsState__i_Compile._ICConstants theDefault = create(Dafny.Sequence<Native____Io__s_Compile._IEndPoint>.Empty, LiveByzRSL____ParametersState__i_Compile.CParameters.Default());
    public static LiveByzRSL____ConstantsState__i_Compile._ICConstants Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____ConstantsState__i_Compile._ICConstants> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____ConstantsState__i_Compile._ICConstants>(LiveByzRSL____ConstantsState__i_Compile.CConstants.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____ConstantsState__i_Compile._ICConstants> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICConstants create(Dafny.ISequence<Native____Io__s_Compile._IEndPoint> config, LiveByzRSL____ParametersState__i_Compile._ICParameters @params) {
      return new CConstants(config, @params);
    }
    public static _ICConstants create_CConstants(Dafny.ISequence<Native____Io__s_Compile._IEndPoint> config, LiveByzRSL____ParametersState__i_Compile._ICParameters @params) {
      return create(config, @params);
    }
    public bool is_CConstants { get { return true; } }
    public Dafny.ISequence<Native____Io__s_Compile._IEndPoint> dtor_config {
      get {
        return this._config;
      }
    }
    public LiveByzRSL____ParametersState__i_Compile._ICParameters dtor_params {
      get {
        return this._params;
      }
    }
  }

  public interface _ICReplicaConstants {
    bool is_CReplicaConstants { get; }
    BigInteger dtor_my__index { get; }
    LiveByzRSL____ConstantsState__i_Compile._ICConstants dtor_all { get; }
    _ICReplicaConstants DowncastClone();
  }
  public class CReplicaConstants : _ICReplicaConstants {
    public readonly BigInteger _my__index;
    public readonly LiveByzRSL____ConstantsState__i_Compile._ICConstants _all;
    public CReplicaConstants(BigInteger my__index, LiveByzRSL____ConstantsState__i_Compile._ICConstants all) {
      this._my__index = my__index;
      this._all = all;
    }
    public _ICReplicaConstants DowncastClone() {
      if (this is _ICReplicaConstants dt) { return dt; }
      return new CReplicaConstants(_my__index, _all);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____ConstantsState__i_Compile.CReplicaConstants;
      return oth != null && this._my__index == oth._my__index && object.Equals(this._all, oth._all);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._my__index));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._all));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____ConstantsState__i_Compile.CReplicaConstants.CReplicaConstants";
      s += "(";
      s += Dafny.Helpers.ToString(this._my__index);
      s += ", ";
      s += Dafny.Helpers.ToString(this._all);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants theDefault = create(BigInteger.Zero, LiveByzRSL____ConstantsState__i_Compile.CConstants.Default());
    public static LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants>(LiveByzRSL____ConstantsState__i_Compile.CReplicaConstants.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICReplicaConstants create(BigInteger my__index, LiveByzRSL____ConstantsState__i_Compile._ICConstants all) {
      return new CReplicaConstants(my__index, all);
    }
    public static _ICReplicaConstants create_CReplicaConstants(BigInteger my__index, LiveByzRSL____ConstantsState__i_Compile._ICConstants all) {
      return create(my__index, all);
    }
    public bool is_CReplicaConstants { get { return true; } }
    public BigInteger dtor_my__index {
      get {
        return this._my__index;
      }
    }
    public LiveByzRSL____ConstantsState__i_Compile._ICConstants dtor_all {
      get {
        return this._all;
      }
    }
  }

  public partial class __default {
    public static bool CReplicaConstantsValid(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants c) {
      return (((c).dtor_my__index).Sign != -1) && (((c).dtor_my__index) < (new BigInteger(((((c).dtor_all).dtor_config)).Count)));
    }
    public static LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants InitReplicaConstantsState(Native____Io__s_Compile._IEndPoint endPoint, Dafny.ISequence<Native____Io__s_Compile._IEndPoint> config)
    {
      LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants rc = LiveByzRSL____ConstantsState__i_Compile.CReplicaConstants.Default();
      LiveByzRSL____ParametersState__i_Compile._ICParameters _46_params;
      _46_params = LiveByzRSL____ParametersState__i_Compile.__default.StaticParams();
      LiveByzRSL____ConstantsState__i_Compile._ICConstants _47_constants;
      _47_constants = LiveByzRSL____ConstantsState__i_Compile.CConstants.create(config, _46_params);
      BigInteger _48_index;
      _48_index = LiveByzRSL____CConfiguration__i_Compile.__default.CGetReplicaIndex(endPoint, config);
      rc = LiveByzRSL____ConstantsState__i_Compile.CReplicaConstants.create(_48_index, _47_constants);
      return rc;
    }
  }
} // end of namespace LiveByzRSL____ConstantsState__i_Compile
namespace LiveByzRSL____Message__i_Compile {

  public interface _IRslMessage {
    bool is_RslMessage__Invalid { get; }
    bool is_RslMessage__Request { get; }
    bool is_RslMessage__1a { get; }
    bool is_RslMessage__1b { get; }
    bool is_RslMessage__1c { get; }
    bool is_RslMessage__2av { get; }
    bool is_RslMessage__2b { get; }
    bool is_RslMessage__Heartbeat { get; }
    bool is_RslMessage__Reply { get; }
    bool is_RslMessage__StartingPhase2 { get; }
    BigInteger dtor_seqno__req { get; }
    AppStateMachine__i_Compile._IAppMessage_k dtor_val { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_bal__1a { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_bal__1b { get; }
    BigInteger dtor_log__truncation__point { get; }
    Dafny.IMap<BigInteger,LiveByzRSL____Types__i_Compile._IBallot> dtor_votes { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_bal__1c { get; }
    BigInteger dtor_opn__1c { get; }
    Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_val__1c { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_bal__2av { get; }
    BigInteger dtor_opn__2av { get; }
    Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_val__2av { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_bal__2b { get; }
    BigInteger dtor_opn__2b { get; }
    Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_val__2b { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_bal__heartbeat { get; }
    bool dtor_suspicious { get; }
    BigInteger dtor_opn__ckpt { get; }
    BigInteger dtor_seqno__reply { get; }
    AppStateMachine__i_Compile._IAppMessage_k dtor_reply { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_bal__2 { get; }
    BigInteger dtor_logTruncationPoint__2 { get; }
    _IRslMessage DowncastClone();
  }
  public abstract class RslMessage : _IRslMessage {
    public RslMessage() { }
    private static readonly LiveByzRSL____Message__i_Compile._IRslMessage theDefault = create_RslMessage__Invalid();
    public static LiveByzRSL____Message__i_Compile._IRslMessage Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Message__i_Compile._IRslMessage> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Message__i_Compile._IRslMessage>(LiveByzRSL____Message__i_Compile.RslMessage.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Message__i_Compile._IRslMessage> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IRslMessage create_RslMessage__Invalid() {
      return new RslMessage_RslMessage__Invalid();
    }
    public static _IRslMessage create_RslMessage__Request(BigInteger seqno__req, AppStateMachine__i_Compile._IAppMessage_k val) {
      return new RslMessage_RslMessage__Request(seqno__req, val);
    }
    public static _IRslMessage create_RslMessage__1a(LiveByzRSL____Types__i_Compile._IBallot bal__1a) {
      return new RslMessage_RslMessage__1a(bal__1a);
    }
    public static _IRslMessage create_RslMessage__1b(LiveByzRSL____Types__i_Compile._IBallot bal__1b, BigInteger log__truncation__point, Dafny.IMap<BigInteger,LiveByzRSL____Types__i_Compile._IBallot> votes) {
      return new RslMessage_RslMessage__1b(bal__1b, log__truncation__point, votes);
    }
    public static _IRslMessage create_RslMessage__1c(LiveByzRSL____Types__i_Compile._IBallot bal__1c, BigInteger opn__1c, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> val__1c) {
      return new RslMessage_RslMessage__1c(bal__1c, opn__1c, val__1c);
    }
    public static _IRslMessage create_RslMessage__2av(LiveByzRSL____Types__i_Compile._IBallot bal__2av, BigInteger opn__2av, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> val__2av) {
      return new RslMessage_RslMessage__2av(bal__2av, opn__2av, val__2av);
    }
    public static _IRslMessage create_RslMessage__2b(LiveByzRSL____Types__i_Compile._IBallot bal__2b, BigInteger opn__2b, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> val__2b) {
      return new RslMessage_RslMessage__2b(bal__2b, opn__2b, val__2b);
    }
    public static _IRslMessage create_RslMessage__Heartbeat(LiveByzRSL____Types__i_Compile._IBallot bal__heartbeat, bool suspicious, BigInteger opn__ckpt) {
      return new RslMessage_RslMessage__Heartbeat(bal__heartbeat, suspicious, opn__ckpt);
    }
    public static _IRslMessage create_RslMessage__Reply(BigInteger seqno__reply, AppStateMachine__i_Compile._IAppMessage_k reply) {
      return new RslMessage_RslMessage__Reply(seqno__reply, reply);
    }
    public static _IRslMessage create_RslMessage__StartingPhase2(LiveByzRSL____Types__i_Compile._IBallot bal__2, BigInteger logTruncationPoint__2) {
      return new RslMessage_RslMessage__StartingPhase2(bal__2, logTruncationPoint__2);
    }
    public bool is_RslMessage__Invalid { get { return this is RslMessage_RslMessage__Invalid; } }
    public bool is_RslMessage__Request { get { return this is RslMessage_RslMessage__Request; } }
    public bool is_RslMessage__1a { get { return this is RslMessage_RslMessage__1a; } }
    public bool is_RslMessage__1b { get { return this is RslMessage_RslMessage__1b; } }
    public bool is_RslMessage__1c { get { return this is RslMessage_RslMessage__1c; } }
    public bool is_RslMessage__2av { get { return this is RslMessage_RslMessage__2av; } }
    public bool is_RslMessage__2b { get { return this is RslMessage_RslMessage__2b; } }
    public bool is_RslMessage__Heartbeat { get { return this is RslMessage_RslMessage__Heartbeat; } }
    public bool is_RslMessage__Reply { get { return this is RslMessage_RslMessage__Reply; } }
    public bool is_RslMessage__StartingPhase2 { get { return this is RslMessage_RslMessage__StartingPhase2; } }
    public BigInteger dtor_seqno__req {
      get {
        var d = this;
        return ((RslMessage_RslMessage__Request)d)._seqno__req;
      }
    }
    public AppStateMachine__i_Compile._IAppMessage_k dtor_val {
      get {
        var d = this;
        return ((RslMessage_RslMessage__Request)d)._val;
      }
    }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_bal__1a {
      get {
        var d = this;
        return ((RslMessage_RslMessage__1a)d)._bal__1a;
      }
    }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_bal__1b {
      get {
        var d = this;
        return ((RslMessage_RslMessage__1b)d)._bal__1b;
      }
    }
    public BigInteger dtor_log__truncation__point {
      get {
        var d = this;
        return ((RslMessage_RslMessage__1b)d)._log__truncation__point;
      }
    }
    public Dafny.IMap<BigInteger,LiveByzRSL____Types__i_Compile._IBallot> dtor_votes {
      get {
        var d = this;
        return ((RslMessage_RslMessage__1b)d)._votes;
      }
    }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_bal__1c {
      get {
        var d = this;
        return ((RslMessage_RslMessage__1c)d)._bal__1c;
      }
    }
    public BigInteger dtor_opn__1c {
      get {
        var d = this;
        return ((RslMessage_RslMessage__1c)d)._opn__1c;
      }
    }
    public Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_val__1c {
      get {
        var d = this;
        return ((RslMessage_RslMessage__1c)d)._val__1c;
      }
    }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_bal__2av {
      get {
        var d = this;
        return ((RslMessage_RslMessage__2av)d)._bal__2av;
      }
    }
    public BigInteger dtor_opn__2av {
      get {
        var d = this;
        return ((RslMessage_RslMessage__2av)d)._opn__2av;
      }
    }
    public Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_val__2av {
      get {
        var d = this;
        return ((RslMessage_RslMessage__2av)d)._val__2av;
      }
    }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_bal__2b {
      get {
        var d = this;
        return ((RslMessage_RslMessage__2b)d)._bal__2b;
      }
    }
    public BigInteger dtor_opn__2b {
      get {
        var d = this;
        return ((RslMessage_RslMessage__2b)d)._opn__2b;
      }
    }
    public Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_val__2b {
      get {
        var d = this;
        return ((RslMessage_RslMessage__2b)d)._val__2b;
      }
    }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_bal__heartbeat {
      get {
        var d = this;
        return ((RslMessage_RslMessage__Heartbeat)d)._bal__heartbeat;
      }
    }
    public bool dtor_suspicious {
      get {
        var d = this;
        return ((RslMessage_RslMessage__Heartbeat)d)._suspicious;
      }
    }
    public BigInteger dtor_opn__ckpt {
      get {
        var d = this;
        return ((RslMessage_RslMessage__Heartbeat)d)._opn__ckpt;
      }
    }
    public BigInteger dtor_seqno__reply {
      get {
        var d = this;
        return ((RslMessage_RslMessage__Reply)d)._seqno__reply;
      }
    }
    public AppStateMachine__i_Compile._IAppMessage_k dtor_reply {
      get {
        var d = this;
        return ((RslMessage_RslMessage__Reply)d)._reply;
      }
    }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_bal__2 {
      get {
        var d = this;
        return ((RslMessage_RslMessage__StartingPhase2)d)._bal__2;
      }
    }
    public BigInteger dtor_logTruncationPoint__2 {
      get {
        var d = this;
        return ((RslMessage_RslMessage__StartingPhase2)d)._logTruncationPoint__2;
      }
    }
    public abstract _IRslMessage DowncastClone();
  }
  public class RslMessage_RslMessage__Invalid : RslMessage {
    public RslMessage_RslMessage__Invalid() {
    }
    public override _IRslMessage DowncastClone() {
      if (this is _IRslMessage dt) { return dt; }
      return new RslMessage_RslMessage__Invalid();
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Message__i_Compile.RslMessage_RslMessage__Invalid;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Message__i_Compile.RslMessage.RslMessage_Invalid";
      return s;
    }
  }
  public class RslMessage_RslMessage__Request : RslMessage {
    public readonly BigInteger _seqno__req;
    public readonly AppStateMachine__i_Compile._IAppMessage_k _val;
    public RslMessage_RslMessage__Request(BigInteger seqno__req, AppStateMachine__i_Compile._IAppMessage_k val) {
      this._seqno__req = seqno__req;
      this._val = val;
    }
    public override _IRslMessage DowncastClone() {
      if (this is _IRslMessage dt) { return dt; }
      return new RslMessage_RslMessage__Request(_seqno__req, _val);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Message__i_Compile.RslMessage_RslMessage__Request;
      return oth != null && this._seqno__req == oth._seqno__req && object.Equals(this._val, oth._val);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._seqno__req));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._val));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Message__i_Compile.RslMessage.RslMessage_Request";
      s += "(";
      s += Dafny.Helpers.ToString(this._seqno__req);
      s += ", ";
      s += Dafny.Helpers.ToString(this._val);
      s += ")";
      return s;
    }
  }
  public class RslMessage_RslMessage__1a : RslMessage {
    public readonly LiveByzRSL____Types__i_Compile._IBallot _bal__1a;
    public RslMessage_RslMessage__1a(LiveByzRSL____Types__i_Compile._IBallot bal__1a) {
      this._bal__1a = bal__1a;
    }
    public override _IRslMessage DowncastClone() {
      if (this is _IRslMessage dt) { return dt; }
      return new RslMessage_RslMessage__1a(_bal__1a);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Message__i_Compile.RslMessage_RslMessage__1a;
      return oth != null && object.Equals(this._bal__1a, oth._bal__1a);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal__1a));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Message__i_Compile.RslMessage.RslMessage_1a";
      s += "(";
      s += Dafny.Helpers.ToString(this._bal__1a);
      s += ")";
      return s;
    }
  }
  public class RslMessage_RslMessage__1b : RslMessage {
    public readonly LiveByzRSL____Types__i_Compile._IBallot _bal__1b;
    public readonly BigInteger _log__truncation__point;
    public readonly Dafny.IMap<BigInteger,LiveByzRSL____Types__i_Compile._IBallot> _votes;
    public RslMessage_RslMessage__1b(LiveByzRSL____Types__i_Compile._IBallot bal__1b, BigInteger log__truncation__point, Dafny.IMap<BigInteger,LiveByzRSL____Types__i_Compile._IBallot> votes) {
      this._bal__1b = bal__1b;
      this._log__truncation__point = log__truncation__point;
      this._votes = votes;
    }
    public override _IRslMessage DowncastClone() {
      if (this is _IRslMessage dt) { return dt; }
      return new RslMessage_RslMessage__1b(_bal__1b, _log__truncation__point, _votes);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Message__i_Compile.RslMessage_RslMessage__1b;
      return oth != null && object.Equals(this._bal__1b, oth._bal__1b) && this._log__truncation__point == oth._log__truncation__point && object.Equals(this._votes, oth._votes);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal__1b));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._log__truncation__point));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._votes));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Message__i_Compile.RslMessage.RslMessage_1b";
      s += "(";
      s += Dafny.Helpers.ToString(this._bal__1b);
      s += ", ";
      s += Dafny.Helpers.ToString(this._log__truncation__point);
      s += ", ";
      s += Dafny.Helpers.ToString(this._votes);
      s += ")";
      return s;
    }
  }
  public class RslMessage_RslMessage__1c : RslMessage {
    public readonly LiveByzRSL____Types__i_Compile._IBallot _bal__1c;
    public readonly BigInteger _opn__1c;
    public readonly Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> _val__1c;
    public RslMessage_RslMessage__1c(LiveByzRSL____Types__i_Compile._IBallot bal__1c, BigInteger opn__1c, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> val__1c) {
      this._bal__1c = bal__1c;
      this._opn__1c = opn__1c;
      this._val__1c = val__1c;
    }
    public override _IRslMessage DowncastClone() {
      if (this is _IRslMessage dt) { return dt; }
      return new RslMessage_RslMessage__1c(_bal__1c, _opn__1c, _val__1c);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Message__i_Compile.RslMessage_RslMessage__1c;
      return oth != null && object.Equals(this._bal__1c, oth._bal__1c) && this._opn__1c == oth._opn__1c && object.Equals(this._val__1c, oth._val__1c);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal__1c));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._opn__1c));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._val__1c));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Message__i_Compile.RslMessage.RslMessage_1c";
      s += "(";
      s += Dafny.Helpers.ToString(this._bal__1c);
      s += ", ";
      s += Dafny.Helpers.ToString(this._opn__1c);
      s += ", ";
      s += Dafny.Helpers.ToString(this._val__1c);
      s += ")";
      return s;
    }
  }
  public class RslMessage_RslMessage__2av : RslMessage {
    public readonly LiveByzRSL____Types__i_Compile._IBallot _bal__2av;
    public readonly BigInteger _opn__2av;
    public readonly Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> _val__2av;
    public RslMessage_RslMessage__2av(LiveByzRSL____Types__i_Compile._IBallot bal__2av, BigInteger opn__2av, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> val__2av) {
      this._bal__2av = bal__2av;
      this._opn__2av = opn__2av;
      this._val__2av = val__2av;
    }
    public override _IRslMessage DowncastClone() {
      if (this is _IRslMessage dt) { return dt; }
      return new RslMessage_RslMessage__2av(_bal__2av, _opn__2av, _val__2av);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Message__i_Compile.RslMessage_RslMessage__2av;
      return oth != null && object.Equals(this._bal__2av, oth._bal__2av) && this._opn__2av == oth._opn__2av && object.Equals(this._val__2av, oth._val__2av);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 5;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal__2av));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._opn__2av));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._val__2av));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Message__i_Compile.RslMessage.RslMessage_2av";
      s += "(";
      s += Dafny.Helpers.ToString(this._bal__2av);
      s += ", ";
      s += Dafny.Helpers.ToString(this._opn__2av);
      s += ", ";
      s += Dafny.Helpers.ToString(this._val__2av);
      s += ")";
      return s;
    }
  }
  public class RslMessage_RslMessage__2b : RslMessage {
    public readonly LiveByzRSL____Types__i_Compile._IBallot _bal__2b;
    public readonly BigInteger _opn__2b;
    public readonly Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> _val__2b;
    public RslMessage_RslMessage__2b(LiveByzRSL____Types__i_Compile._IBallot bal__2b, BigInteger opn__2b, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> val__2b) {
      this._bal__2b = bal__2b;
      this._opn__2b = opn__2b;
      this._val__2b = val__2b;
    }
    public override _IRslMessage DowncastClone() {
      if (this is _IRslMessage dt) { return dt; }
      return new RslMessage_RslMessage__2b(_bal__2b, _opn__2b, _val__2b);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Message__i_Compile.RslMessage_RslMessage__2b;
      return oth != null && object.Equals(this._bal__2b, oth._bal__2b) && this._opn__2b == oth._opn__2b && object.Equals(this._val__2b, oth._val__2b);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 6;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal__2b));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._opn__2b));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._val__2b));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Message__i_Compile.RslMessage.RslMessage_2b";
      s += "(";
      s += Dafny.Helpers.ToString(this._bal__2b);
      s += ", ";
      s += Dafny.Helpers.ToString(this._opn__2b);
      s += ", ";
      s += Dafny.Helpers.ToString(this._val__2b);
      s += ")";
      return s;
    }
  }
  public class RslMessage_RslMessage__Heartbeat : RslMessage {
    public readonly LiveByzRSL____Types__i_Compile._IBallot _bal__heartbeat;
    public readonly bool _suspicious;
    public readonly BigInteger _opn__ckpt;
    public RslMessage_RslMessage__Heartbeat(LiveByzRSL____Types__i_Compile._IBallot bal__heartbeat, bool suspicious, BigInteger opn__ckpt) {
      this._bal__heartbeat = bal__heartbeat;
      this._suspicious = suspicious;
      this._opn__ckpt = opn__ckpt;
    }
    public override _IRslMessage DowncastClone() {
      if (this is _IRslMessage dt) { return dt; }
      return new RslMessage_RslMessage__Heartbeat(_bal__heartbeat, _suspicious, _opn__ckpt);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Message__i_Compile.RslMessage_RslMessage__Heartbeat;
      return oth != null && object.Equals(this._bal__heartbeat, oth._bal__heartbeat) && this._suspicious == oth._suspicious && this._opn__ckpt == oth._opn__ckpt;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 7;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal__heartbeat));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._suspicious));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._opn__ckpt));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Message__i_Compile.RslMessage.RslMessage_Heartbeat";
      s += "(";
      s += Dafny.Helpers.ToString(this._bal__heartbeat);
      s += ", ";
      s += Dafny.Helpers.ToString(this._suspicious);
      s += ", ";
      s += Dafny.Helpers.ToString(this._opn__ckpt);
      s += ")";
      return s;
    }
  }
  public class RslMessage_RslMessage__Reply : RslMessage {
    public readonly BigInteger _seqno__reply;
    public readonly AppStateMachine__i_Compile._IAppMessage_k _reply;
    public RslMessage_RslMessage__Reply(BigInteger seqno__reply, AppStateMachine__i_Compile._IAppMessage_k reply) {
      this._seqno__reply = seqno__reply;
      this._reply = reply;
    }
    public override _IRslMessage DowncastClone() {
      if (this is _IRslMessage dt) { return dt; }
      return new RslMessage_RslMessage__Reply(_seqno__reply, _reply);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Message__i_Compile.RslMessage_RslMessage__Reply;
      return oth != null && this._seqno__reply == oth._seqno__reply && object.Equals(this._reply, oth._reply);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 8;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._seqno__reply));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._reply));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Message__i_Compile.RslMessage.RslMessage_Reply";
      s += "(";
      s += Dafny.Helpers.ToString(this._seqno__reply);
      s += ", ";
      s += Dafny.Helpers.ToString(this._reply);
      s += ")";
      return s;
    }
  }
  public class RslMessage_RslMessage__StartingPhase2 : RslMessage {
    public readonly LiveByzRSL____Types__i_Compile._IBallot _bal__2;
    public readonly BigInteger _logTruncationPoint__2;
    public RslMessage_RslMessage__StartingPhase2(LiveByzRSL____Types__i_Compile._IBallot bal__2, BigInteger logTruncationPoint__2) {
      this._bal__2 = bal__2;
      this._logTruncationPoint__2 = logTruncationPoint__2;
    }
    public override _IRslMessage DowncastClone() {
      if (this is _IRslMessage dt) { return dt; }
      return new RslMessage_RslMessage__StartingPhase2(_bal__2, _logTruncationPoint__2);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Message__i_Compile.RslMessage_RslMessage__StartingPhase2;
      return oth != null && object.Equals(this._bal__2, oth._bal__2) && this._logTruncationPoint__2 == oth._logTruncationPoint__2;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 9;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal__2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._logTruncationPoint__2));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Message__i_Compile.RslMessage.RslMessage_StartingPhase2";
      s += "(";
      s += Dafny.Helpers.ToString(this._bal__2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._logTruncationPoint__2);
      s += ")";
      return s;
    }
  }

} // end of namespace LiveByzRSL____Message__i_Compile
namespace LiveByzRSL____Environment__i_Compile {

} // end of namespace LiveByzRSL____Environment__i_Compile
namespace LiveByzRSL____ClockReading__i_Compile {

  public interface _IClockReading {
    bool is_ClockReading { get; }
    BigInteger dtor_t { get; }
  }
  public class ClockReading : _IClockReading {
    public readonly BigInteger _t;
    public ClockReading(BigInteger t) {
      this._t = t;
    }
    public static BigInteger DowncastClone(BigInteger _this) {
      return _this;
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____ClockReading__i_Compile.ClockReading;
      return oth != null && this._t == oth._t;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._t));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____ClockReading__i_Compile.ClockReading.ClockReading";
      s += "(";
      s += Dafny.Helpers.ToString(this._t);
      s += ")";
      return s;
    }
    private static readonly BigInteger theDefault = BigInteger.Zero;
    public static BigInteger Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<BigInteger> _TYPE = new Dafny.TypeDescriptor<BigInteger>(BigInteger.Zero);
    public static Dafny.TypeDescriptor<BigInteger> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IClockReading create(BigInteger t) {
      return new ClockReading(t);
    }
    public static _IClockReading create_ClockReading(BigInteger t) {
      return create(t);
    }
    public bool is_ClockReading { get { return true; } }
    public BigInteger dtor_t {
      get {
        return this._t;
      }
    }
  }

} // end of namespace LiveByzRSL____ClockReading__i_Compile
namespace LiveByzRSL____Broadcast__i_Compile {

} // end of namespace LiveByzRSL____Broadcast__i_Compile
namespace Collections____CountMatches__i_Compile {

  public partial class __default {
    public static BigInteger CountMatchesInSeq<__T>(Dafny.ISequence<__T> s, Func<__T, bool> f)
    {
      BigInteger _49___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return (BigInteger.Zero) + (_49___accumulator);
      } else {
        _49___accumulator = (((Dafny.Helpers.Id<Func<__T, bool>>(f)((s).Select(BigInteger.Zero))) ? (BigInteger.One) : (BigInteger.Zero))) + (_49___accumulator);
        Dafny.ISequence<__T> _in0 = (s).Drop(BigInteger.One);
        Func<__T, bool> _in1 = f;
        s = _in0;
        f = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static bool IsNthHighestValueInSequence(BigInteger v, Dafny.ISequence<BigInteger> s, BigInteger n)
    {
      return (((((n).Sign == 1) && ((n) <= (new BigInteger((s).Count)))) && ((s).Contains((v)))) && ((Collections____CountMatches__i_Compile.__default.CountMatchesInSeq<BigInteger>(s, Dafny.Helpers.Id<Func<BigInteger, Func<BigInteger, bool>>>((_50_v) => ((System.Func<BigInteger, bool>)((_51_x) => {
        return (_51_x) > (_50_v);
      })))(v))) < (n))) && ((Collections____CountMatches__i_Compile.__default.CountMatchesInSeq<BigInteger>(s, Dafny.Helpers.Id<Func<BigInteger, Func<BigInteger, bool>>>((_52_v) => ((System.Func<BigInteger, bool>)((_53_x) => {
        return (_53_x) >= (_52_v);
      })))(v))) >= (n));
    }
  }
} // end of namespace Collections____CountMatches__i_Compile
namespace LiveByzRSL____CheckValSafety__i_Compile {

} // end of namespace LiveByzRSL____CheckValSafety__i_Compile
namespace LiveByzRSL____Acceptor__i_Compile {

  public interface _IAcceptorTuple {
    bool is_AcceptorTuple { get; }
    Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> dtor_received__2av__packets { get; }
  }
  public class AcceptorTuple : _IAcceptorTuple {
    public readonly Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> _received__2av__packets;
    public AcceptorTuple(Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> received__2av__packets) {
      this._received__2av__packets = received__2av__packets;
    }
    public static Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> DowncastClone(Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> _this) {
      return _this;
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Acceptor__i_Compile.AcceptorTuple;
      return oth != null && object.Equals(this._received__2av__packets, oth._received__2av__packets);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._received__2av__packets));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Acceptor__i_Compile.AcceptorTuple.AcceptorTuple";
      s += "(";
      s += Dafny.Helpers.ToString(this._received__2av__packets);
      s += ")";
      return s;
    }
    private static readonly Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> theDefault = Dafny.Sequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>.Empty;
    public static Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>>(Dafny.Sequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAcceptorTuple create(Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> received__2av__packets) {
      return new AcceptorTuple(received__2av__packets);
    }
    public static _IAcceptorTuple create_AcceptorTuple(Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> received__2av__packets) {
      return create(received__2av__packets);
    }
    public bool is_AcceptorTuple { get { return true; } }
    public Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> dtor_received__2av__packets {
      get {
        return this._received__2av__packets;
      }
    }
  }

  public interface _IValToBeSent2b {
    bool is_ValToBeSent2bKnown { get; }
    bool is_ValToBeSent2bUnknown { get; }
    Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_v { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_bal { get; }
    _IValToBeSent2b DowncastClone();
  }
  public abstract class ValToBeSent2b : _IValToBeSent2b {
    public ValToBeSent2b() { }
    private static readonly LiveByzRSL____Acceptor__i_Compile._IValToBeSent2b theDefault = create_ValToBeSent2bKnown(Dafny.Sequence<LiveByzRSL____Types__i_Compile._IRequest>.Empty, LiveByzRSL____Types__i_Compile.Ballot.Default());
    public static LiveByzRSL____Acceptor__i_Compile._IValToBeSent2b Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Acceptor__i_Compile._IValToBeSent2b> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Acceptor__i_Compile._IValToBeSent2b>(LiveByzRSL____Acceptor__i_Compile.ValToBeSent2b.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Acceptor__i_Compile._IValToBeSent2b> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IValToBeSent2b create_ValToBeSent2bKnown(Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> v, LiveByzRSL____Types__i_Compile._IBallot bal) {
      return new ValToBeSent2b_ValToBeSent2bKnown(v, bal);
    }
    public static _IValToBeSent2b create_ValToBeSent2bUnknown() {
      return new ValToBeSent2b_ValToBeSent2bUnknown();
    }
    public bool is_ValToBeSent2bKnown { get { return this is ValToBeSent2b_ValToBeSent2bKnown; } }
    public bool is_ValToBeSent2bUnknown { get { return this is ValToBeSent2b_ValToBeSent2bUnknown; } }
    public Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_v {
      get {
        var d = this;
        return ((ValToBeSent2b_ValToBeSent2bKnown)d)._v;
      }
    }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_bal {
      get {
        var d = this;
        return ((ValToBeSent2b_ValToBeSent2bKnown)d)._bal;
      }
    }
    public abstract _IValToBeSent2b DowncastClone();
  }
  public class ValToBeSent2b_ValToBeSent2bKnown : ValToBeSent2b {
    public readonly Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> _v;
    public readonly LiveByzRSL____Types__i_Compile._IBallot _bal;
    public ValToBeSent2b_ValToBeSent2bKnown(Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> v, LiveByzRSL____Types__i_Compile._IBallot bal) {
      this._v = v;
      this._bal = bal;
    }
    public override _IValToBeSent2b DowncastClone() {
      if (this is _IValToBeSent2b dt) { return dt; }
      return new ValToBeSent2b_ValToBeSent2bKnown(_v, _bal);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Acceptor__i_Compile.ValToBeSent2b_ValToBeSent2bKnown;
      return oth != null && object.Equals(this._v, oth._v) && object.Equals(this._bal, oth._bal);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._v));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Acceptor__i_Compile.ValToBeSent2b.ValToBeSent2bKnown";
      s += "(";
      s += Dafny.Helpers.ToString(this._v);
      s += ", ";
      s += Dafny.Helpers.ToString(this._bal);
      s += ")";
      return s;
    }
  }
  public class ValToBeSent2b_ValToBeSent2bUnknown : ValToBeSent2b {
    public ValToBeSent2b_ValToBeSent2bUnknown() {
    }
    public override _IValToBeSent2b DowncastClone() {
      if (this is _IValToBeSent2b dt) { return dt; }
      return new ValToBeSent2b_ValToBeSent2bUnknown();
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Acceptor__i_Compile.ValToBeSent2b_ValToBeSent2bUnknown;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Acceptor__i_Compile.ValToBeSent2b.ValToBeSent2bUnknown";
      return s;
    }
  }

  public interface _ILAcceptor {
    bool is_LAcceptor { get; }
    LiveByzRSL____Constants__i_Compile._ILReplicaConstants dtor_constants { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_max__bal { get; }
    Dafny.IMap<BigInteger,LiveByzRSL____Types__i_Compile._IBallot> dtor_votes { get; }
    Dafny.ISequence<BigInteger> dtor_last__checkpointed__operation { get; }
    BigInteger dtor_log__truncation__point { get; }
    Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> dtor_received__1b__packets { get; }
    Dafny.IMap<BigInteger,Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>> dtor_received__2avs { get; }
    BigInteger dtor_opn__to__be__send__2b { get; }
    LiveByzRSL____Acceptor__i_Compile._IValToBeSent2b dtor_val__to__be__sent__2b { get; }
    _ILAcceptor DowncastClone();
  }
  public class LAcceptor : _ILAcceptor {
    public readonly LiveByzRSL____Constants__i_Compile._ILReplicaConstants _constants;
    public readonly LiveByzRSL____Types__i_Compile._IBallot _max__bal;
    public readonly Dafny.IMap<BigInteger,LiveByzRSL____Types__i_Compile._IBallot> _votes;
    public readonly Dafny.ISequence<BigInteger> _last__checkpointed__operation;
    public readonly BigInteger _log__truncation__point;
    public readonly Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> _received__1b__packets;
    public readonly Dafny.IMap<BigInteger,Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>> _received__2avs;
    public readonly BigInteger _opn__to__be__send__2b;
    public readonly LiveByzRSL____Acceptor__i_Compile._IValToBeSent2b _val__to__be__sent__2b;
    public LAcceptor(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, LiveByzRSL____Types__i_Compile._IBallot max__bal, Dafny.IMap<BigInteger,LiveByzRSL____Types__i_Compile._IBallot> votes, Dafny.ISequence<BigInteger> last__checkpointed__operation, BigInteger log__truncation__point, Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> received__1b__packets, Dafny.IMap<BigInteger,Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>> received__2avs, BigInteger opn__to__be__send__2b, LiveByzRSL____Acceptor__i_Compile._IValToBeSent2b val__to__be__sent__2b) {
      this._constants = constants;
      this._max__bal = max__bal;
      this._votes = votes;
      this._last__checkpointed__operation = last__checkpointed__operation;
      this._log__truncation__point = log__truncation__point;
      this._received__1b__packets = received__1b__packets;
      this._received__2avs = received__2avs;
      this._opn__to__be__send__2b = opn__to__be__send__2b;
      this._val__to__be__sent__2b = val__to__be__sent__2b;
    }
    public _ILAcceptor DowncastClone() {
      if (this is _ILAcceptor dt) { return dt; }
      return new LAcceptor(_constants, _max__bal, _votes, _last__checkpointed__operation, _log__truncation__point, _received__1b__packets, _received__2avs, _opn__to__be__send__2b, _val__to__be__sent__2b);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Acceptor__i_Compile.LAcceptor;
      return oth != null && object.Equals(this._constants, oth._constants) && object.Equals(this._max__bal, oth._max__bal) && object.Equals(this._votes, oth._votes) && object.Equals(this._last__checkpointed__operation, oth._last__checkpointed__operation) && this._log__truncation__point == oth._log__truncation__point && object.Equals(this._received__1b__packets, oth._received__1b__packets) && object.Equals(this._received__2avs, oth._received__2avs) && this._opn__to__be__send__2b == oth._opn__to__be__send__2b && object.Equals(this._val__to__be__sent__2b, oth._val__to__be__sent__2b);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._constants));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__bal));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._votes));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._last__checkpointed__operation));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._log__truncation__point));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._received__1b__packets));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._received__2avs));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._opn__to__be__send__2b));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._val__to__be__sent__2b));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Acceptor__i_Compile.LAcceptor.LAcceptor";
      s += "(";
      s += Dafny.Helpers.ToString(this._constants);
      s += ", ";
      s += Dafny.Helpers.ToString(this._max__bal);
      s += ", ";
      s += Dafny.Helpers.ToString(this._votes);
      s += ", ";
      s += Dafny.Helpers.ToString(this._last__checkpointed__operation);
      s += ", ";
      s += Dafny.Helpers.ToString(this._log__truncation__point);
      s += ", ";
      s += Dafny.Helpers.ToString(this._received__1b__packets);
      s += ", ";
      s += Dafny.Helpers.ToString(this._received__2avs);
      s += ", ";
      s += Dafny.Helpers.ToString(this._opn__to__be__send__2b);
      s += ", ";
      s += Dafny.Helpers.ToString(this._val__to__be__sent__2b);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____Acceptor__i_Compile._ILAcceptor theDefault = create(LiveByzRSL____Constants__i_Compile.LReplicaConstants.Default(), LiveByzRSL____Types__i_Compile.Ballot.Default(), Dafny.Map<BigInteger, LiveByzRSL____Types__i_Compile._IBallot>.Empty, Dafny.Sequence<BigInteger>.Empty, BigInteger.Zero, Dafny.Sequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>.Empty, Dafny.Map<BigInteger, Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>>.Empty, BigInteger.Zero, LiveByzRSL____Acceptor__i_Compile.ValToBeSent2b.Default());
    public static LiveByzRSL____Acceptor__i_Compile._ILAcceptor Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Acceptor__i_Compile._ILAcceptor> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Acceptor__i_Compile._ILAcceptor>(LiveByzRSL____Acceptor__i_Compile.LAcceptor.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Acceptor__i_Compile._ILAcceptor> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ILAcceptor create(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, LiveByzRSL____Types__i_Compile._IBallot max__bal, Dafny.IMap<BigInteger,LiveByzRSL____Types__i_Compile._IBallot> votes, Dafny.ISequence<BigInteger> last__checkpointed__operation, BigInteger log__truncation__point, Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> received__1b__packets, Dafny.IMap<BigInteger,Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>> received__2avs, BigInteger opn__to__be__send__2b, LiveByzRSL____Acceptor__i_Compile._IValToBeSent2b val__to__be__sent__2b) {
      return new LAcceptor(constants, max__bal, votes, last__checkpointed__operation, log__truncation__point, received__1b__packets, received__2avs, opn__to__be__send__2b, val__to__be__sent__2b);
    }
    public static _ILAcceptor create_LAcceptor(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, LiveByzRSL____Types__i_Compile._IBallot max__bal, Dafny.IMap<BigInteger,LiveByzRSL____Types__i_Compile._IBallot> votes, Dafny.ISequence<BigInteger> last__checkpointed__operation, BigInteger log__truncation__point, Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> received__1b__packets, Dafny.IMap<BigInteger,Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>> received__2avs, BigInteger opn__to__be__send__2b, LiveByzRSL____Acceptor__i_Compile._IValToBeSent2b val__to__be__sent__2b) {
      return create(constants, max__bal, votes, last__checkpointed__operation, log__truncation__point, received__1b__packets, received__2avs, opn__to__be__send__2b, val__to__be__sent__2b);
    }
    public bool is_LAcceptor { get { return true; } }
    public LiveByzRSL____Constants__i_Compile._ILReplicaConstants dtor_constants {
      get {
        return this._constants;
      }
    }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_max__bal {
      get {
        return this._max__bal;
      }
    }
    public Dafny.IMap<BigInteger,LiveByzRSL____Types__i_Compile._IBallot> dtor_votes {
      get {
        return this._votes;
      }
    }
    public Dafny.ISequence<BigInteger> dtor_last__checkpointed__operation {
      get {
        return this._last__checkpointed__operation;
      }
    }
    public BigInteger dtor_log__truncation__point {
      get {
        return this._log__truncation__point;
      }
    }
    public Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> dtor_received__1b__packets {
      get {
        return this._received__1b__packets;
      }
    }
    public Dafny.IMap<BigInteger,Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>> dtor_received__2avs {
      get {
        return this._received__2avs;
      }
    }
    public BigInteger dtor_opn__to__be__send__2b {
      get {
        return this._opn__to__be__send__2b;
      }
    }
    public LiveByzRSL____Acceptor__i_Compile._IValToBeSent2b dtor_val__to__be__sent__2b {
      get {
        return this._val__to__be__sent__2b;
      }
    }
  }

} // end of namespace LiveByzRSL____Acceptor__i_Compile
namespace LiveByzRSL____Election__i_Compile {

  public interface _IElectionState {
    bool is_ElectionState { get; }
    LiveByzRSL____Constants__i_Compile._ILReplicaConstants dtor_constants { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_current__view { get; }
    Dafny.ISet<BigInteger> dtor_current__view__suspectors { get; }
    BigInteger dtor_epoch__end__time { get; }
    BigInteger dtor_epoch__length { get; }
    Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_requests__received__this__epoch { get; }
    Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_requests__received__prev__epochs { get; }
    _IElectionState DowncastClone();
  }
  public class ElectionState : _IElectionState {
    public readonly LiveByzRSL____Constants__i_Compile._ILReplicaConstants _constants;
    public readonly LiveByzRSL____Types__i_Compile._IBallot _current__view;
    public readonly Dafny.ISet<BigInteger> _current__view__suspectors;
    public readonly BigInteger _epoch__end__time;
    public readonly BigInteger _epoch__length;
    public readonly Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> _requests__received__this__epoch;
    public readonly Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> _requests__received__prev__epochs;
    public ElectionState(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, LiveByzRSL____Types__i_Compile._IBallot current__view, Dafny.ISet<BigInteger> current__view__suspectors, BigInteger epoch__end__time, BigInteger epoch__length, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> requests__received__this__epoch, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> requests__received__prev__epochs) {
      this._constants = constants;
      this._current__view = current__view;
      this._current__view__suspectors = current__view__suspectors;
      this._epoch__end__time = epoch__end__time;
      this._epoch__length = epoch__length;
      this._requests__received__this__epoch = requests__received__this__epoch;
      this._requests__received__prev__epochs = requests__received__prev__epochs;
    }
    public _IElectionState DowncastClone() {
      if (this is _IElectionState dt) { return dt; }
      return new ElectionState(_constants, _current__view, _current__view__suspectors, _epoch__end__time, _epoch__length, _requests__received__this__epoch, _requests__received__prev__epochs);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Election__i_Compile.ElectionState;
      return oth != null && object.Equals(this._constants, oth._constants) && object.Equals(this._current__view, oth._current__view) && object.Equals(this._current__view__suspectors, oth._current__view__suspectors) && this._epoch__end__time == oth._epoch__end__time && this._epoch__length == oth._epoch__length && object.Equals(this._requests__received__this__epoch, oth._requests__received__this__epoch) && object.Equals(this._requests__received__prev__epochs, oth._requests__received__prev__epochs);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._constants));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._current__view));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._current__view__suspectors));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._epoch__end__time));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._epoch__length));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._requests__received__this__epoch));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._requests__received__prev__epochs));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Election__i_Compile.ElectionState.ElectionState";
      s += "(";
      s += Dafny.Helpers.ToString(this._constants);
      s += ", ";
      s += Dafny.Helpers.ToString(this._current__view);
      s += ", ";
      s += Dafny.Helpers.ToString(this._current__view__suspectors);
      s += ", ";
      s += Dafny.Helpers.ToString(this._epoch__end__time);
      s += ", ";
      s += Dafny.Helpers.ToString(this._epoch__length);
      s += ", ";
      s += Dafny.Helpers.ToString(this._requests__received__this__epoch);
      s += ", ";
      s += Dafny.Helpers.ToString(this._requests__received__prev__epochs);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____Election__i_Compile._IElectionState theDefault = create(LiveByzRSL____Constants__i_Compile.LReplicaConstants.Default(), LiveByzRSL____Types__i_Compile.Ballot.Default(), Dafny.Set<BigInteger>.Empty, BigInteger.Zero, BigInteger.Zero, Dafny.Sequence<LiveByzRSL____Types__i_Compile._IRequest>.Empty, Dafny.Sequence<LiveByzRSL____Types__i_Compile._IRequest>.Empty);
    public static LiveByzRSL____Election__i_Compile._IElectionState Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Election__i_Compile._IElectionState> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Election__i_Compile._IElectionState>(LiveByzRSL____Election__i_Compile.ElectionState.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Election__i_Compile._IElectionState> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IElectionState create(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, LiveByzRSL____Types__i_Compile._IBallot current__view, Dafny.ISet<BigInteger> current__view__suspectors, BigInteger epoch__end__time, BigInteger epoch__length, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> requests__received__this__epoch, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> requests__received__prev__epochs) {
      return new ElectionState(constants, current__view, current__view__suspectors, epoch__end__time, epoch__length, requests__received__this__epoch, requests__received__prev__epochs);
    }
    public static _IElectionState create_ElectionState(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, LiveByzRSL____Types__i_Compile._IBallot current__view, Dafny.ISet<BigInteger> current__view__suspectors, BigInteger epoch__end__time, BigInteger epoch__length, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> requests__received__this__epoch, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> requests__received__prev__epochs) {
      return create(constants, current__view, current__view__suspectors, epoch__end__time, epoch__length, requests__received__this__epoch, requests__received__prev__epochs);
    }
    public bool is_ElectionState { get { return true; } }
    public LiveByzRSL____Constants__i_Compile._ILReplicaConstants dtor_constants {
      get {
        return this._constants;
      }
    }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_current__view {
      get {
        return this._current__view;
      }
    }
    public Dafny.ISet<BigInteger> dtor_current__view__suspectors {
      get {
        return this._current__view__suspectors;
      }
    }
    public BigInteger dtor_epoch__end__time {
      get {
        return this._epoch__end__time;
      }
    }
    public BigInteger dtor_epoch__length {
      get {
        return this._epoch__length;
      }
    }
    public Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_requests__received__this__epoch {
      get {
        return this._requests__received__this__epoch;
      }
    }
    public Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_requests__received__prev__epochs {
      get {
        return this._requests__received__prev__epochs;
      }
    }
  }

} // end of namespace LiveByzRSL____Election__i_Compile
namespace LiveByzRSL____Proposer__i_Compile {

  public interface _IIncompleteBatchTimer {
    bool is_IncompleteBatchTimerOn { get; }
    bool is_IncompleteBatchTimerOff { get; }
    BigInteger dtor_when { get; }
    _IIncompleteBatchTimer DowncastClone();
  }
  public abstract class IncompleteBatchTimer : _IIncompleteBatchTimer {
    public IncompleteBatchTimer() { }
    private static readonly LiveByzRSL____Proposer__i_Compile._IIncompleteBatchTimer theDefault = create_IncompleteBatchTimerOn(BigInteger.Zero);
    public static LiveByzRSL____Proposer__i_Compile._IIncompleteBatchTimer Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Proposer__i_Compile._IIncompleteBatchTimer> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Proposer__i_Compile._IIncompleteBatchTimer>(LiveByzRSL____Proposer__i_Compile.IncompleteBatchTimer.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Proposer__i_Compile._IIncompleteBatchTimer> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IIncompleteBatchTimer create_IncompleteBatchTimerOn(BigInteger @when) {
      return new IncompleteBatchTimer_IncompleteBatchTimerOn(@when);
    }
    public static _IIncompleteBatchTimer create_IncompleteBatchTimerOff() {
      return new IncompleteBatchTimer_IncompleteBatchTimerOff();
    }
    public bool is_IncompleteBatchTimerOn { get { return this is IncompleteBatchTimer_IncompleteBatchTimerOn; } }
    public bool is_IncompleteBatchTimerOff { get { return this is IncompleteBatchTimer_IncompleteBatchTimerOff; } }
    public BigInteger dtor_when {
      get {
        var d = this;
        return ((IncompleteBatchTimer_IncompleteBatchTimerOn)d)._when;
      }
    }
    public abstract _IIncompleteBatchTimer DowncastClone();
  }
  public class IncompleteBatchTimer_IncompleteBatchTimerOn : IncompleteBatchTimer {
    public readonly BigInteger _when;
    public IncompleteBatchTimer_IncompleteBatchTimerOn(BigInteger @when) {
      this._when = @when;
    }
    public override _IIncompleteBatchTimer DowncastClone() {
      if (this is _IIncompleteBatchTimer dt) { return dt; }
      return new IncompleteBatchTimer_IncompleteBatchTimerOn(_when);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Proposer__i_Compile.IncompleteBatchTimer_IncompleteBatchTimerOn;
      return oth != null && this._when == oth._when;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._when));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Proposer__i_Compile.IncompleteBatchTimer.IncompleteBatchTimerOn";
      s += "(";
      s += Dafny.Helpers.ToString(this._when);
      s += ")";
      return s;
    }
  }
  public class IncompleteBatchTimer_IncompleteBatchTimerOff : IncompleteBatchTimer {
    public IncompleteBatchTimer_IncompleteBatchTimerOff() {
    }
    public override _IIncompleteBatchTimer DowncastClone() {
      if (this is _IIncompleteBatchTimer dt) { return dt; }
      return new IncompleteBatchTimer_IncompleteBatchTimerOff();
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Proposer__i_Compile.IncompleteBatchTimer_IncompleteBatchTimerOff;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Proposer__i_Compile.IncompleteBatchTimer.IncompleteBatchTimerOff";
      return s;
    }
  }

  public interface _ILProposer {
    bool is_LProposer { get; }
    LiveByzRSL____Constants__i_Compile._ILReplicaConstants dtor_constants { get; }
    BigInteger dtor_current__state { get; }
    Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_request__queue { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_max__ballot__i__sent__1a { get; }
    BigInteger dtor_next__operation__number__to__propose { get; }
    Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> dtor_received__1b__packets { get; }
    Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger> dtor_highest__seqno__requested__by__client__this__view { get; }
    LiveByzRSL____Proposer__i_Compile._IIncompleteBatchTimer dtor_incomplete__batch__timer { get; }
    LiveByzRSL____Election__i_Compile._IElectionState dtor_election__state { get; }
    _ILProposer DowncastClone();
  }
  public class LProposer : _ILProposer {
    public readonly LiveByzRSL____Constants__i_Compile._ILReplicaConstants _constants;
    public readonly BigInteger _current__state;
    public readonly Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> _request__queue;
    public readonly LiveByzRSL____Types__i_Compile._IBallot _max__ballot__i__sent__1a;
    public readonly BigInteger _next__operation__number__to__propose;
    public readonly Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> _received__1b__packets;
    public readonly Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger> _highest__seqno__requested__by__client__this__view;
    public readonly LiveByzRSL____Proposer__i_Compile._IIncompleteBatchTimer _incomplete__batch__timer;
    public readonly LiveByzRSL____Election__i_Compile._IElectionState _election__state;
    public LProposer(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, BigInteger current__state, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> request__queue, LiveByzRSL____Types__i_Compile._IBallot max__ballot__i__sent__1a, BigInteger next__operation__number__to__propose, Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> received__1b__packets, Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger> highest__seqno__requested__by__client__this__view, LiveByzRSL____Proposer__i_Compile._IIncompleteBatchTimer incomplete__batch__timer, LiveByzRSL____Election__i_Compile._IElectionState election__state) {
      this._constants = constants;
      this._current__state = current__state;
      this._request__queue = request__queue;
      this._max__ballot__i__sent__1a = max__ballot__i__sent__1a;
      this._next__operation__number__to__propose = next__operation__number__to__propose;
      this._received__1b__packets = received__1b__packets;
      this._highest__seqno__requested__by__client__this__view = highest__seqno__requested__by__client__this__view;
      this._incomplete__batch__timer = incomplete__batch__timer;
      this._election__state = election__state;
    }
    public _ILProposer DowncastClone() {
      if (this is _ILProposer dt) { return dt; }
      return new LProposer(_constants, _current__state, _request__queue, _max__ballot__i__sent__1a, _next__operation__number__to__propose, _received__1b__packets, _highest__seqno__requested__by__client__this__view, _incomplete__batch__timer, _election__state);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Proposer__i_Compile.LProposer;
      return oth != null && object.Equals(this._constants, oth._constants) && this._current__state == oth._current__state && object.Equals(this._request__queue, oth._request__queue) && object.Equals(this._max__ballot__i__sent__1a, oth._max__ballot__i__sent__1a) && this._next__operation__number__to__propose == oth._next__operation__number__to__propose && object.Equals(this._received__1b__packets, oth._received__1b__packets) && object.Equals(this._highest__seqno__requested__by__client__this__view, oth._highest__seqno__requested__by__client__this__view) && object.Equals(this._incomplete__batch__timer, oth._incomplete__batch__timer) && object.Equals(this._election__state, oth._election__state);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._constants));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._current__state));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._request__queue));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__ballot__i__sent__1a));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._next__operation__number__to__propose));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._received__1b__packets));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._highest__seqno__requested__by__client__this__view));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._incomplete__batch__timer));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._election__state));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Proposer__i_Compile.LProposer.LProposer";
      s += "(";
      s += Dafny.Helpers.ToString(this._constants);
      s += ", ";
      s += Dafny.Helpers.ToString(this._current__state);
      s += ", ";
      s += Dafny.Helpers.ToString(this._request__queue);
      s += ", ";
      s += Dafny.Helpers.ToString(this._max__ballot__i__sent__1a);
      s += ", ";
      s += Dafny.Helpers.ToString(this._next__operation__number__to__propose);
      s += ", ";
      s += Dafny.Helpers.ToString(this._received__1b__packets);
      s += ", ";
      s += Dafny.Helpers.ToString(this._highest__seqno__requested__by__client__this__view);
      s += ", ";
      s += Dafny.Helpers.ToString(this._incomplete__batch__timer);
      s += ", ";
      s += Dafny.Helpers.ToString(this._election__state);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____Proposer__i_Compile._ILProposer theDefault = create(LiveByzRSL____Constants__i_Compile.LReplicaConstants.Default(), BigInteger.Zero, Dafny.Sequence<LiveByzRSL____Types__i_Compile._IRequest>.Empty, LiveByzRSL____Types__i_Compile.Ballot.Default(), BigInteger.Zero, Dafny.Sequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>.Empty, Dafny.Map<Native____Io__s_Compile._IEndPoint, BigInteger>.Empty, LiveByzRSL____Proposer__i_Compile.IncompleteBatchTimer.Default(), LiveByzRSL____Election__i_Compile.ElectionState.Default());
    public static LiveByzRSL____Proposer__i_Compile._ILProposer Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Proposer__i_Compile._ILProposer> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Proposer__i_Compile._ILProposer>(LiveByzRSL____Proposer__i_Compile.LProposer.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Proposer__i_Compile._ILProposer> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ILProposer create(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, BigInteger current__state, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> request__queue, LiveByzRSL____Types__i_Compile._IBallot max__ballot__i__sent__1a, BigInteger next__operation__number__to__propose, Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> received__1b__packets, Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger> highest__seqno__requested__by__client__this__view, LiveByzRSL____Proposer__i_Compile._IIncompleteBatchTimer incomplete__batch__timer, LiveByzRSL____Election__i_Compile._IElectionState election__state) {
      return new LProposer(constants, current__state, request__queue, max__ballot__i__sent__1a, next__operation__number__to__propose, received__1b__packets, highest__seqno__requested__by__client__this__view, incomplete__batch__timer, election__state);
    }
    public static _ILProposer create_LProposer(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, BigInteger current__state, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> request__queue, LiveByzRSL____Types__i_Compile._IBallot max__ballot__i__sent__1a, BigInteger next__operation__number__to__propose, Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> received__1b__packets, Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger> highest__seqno__requested__by__client__this__view, LiveByzRSL____Proposer__i_Compile._IIncompleteBatchTimer incomplete__batch__timer, LiveByzRSL____Election__i_Compile._IElectionState election__state) {
      return create(constants, current__state, request__queue, max__ballot__i__sent__1a, next__operation__number__to__propose, received__1b__packets, highest__seqno__requested__by__client__this__view, incomplete__batch__timer, election__state);
    }
    public bool is_LProposer { get { return true; } }
    public LiveByzRSL____Constants__i_Compile._ILReplicaConstants dtor_constants {
      get {
        return this._constants;
      }
    }
    public BigInteger dtor_current__state {
      get {
        return this._current__state;
      }
    }
    public Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_request__queue {
      get {
        return this._request__queue;
      }
    }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_max__ballot__i__sent__1a {
      get {
        return this._max__ballot__i__sent__1a;
      }
    }
    public BigInteger dtor_next__operation__number__to__propose {
      get {
        return this._next__operation__number__to__propose;
      }
    }
    public Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> dtor_received__1b__packets {
      get {
        return this._received__1b__packets;
      }
    }
    public Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger> dtor_highest__seqno__requested__by__client__this__view {
      get {
        return this._highest__seqno__requested__by__client__this__view;
      }
    }
    public LiveByzRSL____Proposer__i_Compile._IIncompleteBatchTimer dtor_incomplete__batch__timer {
      get {
        return this._incomplete__batch__timer;
      }
    }
    public LiveByzRSL____Election__i_Compile._IElectionState dtor_election__state {
      get {
        return this._election__state;
      }
    }
  }

} // end of namespace LiveByzRSL____Proposer__i_Compile
namespace LiveByzRSL____StateMachine__i_Compile {

} // end of namespace LiveByzRSL____StateMachine__i_Compile
namespace LiveByzRSL____Executor__i_Compile {

  public interface _IOutstandingOperation {
    bool is_OutstandingOpKnown { get; }
    bool is_OutstandingOpUnknown { get; }
    Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_v { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_bal { get; }
    _IOutstandingOperation DowncastClone();
  }
  public abstract class OutstandingOperation : _IOutstandingOperation {
    public OutstandingOperation() { }
    private static readonly LiveByzRSL____Executor__i_Compile._IOutstandingOperation theDefault = create_OutstandingOpKnown(Dafny.Sequence<LiveByzRSL____Types__i_Compile._IRequest>.Empty, LiveByzRSL____Types__i_Compile.Ballot.Default());
    public static LiveByzRSL____Executor__i_Compile._IOutstandingOperation Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Executor__i_Compile._IOutstandingOperation> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Executor__i_Compile._IOutstandingOperation>(LiveByzRSL____Executor__i_Compile.OutstandingOperation.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Executor__i_Compile._IOutstandingOperation> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IOutstandingOperation create_OutstandingOpKnown(Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> v, LiveByzRSL____Types__i_Compile._IBallot bal) {
      return new OutstandingOperation_OutstandingOpKnown(v, bal);
    }
    public static _IOutstandingOperation create_OutstandingOpUnknown() {
      return new OutstandingOperation_OutstandingOpUnknown();
    }
    public bool is_OutstandingOpKnown { get { return this is OutstandingOperation_OutstandingOpKnown; } }
    public bool is_OutstandingOpUnknown { get { return this is OutstandingOperation_OutstandingOpUnknown; } }
    public Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_v {
      get {
        var d = this;
        return ((OutstandingOperation_OutstandingOpKnown)d)._v;
      }
    }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_bal {
      get {
        var d = this;
        return ((OutstandingOperation_OutstandingOpKnown)d)._bal;
      }
    }
    public abstract _IOutstandingOperation DowncastClone();
  }
  public class OutstandingOperation_OutstandingOpKnown : OutstandingOperation {
    public readonly Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> _v;
    public readonly LiveByzRSL____Types__i_Compile._IBallot _bal;
    public OutstandingOperation_OutstandingOpKnown(Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> v, LiveByzRSL____Types__i_Compile._IBallot bal) {
      this._v = v;
      this._bal = bal;
    }
    public override _IOutstandingOperation DowncastClone() {
      if (this is _IOutstandingOperation dt) { return dt; }
      return new OutstandingOperation_OutstandingOpKnown(_v, _bal);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Executor__i_Compile.OutstandingOperation_OutstandingOpKnown;
      return oth != null && object.Equals(this._v, oth._v) && object.Equals(this._bal, oth._bal);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._v));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Executor__i_Compile.OutstandingOperation.OutstandingOpKnown";
      s += "(";
      s += Dafny.Helpers.ToString(this._v);
      s += ", ";
      s += Dafny.Helpers.ToString(this._bal);
      s += ")";
      return s;
    }
  }
  public class OutstandingOperation_OutstandingOpUnknown : OutstandingOperation {
    public OutstandingOperation_OutstandingOpUnknown() {
    }
    public override _IOutstandingOperation DowncastClone() {
      if (this is _IOutstandingOperation dt) { return dt; }
      return new OutstandingOperation_OutstandingOpUnknown();
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Executor__i_Compile.OutstandingOperation_OutstandingOpUnknown;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Executor__i_Compile.OutstandingOperation.OutstandingOpUnknown";
      return s;
    }
  }

  public interface _ILExecutor {
    bool is_LExecutor { get; }
    LiveByzRSL____Constants__i_Compile._ILReplicaConstants dtor_constants { get; }
    ulong dtor_app { get; }
    BigInteger dtor_ops__complete { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_max__bal__reflected { get; }
    LiveByzRSL____Executor__i_Compile._IOutstandingOperation dtor_next__op__to__execute { get; }
    Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____Types__i_Compile._IReply> dtor_reply__cache { get; }
    _ILExecutor DowncastClone();
  }
  public class LExecutor : _ILExecutor {
    public readonly LiveByzRSL____Constants__i_Compile._ILReplicaConstants _constants;
    public readonly ulong _app;
    public readonly BigInteger _ops__complete;
    public readonly LiveByzRSL____Types__i_Compile._IBallot _max__bal__reflected;
    public readonly LiveByzRSL____Executor__i_Compile._IOutstandingOperation _next__op__to__execute;
    public readonly Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____Types__i_Compile._IReply> _reply__cache;
    public LExecutor(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, ulong app, BigInteger ops__complete, LiveByzRSL____Types__i_Compile._IBallot max__bal__reflected, LiveByzRSL____Executor__i_Compile._IOutstandingOperation next__op__to__execute, Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____Types__i_Compile._IReply> reply__cache) {
      this._constants = constants;
      this._app = app;
      this._ops__complete = ops__complete;
      this._max__bal__reflected = max__bal__reflected;
      this._next__op__to__execute = next__op__to__execute;
      this._reply__cache = reply__cache;
    }
    public _ILExecutor DowncastClone() {
      if (this is _ILExecutor dt) { return dt; }
      return new LExecutor(_constants, _app, _ops__complete, _max__bal__reflected, _next__op__to__execute, _reply__cache);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Executor__i_Compile.LExecutor;
      return oth != null && object.Equals(this._constants, oth._constants) && this._app == oth._app && this._ops__complete == oth._ops__complete && object.Equals(this._max__bal__reflected, oth._max__bal__reflected) && object.Equals(this._next__op__to__execute, oth._next__op__to__execute) && object.Equals(this._reply__cache, oth._reply__cache);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._constants));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._app));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ops__complete));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__bal__reflected));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._next__op__to__execute));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._reply__cache));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Executor__i_Compile.LExecutor.LExecutor";
      s += "(";
      s += Dafny.Helpers.ToString(this._constants);
      s += ", ";
      s += Dafny.Helpers.ToString(this._app);
      s += ", ";
      s += Dafny.Helpers.ToString(this._ops__complete);
      s += ", ";
      s += Dafny.Helpers.ToString(this._max__bal__reflected);
      s += ", ";
      s += Dafny.Helpers.ToString(this._next__op__to__execute);
      s += ", ";
      s += Dafny.Helpers.ToString(this._reply__cache);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____Executor__i_Compile._ILExecutor theDefault = create(LiveByzRSL____Constants__i_Compile.LReplicaConstants.Default(), 0, BigInteger.Zero, LiveByzRSL____Types__i_Compile.Ballot.Default(), LiveByzRSL____Executor__i_Compile.OutstandingOperation.Default(), Dafny.Map<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Types__i_Compile._IReply>.Empty);
    public static LiveByzRSL____Executor__i_Compile._ILExecutor Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Executor__i_Compile._ILExecutor> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Executor__i_Compile._ILExecutor>(LiveByzRSL____Executor__i_Compile.LExecutor.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Executor__i_Compile._ILExecutor> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ILExecutor create(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, ulong app, BigInteger ops__complete, LiveByzRSL____Types__i_Compile._IBallot max__bal__reflected, LiveByzRSL____Executor__i_Compile._IOutstandingOperation next__op__to__execute, Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____Types__i_Compile._IReply> reply__cache) {
      return new LExecutor(constants, app, ops__complete, max__bal__reflected, next__op__to__execute, reply__cache);
    }
    public static _ILExecutor create_LExecutor(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, ulong app, BigInteger ops__complete, LiveByzRSL____Types__i_Compile._IBallot max__bal__reflected, LiveByzRSL____Executor__i_Compile._IOutstandingOperation next__op__to__execute, Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____Types__i_Compile._IReply> reply__cache) {
      return create(constants, app, ops__complete, max__bal__reflected, next__op__to__execute, reply__cache);
    }
    public bool is_LExecutor { get { return true; } }
    public LiveByzRSL____Constants__i_Compile._ILReplicaConstants dtor_constants {
      get {
        return this._constants;
      }
    }
    public ulong dtor_app {
      get {
        return this._app;
      }
    }
    public BigInteger dtor_ops__complete {
      get {
        return this._ops__complete;
      }
    }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_max__bal__reflected {
      get {
        return this._max__bal__reflected;
      }
    }
    public LiveByzRSL____Executor__i_Compile._IOutstandingOperation dtor_next__op__to__execute {
      get {
        return this._next__op__to__execute;
      }
    }
    public Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____Types__i_Compile._IReply> dtor_reply__cache {
      get {
        return this._reply__cache;
      }
    }
  }

} // end of namespace LiveByzRSL____Executor__i_Compile
namespace LiveByzRSL____Learner__i_Compile {

  public interface _ILearnerTuple {
    bool is_LearnerTuple { get; }
    Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> dtor_received__2bs { get; }
  }
  public class LearnerTuple : _ILearnerTuple {
    public readonly Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> _received__2bs;
    public LearnerTuple(Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> received__2bs) {
      this._received__2bs = received__2bs;
    }
    public static Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> DowncastClone(Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> _this) {
      return _this;
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Learner__i_Compile.LearnerTuple;
      return oth != null && object.Equals(this._received__2bs, oth._received__2bs);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._received__2bs));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Learner__i_Compile.LearnerTuple.LearnerTuple";
      s += "(";
      s += Dafny.Helpers.ToString(this._received__2bs);
      s += ")";
      return s;
    }
    private static readonly Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> theDefault = Dafny.Sequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>.Empty;
    public static Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>>(Dafny.Sequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ILearnerTuple create(Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> received__2bs) {
      return new LearnerTuple(received__2bs);
    }
    public static _ILearnerTuple create_LearnerTuple(Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> received__2bs) {
      return create(received__2bs);
    }
    public bool is_LearnerTuple { get { return true; } }
    public Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> dtor_received__2bs {
      get {
        return this._received__2bs;
      }
    }
  }

  public interface _ILLearner {
    bool is_LLearner { get; }
    LiveByzRSL____Constants__i_Compile._ILReplicaConstants dtor_constants { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_max__ballot__seen { get; }
    Dafny.IMap<BigInteger,Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>> dtor_unexecuted__learner__state { get; }
    _ILLearner DowncastClone();
  }
  public class LLearner : _ILLearner {
    public readonly LiveByzRSL____Constants__i_Compile._ILReplicaConstants _constants;
    public readonly LiveByzRSL____Types__i_Compile._IBallot _max__ballot__seen;
    public readonly Dafny.IMap<BigInteger,Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>> _unexecuted__learner__state;
    public LLearner(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, LiveByzRSL____Types__i_Compile._IBallot max__ballot__seen, Dafny.IMap<BigInteger,Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>> unexecuted__learner__state) {
      this._constants = constants;
      this._max__ballot__seen = max__ballot__seen;
      this._unexecuted__learner__state = unexecuted__learner__state;
    }
    public _ILLearner DowncastClone() {
      if (this is _ILLearner dt) { return dt; }
      return new LLearner(_constants, _max__ballot__seen, _unexecuted__learner__state);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Learner__i_Compile.LLearner;
      return oth != null && object.Equals(this._constants, oth._constants) && object.Equals(this._max__ballot__seen, oth._max__ballot__seen) && object.Equals(this._unexecuted__learner__state, oth._unexecuted__learner__state);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._constants));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__ballot__seen));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._unexecuted__learner__state));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Learner__i_Compile.LLearner.LLearner";
      s += "(";
      s += Dafny.Helpers.ToString(this._constants);
      s += ", ";
      s += Dafny.Helpers.ToString(this._max__ballot__seen);
      s += ", ";
      s += Dafny.Helpers.ToString(this._unexecuted__learner__state);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____Learner__i_Compile._ILLearner theDefault = create(LiveByzRSL____Constants__i_Compile.LReplicaConstants.Default(), LiveByzRSL____Types__i_Compile.Ballot.Default(), Dafny.Map<BigInteger, Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>>.Empty);
    public static LiveByzRSL____Learner__i_Compile._ILLearner Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Learner__i_Compile._ILLearner> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Learner__i_Compile._ILLearner>(LiveByzRSL____Learner__i_Compile.LLearner.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Learner__i_Compile._ILLearner> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ILLearner create(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, LiveByzRSL____Types__i_Compile._IBallot max__ballot__seen, Dafny.IMap<BigInteger,Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>> unexecuted__learner__state) {
      return new LLearner(constants, max__ballot__seen, unexecuted__learner__state);
    }
    public static _ILLearner create_LLearner(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, LiveByzRSL____Types__i_Compile._IBallot max__ballot__seen, Dafny.IMap<BigInteger,Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>> unexecuted__learner__state) {
      return create(constants, max__ballot__seen, unexecuted__learner__state);
    }
    public bool is_LLearner { get { return true; } }
    public LiveByzRSL____Constants__i_Compile._ILReplicaConstants dtor_constants {
      get {
        return this._constants;
      }
    }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_max__ballot__seen {
      get {
        return this._max__ballot__seen;
      }
    }
    public Dafny.IMap<BigInteger,Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>> dtor_unexecuted__learner__state {
      get {
        return this._unexecuted__learner__state;
      }
    }
  }

} // end of namespace LiveByzRSL____Learner__i_Compile
namespace LiveByzRSL____Replica__i_Compile {

  public interface _ILReplica {
    bool is_LReplica { get; }
    LiveByzRSL____Constants__i_Compile._ILReplicaConstants dtor_constants { get; }
    BigInteger dtor_nextHeartbeatTime { get; }
    LiveByzRSL____Proposer__i_Compile._ILProposer dtor_proposer { get; }
    LiveByzRSL____Acceptor__i_Compile._ILAcceptor dtor_acceptor { get; }
    LiveByzRSL____Learner__i_Compile._ILLearner dtor_learner { get; }
    LiveByzRSL____Executor__i_Compile._ILExecutor dtor_executor { get; }
    _ILReplica DowncastClone();
  }
  public class LReplica : _ILReplica {
    public readonly LiveByzRSL____Constants__i_Compile._ILReplicaConstants _constants;
    public readonly BigInteger _nextHeartbeatTime;
    public readonly LiveByzRSL____Proposer__i_Compile._ILProposer _proposer;
    public readonly LiveByzRSL____Acceptor__i_Compile._ILAcceptor _acceptor;
    public readonly LiveByzRSL____Learner__i_Compile._ILLearner _learner;
    public readonly LiveByzRSL____Executor__i_Compile._ILExecutor _executor;
    public LReplica(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, BigInteger nextHeartbeatTime, LiveByzRSL____Proposer__i_Compile._ILProposer proposer, LiveByzRSL____Acceptor__i_Compile._ILAcceptor acceptor, LiveByzRSL____Learner__i_Compile._ILLearner learner, LiveByzRSL____Executor__i_Compile._ILExecutor executor) {
      this._constants = constants;
      this._nextHeartbeatTime = nextHeartbeatTime;
      this._proposer = proposer;
      this._acceptor = acceptor;
      this._learner = learner;
      this._executor = executor;
    }
    public _ILReplica DowncastClone() {
      if (this is _ILReplica dt) { return dt; }
      return new LReplica(_constants, _nextHeartbeatTime, _proposer, _acceptor, _learner, _executor);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Replica__i_Compile.LReplica;
      return oth != null && object.Equals(this._constants, oth._constants) && this._nextHeartbeatTime == oth._nextHeartbeatTime && object.Equals(this._proposer, oth._proposer) && object.Equals(this._acceptor, oth._acceptor) && object.Equals(this._learner, oth._learner) && object.Equals(this._executor, oth._executor);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._constants));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._nextHeartbeatTime));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._proposer));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._acceptor));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._learner));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._executor));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Replica__i_Compile.LReplica.LReplica";
      s += "(";
      s += Dafny.Helpers.ToString(this._constants);
      s += ", ";
      s += Dafny.Helpers.ToString(this._nextHeartbeatTime);
      s += ", ";
      s += Dafny.Helpers.ToString(this._proposer);
      s += ", ";
      s += Dafny.Helpers.ToString(this._acceptor);
      s += ", ";
      s += Dafny.Helpers.ToString(this._learner);
      s += ", ";
      s += Dafny.Helpers.ToString(this._executor);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____Replica__i_Compile._ILReplica theDefault = create(LiveByzRSL____Constants__i_Compile.LReplicaConstants.Default(), BigInteger.Zero, LiveByzRSL____Proposer__i_Compile.LProposer.Default(), LiveByzRSL____Acceptor__i_Compile.LAcceptor.Default(), LiveByzRSL____Learner__i_Compile.LLearner.Default(), LiveByzRSL____Executor__i_Compile.LExecutor.Default());
    public static LiveByzRSL____Replica__i_Compile._ILReplica Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Replica__i_Compile._ILReplica> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Replica__i_Compile._ILReplica>(LiveByzRSL____Replica__i_Compile.LReplica.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Replica__i_Compile._ILReplica> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ILReplica create(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, BigInteger nextHeartbeatTime, LiveByzRSL____Proposer__i_Compile._ILProposer proposer, LiveByzRSL____Acceptor__i_Compile._ILAcceptor acceptor, LiveByzRSL____Learner__i_Compile._ILLearner learner, LiveByzRSL____Executor__i_Compile._ILExecutor executor) {
      return new LReplica(constants, nextHeartbeatTime, proposer, acceptor, learner, executor);
    }
    public static _ILReplica create_LReplica(LiveByzRSL____Constants__i_Compile._ILReplicaConstants constants, BigInteger nextHeartbeatTime, LiveByzRSL____Proposer__i_Compile._ILProposer proposer, LiveByzRSL____Acceptor__i_Compile._ILAcceptor acceptor, LiveByzRSL____Learner__i_Compile._ILLearner learner, LiveByzRSL____Executor__i_Compile._ILExecutor executor) {
      return create(constants, nextHeartbeatTime, proposer, acceptor, learner, executor);
    }
    public bool is_LReplica { get { return true; } }
    public LiveByzRSL____Constants__i_Compile._ILReplicaConstants dtor_constants {
      get {
        return this._constants;
      }
    }
    public BigInteger dtor_nextHeartbeatTime {
      get {
        return this._nextHeartbeatTime;
      }
    }
    public LiveByzRSL____Proposer__i_Compile._ILProposer dtor_proposer {
      get {
        return this._proposer;
      }
    }
    public LiveByzRSL____Acceptor__i_Compile._ILAcceptor dtor_acceptor {
      get {
        return this._acceptor;
      }
    }
    public LiveByzRSL____Learner__i_Compile._ILLearner dtor_learner {
      get {
        return this._learner;
      }
    }
    public LiveByzRSL____Executor__i_Compile._ILExecutor dtor_executor {
      get {
        return this._executor;
      }
    }
  }

  public interface _ILScheduler {
    bool is_LScheduler { get; }
    LiveByzRSL____Replica__i_Compile._ILReplica dtor_replica { get; }
    BigInteger dtor_nextActionIndex { get; }
    _ILScheduler DowncastClone();
  }
  public class LScheduler : _ILScheduler {
    public readonly LiveByzRSL____Replica__i_Compile._ILReplica _replica;
    public readonly BigInteger _nextActionIndex;
    public LScheduler(LiveByzRSL____Replica__i_Compile._ILReplica replica, BigInteger nextActionIndex) {
      this._replica = replica;
      this._nextActionIndex = nextActionIndex;
    }
    public _ILScheduler DowncastClone() {
      if (this is _ILScheduler dt) { return dt; }
      return new LScheduler(_replica, _nextActionIndex);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____Replica__i_Compile.LScheduler;
      return oth != null && object.Equals(this._replica, oth._replica) && this._nextActionIndex == oth._nextActionIndex;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._replica));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._nextActionIndex));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____Replica__i_Compile.LScheduler.LScheduler";
      s += "(";
      s += Dafny.Helpers.ToString(this._replica);
      s += ", ";
      s += Dafny.Helpers.ToString(this._nextActionIndex);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____Replica__i_Compile._ILScheduler theDefault = create(LiveByzRSL____Replica__i_Compile.LReplica.Default(), BigInteger.Zero);
    public static LiveByzRSL____Replica__i_Compile._ILScheduler Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____Replica__i_Compile._ILScheduler> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____Replica__i_Compile._ILScheduler>(LiveByzRSL____Replica__i_Compile.LScheduler.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____Replica__i_Compile._ILScheduler> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ILScheduler create(LiveByzRSL____Replica__i_Compile._ILReplica replica, BigInteger nextActionIndex) {
      return new LScheduler(replica, nextActionIndex);
    }
    public static _ILScheduler create_LScheduler(LiveByzRSL____Replica__i_Compile._ILReplica replica, BigInteger nextActionIndex) {
      return create(replica, nextActionIndex);
    }
    public bool is_LScheduler { get { return true; } }
    public LiveByzRSL____Replica__i_Compile._ILReplica dtor_replica {
      get {
        return this._replica;
      }
    }
    public BigInteger dtor_nextActionIndex {
      get {
        return this._nextActionIndex;
      }
    }
  }

} // end of namespace LiveByzRSL____Replica__i_Compile
namespace LiveByzRSL____QRelations__i_Compile {

} // end of namespace LiveByzRSL____QRelations__i_Compile
namespace Common____MarshallInt__i_Compile {

  public partial class __default {
    public static void MarshallUint64__guts(ulong n, byte[] data, ulong index)
    {
      (data)[(int)((index))] = (byte)((n) / (72057594037927936UL));
      var _index1 = (index) + (1UL);
      (data)[(int)(_index1)] = (byte)(((n) / (281474976710656UL)) % (256UL));
      var _index2 = (index) + (2UL);
      (data)[(int)(_index2)] = (byte)(((n) / (1099511627776UL)) % (256UL));
      var _index3 = (index) + (3UL);
      (data)[(int)(_index3)] = (byte)(((n) / (4294967296UL)) % (256UL));
      var _index4 = (index) + (4UL);
      (data)[(int)(_index4)] = (byte)(((n) / (16777216UL)) % (256UL));
      var _index5 = (index) + (5UL);
      (data)[(int)(_index5)] = (byte)(((n) / (65536UL)) % (256UL));
      var _index6 = (index) + (6UL);
      (data)[(int)(_index6)] = (byte)(((n) / (256UL)) % (256UL));
      var _index7 = (index) + (7UL);
      (data)[(int)(_index7)] = (byte)((n) % (256UL));
    }
  }
} // end of namespace Common____MarshallInt__i_Compile
namespace Common____GenericMarshalling__i_Compile {

  public interface _IG {
    bool is_GUint64 { get; }
    bool is_GArray { get; }
    bool is_GTuple { get; }
    bool is_GByteArray { get; }
    bool is_GTaggedUnion { get; }
    Common____GenericMarshalling__i_Compile._IG dtor_elt { get; }
    Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> dtor_t { get; }
    Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> dtor_cases { get; }
    _IG DowncastClone();
  }
  public abstract class G : _IG {
    public G() { }
    private static readonly Common____GenericMarshalling__i_Compile._IG theDefault = create_GUint64();
    public static Common____GenericMarshalling__i_Compile._IG Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Common____GenericMarshalling__i_Compile._IG> _TYPE = new Dafny.TypeDescriptor<Common____GenericMarshalling__i_Compile._IG>(Common____GenericMarshalling__i_Compile.G.Default());
    public static Dafny.TypeDescriptor<Common____GenericMarshalling__i_Compile._IG> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IG create_GUint64() {
      return new G_GUint64();
    }
    public static _IG create_GArray(Common____GenericMarshalling__i_Compile._IG elt) {
      return new G_GArray(elt);
    }
    public static _IG create_GTuple(Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> t) {
      return new G_GTuple(t);
    }
    public static _IG create_GByteArray() {
      return new G_GByteArray();
    }
    public static _IG create_GTaggedUnion(Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> cases) {
      return new G_GTaggedUnion(cases);
    }
    public bool is_GUint64 { get { return this is G_GUint64; } }
    public bool is_GArray { get { return this is G_GArray; } }
    public bool is_GTuple { get { return this is G_GTuple; } }
    public bool is_GByteArray { get { return this is G_GByteArray; } }
    public bool is_GTaggedUnion { get { return this is G_GTaggedUnion; } }
    public Common____GenericMarshalling__i_Compile._IG dtor_elt {
      get {
        var d = this;
        return ((G_GArray)d)._elt;
      }
    }
    public Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> dtor_t {
      get {
        var d = this;
        return ((G_GTuple)d)._t;
      }
    }
    public Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> dtor_cases {
      get {
        var d = this;
        return ((G_GTaggedUnion)d)._cases;
      }
    }
    public abstract _IG DowncastClone();
  }
  public class G_GUint64 : G {
    public G_GUint64() {
    }
    public override _IG DowncastClone() {
      if (this is _IG dt) { return dt; }
      return new G_GUint64();
    }
    public override bool Equals(object other) {
      var oth = other as Common____GenericMarshalling__i_Compile.G_GUint64;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Common____GenericMarshalling__i_Compile.G.GUint64";
      return s;
    }
  }
  public class G_GArray : G {
    public readonly Common____GenericMarshalling__i_Compile._IG _elt;
    public G_GArray(Common____GenericMarshalling__i_Compile._IG elt) {
      this._elt = elt;
    }
    public override _IG DowncastClone() {
      if (this is _IG dt) { return dt; }
      return new G_GArray(_elt);
    }
    public override bool Equals(object other) {
      var oth = other as Common____GenericMarshalling__i_Compile.G_GArray;
      return oth != null && object.Equals(this._elt, oth._elt);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._elt));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Common____GenericMarshalling__i_Compile.G.GArray";
      s += "(";
      s += Dafny.Helpers.ToString(this._elt);
      s += ")";
      return s;
    }
  }
  public class G_GTuple : G {
    public readonly Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> _t;
    public G_GTuple(Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> t) {
      this._t = t;
    }
    public override _IG DowncastClone() {
      if (this is _IG dt) { return dt; }
      return new G_GTuple(_t);
    }
    public override bool Equals(object other) {
      var oth = other as Common____GenericMarshalling__i_Compile.G_GTuple;
      return oth != null && object.Equals(this._t, oth._t);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._t));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Common____GenericMarshalling__i_Compile.G.GTuple";
      s += "(";
      s += Dafny.Helpers.ToString(this._t);
      s += ")";
      return s;
    }
  }
  public class G_GByteArray : G {
    public G_GByteArray() {
    }
    public override _IG DowncastClone() {
      if (this is _IG dt) { return dt; }
      return new G_GByteArray();
    }
    public override bool Equals(object other) {
      var oth = other as Common____GenericMarshalling__i_Compile.G_GByteArray;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Common____GenericMarshalling__i_Compile.G.GByteArray";
      return s;
    }
  }
  public class G_GTaggedUnion : G {
    public readonly Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> _cases;
    public G_GTaggedUnion(Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> cases) {
      this._cases = cases;
    }
    public override _IG DowncastClone() {
      if (this is _IG dt) { return dt; }
      return new G_GTaggedUnion(_cases);
    }
    public override bool Equals(object other) {
      var oth = other as Common____GenericMarshalling__i_Compile.G_GTaggedUnion;
      return oth != null && object.Equals(this._cases, oth._cases);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cases));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Common____GenericMarshalling__i_Compile.G.GTaggedUnion";
      s += "(";
      s += Dafny.Helpers.ToString(this._cases);
      s += ")";
      return s;
    }
  }

  public interface _IV {
    bool is_VUint64 { get; }
    bool is_VArray { get; }
    bool is_VTuple { get; }
    bool is_VByteArray { get; }
    bool is_VCase { get; }
    ulong dtor_u { get; }
    Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> dtor_a { get; }
    Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> dtor_t { get; }
    Dafny.ISequence<byte> dtor_b { get; }
    ulong dtor_c { get; }
    Common____GenericMarshalling__i_Compile._IV dtor_val { get; }
    _IV DowncastClone();
  }
  public abstract class V : _IV {
    public V() { }
    private static readonly Common____GenericMarshalling__i_Compile._IV theDefault = create_VUint64(0);
    public static Common____GenericMarshalling__i_Compile._IV Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Common____GenericMarshalling__i_Compile._IV> _TYPE = new Dafny.TypeDescriptor<Common____GenericMarshalling__i_Compile._IV>(Common____GenericMarshalling__i_Compile.V.Default());
    public static Dafny.TypeDescriptor<Common____GenericMarshalling__i_Compile._IV> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IV create_VUint64(ulong u) {
      return new V_VUint64(u);
    }
    public static _IV create_VArray(Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> a) {
      return new V_VArray(a);
    }
    public static _IV create_VTuple(Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> t) {
      return new V_VTuple(t);
    }
    public static _IV create_VByteArray(Dafny.ISequence<byte> b) {
      return new V_VByteArray(b);
    }
    public static _IV create_VCase(ulong c, Common____GenericMarshalling__i_Compile._IV val) {
      return new V_VCase(c, val);
    }
    public bool is_VUint64 { get { return this is V_VUint64; } }
    public bool is_VArray { get { return this is V_VArray; } }
    public bool is_VTuple { get { return this is V_VTuple; } }
    public bool is_VByteArray { get { return this is V_VByteArray; } }
    public bool is_VCase { get { return this is V_VCase; } }
    public ulong dtor_u {
      get {
        var d = this;
        return ((V_VUint64)d)._u;
      }
    }
    public Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> dtor_a {
      get {
        var d = this;
        return ((V_VArray)d)._a;
      }
    }
    public Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> dtor_t {
      get {
        var d = this;
        return ((V_VTuple)d)._t;
      }
    }
    public Dafny.ISequence<byte> dtor_b {
      get {
        var d = this;
        return ((V_VByteArray)d)._b;
      }
    }
    public ulong dtor_c {
      get {
        var d = this;
        return ((V_VCase)d)._c;
      }
    }
    public Common____GenericMarshalling__i_Compile._IV dtor_val {
      get {
        var d = this;
        return ((V_VCase)d)._val;
      }
    }
    public abstract _IV DowncastClone();
  }
  public class V_VUint64 : V {
    public readonly ulong _u;
    public V_VUint64(ulong u) {
      this._u = u;
    }
    public override _IV DowncastClone() {
      if (this is _IV dt) { return dt; }
      return new V_VUint64(_u);
    }
    public override bool Equals(object other) {
      var oth = other as Common____GenericMarshalling__i_Compile.V_VUint64;
      return oth != null && this._u == oth._u;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._u));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Common____GenericMarshalling__i_Compile.V.VUint64";
      s += "(";
      s += Dafny.Helpers.ToString(this._u);
      s += ")";
      return s;
    }
  }
  public class V_VArray : V {
    public readonly Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> _a;
    public V_VArray(Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> a) {
      this._a = a;
    }
    public override _IV DowncastClone() {
      if (this is _IV dt) { return dt; }
      return new V_VArray(_a);
    }
    public override bool Equals(object other) {
      var oth = other as Common____GenericMarshalling__i_Compile.V_VArray;
      return oth != null && object.Equals(this._a, oth._a);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._a));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Common____GenericMarshalling__i_Compile.V.VArray";
      s += "(";
      s += Dafny.Helpers.ToString(this._a);
      s += ")";
      return s;
    }
  }
  public class V_VTuple : V {
    public readonly Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> _t;
    public V_VTuple(Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> t) {
      this._t = t;
    }
    public override _IV DowncastClone() {
      if (this is _IV dt) { return dt; }
      return new V_VTuple(_t);
    }
    public override bool Equals(object other) {
      var oth = other as Common____GenericMarshalling__i_Compile.V_VTuple;
      return oth != null && object.Equals(this._t, oth._t);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._t));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Common____GenericMarshalling__i_Compile.V.VTuple";
      s += "(";
      s += Dafny.Helpers.ToString(this._t);
      s += ")";
      return s;
    }
  }
  public class V_VByteArray : V {
    public readonly Dafny.ISequence<byte> _b;
    public V_VByteArray(Dafny.ISequence<byte> b) {
      this._b = b;
    }
    public override _IV DowncastClone() {
      if (this is _IV dt) { return dt; }
      return new V_VByteArray(_b);
    }
    public override bool Equals(object other) {
      var oth = other as Common____GenericMarshalling__i_Compile.V_VByteArray;
      return oth != null && object.Equals(this._b, oth._b);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._b));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Common____GenericMarshalling__i_Compile.V.VByteArray";
      s += "(";
      s += Dafny.Helpers.ToString(this._b);
      s += ")";
      return s;
    }
  }
  public class V_VCase : V {
    public readonly ulong _c;
    public readonly Common____GenericMarshalling__i_Compile._IV _val;
    public V_VCase(ulong c, Common____GenericMarshalling__i_Compile._IV val) {
      this._c = c;
      this._val = val;
    }
    public override _IV DowncastClone() {
      if (this is _IV dt) { return dt; }
      return new V_VCase(_c, _val);
    }
    public override bool Equals(object other) {
      var oth = other as Common____GenericMarshalling__i_Compile.V_VCase;
      return oth != null && this._c == oth._c && object.Equals(this._val, oth._val);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._c));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._val));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Common____GenericMarshalling__i_Compile.V.VCase";
      s += "(";
      s += Dafny.Helpers.ToString(this._c);
      s += ", ";
      s += Dafny.Helpers.ToString(this._val);
      s += ")";
      return s;
    }
  }

  public interface _IContentsTraceStep {
    bool is_ContentsTraceStep { get; }
    Dafny.ISequence<byte> dtor_data { get; }
    Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV> dtor_val { get; }
    _IContentsTraceStep DowncastClone();
  }
  public class ContentsTraceStep : _IContentsTraceStep {
    public readonly Dafny.ISequence<byte> _data;
    public readonly Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV> _val;
    public ContentsTraceStep(Dafny.ISequence<byte> data, Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV> val) {
      this._data = data;
      this._val = val;
    }
    public _IContentsTraceStep DowncastClone() {
      if (this is _IContentsTraceStep dt) { return dt; }
      return new ContentsTraceStep(_data, _val);
    }
    public override bool Equals(object other) {
      var oth = other as Common____GenericMarshalling__i_Compile.ContentsTraceStep;
      return oth != null && object.Equals(this._data, oth._data) && object.Equals(this._val, oth._val);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._data));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._val));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Common____GenericMarshalling__i_Compile.ContentsTraceStep.ContentsTraceStep";
      s += "(";
      s += Dafny.Helpers.ToString(this._data);
      s += ", ";
      s += Dafny.Helpers.ToString(this._val);
      s += ")";
      return s;
    }
    private static readonly Common____GenericMarshalling__i_Compile._IContentsTraceStep theDefault = create(Dafny.Sequence<byte>.Empty, Logic____Option__i_Compile.Option<Common____GenericMarshalling__i_Compile._IV>.Default());
    public static Common____GenericMarshalling__i_Compile._IContentsTraceStep Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Common____GenericMarshalling__i_Compile._IContentsTraceStep> _TYPE = new Dafny.TypeDescriptor<Common____GenericMarshalling__i_Compile._IContentsTraceStep>(Common____GenericMarshalling__i_Compile.ContentsTraceStep.Default());
    public static Dafny.TypeDescriptor<Common____GenericMarshalling__i_Compile._IContentsTraceStep> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IContentsTraceStep create(Dafny.ISequence<byte> data, Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV> val) {
      return new ContentsTraceStep(data, val);
    }
    public static _IContentsTraceStep create_ContentsTraceStep(Dafny.ISequence<byte> data, Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV> val) {
      return create(data, val);
    }
    public bool is_ContentsTraceStep { get { return true; } }
    public Dafny.ISequence<byte> dtor_data {
      get {
        return this._data;
      }
    }
    public Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV> dtor_val {
      get {
        return this._val;
      }
    }
  }

  public partial class __default {
    public static _System._ITuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>> parse__Uint64(Dafny.ISequence<byte> data) {
      if (((ulong)(data).LongCount) >= (Native____NativeTypes__i_Compile.__default.Uint64Size())) {
        return _System.Tuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Common____GenericMarshalling__i_Compile._IV>.create_Some(Common____GenericMarshalling__i_Compile.V.create_VUint64(Common____Util__i_Compile.__default.SeqByteToUint64((data).Take(Native____NativeTypes__i_Compile.__default.Uint64Size())))), (data).Drop(Native____NativeTypes__i_Compile.__default.Uint64Size()));
      } else {
        return _System.Tuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Common____GenericMarshalling__i_Compile._IV>.create_None(), Dafny.Sequence<byte>.FromElements());
      }
    }
    public static void ParseUint64(byte[] data, ulong index, out bool success, out Common____GenericMarshalling__i_Compile._IV v, out ulong rest__index)
    {
      success = false;
      v = Common____GenericMarshalling__i_Compile.V.Default();
      rest__index = 0;
      if ((((ulong)(data).LongLength) >= (8UL)) && ((index) <= (((ulong)(data).LongLength) - (8UL)))) {
        ulong _54_result;
        _54_result = (((((((((ulong)((data)[(int)(new BigInteger(index))])) * (72057594037927936UL)) + (((ulong)((data)[(int)((new BigInteger(index)) + (BigInteger.One))])) * (281474976710656UL))) + (((ulong)((data)[(int)((new BigInteger(index)) + (new BigInteger(2)))])) * (1099511627776UL))) + (((ulong)((data)[(int)((new BigInteger(index)) + (new BigInteger(3)))])) * (4294967296UL))) + (((ulong)((data)[(int)((new BigInteger(index)) + (new BigInteger(4)))])) * (16777216UL))) + (((ulong)((data)[(int)((new BigInteger(index)) + (new BigInteger(5)))])) * (65536UL))) + (((ulong)((data)[(int)((new BigInteger(index)) + (new BigInteger(6)))])) * (256UL))) + ((ulong)((data)[(int)((new BigInteger(index)) + (new BigInteger(7)))]));
        success = true;
        v = Common____GenericMarshalling__i_Compile.V.create_VUint64(_54_result);
        rest__index = (index) + (Native____NativeTypes__i_Compile.__default.Uint64Size());
      } else {
        success = false;
        rest__index = (ulong)(data).LongLength;
      }
    }
    public static _System._ITuple2<Logic____Option__i_Compile._IOption<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>, Dafny.ISequence<byte>> parse__Array__contents(Dafny.ISequence<byte> data, Common____GenericMarshalling__i_Compile._IG eltType, ulong len)
    {
      if ((len) == (0UL)) {
        return _System.Tuple2<Logic____Option__i_Compile._IOption<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>.create_Some(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements()), data);
      } else {
        _System._ITuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>> _let_tmp_rhs0 = Common____GenericMarshalling__i_Compile.__default.parse__Val(data, eltType);
        Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV> _55_val = _let_tmp_rhs0.dtor__0;
        Dafny.ISequence<byte> _56_rest1 = _let_tmp_rhs0.dtor__1;
        _System._ITuple2<Logic____Option__i_Compile._IOption<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>, Dafny.ISequence<byte>> _let_tmp_rhs1 = Common____GenericMarshalling__i_Compile.__default.parse__Array__contents(_56_rest1, eltType, (len) - (1UL));
        Logic____Option__i_Compile._IOption<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>> _57_others = _let_tmp_rhs1.dtor__0;
        Dafny.ISequence<byte> _58_rest2 = _let_tmp_rhs1.dtor__1;
        if ((!((_55_val).is_None)) && (!((_57_others).is_None))) {
          return _System.Tuple2<Logic____Option__i_Compile._IOption<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>.create_Some(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.Concat(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements((_55_val).dtor_v), (_57_others).dtor_v)), _58_rest2);
        } else {
          return _System.Tuple2<Logic____Option__i_Compile._IOption<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>.create_None(), Dafny.Sequence<byte>.FromElements());
        }
      }
    }
    public static void ParseArrayContents(byte[] data, ulong index, Common____GenericMarshalling__i_Compile._IG eltType, ulong len, out bool success, out Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> v, out ulong rest__index)
    {
      success = false;
      v = Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.Empty;
      rest__index = 0;
      Common____GenericMarshalling__i_Compile._IV[] _59_vArr;
      Common____GenericMarshalling__i_Compile._IV[] _nw5 = Dafny.ArrayHelpers.InitNewArray1<Common____GenericMarshalling__i_Compile._IV>(Common____GenericMarshalling__i_Compile.V.Default(), Dafny.Helpers.ToIntChecked(len, "array size exceeds memory limit"));
      _59_vArr = _nw5;
      success = true;
      ulong _60_i;
      _60_i = 0UL;
      ulong _61_next__val__index;
      _61_next__val__index = index;
      while ((_60_i) < (len)) {
        bool _62_some1;
        Common____GenericMarshalling__i_Compile._IV _63_val;
        ulong _64_rest1;
        bool _out4;
        Common____GenericMarshalling__i_Compile._IV _out5;
        ulong _out6;
        Common____GenericMarshalling__i_Compile.__default.ParseVal(data, _61_next__val__index, eltType, out _out4, out _out5, out _out6);
        _62_some1 = _out4;
        _63_val = _out5;
        _64_rest1 = _out6;
        if (!(_62_some1)) {
          success = false;
          rest__index = (ulong)(data).LongLength;
          return ;
        }
        (_59_vArr)[(int)((_60_i))] = _63_val;
        _61_next__val__index = _64_rest1;
        _60_i = (_60_i) + (1UL);
      }
      success = true;
      rest__index = _61_next__val__index;
      v = Dafny.Helpers.SeqFromArray(_59_vArr);
    }
    public static _System._ITuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>> parse__Array(Dafny.ISequence<byte> data, Common____GenericMarshalling__i_Compile._IG eltType)
    {
      _System._ITuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>> _let_tmp_rhs2 = Common____GenericMarshalling__i_Compile.__default.parse__Uint64(data);
      Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV> _65_len = _let_tmp_rhs2.dtor__0;
      Dafny.ISequence<byte> _66_rest = _let_tmp_rhs2.dtor__1;
      if (!((_65_len).is_None)) {
        _System._ITuple2<Logic____Option__i_Compile._IOption<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>, Dafny.ISequence<byte>> _let_tmp_rhs3 = Common____GenericMarshalling__i_Compile.__default.parse__Array__contents(_66_rest, eltType, ((_65_len).dtor_v).dtor_u);
        Logic____Option__i_Compile._IOption<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>> _67_contents = _let_tmp_rhs3.dtor__0;
        Dafny.ISequence<byte> _68_remainder = _let_tmp_rhs3.dtor__1;
        if (!((_67_contents).is_None)) {
          return _System.Tuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Common____GenericMarshalling__i_Compile._IV>.create_Some(Common____GenericMarshalling__i_Compile.V.create_VArray((_67_contents).dtor_v)), _68_remainder);
        } else {
          return _System.Tuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Common____GenericMarshalling__i_Compile._IV>.create_None(), Dafny.Sequence<byte>.FromElements());
        }
      } else {
        return _System.Tuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Common____GenericMarshalling__i_Compile._IV>.create_None(), Dafny.Sequence<byte>.FromElements());
      }
    }
    public static void ParseArray(byte[] data, ulong index, Common____GenericMarshalling__i_Compile._IG eltType, out bool success, out Common____GenericMarshalling__i_Compile._IV v, out ulong rest__index)
    {
      success = false;
      v = Common____GenericMarshalling__i_Compile.V.Default();
      rest__index = 0;
      bool _69_some1;
      Common____GenericMarshalling__i_Compile._IV _70_len;
      ulong _71_rest;
      bool _out7;
      Common____GenericMarshalling__i_Compile._IV _out8;
      ulong _out9;
      Common____GenericMarshalling__i_Compile.__default.ParseUint64(data, index, out _out7, out _out8, out _out9);
      _69_some1 = _out7;
      _70_len = _out8;
      _71_rest = _out9;
      if (_69_some1) {
        bool _72_some2;
        Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> _73_contents;
        ulong _74_remainder;
        bool _out10;
        Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> _out11;
        ulong _out12;
        Common____GenericMarshalling__i_Compile.__default.ParseArrayContents(data, _71_rest, eltType, (_70_len).dtor_u, out _out10, out _out11, out _out12);
        _72_some2 = _out10;
        _73_contents = _out11;
        _74_remainder = _out12;
        if (_72_some2) {
          success = true;
          v = Common____GenericMarshalling__i_Compile.V.create_VArray(_73_contents);
          rest__index = _74_remainder;
        } else {
          success = false;
          rest__index = (ulong)(data).LongLength;
        }
      } else {
        success = false;
        rest__index = (ulong)(data).LongLength;
      }
    }
    public static _System._ITuple2<Logic____Option__i_Compile._IOption<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>, Dafny.ISequence<byte>> parse__Tuple__contents(Dafny.ISequence<byte> data, Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> eltTypes)
    {
      if ((eltTypes).Equals((Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements()))) {
        return _System.Tuple2<Logic____Option__i_Compile._IOption<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>.create_Some(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements()), data);
      } else {
        _System._ITuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>> _let_tmp_rhs4 = Common____GenericMarshalling__i_Compile.__default.parse__Val(data, (eltTypes).Select(BigInteger.Zero));
        Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV> _75_val = _let_tmp_rhs4.dtor__0;
        Dafny.ISequence<byte> _76_rest1 = _let_tmp_rhs4.dtor__1;
        _System._ITuple2<Logic____Option__i_Compile._IOption<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>, Dafny.ISequence<byte>> _let_tmp_rhs5 = Common____GenericMarshalling__i_Compile.__default.parse__Tuple__contents(_76_rest1, (eltTypes).Drop(BigInteger.One));
        Logic____Option__i_Compile._IOption<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>> _77_contents = _let_tmp_rhs5.dtor__0;
        Dafny.ISequence<byte> _78_rest2 = _let_tmp_rhs5.dtor__1;
        if ((!((_75_val).is_None)) && (!((_77_contents).is_None))) {
          return _System.Tuple2<Logic____Option__i_Compile._IOption<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>.create_Some(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.Concat(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements((_75_val).dtor_v), (_77_contents).dtor_v)), _78_rest2);
        } else {
          return _System.Tuple2<Logic____Option__i_Compile._IOption<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>.create_None(), Dafny.Sequence<byte>.FromElements());
        }
      }
    }
    public static void ParseTupleContents(byte[] data, ulong index, Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> eltTypes, out bool success, out Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> v, out ulong rest__index)
    {
      success = false;
      v = Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.Empty;
      rest__index = 0;
      Common____GenericMarshalling__i_Compile._IV[] _79_vArr;
      Common____GenericMarshalling__i_Compile._IV[] _nw6 = Dafny.ArrayHelpers.InitNewArray1<Common____GenericMarshalling__i_Compile._IV>(Common____GenericMarshalling__i_Compile.V.Default(), Dafny.Helpers.ToIntChecked(new BigInteger((eltTypes).Count), "array size exceeds memory limit"));
      _79_vArr = _nw6;
      success = true;
      BigInteger _80_i;
      _80_i = BigInteger.Zero;
      ulong _81_next__val__index;
      _81_next__val__index = index;
      while ((_80_i) < (new BigInteger((eltTypes).Count))) {
        bool _82_some1;
        Common____GenericMarshalling__i_Compile._IV _83_val;
        ulong _84_rest1;
        bool _out13;
        Common____GenericMarshalling__i_Compile._IV _out14;
        ulong _out15;
        Common____GenericMarshalling__i_Compile.__default.ParseVal(data, _81_next__val__index, (eltTypes).Select(_80_i), out _out13, out _out14, out _out15);
        _82_some1 = _out13;
        _83_val = _out14;
        _84_rest1 = _out15;
        if (!(_82_some1)) {
          success = false;
          rest__index = (ulong)(data).LongLength;
          return ;
        }
        (_79_vArr)[(int)((_80_i))] = _83_val;
        _81_next__val__index = _84_rest1;
        _80_i = (_80_i) + (BigInteger.One);
      }
      success = true;
      rest__index = _81_next__val__index;
      v = Dafny.Helpers.SeqFromArray(_79_vArr);
    }
    public static _System._ITuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>> parse__Tuple(Dafny.ISequence<byte> data, Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> eltTypes)
    {
      _System._ITuple2<Logic____Option__i_Compile._IOption<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>>, Dafny.ISequence<byte>> _let_tmp_rhs6 = Common____GenericMarshalling__i_Compile.__default.parse__Tuple__contents(data, eltTypes);
      Logic____Option__i_Compile._IOption<Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV>> _85_contents = _let_tmp_rhs6.dtor__0;
      Dafny.ISequence<byte> _86_rest = _let_tmp_rhs6.dtor__1;
      if (!((_85_contents).is_None)) {
        return _System.Tuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Common____GenericMarshalling__i_Compile._IV>.create_Some(Common____GenericMarshalling__i_Compile.V.create_VTuple((_85_contents).dtor_v)), _86_rest);
      } else {
        return _System.Tuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Common____GenericMarshalling__i_Compile._IV>.create_None(), Dafny.Sequence<byte>.FromElements());
      }
    }
    public static void ParseTuple(byte[] data, ulong index, Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> eltTypes, out bool success, out Common____GenericMarshalling__i_Compile._IV v, out ulong rest__index)
    {
      success = false;
      v = Common____GenericMarshalling__i_Compile.V.Default();
      rest__index = 0;
      bool _87_some;
      Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> _88_contents;
      ulong _89_rest;
      bool _out16;
      Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> _out17;
      ulong _out18;
      Common____GenericMarshalling__i_Compile.__default.ParseTupleContents(data, index, eltTypes, out _out16, out _out17, out _out18);
      _87_some = _out16;
      _88_contents = _out17;
      _89_rest = _out18;
      if (_87_some) {
        success = true;
        v = Common____GenericMarshalling__i_Compile.V.create_VTuple(_88_contents);
        rest__index = _89_rest;
      } else {
        success = false;
        rest__index = (ulong)(data).LongLength;
      }
    }
    public static _System._ITuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>> parse__ByteArray(Dafny.ISequence<byte> data) {
      _System._ITuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>> _let_tmp_rhs7 = Common____GenericMarshalling__i_Compile.__default.parse__Uint64(data);
      Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV> _90_len = _let_tmp_rhs7.dtor__0;
      Dafny.ISequence<byte> _91_rest = _let_tmp_rhs7.dtor__1;
      if ((!((_90_len).is_None)) && ((((_90_len).dtor_v).dtor_u) <= ((ulong)(_91_rest).LongCount))) {
        return _System.Tuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Common____GenericMarshalling__i_Compile._IV>.create_Some(Common____GenericMarshalling__i_Compile.V.create_VByteArray((_91_rest).Subsequence(BigInteger.Zero, ((_90_len).dtor_v).dtor_u))), (_91_rest).Drop(((_90_len).dtor_v).dtor_u));
      } else {
        return _System.Tuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Common____GenericMarshalling__i_Compile._IV>.create_None(), Dafny.Sequence<byte>.FromElements());
      }
    }
    public static void ParseByteArray(byte[] data, ulong index, out bool success, out Common____GenericMarshalling__i_Compile._IV v, out ulong rest__index)
    {
      success = false;
      v = Common____GenericMarshalling__i_Compile.V.Default();
      rest__index = 0;
      bool _92_some;
      Common____GenericMarshalling__i_Compile._IV _93_len;
      ulong _94_rest;
      bool _out19;
      Common____GenericMarshalling__i_Compile._IV _out20;
      ulong _out21;
      Common____GenericMarshalling__i_Compile.__default.ParseUint64(data, index, out _out19, out _out20, out _out21);
      _92_some = _out19;
      _93_len = _out20;
      _94_rest = _out21;
      if ((_92_some) && (((_93_len).dtor_u) <= (((ulong)(data).LongLength) - (_94_rest)))) {
        Dafny.ISequence<byte> _95_rest__seq;
        _95_rest__seq = Dafny.Helpers.SeqFromArray(data).Drop(_94_rest);
        success = true;
        v = Common____GenericMarshalling__i_Compile.V.create_VByteArray(Dafny.Helpers.SeqFromArray(data).Subsequence(_94_rest, (_94_rest) + ((_93_len).dtor_u)));
        rest__index = (_94_rest) + ((_93_len).dtor_u);
      } else {
        success = false;
        rest__index = (ulong)(data).LongLength;
      }
    }
    public static _System._ITuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>> parse__Case(Dafny.ISequence<byte> data, Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> cases)
    {
      _System._ITuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>> _let_tmp_rhs8 = Common____GenericMarshalling__i_Compile.__default.parse__Uint64(data);
      Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV> _96_caseID = _let_tmp_rhs8.dtor__0;
      Dafny.ISequence<byte> _97_rest1 = _let_tmp_rhs8.dtor__1;
      if ((!((_96_caseID).is_None)) && ((((_96_caseID).dtor_v).dtor_u) < ((ulong)(cases).LongCount))) {
        _System._ITuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>> _let_tmp_rhs9 = Common____GenericMarshalling__i_Compile.__default.parse__Val(_97_rest1, (cases).Select(((_96_caseID).dtor_v).dtor_u));
        Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV> _98_val = _let_tmp_rhs9.dtor__0;
        Dafny.ISequence<byte> _99_rest2 = _let_tmp_rhs9.dtor__1;
        if (!((_98_val).is_None)) {
          return _System.Tuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Common____GenericMarshalling__i_Compile._IV>.create_Some(Common____GenericMarshalling__i_Compile.V.create_VCase(((_96_caseID).dtor_v).dtor_u, (_98_val).dtor_v)), _99_rest2);
        } else {
          return _System.Tuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Common____GenericMarshalling__i_Compile._IV>.create_None(), Dafny.Sequence<byte>.FromElements());
        }
      } else {
        return _System.Tuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>>.create(Logic____Option__i_Compile.Option<Common____GenericMarshalling__i_Compile._IV>.create_None(), Dafny.Sequence<byte>.FromElements());
      }
    }
    public static void ParseCase(byte[] data, ulong index, Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> cases, out bool success, out Common____GenericMarshalling__i_Compile._IV v, out ulong rest__index)
    {
      success = false;
      v = Common____GenericMarshalling__i_Compile.V.Default();
      rest__index = 0;
      bool _100_some1;
      Common____GenericMarshalling__i_Compile._IV _101_caseID;
      ulong _102_rest1;
      bool _out22;
      Common____GenericMarshalling__i_Compile._IV _out23;
      ulong _out24;
      Common____GenericMarshalling__i_Compile.__default.ParseUint64(data, index, out _out22, out _out23, out _out24);
      _100_some1 = _out22;
      _101_caseID = _out23;
      _102_rest1 = _out24;
      if ((_100_some1) && (((_101_caseID).dtor_u) < ((ulong)(cases).LongCount))) {
        bool _103_some2;
        Common____GenericMarshalling__i_Compile._IV _104_val;
        ulong _105_rest2;
        bool _out25;
        Common____GenericMarshalling__i_Compile._IV _out26;
        ulong _out27;
        Common____GenericMarshalling__i_Compile.__default.ParseVal(data, _102_rest1, (cases).Select((_101_caseID).dtor_u), out _out25, out _out26, out _out27);
        _103_some2 = _out25;
        _104_val = _out26;
        _105_rest2 = _out27;
        if (_103_some2) {
          success = true;
          v = Common____GenericMarshalling__i_Compile.V.create_VCase((_101_caseID).dtor_u, _104_val);
          rest__index = _105_rest2;
        } else {
          success = false;
          rest__index = (ulong)(data).LongLength;
        }
      } else {
        success = false;
        rest__index = (ulong)(data).LongLength;
      }
    }
    public static _System._ITuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>> parse__Val(Dafny.ISequence<byte> data, Common____GenericMarshalling__i_Compile._IG grammar)
    {
      Common____GenericMarshalling__i_Compile._IG _source2 = grammar;
      if (_source2.is_GUint64) {
        return Common____GenericMarshalling__i_Compile.__default.parse__Uint64(data);
      } else if (_source2.is_GArray) {
        Common____GenericMarshalling__i_Compile._IG _106___mcc_h0 = _source2.dtor_elt;
        Common____GenericMarshalling__i_Compile._IG _107_elt = _106___mcc_h0;
        return Common____GenericMarshalling__i_Compile.__default.parse__Array(data, _107_elt);
      } else if (_source2.is_GTuple) {
        Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> _108___mcc_h1 = _source2.dtor_t;
        Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> _109_t = _108___mcc_h1;
        return Common____GenericMarshalling__i_Compile.__default.parse__Tuple(data, _109_t);
      } else if (_source2.is_GByteArray) {
        return Common____GenericMarshalling__i_Compile.__default.parse__ByteArray(data);
      } else {
        Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> _110___mcc_h2 = _source2.dtor_cases;
        Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> _111_cases = _110___mcc_h2;
        return Common____GenericMarshalling__i_Compile.__default.parse__Case(data, _111_cases);
      }
    }
    public static void ParseVal(byte[] data, ulong index, Common____GenericMarshalling__i_Compile._IG grammar, out bool success, out Common____GenericMarshalling__i_Compile._IV v, out ulong rest__index)
    {
      success = false;
      v = Common____GenericMarshalling__i_Compile.V.Default();
      rest__index = 0;
      Common____GenericMarshalling__i_Compile._IG _source3 = grammar;
      if (_source3.is_GUint64) {
        bool _out28;
        Common____GenericMarshalling__i_Compile._IV _out29;
        ulong _out30;
        Common____GenericMarshalling__i_Compile.__default.ParseUint64(data, index, out _out28, out _out29, out _out30);
        success = _out28;
        v = _out29;
        rest__index = _out30;
      } else if (_source3.is_GArray) {
        Common____GenericMarshalling__i_Compile._IG _112___mcc_h0 = _source3.dtor_elt;
        Common____GenericMarshalling__i_Compile._IG _113_elt = _112___mcc_h0;
        bool _out31;
        Common____GenericMarshalling__i_Compile._IV _out32;
        ulong _out33;
        Common____GenericMarshalling__i_Compile.__default.ParseArray(data, index, _113_elt, out _out31, out _out32, out _out33);
        success = _out31;
        v = _out32;
        rest__index = _out33;
      } else if (_source3.is_GTuple) {
        Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> _114___mcc_h1 = _source3.dtor_t;
        Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> _115_t = _114___mcc_h1;
        bool _out34;
        Common____GenericMarshalling__i_Compile._IV _out35;
        ulong _out36;
        Common____GenericMarshalling__i_Compile.__default.ParseTuple(data, index, _115_t, out _out34, out _out35, out _out36);
        success = _out34;
        v = _out35;
        rest__index = _out36;
      } else if (_source3.is_GByteArray) {
        bool _out37;
        Common____GenericMarshalling__i_Compile._IV _out38;
        ulong _out39;
        Common____GenericMarshalling__i_Compile.__default.ParseByteArray(data, index, out _out37, out _out38, out _out39);
        success = _out37;
        v = _out38;
        rest__index = _out39;
      } else {
        Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> _116___mcc_h2 = _source3.dtor_cases;
        Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> _117_cases = _116___mcc_h2;
        bool _out40;
        Common____GenericMarshalling__i_Compile._IV _out41;
        ulong _out42;
        Common____GenericMarshalling__i_Compile.__default.ParseCase(data, index, _117_cases, out _out40, out _out41, out _out42);
        success = _out40;
        v = _out41;
        rest__index = _out42;
      }
    }
    public static void Demarshall(byte[] data, Common____GenericMarshalling__i_Compile._IG grammar, out bool success, out Common____GenericMarshalling__i_Compile._IV v)
    {
      success = false;
      v = Common____GenericMarshalling__i_Compile.V.Default();
      ulong _118_rest = 0;
      bool _out43;
      Common____GenericMarshalling__i_Compile._IV _out44;
      ulong _out45;
      Common____GenericMarshalling__i_Compile.__default.ParseVal(data, 0UL, grammar, out _out43, out _out44, out _out45);
      success = _out43;
      v = _out44;
      _118_rest = _out45;
      if ((success) && ((_118_rest) == ((ulong)(data).LongLength))) {
      } else {
        success = false;
      }
    }
    public static ulong ComputeSeqSum(Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> s)
    {
      ulong size = 0;
      if (((ulong)(s).LongCount) == (0UL)) {
        size = 0UL;
      } else {
        ulong _119_v__size;
        ulong _out46;
        _out46 = Common____GenericMarshalling__i_Compile.__default.ComputeSizeOf((s).Select(BigInteger.Zero));
        _119_v__size = _out46;
        ulong _120_rest__size;
        ulong _out47;
        _out47 = Common____GenericMarshalling__i_Compile.__default.ComputeSeqSum((s).Drop(BigInteger.One));
        _120_rest__size = _out47;
        size = (_119_v__size) + (_120_rest__size);
      }
      return size;
    }
    public static ulong ComputeSizeOf(Common____GenericMarshalling__i_Compile._IV val)
    {
      ulong size = 0;
      Common____GenericMarshalling__i_Compile._IV _source4 = val;
      if (_source4.is_VUint64) {
        ulong _121___mcc_h0 = _source4.dtor_u;
        size = 8UL;
      } else if (_source4.is_VArray) {
        Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> _122___mcc_h1 = _source4.dtor_a;
        Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> _123_a = _122___mcc_h1;
        ulong _124_v;
        ulong _out48;
        _out48 = Common____GenericMarshalling__i_Compile.__default.ComputeSeqSum(_123_a);
        _124_v = _out48;
        if ((_124_v) == (0UL)) {
          size = 8UL;
        } else {
          size = (8UL) + (_124_v);
        }
      } else if (_source4.is_VTuple) {
        Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> _125___mcc_h2 = _source4.dtor_t;
        Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> _126_t = _125___mcc_h2;
        ulong _out49;
        _out49 = Common____GenericMarshalling__i_Compile.__default.ComputeSeqSum(_126_t);
        size = _out49;
      } else if (_source4.is_VByteArray) {
        Dafny.ISequence<byte> _127___mcc_h3 = _source4.dtor_b;
        Dafny.ISequence<byte> _128_b = _127___mcc_h3;
        size = (8UL) + ((ulong)(_128_b).LongCount);
      } else {
        ulong _129___mcc_h4 = _source4.dtor_c;
        Common____GenericMarshalling__i_Compile._IV _130___mcc_h5 = _source4.dtor_val;
        Common____GenericMarshalling__i_Compile._IV _131_v = _130___mcc_h5;
        ulong _132_c = _129___mcc_h4;
        ulong _133_vs;
        ulong _out50;
        _out50 = Common____GenericMarshalling__i_Compile.__default.ComputeSizeOf(_131_v);
        _133_vs = _out50;
        size = (8UL) + (_133_vs);
      }
      return size;
    }
    public static void MarshallUint64(ulong n, byte[] data, ulong index)
    {
      Common____MarshallInt__i_Compile.__default.MarshallUint64__guts(n, data, index);
      _System._ITuple2<Logic____Option__i_Compile._IOption<Common____GenericMarshalling__i_Compile._IV>, Dafny.ISequence<byte>> _134_tuple;
      _134_tuple = Common____GenericMarshalling__i_Compile.__default.parse__Uint64(Dafny.Helpers.SeqFromArray(data).Drop(index));
    }
    public static ulong MarshallArrayContents(Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> contents, Common____GenericMarshalling__i_Compile._IG eltType, byte[] data, ulong index)
    {
      ulong size = 0;
      BigInteger _135_i;
      _135_i = BigInteger.Zero;
      ulong _136_cur__index;
      _136_cur__index = index;
      while ((_135_i) < (new BigInteger((contents).Count))) {
        ulong _137_item__size;
        ulong _out51;
        _out51 = Common____GenericMarshalling__i_Compile.__default.MarshallVal((contents).Select(_135_i), eltType, data, _136_cur__index);
        _137_item__size = _out51;
        _136_cur__index = (_136_cur__index) + (_137_item__size);
        _135_i = (_135_i) + (BigInteger.One);
      }
      size = (_136_cur__index) - (index);
      return size;
    }
    public static ulong MarshallArray(Common____GenericMarshalling__i_Compile._IV val, Common____GenericMarshalling__i_Compile._IG grammar, byte[] data, ulong index)
    {
      ulong size = 0;
      Common____GenericMarshalling__i_Compile.__default.MarshallUint64((ulong)((val).dtor_a).LongCount, data, index);
      ulong _138_contents__size;
      ulong _out52;
      _out52 = Common____GenericMarshalling__i_Compile.__default.MarshallArrayContents((val).dtor_a, (grammar).dtor_elt, data, (index) + (Native____NativeTypes__i_Compile.__default.Uint64Size()));
      _138_contents__size = _out52;
      size = (8UL) + (_138_contents__size);
      return size;
    }
    public static ulong MarshallTupleContents(Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> contents, Dafny.ISequence<Common____GenericMarshalling__i_Compile._IG> eltTypes, byte[] data, ulong index)
    {
      ulong size = 0;
      BigInteger _139_i;
      _139_i = BigInteger.Zero;
      ulong _140_cur__index;
      _140_cur__index = index;
      while ((_139_i) < (new BigInteger((contents).Count))) {
        ulong _141_item__size;
        ulong _out53;
        _out53 = Common____GenericMarshalling__i_Compile.__default.MarshallVal((contents).Select(_139_i), (eltTypes).Select(_139_i), data, _140_cur__index);
        _141_item__size = _out53;
        _140_cur__index = (_140_cur__index) + (_141_item__size);
        _139_i = (_139_i) + (BigInteger.One);
      }
      size = (_140_cur__index) - (index);
      return size;
    }
    public static ulong MarshallTuple(Common____GenericMarshalling__i_Compile._IV val, Common____GenericMarshalling__i_Compile._IG grammar, byte[] data, ulong index)
    {
      ulong size = 0;
      ulong _out54;
      _out54 = Common____GenericMarshalling__i_Compile.__default.MarshallTupleContents((val).dtor_t, (grammar).dtor_t, data, index);
      size = _out54;
      return size;
    }
    public static void MarshallBytes(Dafny.ISequence<byte> bytes, byte[] data, ulong index)
    {
      Native____Io__s_Compile.Arrays.CopySeqIntoArray<byte>(bytes, 0UL, data, index, (ulong)(bytes).LongCount);
    }
    public static ulong MarshallByteArray(Common____GenericMarshalling__i_Compile._IV val, Common____GenericMarshalling__i_Compile._IG grammar, byte[] data, ulong index)
    {
      ulong size = 0;
      Common____GenericMarshalling__i_Compile.__default.MarshallUint64((ulong)((val).dtor_b).LongCount, data, index);
      Common____GenericMarshalling__i_Compile.__default.MarshallBytes((val).dtor_b, data, (index) + (8UL));
      size = (8UL) + ((ulong)((val).dtor_b).LongCount);
      return size;
    }
    public static ulong MarshallCase(Common____GenericMarshalling__i_Compile._IV val, Common____GenericMarshalling__i_Compile._IG grammar, byte[] data, ulong index)
    {
      ulong size = 0;
      Common____GenericMarshalling__i_Compile.__default.MarshallUint64((val).dtor_c, data, index);
      ulong _142_val__size;
      ulong _out55;
      _out55 = Common____GenericMarshalling__i_Compile.__default.MarshallVal((val).dtor_val, ((grammar).dtor_cases).Select((val).dtor_c), data, (index) + (8UL));
      _142_val__size = _out55;
      size = (8UL) + (_142_val__size);
      return size;
    }
    public static ulong MarshallVUint64(Common____GenericMarshalling__i_Compile._IV val, Common____GenericMarshalling__i_Compile._IG grammar, byte[] data, ulong index)
    {
      ulong size = 0;
      Common____GenericMarshalling__i_Compile.__default.MarshallUint64((val).dtor_u, data, index);
      size = 8UL;
      return size;
      return size;
    }
    public static ulong MarshallVal(Common____GenericMarshalling__i_Compile._IV val, Common____GenericMarshalling__i_Compile._IG grammar, byte[] data, ulong index)
    {
      ulong size = 0;
      Common____GenericMarshalling__i_Compile._IV _source5 = val;
      if (_source5.is_VUint64) {
        ulong _143___mcc_h0 = _source5.dtor_u;
        ulong _out56;
        _out56 = Common____GenericMarshalling__i_Compile.__default.MarshallVUint64(val, grammar, data, index);
        size = _out56;
      } else if (_source5.is_VArray) {
        Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> _144___mcc_h1 = _source5.dtor_a;
        ulong _out57;
        _out57 = Common____GenericMarshalling__i_Compile.__default.MarshallArray(val, grammar, data, index);
        size = _out57;
      } else if (_source5.is_VTuple) {
        Dafny.ISequence<Common____GenericMarshalling__i_Compile._IV> _145___mcc_h2 = _source5.dtor_t;
        ulong _out58;
        _out58 = Common____GenericMarshalling__i_Compile.__default.MarshallTuple(val, grammar, data, index);
        size = _out58;
      } else if (_source5.is_VByteArray) {
        Dafny.ISequence<byte> _146___mcc_h3 = _source5.dtor_b;
        ulong _out59;
        _out59 = Common____GenericMarshalling__i_Compile.__default.MarshallByteArray(val, grammar, data, index);
        size = _out59;
      } else {
        ulong _147___mcc_h4 = _source5.dtor_c;
        Common____GenericMarshalling__i_Compile._IV _148___mcc_h5 = _source5.dtor_val;
        ulong _out60;
        _out60 = Common____GenericMarshalling__i_Compile.__default.MarshallCase(val, grammar, data, index);
        size = _out60;
      }
      return size;
    }
    public static byte[] Marshall(Common____GenericMarshalling__i_Compile._IV val, Common____GenericMarshalling__i_Compile._IG grammar)
    {
      byte[] data = new byte[0];
      ulong _149_size;
      ulong _out61;
      _out61 = Common____GenericMarshalling__i_Compile.__default.ComputeSizeOf(val);
      _149_size = _out61;
      byte[] _nw7 = new byte[Dafny.Helpers.ToIntChecked(_149_size, "array size exceeds memory limit")];
      data = _nw7;
      ulong _150_computed__size;
      ulong _out62;
      _out62 = Common____GenericMarshalling__i_Compile.__default.MarshallVal(val, grammar, data, 0UL);
      _150_computed__size = _out62;
      return data;
    }
  }
} // end of namespace Common____GenericMarshalling__i_Compile
namespace LiveByzRSL____AppInterface__i_Compile {

  public interface _ICAppMessage {
    bool is_CAppIncrement { get; }
    bool is_CAppReply { get; }
    bool is_CAppInvalid { get; }
    ulong dtor_response { get; }
    _ICAppMessage DowncastClone();
  }
  public abstract class CAppMessage : _ICAppMessage {
    public CAppMessage() { }
    private static readonly LiveByzRSL____AppInterface__i_Compile._ICAppMessage theDefault = create_CAppIncrement();
    public static LiveByzRSL____AppInterface__i_Compile._ICAppMessage Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____AppInterface__i_Compile._ICAppMessage> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____AppInterface__i_Compile._ICAppMessage>(LiveByzRSL____AppInterface__i_Compile.CAppMessage.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____AppInterface__i_Compile._ICAppMessage> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICAppMessage create_CAppIncrement() {
      return new CAppMessage_CAppIncrement();
    }
    public static _ICAppMessage create_CAppReply(ulong response) {
      return new CAppMessage_CAppReply(response);
    }
    public static _ICAppMessage create_CAppInvalid() {
      return new CAppMessage_CAppInvalid();
    }
    public bool is_CAppIncrement { get { return this is CAppMessage_CAppIncrement; } }
    public bool is_CAppReply { get { return this is CAppMessage_CAppReply; } }
    public bool is_CAppInvalid { get { return this is CAppMessage_CAppInvalid; } }
    public ulong dtor_response {
      get {
        var d = this;
        return ((CAppMessage_CAppReply)d)._response;
      }
    }
    public abstract _ICAppMessage DowncastClone();
  }
  public class CAppMessage_CAppIncrement : CAppMessage {
    public CAppMessage_CAppIncrement() {
    }
    public override _ICAppMessage DowncastClone() {
      if (this is _ICAppMessage dt) { return dt; }
      return new CAppMessage_CAppIncrement();
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____AppInterface__i_Compile.CAppMessage_CAppIncrement;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____AppInterface__i_Compile.CAppMessage.CAppIncrement";
      return s;
    }
  }
  public class CAppMessage_CAppReply : CAppMessage {
    public readonly ulong _response;
    public CAppMessage_CAppReply(ulong response) {
      this._response = response;
    }
    public override _ICAppMessage DowncastClone() {
      if (this is _ICAppMessage dt) { return dt; }
      return new CAppMessage_CAppReply(_response);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____AppInterface__i_Compile.CAppMessage_CAppReply;
      return oth != null && this._response == oth._response;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._response));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____AppInterface__i_Compile.CAppMessage.CAppReply";
      s += "(";
      s += Dafny.Helpers.ToString(this._response);
      s += ")";
      return s;
    }
  }
  public class CAppMessage_CAppInvalid : CAppMessage {
    public CAppMessage_CAppInvalid() {
    }
    public override _ICAppMessage DowncastClone() {
      if (this is _ICAppMessage dt) { return dt; }
      return new CAppMessage_CAppInvalid();
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____AppInterface__i_Compile.CAppMessage_CAppInvalid;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____AppInterface__i_Compile.CAppMessage.CAppInvalid";
      return s;
    }
  }

  public partial class __default {
    public static Common____GenericMarshalling__i_Compile._IG CAppState__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GUint64();
    }
    public static ulong parse__AppState(Common____GenericMarshalling__i_Compile._IV val) {
      return (ulong)((val).dtor_u);
    }
    public static bool AppStateMarshallable(ulong msg) {
      return true;
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallAppState(ulong c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      val = Common____GenericMarshalling__i_Compile.V.create_VUint64(c);
      return val;
    }
    public static bool CAppMessageIsValid(LiveByzRSL____AppInterface__i_Compile._ICAppMessage c) {
      return LiveByzRSL____AppInterface__i_Compile.__default.CAppMessageIsAbstractable(c);
    }
    public static bool CAppMessageIsAbstractable(LiveByzRSL____AppInterface__i_Compile._ICAppMessage c) {
      return true;
    }
    public static Common____GenericMarshalling__i_Compile._IG CAppMessage__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GTaggedUnion(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements()), Common____GenericMarshalling__i_Compile.G.create_GUint64(), Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements())));
    }
    public static LiveByzRSL____AppInterface__i_Compile._ICAppMessage parse__AppMessage(Common____GenericMarshalling__i_Compile._IV val) {
      if (((val).dtor_c) == (0UL)) {
        return LiveByzRSL____AppInterface__i_Compile.CAppMessage.create_CAppIncrement();
      } else if (((val).dtor_c) == (1UL)) {
        return LiveByzRSL____AppInterface__i_Compile.CAppMessage.create_CAppReply(((val).dtor_val).dtor_u);
      } else {
        return LiveByzRSL____AppInterface__i_Compile.CAppMessage.create_CAppInvalid();
      }
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallCAppMessage(LiveByzRSL____AppInterface__i_Compile._ICAppMessage c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      LiveByzRSL____AppInterface__i_Compile._ICAppMessage _source6 = c;
      if (_source6.is_CAppIncrement) {
        val = Common____GenericMarshalling__i_Compile.V.create_VCase(0UL, Common____GenericMarshalling__i_Compile.V.create_VTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements()));
      } else if (_source6.is_CAppReply) {
        ulong _151___mcc_h0 = _source6.dtor_response;
        ulong _152_response = _151___mcc_h0;
        val = Common____GenericMarshalling__i_Compile.V.create_VCase(1UL, Common____GenericMarshalling__i_Compile.V.create_VUint64(_152_response));
      } else {
        val = Common____GenericMarshalling__i_Compile.V.create_VCase(2UL, Common____GenericMarshalling__i_Compile.V.create_VTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements()));
      }
      return val;
    }
    public static BigInteger max__val__len() {
      return new BigInteger(64);
    }
    public static ulong CAppStateInit() {
      return (ulong)(0UL);
    }
    public static ulong CappedIncrImpl(ulong v) {
      if ((v) == (18446744073709551615UL)) {
        return v;
      } else {
        return (v) + (1UL);
      }
    }
    public static _System._ITuple2<ulong, LiveByzRSL____AppInterface__i_Compile._ICAppMessage> HandleAppRequest(ulong appState, LiveByzRSL____AppInterface__i_Compile._ICAppMessage request)
    {
      if ((request).is_CAppIncrement) {
        return _System.Tuple2<ulong, LiveByzRSL____AppInterface__i_Compile._ICAppMessage>.create(LiveByzRSL____AppInterface__i_Compile.__default.CappedIncrImpl(appState), LiveByzRSL____AppInterface__i_Compile.CAppMessage.create_CAppReply(LiveByzRSL____AppInterface__i_Compile.__default.CappedIncrImpl(appState)));
      } else {
        return _System.Tuple2<ulong, LiveByzRSL____AppInterface__i_Compile._ICAppMessage>.create(appState, LiveByzRSL____AppInterface__i_Compile.CAppMessage.create_CAppInvalid());
      }
    }
  }
} // end of namespace LiveByzRSL____AppInterface__i_Compile
namespace LiveByzRSL____CTypes__i_Compile {

  public interface _ICBallot {
    bool is_CBallot { get; }
    BigInteger dtor_seqno { get; }
    BigInteger dtor_proposer__id { get; }
    _ICBallot DowncastClone();
  }
  public class CBallot : _ICBallot {
    public readonly BigInteger _seqno;
    public readonly BigInteger _proposer__id;
    public CBallot(BigInteger seqno, BigInteger proposer__id) {
      this._seqno = seqno;
      this._proposer__id = proposer__id;
    }
    public _ICBallot DowncastClone() {
      if (this is _ICBallot dt) { return dt; }
      return new CBallot(_seqno, _proposer__id);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CTypes__i_Compile.CBallot;
      return oth != null && this._seqno == oth._seqno && this._proposer__id == oth._proposer__id;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._seqno));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._proposer__id));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CTypes__i_Compile.CBallot.CBallot";
      s += "(";
      s += Dafny.Helpers.ToString(this._seqno);
      s += ", ";
      s += Dafny.Helpers.ToString(this._proposer__id);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____CTypes__i_Compile._ICBallot theDefault = create(BigInteger.Zero, BigInteger.Zero);
    public static LiveByzRSL____CTypes__i_Compile._ICBallot Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____CTypes__i_Compile._ICBallot> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____CTypes__i_Compile._ICBallot>(LiveByzRSL____CTypes__i_Compile.CBallot.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____CTypes__i_Compile._ICBallot> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICBallot create(BigInteger seqno, BigInteger proposer__id) {
      return new CBallot(seqno, proposer__id);
    }
    public static _ICBallot create_CBallot(BigInteger seqno, BigInteger proposer__id) {
      return create(seqno, proposer__id);
    }
    public bool is_CBallot { get { return true; } }
    public BigInteger dtor_seqno {
      get {
        return this._seqno;
      }
    }
    public BigInteger dtor_proposer__id {
      get {
        return this._proposer__id;
      }
    }
  }

  public interface _ICRequest {
    bool is_CRequest { get; }
    Native____Io__s_Compile._IEndPoint dtor_client { get; }
    BigInteger dtor_seqno { get; }
    LiveByzRSL____AppInterface__i_Compile._ICAppMessage dtor_request { get; }
    _ICRequest DowncastClone();
  }
  public class CRequest : _ICRequest {
    public readonly Native____Io__s_Compile._IEndPoint _client;
    public readonly BigInteger _seqno;
    public readonly LiveByzRSL____AppInterface__i_Compile._ICAppMessage _request;
    public CRequest(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, LiveByzRSL____AppInterface__i_Compile._ICAppMessage request) {
      this._client = client;
      this._seqno = seqno;
      this._request = request;
    }
    public _ICRequest DowncastClone() {
      if (this is _ICRequest dt) { return dt; }
      return new CRequest(_client, _seqno, _request);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CTypes__i_Compile.CRequest;
      return oth != null && object.Equals(this._client, oth._client) && this._seqno == oth._seqno && object.Equals(this._request, oth._request);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._client));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._seqno));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._request));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CTypes__i_Compile.CRequest.CRequest";
      s += "(";
      s += Dafny.Helpers.ToString(this._client);
      s += ", ";
      s += Dafny.Helpers.ToString(this._seqno);
      s += ", ";
      s += Dafny.Helpers.ToString(this._request);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____CTypes__i_Compile._ICRequest theDefault = create(Native____Io__s_Compile.EndPoint.Default(), BigInteger.Zero, LiveByzRSL____AppInterface__i_Compile.CAppMessage.Default());
    public static LiveByzRSL____CTypes__i_Compile._ICRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____CTypes__i_Compile._ICRequest> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____CTypes__i_Compile._ICRequest>(LiveByzRSL____CTypes__i_Compile.CRequest.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____CTypes__i_Compile._ICRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICRequest create(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, LiveByzRSL____AppInterface__i_Compile._ICAppMessage request) {
      return new CRequest(client, seqno, request);
    }
    public static _ICRequest create_CRequest(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, LiveByzRSL____AppInterface__i_Compile._ICAppMessage request) {
      return create(client, seqno, request);
    }
    public bool is_CRequest { get { return true; } }
    public Native____Io__s_Compile._IEndPoint dtor_client {
      get {
        return this._client;
      }
    }
    public BigInteger dtor_seqno {
      get {
        return this._seqno;
      }
    }
    public LiveByzRSL____AppInterface__i_Compile._ICAppMessage dtor_request {
      get {
        return this._request;
      }
    }
  }

  public interface _ICReply {
    bool is_CReply { get; }
    Native____Io__s_Compile._IEndPoint dtor_client { get; }
    BigInteger dtor_seqno { get; }
    LiveByzRSL____AppInterface__i_Compile._ICAppMessage dtor_reply { get; }
    _ICReply DowncastClone();
  }
  public class CReply : _ICReply {
    public readonly Native____Io__s_Compile._IEndPoint _client;
    public readonly BigInteger _seqno;
    public readonly LiveByzRSL____AppInterface__i_Compile._ICAppMessage _reply;
    public CReply(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, LiveByzRSL____AppInterface__i_Compile._ICAppMessage reply) {
      this._client = client;
      this._seqno = seqno;
      this._reply = reply;
    }
    public _ICReply DowncastClone() {
      if (this is _ICReply dt) { return dt; }
      return new CReply(_client, _seqno, _reply);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CTypes__i_Compile.CReply;
      return oth != null && object.Equals(this._client, oth._client) && this._seqno == oth._seqno && object.Equals(this._reply, oth._reply);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._client));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._seqno));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._reply));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CTypes__i_Compile.CReply.CReply";
      s += "(";
      s += Dafny.Helpers.ToString(this._client);
      s += ", ";
      s += Dafny.Helpers.ToString(this._seqno);
      s += ", ";
      s += Dafny.Helpers.ToString(this._reply);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____CTypes__i_Compile._ICReply theDefault = create(Native____Io__s_Compile.EndPoint.Default(), BigInteger.Zero, LiveByzRSL____AppInterface__i_Compile.CAppMessage.Default());
    public static LiveByzRSL____CTypes__i_Compile._ICReply Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____CTypes__i_Compile._ICReply> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____CTypes__i_Compile._ICReply>(LiveByzRSL____CTypes__i_Compile.CReply.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____CTypes__i_Compile._ICReply> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICReply create(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, LiveByzRSL____AppInterface__i_Compile._ICAppMessage reply) {
      return new CReply(client, seqno, reply);
    }
    public static _ICReply create_CReply(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, LiveByzRSL____AppInterface__i_Compile._ICAppMessage reply) {
      return create(client, seqno, reply);
    }
    public bool is_CReply { get { return true; } }
    public Native____Io__s_Compile._IEndPoint dtor_client {
      get {
        return this._client;
      }
    }
    public BigInteger dtor_seqno {
      get {
        return this._seqno;
      }
    }
    public LiveByzRSL____AppInterface__i_Compile._ICAppMessage dtor_reply {
      get {
        return this._reply;
      }
    }
  }

  public interface _ICVote {
    bool is_CVote { get; }
    LiveByzRSL____CTypes__i_Compile._ICBallot dtor_max__value__bal { get; }
    Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_max__val { get; }
    _ICVote DowncastClone();
  }
  public class CVote : _ICVote {
    public readonly LiveByzRSL____CTypes__i_Compile._ICBallot _max__value__bal;
    public readonly Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _max__val;
    public CVote(LiveByzRSL____CTypes__i_Compile._ICBallot max__value__bal, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> max__val) {
      this._max__value__bal = max__value__bal;
      this._max__val = max__val;
    }
    public _ICVote DowncastClone() {
      if (this is _ICVote dt) { return dt; }
      return new CVote(_max__value__bal, _max__val);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CTypes__i_Compile.CVote;
      return oth != null && object.Equals(this._max__value__bal, oth._max__value__bal) && object.Equals(this._max__val, oth._max__val);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__value__bal));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__val));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CTypes__i_Compile.CVote.CVote";
      s += "(";
      s += Dafny.Helpers.ToString(this._max__value__bal);
      s += ", ";
      s += Dafny.Helpers.ToString(this._max__val);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____CTypes__i_Compile._ICVote theDefault = create(LiveByzRSL____CTypes__i_Compile.CBallot.Default(), Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.Empty);
    public static LiveByzRSL____CTypes__i_Compile._ICVote Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____CTypes__i_Compile._ICVote> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____CTypes__i_Compile._ICVote>(LiveByzRSL____CTypes__i_Compile.CVote.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____CTypes__i_Compile._ICVote> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICVote create(LiveByzRSL____CTypes__i_Compile._ICBallot max__value__bal, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> max__val) {
      return new CVote(max__value__bal, max__val);
    }
    public static _ICVote create_CVote(LiveByzRSL____CTypes__i_Compile._ICBallot max__value__bal, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> max__val) {
      return create(max__value__bal, max__val);
    }
    public bool is_CVote { get { return true; } }
    public LiveByzRSL____CTypes__i_Compile._ICBallot dtor_max__value__bal {
      get {
        return this._max__value__bal;
      }
    }
    public Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_max__val {
      get {
        return this._max__val;
      }
    }
  }

  public partial class __default {
    public static bool CBalLt(LiveByzRSL____CTypes__i_Compile._ICBallot ba, LiveByzRSL____CTypes__i_Compile._ICBallot bb)
    {
      return (((ba).dtor_seqno) < ((bb).dtor_seqno)) || ((((ba).dtor_seqno) == ((bb).dtor_seqno)) && (((ba).dtor_proposer__id) < ((bb).dtor_proposer__id)));
    }
    public static bool CBalLeq(LiveByzRSL____CTypes__i_Compile._ICBallot ba, LiveByzRSL____CTypes__i_Compile._ICBallot bb)
    {
      return (((ba).dtor_seqno) < ((bb).dtor_seqno)) || ((((ba).dtor_seqno) == ((bb).dtor_seqno)) && (((ba).dtor_proposer__id) <= ((bb).dtor_proposer__id)));
    }
    public static BigInteger RequestBatchSizeLimit() {
      return new BigInteger(1000);
    }
    public static BigInteger max__reply__cache__size() {
      return new BigInteger(256);
    }
    public static BigInteger max__votes__len() {
      return new BigInteger(1000);
    }
  }
} // end of namespace LiveByzRSL____CTypes__i_Compile
namespace LiveByzRSL____CMessage__i_Compile {

  public interface _ICMessage {
    bool is_CMessage__Invalid { get; }
    bool is_CMessage__Request { get; }
    bool is_CMessage__1a { get; }
    bool is_CMessage__1b { get; }
    bool is_CMessage__1c { get; }
    bool is_CMessage__2av { get; }
    bool is_CMessage__2b { get; }
    bool is_CMessage__Heartbeat { get; }
    bool is_CMessage__Reply { get; }
    bool is_CMessage__StartingPhase2 { get; }
    BigInteger dtor_seqno__req { get; }
    LiveByzRSL____AppInterface__i_Compile._ICAppMessage dtor_val { get; }
    LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal__1a { get; }
    LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal__1b { get; }
    BigInteger dtor_log__truncation__point { get; }
    Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> dtor_votes { get; }
    LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal__1c { get; }
    BigInteger dtor_opn__1c { get; }
    Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_val__1c { get; }
    LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal__2av { get; }
    BigInteger dtor_opn__2av { get; }
    Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_val__2av { get; }
    LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal__2b { get; }
    BigInteger dtor_opn__2b { get; }
    Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_val__2b { get; }
    LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal__heartbeat { get; }
    bool dtor_suspicious { get; }
    BigInteger dtor_opn__ckpt { get; }
    BigInteger dtor_seqno__reply { get; }
    LiveByzRSL____AppInterface__i_Compile._ICAppMessage dtor_reply { get; }
    LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal__2 { get; }
    BigInteger dtor_logTruncationPoint__2 { get; }
    _ICMessage DowncastClone();
  }
  public abstract class CMessage : _ICMessage {
    public CMessage() { }
    private static readonly LiveByzRSL____CMessage__i_Compile._ICMessage theDefault = create_CMessage__Invalid();
    public static LiveByzRSL____CMessage__i_Compile._ICMessage Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____CMessage__i_Compile._ICMessage> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____CMessage__i_Compile._ICMessage>(LiveByzRSL____CMessage__i_Compile.CMessage.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____CMessage__i_Compile._ICMessage> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICMessage create_CMessage__Invalid() {
      return new CMessage_CMessage__Invalid();
    }
    public static _ICMessage create_CMessage__Request(BigInteger seqno__req, LiveByzRSL____AppInterface__i_Compile._ICAppMessage val) {
      return new CMessage_CMessage__Request(seqno__req, val);
    }
    public static _ICMessage create_CMessage__1a(LiveByzRSL____CTypes__i_Compile._ICBallot bal__1a) {
      return new CMessage_CMessage__1a(bal__1a);
    }
    public static _ICMessage create_CMessage__1b(LiveByzRSL____CTypes__i_Compile._ICBallot bal__1b, BigInteger log__truncation__point, Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> votes) {
      return new CMessage_CMessage__1b(bal__1b, log__truncation__point, votes);
    }
    public static _ICMessage create_CMessage__1c(LiveByzRSL____CTypes__i_Compile._ICBallot bal__1c, BigInteger opn__1c, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> val__1c) {
      return new CMessage_CMessage__1c(bal__1c, opn__1c, val__1c);
    }
    public static _ICMessage create_CMessage__2av(LiveByzRSL____CTypes__i_Compile._ICBallot bal__2av, BigInteger opn__2av, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> val__2av) {
      return new CMessage_CMessage__2av(bal__2av, opn__2av, val__2av);
    }
    public static _ICMessage create_CMessage__2b(LiveByzRSL____CTypes__i_Compile._ICBallot bal__2b, BigInteger opn__2b, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> val__2b) {
      return new CMessage_CMessage__2b(bal__2b, opn__2b, val__2b);
    }
    public static _ICMessage create_CMessage__Heartbeat(LiveByzRSL____CTypes__i_Compile._ICBallot bal__heartbeat, bool suspicious, BigInteger opn__ckpt) {
      return new CMessage_CMessage__Heartbeat(bal__heartbeat, suspicious, opn__ckpt);
    }
    public static _ICMessage create_CMessage__Reply(BigInteger seqno__reply, LiveByzRSL____AppInterface__i_Compile._ICAppMessage reply) {
      return new CMessage_CMessage__Reply(seqno__reply, reply);
    }
    public static _ICMessage create_CMessage__StartingPhase2(LiveByzRSL____CTypes__i_Compile._ICBallot bal__2, BigInteger logTruncationPoint__2) {
      return new CMessage_CMessage__StartingPhase2(bal__2, logTruncationPoint__2);
    }
    public bool is_CMessage__Invalid { get { return this is CMessage_CMessage__Invalid; } }
    public bool is_CMessage__Request { get { return this is CMessage_CMessage__Request; } }
    public bool is_CMessage__1a { get { return this is CMessage_CMessage__1a; } }
    public bool is_CMessage__1b { get { return this is CMessage_CMessage__1b; } }
    public bool is_CMessage__1c { get { return this is CMessage_CMessage__1c; } }
    public bool is_CMessage__2av { get { return this is CMessage_CMessage__2av; } }
    public bool is_CMessage__2b { get { return this is CMessage_CMessage__2b; } }
    public bool is_CMessage__Heartbeat { get { return this is CMessage_CMessage__Heartbeat; } }
    public bool is_CMessage__Reply { get { return this is CMessage_CMessage__Reply; } }
    public bool is_CMessage__StartingPhase2 { get { return this is CMessage_CMessage__StartingPhase2; } }
    public BigInteger dtor_seqno__req {
      get {
        var d = this;
        return ((CMessage_CMessage__Request)d)._seqno__req;
      }
    }
    public LiveByzRSL____AppInterface__i_Compile._ICAppMessage dtor_val {
      get {
        var d = this;
        return ((CMessage_CMessage__Request)d)._val;
      }
    }
    public LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal__1a {
      get {
        var d = this;
        return ((CMessage_CMessage__1a)d)._bal__1a;
      }
    }
    public LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal__1b {
      get {
        var d = this;
        return ((CMessage_CMessage__1b)d)._bal__1b;
      }
    }
    public BigInteger dtor_log__truncation__point {
      get {
        var d = this;
        return ((CMessage_CMessage__1b)d)._log__truncation__point;
      }
    }
    public Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> dtor_votes {
      get {
        var d = this;
        return ((CMessage_CMessage__1b)d)._votes;
      }
    }
    public LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal__1c {
      get {
        var d = this;
        return ((CMessage_CMessage__1c)d)._bal__1c;
      }
    }
    public BigInteger dtor_opn__1c {
      get {
        var d = this;
        return ((CMessage_CMessage__1c)d)._opn__1c;
      }
    }
    public Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_val__1c {
      get {
        var d = this;
        return ((CMessage_CMessage__1c)d)._val__1c;
      }
    }
    public LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal__2av {
      get {
        var d = this;
        return ((CMessage_CMessage__2av)d)._bal__2av;
      }
    }
    public BigInteger dtor_opn__2av {
      get {
        var d = this;
        return ((CMessage_CMessage__2av)d)._opn__2av;
      }
    }
    public Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_val__2av {
      get {
        var d = this;
        return ((CMessage_CMessage__2av)d)._val__2av;
      }
    }
    public LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal__2b {
      get {
        var d = this;
        return ((CMessage_CMessage__2b)d)._bal__2b;
      }
    }
    public BigInteger dtor_opn__2b {
      get {
        var d = this;
        return ((CMessage_CMessage__2b)d)._opn__2b;
      }
    }
    public Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_val__2b {
      get {
        var d = this;
        return ((CMessage_CMessage__2b)d)._val__2b;
      }
    }
    public LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal__heartbeat {
      get {
        var d = this;
        return ((CMessage_CMessage__Heartbeat)d)._bal__heartbeat;
      }
    }
    public bool dtor_suspicious {
      get {
        var d = this;
        return ((CMessage_CMessage__Heartbeat)d)._suspicious;
      }
    }
    public BigInteger dtor_opn__ckpt {
      get {
        var d = this;
        return ((CMessage_CMessage__Heartbeat)d)._opn__ckpt;
      }
    }
    public BigInteger dtor_seqno__reply {
      get {
        var d = this;
        return ((CMessage_CMessage__Reply)d)._seqno__reply;
      }
    }
    public LiveByzRSL____AppInterface__i_Compile._ICAppMessage dtor_reply {
      get {
        var d = this;
        return ((CMessage_CMessage__Reply)d)._reply;
      }
    }
    public LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal__2 {
      get {
        var d = this;
        return ((CMessage_CMessage__StartingPhase2)d)._bal__2;
      }
    }
    public BigInteger dtor_logTruncationPoint__2 {
      get {
        var d = this;
        return ((CMessage_CMessage__StartingPhase2)d)._logTruncationPoint__2;
      }
    }
    public abstract _ICMessage DowncastClone();
  }
  public class CMessage_CMessage__Invalid : CMessage {
    public CMessage_CMessage__Invalid() {
    }
    public override _ICMessage DowncastClone() {
      if (this is _ICMessage dt) { return dt; }
      return new CMessage_CMessage__Invalid();
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CMessage__i_Compile.CMessage_CMessage__Invalid;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CMessage__i_Compile.CMessage.CMessage_Invalid";
      return s;
    }
  }
  public class CMessage_CMessage__Request : CMessage {
    public readonly BigInteger _seqno__req;
    public readonly LiveByzRSL____AppInterface__i_Compile._ICAppMessage _val;
    public CMessage_CMessage__Request(BigInteger seqno__req, LiveByzRSL____AppInterface__i_Compile._ICAppMessage val) {
      this._seqno__req = seqno__req;
      this._val = val;
    }
    public override _ICMessage DowncastClone() {
      if (this is _ICMessage dt) { return dt; }
      return new CMessage_CMessage__Request(_seqno__req, _val);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CMessage__i_Compile.CMessage_CMessage__Request;
      return oth != null && this._seqno__req == oth._seqno__req && object.Equals(this._val, oth._val);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._seqno__req));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._val));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CMessage__i_Compile.CMessage.CMessage_Request";
      s += "(";
      s += Dafny.Helpers.ToString(this._seqno__req);
      s += ", ";
      s += Dafny.Helpers.ToString(this._val);
      s += ")";
      return s;
    }
  }
  public class CMessage_CMessage__1a : CMessage {
    public readonly LiveByzRSL____CTypes__i_Compile._ICBallot _bal__1a;
    public CMessage_CMessage__1a(LiveByzRSL____CTypes__i_Compile._ICBallot bal__1a) {
      this._bal__1a = bal__1a;
    }
    public override _ICMessage DowncastClone() {
      if (this is _ICMessage dt) { return dt; }
      return new CMessage_CMessage__1a(_bal__1a);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CMessage__i_Compile.CMessage_CMessage__1a;
      return oth != null && object.Equals(this._bal__1a, oth._bal__1a);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal__1a));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CMessage__i_Compile.CMessage.CMessage_1a";
      s += "(";
      s += Dafny.Helpers.ToString(this._bal__1a);
      s += ")";
      return s;
    }
  }
  public class CMessage_CMessage__1b : CMessage {
    public readonly LiveByzRSL____CTypes__i_Compile._ICBallot _bal__1b;
    public readonly BigInteger _log__truncation__point;
    public readonly Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> _votes;
    public CMessage_CMessage__1b(LiveByzRSL____CTypes__i_Compile._ICBallot bal__1b, BigInteger log__truncation__point, Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> votes) {
      this._bal__1b = bal__1b;
      this._log__truncation__point = log__truncation__point;
      this._votes = votes;
    }
    public override _ICMessage DowncastClone() {
      if (this is _ICMessage dt) { return dt; }
      return new CMessage_CMessage__1b(_bal__1b, _log__truncation__point, _votes);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CMessage__i_Compile.CMessage_CMessage__1b;
      return oth != null && object.Equals(this._bal__1b, oth._bal__1b) && this._log__truncation__point == oth._log__truncation__point && object.Equals(this._votes, oth._votes);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal__1b));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._log__truncation__point));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._votes));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CMessage__i_Compile.CMessage.CMessage_1b";
      s += "(";
      s += Dafny.Helpers.ToString(this._bal__1b);
      s += ", ";
      s += Dafny.Helpers.ToString(this._log__truncation__point);
      s += ", ";
      s += Dafny.Helpers.ToString(this._votes);
      s += ")";
      return s;
    }
  }
  public class CMessage_CMessage__1c : CMessage {
    public readonly LiveByzRSL____CTypes__i_Compile._ICBallot _bal__1c;
    public readonly BigInteger _opn__1c;
    public readonly Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _val__1c;
    public CMessage_CMessage__1c(LiveByzRSL____CTypes__i_Compile._ICBallot bal__1c, BigInteger opn__1c, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> val__1c) {
      this._bal__1c = bal__1c;
      this._opn__1c = opn__1c;
      this._val__1c = val__1c;
    }
    public override _ICMessage DowncastClone() {
      if (this is _ICMessage dt) { return dt; }
      return new CMessage_CMessage__1c(_bal__1c, _opn__1c, _val__1c);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CMessage__i_Compile.CMessage_CMessage__1c;
      return oth != null && object.Equals(this._bal__1c, oth._bal__1c) && this._opn__1c == oth._opn__1c && object.Equals(this._val__1c, oth._val__1c);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal__1c));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._opn__1c));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._val__1c));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CMessage__i_Compile.CMessage.CMessage_1c";
      s += "(";
      s += Dafny.Helpers.ToString(this._bal__1c);
      s += ", ";
      s += Dafny.Helpers.ToString(this._opn__1c);
      s += ", ";
      s += Dafny.Helpers.ToString(this._val__1c);
      s += ")";
      return s;
    }
  }
  public class CMessage_CMessage__2av : CMessage {
    public readonly LiveByzRSL____CTypes__i_Compile._ICBallot _bal__2av;
    public readonly BigInteger _opn__2av;
    public readonly Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _val__2av;
    public CMessage_CMessage__2av(LiveByzRSL____CTypes__i_Compile._ICBallot bal__2av, BigInteger opn__2av, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> val__2av) {
      this._bal__2av = bal__2av;
      this._opn__2av = opn__2av;
      this._val__2av = val__2av;
    }
    public override _ICMessage DowncastClone() {
      if (this is _ICMessage dt) { return dt; }
      return new CMessage_CMessage__2av(_bal__2av, _opn__2av, _val__2av);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CMessage__i_Compile.CMessage_CMessage__2av;
      return oth != null && object.Equals(this._bal__2av, oth._bal__2av) && this._opn__2av == oth._opn__2av && object.Equals(this._val__2av, oth._val__2av);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 5;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal__2av));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._opn__2av));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._val__2av));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CMessage__i_Compile.CMessage.CMessage_2av";
      s += "(";
      s += Dafny.Helpers.ToString(this._bal__2av);
      s += ", ";
      s += Dafny.Helpers.ToString(this._opn__2av);
      s += ", ";
      s += Dafny.Helpers.ToString(this._val__2av);
      s += ")";
      return s;
    }
  }
  public class CMessage_CMessage__2b : CMessage {
    public readonly LiveByzRSL____CTypes__i_Compile._ICBallot _bal__2b;
    public readonly BigInteger _opn__2b;
    public readonly Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _val__2b;
    public CMessage_CMessage__2b(LiveByzRSL____CTypes__i_Compile._ICBallot bal__2b, BigInteger opn__2b, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> val__2b) {
      this._bal__2b = bal__2b;
      this._opn__2b = opn__2b;
      this._val__2b = val__2b;
    }
    public override _ICMessage DowncastClone() {
      if (this is _ICMessage dt) { return dt; }
      return new CMessage_CMessage__2b(_bal__2b, _opn__2b, _val__2b);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CMessage__i_Compile.CMessage_CMessage__2b;
      return oth != null && object.Equals(this._bal__2b, oth._bal__2b) && this._opn__2b == oth._opn__2b && object.Equals(this._val__2b, oth._val__2b);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 6;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal__2b));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._opn__2b));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._val__2b));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CMessage__i_Compile.CMessage.CMessage_2b";
      s += "(";
      s += Dafny.Helpers.ToString(this._bal__2b);
      s += ", ";
      s += Dafny.Helpers.ToString(this._opn__2b);
      s += ", ";
      s += Dafny.Helpers.ToString(this._val__2b);
      s += ")";
      return s;
    }
  }
  public class CMessage_CMessage__Heartbeat : CMessage {
    public readonly LiveByzRSL____CTypes__i_Compile._ICBallot _bal__heartbeat;
    public readonly bool _suspicious;
    public readonly BigInteger _opn__ckpt;
    public CMessage_CMessage__Heartbeat(LiveByzRSL____CTypes__i_Compile._ICBallot bal__heartbeat, bool suspicious, BigInteger opn__ckpt) {
      this._bal__heartbeat = bal__heartbeat;
      this._suspicious = suspicious;
      this._opn__ckpt = opn__ckpt;
    }
    public override _ICMessage DowncastClone() {
      if (this is _ICMessage dt) { return dt; }
      return new CMessage_CMessage__Heartbeat(_bal__heartbeat, _suspicious, _opn__ckpt);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CMessage__i_Compile.CMessage_CMessage__Heartbeat;
      return oth != null && object.Equals(this._bal__heartbeat, oth._bal__heartbeat) && this._suspicious == oth._suspicious && this._opn__ckpt == oth._opn__ckpt;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 7;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal__heartbeat));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._suspicious));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._opn__ckpt));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CMessage__i_Compile.CMessage.CMessage_Heartbeat";
      s += "(";
      s += Dafny.Helpers.ToString(this._bal__heartbeat);
      s += ", ";
      s += Dafny.Helpers.ToString(this._suspicious);
      s += ", ";
      s += Dafny.Helpers.ToString(this._opn__ckpt);
      s += ")";
      return s;
    }
  }
  public class CMessage_CMessage__Reply : CMessage {
    public readonly BigInteger _seqno__reply;
    public readonly LiveByzRSL____AppInterface__i_Compile._ICAppMessage _reply;
    public CMessage_CMessage__Reply(BigInteger seqno__reply, LiveByzRSL____AppInterface__i_Compile._ICAppMessage reply) {
      this._seqno__reply = seqno__reply;
      this._reply = reply;
    }
    public override _ICMessage DowncastClone() {
      if (this is _ICMessage dt) { return dt; }
      return new CMessage_CMessage__Reply(_seqno__reply, _reply);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CMessage__i_Compile.CMessage_CMessage__Reply;
      return oth != null && this._seqno__reply == oth._seqno__reply && object.Equals(this._reply, oth._reply);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 8;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._seqno__reply));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._reply));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CMessage__i_Compile.CMessage.CMessage_Reply";
      s += "(";
      s += Dafny.Helpers.ToString(this._seqno__reply);
      s += ", ";
      s += Dafny.Helpers.ToString(this._reply);
      s += ")";
      return s;
    }
  }
  public class CMessage_CMessage__StartingPhase2 : CMessage {
    public readonly LiveByzRSL____CTypes__i_Compile._ICBallot _bal__2;
    public readonly BigInteger _logTruncationPoint__2;
    public CMessage_CMessage__StartingPhase2(LiveByzRSL____CTypes__i_Compile._ICBallot bal__2, BigInteger logTruncationPoint__2) {
      this._bal__2 = bal__2;
      this._logTruncationPoint__2 = logTruncationPoint__2;
    }
    public override _ICMessage DowncastClone() {
      if (this is _ICMessage dt) { return dt; }
      return new CMessage_CMessage__StartingPhase2(_bal__2, _logTruncationPoint__2);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CMessage__i_Compile.CMessage_CMessage__StartingPhase2;
      return oth != null && object.Equals(this._bal__2, oth._bal__2) && this._logTruncationPoint__2 == oth._logTruncationPoint__2;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 9;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal__2));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._logTruncationPoint__2));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CMessage__i_Compile.CMessage.CMessage_StartingPhase2";
      s += "(";
      s += Dafny.Helpers.ToString(this._bal__2);
      s += ", ";
      s += Dafny.Helpers.ToString(this._logTruncationPoint__2);
      s += ")";
      return s;
    }
  }

  public interface _ICPacket {
    bool is_CPacket { get; }
    Native____Io__s_Compile._IEndPoint dtor_dst { get; }
    Native____Io__s_Compile._IEndPoint dtor_src { get; }
    LiveByzRSL____CMessage__i_Compile._ICMessage dtor_msg { get; }
    _ICPacket DowncastClone();
  }
  public class CPacket : _ICPacket {
    public readonly Native____Io__s_Compile._IEndPoint _dst;
    public readonly Native____Io__s_Compile._IEndPoint _src;
    public readonly LiveByzRSL____CMessage__i_Compile._ICMessage _msg;
    public CPacket(Native____Io__s_Compile._IEndPoint dst, Native____Io__s_Compile._IEndPoint src, LiveByzRSL____CMessage__i_Compile._ICMessage msg) {
      this._dst = dst;
      this._src = src;
      this._msg = msg;
    }
    public _ICPacket DowncastClone() {
      if (this is _ICPacket dt) { return dt; }
      return new CPacket(_dst, _src, _msg);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CMessage__i_Compile.CPacket;
      return oth != null && object.Equals(this._dst, oth._dst) && object.Equals(this._src, oth._src) && object.Equals(this._msg, oth._msg);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._dst));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._src));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._msg));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CMessage__i_Compile.CPacket.CPacket";
      s += "(";
      s += Dafny.Helpers.ToString(this._dst);
      s += ", ";
      s += Dafny.Helpers.ToString(this._src);
      s += ", ";
      s += Dafny.Helpers.ToString(this._msg);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____CMessage__i_Compile._ICPacket theDefault = create(Native____Io__s_Compile.EndPoint.Default(), Native____Io__s_Compile.EndPoint.Default(), LiveByzRSL____CMessage__i_Compile.CMessage.Default());
    public static LiveByzRSL____CMessage__i_Compile._ICPacket Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____CMessage__i_Compile._ICPacket> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____CMessage__i_Compile._ICPacket>(LiveByzRSL____CMessage__i_Compile.CPacket.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____CMessage__i_Compile._ICPacket> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICPacket create(Native____Io__s_Compile._IEndPoint dst, Native____Io__s_Compile._IEndPoint src, LiveByzRSL____CMessage__i_Compile._ICMessage msg) {
      return new CPacket(dst, src, msg);
    }
    public static _ICPacket create_CPacket(Native____Io__s_Compile._IEndPoint dst, Native____Io__s_Compile._IEndPoint src, LiveByzRSL____CMessage__i_Compile._ICMessage msg) {
      return create(dst, src, msg);
    }
    public bool is_CPacket { get { return true; } }
    public Native____Io__s_Compile._IEndPoint dtor_dst {
      get {
        return this._dst;
      }
    }
    public Native____Io__s_Compile._IEndPoint dtor_src {
      get {
        return this._src;
      }
    }
    public LiveByzRSL____CMessage__i_Compile._ICMessage dtor_msg {
      get {
        return this._msg;
      }
    }
  }

  public interface _ICBroadcast {
    bool is_CBroadcast { get; }
    bool is_CBroadcastNop { get; }
    Native____Io__s_Compile._IEndPoint dtor_src { get; }
    Dafny.ISequence<Native____Io__s_Compile._IEndPoint> dtor_dsts { get; }
    LiveByzRSL____CMessage__i_Compile._ICMessage dtor_msg { get; }
    _ICBroadcast DowncastClone();
  }
  public abstract class CBroadcast : _ICBroadcast {
    public CBroadcast() { }
    private static readonly LiveByzRSL____CMessage__i_Compile._ICBroadcast theDefault = create_CBroadcast(Native____Io__s_Compile.EndPoint.Default(), Dafny.Sequence<Native____Io__s_Compile._IEndPoint>.Empty, LiveByzRSL____CMessage__i_Compile.CMessage.Default());
    public static LiveByzRSL____CMessage__i_Compile._ICBroadcast Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____CMessage__i_Compile._ICBroadcast> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____CMessage__i_Compile._ICBroadcast>(LiveByzRSL____CMessage__i_Compile.CBroadcast.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____CMessage__i_Compile._ICBroadcast> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICBroadcast create_CBroadcast(Native____Io__s_Compile._IEndPoint src, Dafny.ISequence<Native____Io__s_Compile._IEndPoint> dsts, LiveByzRSL____CMessage__i_Compile._ICMessage msg) {
      return new CBroadcast_CBroadcast(src, dsts, msg);
    }
    public static _ICBroadcast create_CBroadcastNop() {
      return new CBroadcast_CBroadcastNop();
    }
    public bool is_CBroadcast { get { return this is CBroadcast_CBroadcast; } }
    public bool is_CBroadcastNop { get { return this is CBroadcast_CBroadcastNop; } }
    public Native____Io__s_Compile._IEndPoint dtor_src {
      get {
        var d = this;
        return ((CBroadcast_CBroadcast)d)._src;
      }
    }
    public Dafny.ISequence<Native____Io__s_Compile._IEndPoint> dtor_dsts {
      get {
        var d = this;
        return ((CBroadcast_CBroadcast)d)._dsts;
      }
    }
    public LiveByzRSL____CMessage__i_Compile._ICMessage dtor_msg {
      get {
        var d = this;
        return ((CBroadcast_CBroadcast)d)._msg;
      }
    }
    public abstract _ICBroadcast DowncastClone();
  }
  public class CBroadcast_CBroadcast : CBroadcast {
    public readonly Native____Io__s_Compile._IEndPoint _src;
    public readonly Dafny.ISequence<Native____Io__s_Compile._IEndPoint> _dsts;
    public readonly LiveByzRSL____CMessage__i_Compile._ICMessage _msg;
    public CBroadcast_CBroadcast(Native____Io__s_Compile._IEndPoint src, Dafny.ISequence<Native____Io__s_Compile._IEndPoint> dsts, LiveByzRSL____CMessage__i_Compile._ICMessage msg) {
      this._src = src;
      this._dsts = dsts;
      this._msg = msg;
    }
    public override _ICBroadcast DowncastClone() {
      if (this is _ICBroadcast dt) { return dt; }
      return new CBroadcast_CBroadcast(_src, _dsts, _msg);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CMessage__i_Compile.CBroadcast_CBroadcast;
      return oth != null && object.Equals(this._src, oth._src) && object.Equals(this._dsts, oth._dsts) && object.Equals(this._msg, oth._msg);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._src));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._dsts));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._msg));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CMessage__i_Compile.CBroadcast.CBroadcast";
      s += "(";
      s += Dafny.Helpers.ToString(this._src);
      s += ", ";
      s += Dafny.Helpers.ToString(this._dsts);
      s += ", ";
      s += Dafny.Helpers.ToString(this._msg);
      s += ")";
      return s;
    }
  }
  public class CBroadcast_CBroadcastNop : CBroadcast {
    public CBroadcast_CBroadcastNop() {
    }
    public override _ICBroadcast DowncastClone() {
      if (this is _ICBroadcast dt) { return dt; }
      return new CBroadcast_CBroadcastNop();
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CMessage__i_Compile.CBroadcast_CBroadcastNop;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CMessage__i_Compile.CBroadcast.CBroadcastNop";
      return s;
    }
  }

  public interface _IOutboundPackets {
    bool is_Broadcast { get; }
    bool is_OutboundPacket { get; }
    bool is_PacketSequence { get; }
    LiveByzRSL____CMessage__i_Compile._ICBroadcast dtor_broadcast { get; }
    Logic____Option__i_Compile._IOption<LiveByzRSL____CMessage__i_Compile._ICPacket> dtor_p { get; }
    Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> dtor_s { get; }
    _IOutboundPackets DowncastClone();
  }
  public abstract class OutboundPackets : _IOutboundPackets {
    public OutboundPackets() { }
    private static readonly LiveByzRSL____CMessage__i_Compile._IOutboundPackets theDefault = create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.Default());
    public static LiveByzRSL____CMessage__i_Compile._IOutboundPackets Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____CMessage__i_Compile._IOutboundPackets>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IOutboundPackets create_Broadcast(LiveByzRSL____CMessage__i_Compile._ICBroadcast broadcast) {
      return new OutboundPackets_Broadcast(broadcast);
    }
    public static _IOutboundPackets create_OutboundPacket(Logic____Option__i_Compile._IOption<LiveByzRSL____CMessage__i_Compile._ICPacket> p) {
      return new OutboundPackets_OutboundPacket(p);
    }
    public static _IOutboundPackets create_PacketSequence(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> s) {
      return new OutboundPackets_PacketSequence(s);
    }
    public bool is_Broadcast { get { return this is OutboundPackets_Broadcast; } }
    public bool is_OutboundPacket { get { return this is OutboundPackets_OutboundPacket; } }
    public bool is_PacketSequence { get { return this is OutboundPackets_PacketSequence; } }
    public LiveByzRSL____CMessage__i_Compile._ICBroadcast dtor_broadcast {
      get {
        var d = this;
        return ((OutboundPackets_Broadcast)d)._broadcast;
      }
    }
    public Logic____Option__i_Compile._IOption<LiveByzRSL____CMessage__i_Compile._ICPacket> dtor_p {
      get {
        var d = this;
        return ((OutboundPackets_OutboundPacket)d)._p;
      }
    }
    public Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> dtor_s {
      get {
        var d = this;
        return ((OutboundPackets_PacketSequence)d)._s;
      }
    }
    public abstract _IOutboundPackets DowncastClone();
  }
  public class OutboundPackets_Broadcast : OutboundPackets {
    public readonly LiveByzRSL____CMessage__i_Compile._ICBroadcast _broadcast;
    public OutboundPackets_Broadcast(LiveByzRSL____CMessage__i_Compile._ICBroadcast broadcast) {
      this._broadcast = broadcast;
    }
    public override _IOutboundPackets DowncastClone() {
      if (this is _IOutboundPackets dt) { return dt; }
      return new OutboundPackets_Broadcast(_broadcast);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CMessage__i_Compile.OutboundPackets_Broadcast;
      return oth != null && object.Equals(this._broadcast, oth._broadcast);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._broadcast));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CMessage__i_Compile.OutboundPackets.Broadcast";
      s += "(";
      s += Dafny.Helpers.ToString(this._broadcast);
      s += ")";
      return s;
    }
  }
  public class OutboundPackets_OutboundPacket : OutboundPackets {
    public readonly Logic____Option__i_Compile._IOption<LiveByzRSL____CMessage__i_Compile._ICPacket> _p;
    public OutboundPackets_OutboundPacket(Logic____Option__i_Compile._IOption<LiveByzRSL____CMessage__i_Compile._ICPacket> p) {
      this._p = p;
    }
    public override _IOutboundPackets DowncastClone() {
      if (this is _IOutboundPackets dt) { return dt; }
      return new OutboundPackets_OutboundPacket(_p);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CMessage__i_Compile.OutboundPackets_OutboundPacket;
      return oth != null && object.Equals(this._p, oth._p);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._p));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CMessage__i_Compile.OutboundPackets.OutboundPacket";
      s += "(";
      s += Dafny.Helpers.ToString(this._p);
      s += ")";
      return s;
    }
  }
  public class OutboundPackets_PacketSequence : OutboundPackets {
    public readonly Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _s;
    public OutboundPackets_PacketSequence(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> s) {
      this._s = s;
    }
    public override _IOutboundPackets DowncastClone() {
      if (this is _IOutboundPackets dt) { return dt; }
      return new OutboundPackets_PacketSequence(_s);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CMessage__i_Compile.OutboundPackets_PacketSequence;
      return oth != null && object.Equals(this._s, oth._s);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._s));
      return (int) hash;
    }
    public override string ToString() {
      string ss = "LiveByzRSL____CMessage__i_Compile.OutboundPackets.PacketSequence";
      ss += "(";
      ss += Dafny.Helpers.ToString(this._s);
      ss += ")";
      return ss;
    }
  }

} // end of namespace LiveByzRSL____CMessage__i_Compile
namespace LiveByzRSL____PacketParsing__i_Compile {

  public partial class __default {
    public static Common____GenericMarshalling__i_Compile._IG EndPoint__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GUint64();
    }
    public static Common____GenericMarshalling__i_Compile._IG CRequest__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(LiveByzRSL____PacketParsing__i_Compile.__default.EndPoint__grammar(), Common____GenericMarshalling__i_Compile.G.create_GUint64(), LiveByzRSL____AppInterface__i_Compile.__default.CAppMessage__grammar()));
    }
    public static Common____GenericMarshalling__i_Compile._IG CRequestBatch__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GArray(LiveByzRSL____PacketParsing__i_Compile.__default.CRequest__grammar());
    }
    public static Common____GenericMarshalling__i_Compile._IG CReply__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(LiveByzRSL____PacketParsing__i_Compile.__default.EndPoint__grammar(), Common____GenericMarshalling__i_Compile.G.create_GUint64(), LiveByzRSL____AppInterface__i_Compile.__default.CAppMessage__grammar()));
    }
    public static Common____GenericMarshalling__i_Compile._IG CBallot__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(Common____GenericMarshalling__i_Compile.G.create_GUint64(), Common____GenericMarshalling__i_Compile.G.create_GUint64()));
    }
    public static Common____GenericMarshalling__i_Compile._IG COperationNumber__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GUint64();
    }
    public static Common____GenericMarshalling__i_Compile._IG CVote__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(LiveByzRSL____PacketParsing__i_Compile.__default.CBallot__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.CRequestBatch__grammar()));
    }
    public static Common____GenericMarshalling__i_Compile._IG CMap__grammar(Common____GenericMarshalling__i_Compile._IG key, Common____GenericMarshalling__i_Compile._IG val)
    {
      return Common____GenericMarshalling__i_Compile.G.create_GArray(Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(key, val)));
    }
    public static Common____GenericMarshalling__i_Compile._IG CVotes__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GArray(Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(LiveByzRSL____PacketParsing__i_Compile.__default.COperationNumber__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.CVote__grammar())));
    }
    public static Common____GenericMarshalling__i_Compile._IG CReplyCache__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GArray(Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(LiveByzRSL____PacketParsing__i_Compile.__default.EndPoint__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.CReply__grammar())));
    }
    public static Common____GenericMarshalling__i_Compile._IG CMessage__Request__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(Common____GenericMarshalling__i_Compile.G.create_GUint64(), LiveByzRSL____AppInterface__i_Compile.__default.CAppMessage__grammar()));
    }
    public static Common____GenericMarshalling__i_Compile._IG CMessage__1a__grammar() {
      return LiveByzRSL____PacketParsing__i_Compile.__default.CBallot__grammar();
    }
    public static Common____GenericMarshalling__i_Compile._IG CMessage__1b__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(LiveByzRSL____PacketParsing__i_Compile.__default.CBallot__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.COperationNumber__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.CVotes__grammar()));
    }
    public static Common____GenericMarshalling__i_Compile._IG CMessage__1c__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(LiveByzRSL____PacketParsing__i_Compile.__default.CBallot__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.COperationNumber__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.CRequestBatch__grammar()));
    }
    public static Common____GenericMarshalling__i_Compile._IG CMessage__2av__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(LiveByzRSL____PacketParsing__i_Compile.__default.CBallot__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.COperationNumber__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.CRequestBatch__grammar()));
    }
    public static Common____GenericMarshalling__i_Compile._IG CMessage__2b__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(LiveByzRSL____PacketParsing__i_Compile.__default.CBallot__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.COperationNumber__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.CRequestBatch__grammar()));
    }
    public static Common____GenericMarshalling__i_Compile._IG CMessage__Heartbeat__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(LiveByzRSL____PacketParsing__i_Compile.__default.CBallot__grammar(), Common____GenericMarshalling__i_Compile.G.create_GUint64(), LiveByzRSL____PacketParsing__i_Compile.__default.COperationNumber__grammar()));
    }
    public static Common____GenericMarshalling__i_Compile._IG CMessage__Reply__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(Common____GenericMarshalling__i_Compile.G.create_GUint64(), LiveByzRSL____AppInterface__i_Compile.__default.CAppMessage__grammar()));
    }
    public static Common____GenericMarshalling__i_Compile._IG CMessage__StartingPhase2__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(LiveByzRSL____PacketParsing__i_Compile.__default.CBallot__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.COperationNumber__grammar()));
    }
    public static Common____GenericMarshalling__i_Compile._IG CMessage__grammar() {
      return Common____GenericMarshalling__i_Compile.G.create_GTaggedUnion(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IG>.FromElements(LiveByzRSL____PacketParsing__i_Compile.__default.CMessage__Request__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.CMessage__1a__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.CMessage__1b__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.CMessage__1c__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.CMessage__2av__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.CMessage__2b__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.CMessage__Heartbeat__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.CMessage__Reply__grammar(), LiveByzRSL____PacketParsing__i_Compile.__default.CMessage__StartingPhase2__grammar()));
    }
    public static Native____Io__s_Compile._IEndPoint parse__EndPoint(Common____GenericMarshalling__i_Compile._IV val) {
      if (((val).dtor_u) <= (281474976710655UL)) {
        return Common____NodeIdentity__i_Compile.__default.ConvertUint64ToEndPoint((val).dtor_u);
      } else {
        return Native____Io__s_Compile.EndPoint.create(Dafny.Sequence<byte>.FromElements((byte)(0), (byte)(0), (byte)(0), (byte)(0)), (ushort)(0));
      }
    }
    public static LiveByzRSL____CTypes__i_Compile._ICRequest parse__Request(Common____GenericMarshalling__i_Compile._IV val) {
      Native____Io__s_Compile._IEndPoint _153_ep = LiveByzRSL____PacketParsing__i_Compile.__default.parse__EndPoint(((val).dtor_t).Select(BigInteger.Zero));
      return LiveByzRSL____CTypes__i_Compile.CRequest.create(_153_ep, new BigInteger((((val).dtor_t).Select(BigInteger.One)).dtor_u), LiveByzRSL____AppInterface__i_Compile.__default.parse__AppMessage(((val).dtor_t).Select(new BigInteger(2))));
    }
    public static Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> Parse__RequestBatch(Common____GenericMarshalling__i_Compile._IV val)
    {
      Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> batch = Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.Empty;
      LiveByzRSL____CTypes__i_Compile._ICRequest[] _154_batchArr;
      LiveByzRSL____CTypes__i_Compile._ICRequest[] _nw8 = Dafny.ArrayHelpers.InitNewArray1<LiveByzRSL____CTypes__i_Compile._ICRequest>(LiveByzRSL____CTypes__i_Compile.CRequest.Default(), Dafny.Helpers.ToIntChecked((ulong)((val).dtor_a).LongCount, "array size exceeds memory limit"));
      _154_batchArr = _nw8;
      ulong _155_i;
      _155_i = 0UL;
      while ((_155_i) < ((ulong)((val).dtor_a).LongCount)) {
        LiveByzRSL____CTypes__i_Compile._ICRequest _156_req;
        _156_req = LiveByzRSL____PacketParsing__i_Compile.__default.parse__Request(((val).dtor_a).Select(_155_i));
        (_154_batchArr)[(int)((_155_i))] = _156_req;
        _155_i = (_155_i) + (1UL);
      }
      batch = Dafny.Helpers.SeqFromArray(_154_batchArr);
      return batch;
    }
    public static LiveByzRSL____CTypes__i_Compile._ICReply parse__Reply(Common____GenericMarshalling__i_Compile._IV val) {
      Native____Io__s_Compile._IEndPoint _157_ep = LiveByzRSL____PacketParsing__i_Compile.__default.parse__EndPoint(((val).dtor_t).Select(BigInteger.Zero));
      return LiveByzRSL____CTypes__i_Compile.CReply.create(_157_ep, new BigInteger((((val).dtor_t).Select(BigInteger.One)).dtor_u), LiveByzRSL____AppInterface__i_Compile.__default.parse__AppMessage(((val).dtor_t).Select(new BigInteger(2))));
    }
    public static LiveByzRSL____CTypes__i_Compile._ICBallot parse__Ballot(Common____GenericMarshalling__i_Compile._IV val) {
      return LiveByzRSL____CTypes__i_Compile.CBallot.create(new BigInteger((((val).dtor_t).Select(BigInteger.Zero)).dtor_u), new BigInteger((((val).dtor_t).Select(BigInteger.One)).dtor_u));
    }
    public static BigInteger parse__OperationNumber(Common____GenericMarshalling__i_Compile._IV val) {
      return new BigInteger((val).dtor_u);
    }
    public static LiveByzRSL____CTypes__i_Compile._ICVote Parse__Vote(Common____GenericMarshalling__i_Compile._IV val)
    {
      LiveByzRSL____CTypes__i_Compile._ICVote vote = LiveByzRSL____CTypes__i_Compile.CVote.Default();
      Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _158_batch;
      Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _out63;
      _out63 = LiveByzRSL____PacketParsing__i_Compile.__default.Parse__RequestBatch(((val).dtor_t).Select(BigInteger.One));
      _158_batch = _out63;
      vote = LiveByzRSL____CTypes__i_Compile.CVote.create(LiveByzRSL____PacketParsing__i_Compile.__default.parse__Ballot(((val).dtor_t).Select(BigInteger.Zero)), _158_batch);
      return vote;
    }
    public static Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> Parse__Votes(Common____GenericMarshalling__i_Compile._IV val)
    {
      Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> votes = Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Empty;
      if (((ulong)((val).dtor_a).LongCount) == (0UL)) {
        votes = Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.FromElements();
      } else {
        Common____GenericMarshalling__i_Compile._IV _159_tuple;
        _159_tuple = ((val).dtor_a).Select(BigInteger.Zero);
        BigInteger _160_op;
        _160_op = LiveByzRSL____PacketParsing__i_Compile.__default.parse__OperationNumber(((_159_tuple).dtor_t).Select(BigInteger.Zero));
        LiveByzRSL____CTypes__i_Compile._ICVote _161_vote;
        LiveByzRSL____CTypes__i_Compile._ICVote _out64;
        _out64 = LiveByzRSL____PacketParsing__i_Compile.__default.Parse__Vote(((_159_tuple).dtor_t).Select(BigInteger.One));
        _161_vote = _out64;
        Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> _162_others;
        Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> _out65;
        _out65 = LiveByzRSL____PacketParsing__i_Compile.__default.Parse__Votes(Common____GenericMarshalling__i_Compile.V.create_VArray(((val).dtor_a).Drop(BigInteger.One)));
        _162_others = _out65;
        Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> _163_m;
        _163_m = Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Update(_162_others, _160_op, _161_vote);
        votes = _163_m;
      }
      return votes;
    }
    public static Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> parse__ReplyCache(Common____GenericMarshalling__i_Compile._IV val) {
      if ((new BigInteger(((val).dtor_a).Count)).Sign == 0) {
        return Dafny.Map<Native____Io__s_Compile._IEndPoint, LiveByzRSL____CTypes__i_Compile._ICReply>.FromElements();
      } else {
        Common____GenericMarshalling__i_Compile._IV _164_tuple = ((val).dtor_a).Select(BigInteger.Zero);
        Native____Io__s_Compile._IEndPoint _165_e = LiveByzRSL____PacketParsing__i_Compile.__default.parse__EndPoint(((_164_tuple).dtor_t).Select(BigInteger.Zero));
        LiveByzRSL____CTypes__i_Compile._ICReply _166_reply = LiveByzRSL____PacketParsing__i_Compile.__default.parse__Reply(((_164_tuple).dtor_t).Select(BigInteger.One));
        Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> _167_others = LiveByzRSL____PacketParsing__i_Compile.__default.parse__ReplyCache(Common____GenericMarshalling__i_Compile.V.create_VArray(((val).dtor_a).Drop(BigInteger.One)));
        Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> _168_m = Dafny.Map<Native____Io__s_Compile._IEndPoint, LiveByzRSL____CTypes__i_Compile._ICReply>.Update(_167_others, _165_e, _166_reply);
        return _168_m;
      }
    }
    public static LiveByzRSL____CMessage__i_Compile._ICMessage parse__Message__Request(Common____GenericMarshalling__i_Compile._IV val) {
      return LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__Request(new BigInteger((((val).dtor_t).Select(BigInteger.Zero)).dtor_u), LiveByzRSL____AppInterface__i_Compile.__default.parse__AppMessage(((val).dtor_t).Select(BigInteger.One)));
    }
    public static LiveByzRSL____CMessage__i_Compile._ICMessage parse__Message__1a(Common____GenericMarshalling__i_Compile._IV val) {
      return LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__1a(LiveByzRSL____PacketParsing__i_Compile.__default.parse__Ballot(val));
    }
    public static LiveByzRSL____CMessage__i_Compile._ICMessage Parse__Message__1b(Common____GenericMarshalling__i_Compile._IV val)
    {
      LiveByzRSL____CMessage__i_Compile._ICMessage msg = LiveByzRSL____CMessage__i_Compile.CMessage.Default();
      Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> _169_votes;
      Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> _out66;
      _out66 = LiveByzRSL____PacketParsing__i_Compile.__default.Parse__Votes(((val).dtor_t).Select(new BigInteger(2)));
      _169_votes = _out66;
      msg = LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__1b(LiveByzRSL____PacketParsing__i_Compile.__default.parse__Ballot(((val).dtor_t).Select(BigInteger.Zero)), LiveByzRSL____PacketParsing__i_Compile.__default.parse__OperationNumber(((val).dtor_t).Select(BigInteger.One)), _169_votes);
      return msg;
    }
    public static LiveByzRSL____CMessage__i_Compile._ICMessage Parse__Message__1c(Common____GenericMarshalling__i_Compile._IV val)
    {
      LiveByzRSL____CMessage__i_Compile._ICMessage msg = LiveByzRSL____CMessage__i_Compile.CMessage.Default();
      Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _170_batch;
      Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _out67;
      _out67 = LiveByzRSL____PacketParsing__i_Compile.__default.Parse__RequestBatch(((val).dtor_t).Select(new BigInteger(2)));
      _170_batch = _out67;
      msg = LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__1c(LiveByzRSL____PacketParsing__i_Compile.__default.parse__Ballot(((val).dtor_t).Select(BigInteger.Zero)), LiveByzRSL____PacketParsing__i_Compile.__default.parse__OperationNumber(((val).dtor_t).Select(BigInteger.One)), _170_batch);
      return msg;
    }
    public static LiveByzRSL____CMessage__i_Compile._ICMessage Parse__Message__2av(Common____GenericMarshalling__i_Compile._IV val)
    {
      LiveByzRSL____CMessage__i_Compile._ICMessage msg = LiveByzRSL____CMessage__i_Compile.CMessage.Default();
      Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _171_batch;
      Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _out68;
      _out68 = LiveByzRSL____PacketParsing__i_Compile.__default.Parse__RequestBatch(((val).dtor_t).Select(new BigInteger(2)));
      _171_batch = _out68;
      msg = LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__2av(LiveByzRSL____PacketParsing__i_Compile.__default.parse__Ballot(((val).dtor_t).Select(BigInteger.Zero)), LiveByzRSL____PacketParsing__i_Compile.__default.parse__OperationNumber(((val).dtor_t).Select(BigInteger.One)), _171_batch);
      return msg;
    }
    public static LiveByzRSL____CMessage__i_Compile._ICMessage Parse__Message__2b(Common____GenericMarshalling__i_Compile._IV val)
    {
      LiveByzRSL____CMessage__i_Compile._ICMessage msg = LiveByzRSL____CMessage__i_Compile.CMessage.Default();
      Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _172_batch;
      Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _out69;
      _out69 = LiveByzRSL____PacketParsing__i_Compile.__default.Parse__RequestBatch(((val).dtor_t).Select(new BigInteger(2)));
      _172_batch = _out69;
      msg = LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__2b(LiveByzRSL____PacketParsing__i_Compile.__default.parse__Ballot(((val).dtor_t).Select(BigInteger.Zero)), LiveByzRSL____PacketParsing__i_Compile.__default.parse__OperationNumber(((val).dtor_t).Select(BigInteger.One)), _172_batch);
      return msg;
    }
    public static LiveByzRSL____CMessage__i_Compile._ICMessage parse__Message__Heartbeat(Common____GenericMarshalling__i_Compile._IV val) {
      return LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__Heartbeat(LiveByzRSL____PacketParsing__i_Compile.__default.parse__Ballot(((val).dtor_t).Select(BigInteger.Zero)), ((((val).dtor_t).Select(BigInteger.One)).dtor_u) != (0UL), LiveByzRSL____PacketParsing__i_Compile.__default.parse__OperationNumber(((val).dtor_t).Select(new BigInteger(2))));
    }
    public static LiveByzRSL____CMessage__i_Compile._ICMessage parse__Message__Reply(Common____GenericMarshalling__i_Compile._IV val) {
      return LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__Reply(new BigInteger((((val).dtor_t).Select(BigInteger.Zero)).dtor_u), LiveByzRSL____AppInterface__i_Compile.__default.parse__AppMessage(((val).dtor_t).Select(BigInteger.One)));
    }
    public static LiveByzRSL____CMessage__i_Compile._ICMessage parse__Message__StartingPhase2(Common____GenericMarshalling__i_Compile._IV val) {
      return LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__StartingPhase2(LiveByzRSL____PacketParsing__i_Compile.__default.parse__Ballot(((val).dtor_t).Select(BigInteger.Zero)), LiveByzRSL____PacketParsing__i_Compile.__default.parse__OperationNumber(((val).dtor_t).Select(BigInteger.One)));
    }
    public static LiveByzRSL____CMessage__i_Compile._ICMessage Parse__Message(Common____GenericMarshalling__i_Compile._IV val)
    {
      LiveByzRSL____CMessage__i_Compile._ICMessage msg = LiveByzRSL____CMessage__i_Compile.CMessage.Default();
      if (((val).dtor_c) == (0UL)) {
        msg = LiveByzRSL____PacketParsing__i_Compile.__default.parse__Message__Request((val).dtor_val);
      } else if (((val).dtor_c) == (1UL)) {
        msg = LiveByzRSL____PacketParsing__i_Compile.__default.parse__Message__1a((val).dtor_val);
      } else if (((val).dtor_c) == (2UL)) {
        LiveByzRSL____CMessage__i_Compile._ICMessage _out70;
        _out70 = LiveByzRSL____PacketParsing__i_Compile.__default.Parse__Message__1b((val).dtor_val);
        msg = _out70;
      } else if (((val).dtor_c) == (3UL)) {
        LiveByzRSL____CMessage__i_Compile._ICMessage _out71;
        _out71 = LiveByzRSL____PacketParsing__i_Compile.__default.Parse__Message__1c((val).dtor_val);
        msg = _out71;
      } else if (((val).dtor_c) == (4UL)) {
        LiveByzRSL____CMessage__i_Compile._ICMessage _out72;
        _out72 = LiveByzRSL____PacketParsing__i_Compile.__default.Parse__Message__2av((val).dtor_val);
        msg = _out72;
      } else if (((val).dtor_c) == (5UL)) {
        LiveByzRSL____CMessage__i_Compile._ICMessage _out73;
        _out73 = LiveByzRSL____PacketParsing__i_Compile.__default.Parse__Message__2b((val).dtor_val);
        msg = _out73;
      } else if (((val).dtor_c) == (6UL)) {
        msg = LiveByzRSL____PacketParsing__i_Compile.__default.parse__Message__Heartbeat((val).dtor_val);
      } else if (((val).dtor_c) == (7UL)) {
        msg = LiveByzRSL____PacketParsing__i_Compile.__default.parse__Message__Reply((val).dtor_val);
      } else if (((val).dtor_c) == (8UL)) {
        msg = LiveByzRSL____PacketParsing__i_Compile.__default.parse__Message__StartingPhase2((val).dtor_val);
      } else {
        msg = LiveByzRSL____PacketParsing__i_Compile.__default.parse__Message__Request(val);
      }
      return msg;
    }
    public static LiveByzRSL____CMessage__i_Compile._ICMessage PaxosDemarshallDataMethod(byte[] data, Common____GenericMarshalling__i_Compile._IG msg__grammar)
    {
      LiveByzRSL____CMessage__i_Compile._ICMessage msg = LiveByzRSL____CMessage__i_Compile.CMessage.Default();
      bool _173_success;
      Common____GenericMarshalling__i_Compile._IV _174_val;
      bool _out74;
      Common____GenericMarshalling__i_Compile._IV _out75;
      Common____GenericMarshalling__i_Compile.__default.Demarshall(data, msg__grammar, out _out74, out _out75);
      _173_success = _out74;
      _174_val = _out75;
      if (_173_success) {
        LiveByzRSL____CMessage__i_Compile._ICMessage _out76;
        _out76 = LiveByzRSL____PacketParsing__i_Compile.__default.Parse__Message(_174_val);
        msg = _out76;
      } else {
        msg = LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__Invalid();
      }
      return msg;
    }
    public static bool DetermineIfValidVote(LiveByzRSL____CTypes__i_Compile._ICVote vote)
    {
      bool b = false;
      if ((new BigInteger(((vote).dtor_max__val).Count)) > (LiveByzRSL____CTypes__i_Compile.__default.RequestBatchSizeLimit())) {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Cvote's RequestBatch exceeds size limit\n")));
        return b;
      }
      b = ((ulong)((vote).dtor_max__val).LongCount) <= ((ulong)(LiveByzRSL____CTypes__i_Compile.__default.RequestBatchSizeLimit()));
      return b;
    }
    public static bool DetermineIfValidVotes(Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> votes)
    {
      bool b = false;
      b = ((ulong)(votes).LongCount) < ((ulong)(LiveByzRSL____CTypes__i_Compile.__default.max__votes__len()));
      if (!(b)) {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("votes exceeds the max length")));
        return b;
      }
      Dafny.ISet<BigInteger> _175_keys;
      _175_keys = Collections____Maps__i_Compile.__default.domain<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>(votes);
      while ((new BigInteger((_175_keys).Count)).Sign == 1) {
        BigInteger _176_opn;
        foreach (BigInteger _assign_such_that_1 in (_175_keys).Elements) {
          _176_opn = (BigInteger)_assign_such_that_1;
          if ((_175_keys).Contains((_176_opn))) {
            goto after__ASSIGN_SUCH_THAT_1;
          }
        }
        throw new System.Exception("assign-such-that search produced no value (line 729)");
      after__ASSIGN_SUCH_THAT_1: ;
        _175_keys = Dafny.Set<BigInteger>.Difference(_175_keys, Dafny.Set<BigInteger>.FromElements(_176_opn));
        bool _out77;
        _out77 = LiveByzRSL____PacketParsing__i_Compile.__default.DetermineIfValidVote(Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Select(votes,_176_opn));
        b = _out77;
        if (!(b)) {
          return b;
        }
      }
      return b;
    }
    public static bool DetermineIfValidRequestBatch(Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> c)
    {
      bool b = false;
      ulong _177_n;
      _177_n = (ulong)(c).LongCount;
      b = (_177_n) <= ((ulong)(LiveByzRSL____CTypes__i_Compile.__default.RequestBatchSizeLimit()));
      if (!(b)) {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("RequestBatch exceeds size limit.\n")));
        return b;
      }
      ulong _178_pos;
      _178_pos = 0UL;
      while ((_178_pos) < (_177_n)) {
        LiveByzRSL____CTypes__i_Compile._ICRequest _179_a;
        _179_a = (c).Select(_178_pos);
        if ((!(LiveByzRSL____AppInterface__i_Compile.__default.CAppMessageIsValid((_179_a).dtor_request))) || (!(Common____UdpClient__i_Compile.__default.EndPointIsValidIPV4((_179_a).dtor_client)))) {
          b = false;
          return b;
        }
        _178_pos = (_178_pos) + (1UL);
      }
      b = true;
      return b;
    }
    public static bool DetermineIfValidReplyCache(Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> m)
    {
      bool b = false;
      b = ((ulong)(m).LongCount) < (256UL);
      if (!(b)) {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("ReplyCache exceeds size limit\n")));
        return b;
      }
      return b;
    }
    public static bool DetermineIfMessageMarshallable(LiveByzRSL____CMessage__i_Compile._ICMessage msg)
    {
      bool b = false;
      if ((msg).is_CMessage__Invalid) {
        b = false;
      } else if ((msg).is_CMessage__Request) {
        b = LiveByzRSL____AppInterface__i_Compile.__default.CAppMessageIsValid((msg).dtor_val);
      } else if ((msg).is_CMessage__1a) {
        b = true;
      } else if ((msg).is_CMessage__1b) {
        bool _out78;
        _out78 = LiveByzRSL____PacketParsing__i_Compile.__default.DetermineIfValidVotes((msg).dtor_votes);
        b = _out78;
      } else if ((msg).is_CMessage__1c) {
        if ((new BigInteger(((msg).dtor_val__1c).Count)) > (LiveByzRSL____CTypes__i_Compile.__default.RequestBatchSizeLimit())) {
          Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("1c msg RequestBatch exceeds size limit\n")));
          return b;
        }
        b = ((ulong)((msg).dtor_val__1c).LongCount) <= ((ulong)(LiveByzRSL____CTypes__i_Compile.__default.RequestBatchSizeLimit()));
      } else if ((msg).is_CMessage__2av) {
        if ((new BigInteger(((msg).dtor_val__2av).Count)) > (LiveByzRSL____CTypes__i_Compile.__default.RequestBatchSizeLimit())) {
          Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("2av msg RequestBatch exceeds size limit\n")));
          return b;
        }
        b = ((ulong)((msg).dtor_val__2av).LongCount) <= ((ulong)(LiveByzRSL____CTypes__i_Compile.__default.RequestBatchSizeLimit()));
      } else if ((msg).is_CMessage__2b) {
        if ((new BigInteger(((msg).dtor_val__2b).Count)) > (LiveByzRSL____CTypes__i_Compile.__default.RequestBatchSizeLimit())) {
          Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("2b msg RequestBatch exceeds size limit\n")));
          return b;
        }
        b = ((ulong)((msg).dtor_val__2b).LongCount) <= ((ulong)(LiveByzRSL____CTypes__i_Compile.__default.RequestBatchSizeLimit()));
      } else if ((msg).is_CMessage__Heartbeat) {
        b = true;
      } else if ((msg).is_CMessage__Reply) {
        b = LiveByzRSL____AppInterface__i_Compile.__default.CAppMessageIsValid((msg).dtor_reply);
      } else if ((msg).is_CMessage__StartingPhase2) {
        b = true;
      } else {
      }
      return b;
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallEndPoint(Native____Io__s_Compile._IEndPoint c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      val = Common____GenericMarshalling__i_Compile.V.create_VUint64(Common____NodeIdentity__i_Compile.__default.ConvertEndPointToUint64(c));
      return val;
    }
    public static bool RequestInRange(LiveByzRSL____CTypes__i_Compile._ICRequest c) {
      return (true) && (LiveByzRSL____PacketParsing__i_Compile.__default.Uint64InRange((c).dtor_seqno));
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallRequest(LiveByzRSL____CTypes__i_Compile._ICRequest c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      Common____GenericMarshalling__i_Compile._IV _180_marshalled__app__message;
      Common____GenericMarshalling__i_Compile._IV _out79;
      _out79 = LiveByzRSL____AppInterface__i_Compile.__default.MarshallCAppMessage((c).dtor_request);
      _180_marshalled__app__message = _out79;
      Common____GenericMarshalling__i_Compile._IV _181_marshalled__ep;
      Common____GenericMarshalling__i_Compile._IV _out80;
      _out80 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallEndPoint((c).dtor_client);
      _181_marshalled__ep = _out80;
      ulong _182_seqno;
      _182_seqno = 0UL;
      if ((((c).dtor_seqno).Sign != -1) && (((c).dtor_seqno) < (BigInteger.Parse("18446744073709551616")))) {
        _182_seqno = (ulong)((c).dtor_seqno);
      } else {
        _182_seqno = 18446744073709551615UL;
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Marshall CRequest seqno overflow\n")));
      }
      val = Common____GenericMarshalling__i_Compile.V.create_VTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements(_181_marshalled__ep, Common____GenericMarshalling__i_Compile.V.create_VUint64(_182_seqno), _180_marshalled__app__message));
      return val;
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallRequestBatch(Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      if ((new BigInteger((c).Count)) > (LiveByzRSL____CTypes__i_Compile.__default.RequestBatchSizeLimit())) {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("RequestBatch exceeds size limit\n")));
        return val;
      }
      Common____GenericMarshalling__i_Compile._IV[] _183_reqs;
      Common____GenericMarshalling__i_Compile._IV[] _nw9 = Dafny.ArrayHelpers.InitNewArray1<Common____GenericMarshalling__i_Compile._IV>(Common____GenericMarshalling__i_Compile.V.Default(), Dafny.Helpers.ToIntChecked((ulong)(c).LongCount, "array size exceeds memory limit"));
      _183_reqs = _nw9;
      ulong _184_i;
      _184_i = 0UL;
      while ((_184_i) < ((ulong)(c).LongCount)) {
        Common____GenericMarshalling__i_Compile._IV _185_single;
        Common____GenericMarshalling__i_Compile._IV _out81;
        _out81 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallRequest((c).Select(_184_i));
        _185_single = _out81;
        (_183_reqs)[(int)((_184_i))] = _185_single;
        _184_i = (_184_i) + (1UL);
      }
      val = Common____GenericMarshalling__i_Compile.V.create_VArray(Dafny.Helpers.SeqFromArray(_183_reqs));
      return val;
    }
    public static bool ReplyInRange(LiveByzRSL____CTypes__i_Compile._ICReply c) {
      return (true) && (LiveByzRSL____PacketParsing__i_Compile.__default.Uint64InRange((c).dtor_seqno));
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallReply(LiveByzRSL____CTypes__i_Compile._ICReply c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      Common____GenericMarshalling__i_Compile._IV _186_marshalled__app__message;
      Common____GenericMarshalling__i_Compile._IV _out82;
      _out82 = LiveByzRSL____AppInterface__i_Compile.__default.MarshallCAppMessage((c).dtor_reply);
      _186_marshalled__app__message = _out82;
      Common____GenericMarshalling__i_Compile._IV _187_marshalled__ep;
      Common____GenericMarshalling__i_Compile._IV _out83;
      _out83 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallEndPoint((c).dtor_client);
      _187_marshalled__ep = _out83;
      ulong _188_seqno;
      _188_seqno = 0UL;
      if ((((c).dtor_seqno).Sign != -1) && (((c).dtor_seqno) < (BigInteger.Parse("18446744073709551616")))) {
        _188_seqno = (ulong)((c).dtor_seqno);
      } else {
        _188_seqno = 18446744073709551615UL;
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Marshall CReply seqno overflow\n")));
      }
      val = Common____GenericMarshalling__i_Compile.V.create_VTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements(_187_marshalled__ep, Common____GenericMarshalling__i_Compile.V.create_VUint64(_188_seqno), _186_marshalled__app__message));
      return val;
    }
    public static bool BallotInRange(LiveByzRSL____CTypes__i_Compile._ICBallot c) {
      return (LiveByzRSL____PacketParsing__i_Compile.__default.Uint64InRange((c).dtor_seqno)) && (LiveByzRSL____PacketParsing__i_Compile.__default.Uint64InRange((c).dtor_proposer__id));
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallBallot(LiveByzRSL____CTypes__i_Compile._ICBallot c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      ulong _189_seqno;
      _189_seqno = 0UL;
      if ((((c).dtor_seqno).Sign != -1) && (((c).dtor_seqno) < (BigInteger.Parse("18446744073709551616")))) {
        _189_seqno = (ulong)((c).dtor_seqno);
      } else {
        _189_seqno = 18446744073709551615UL;
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Marshall CBallot seqno overflow\n")));
      }
      ulong _190_id;
      _190_id = 0UL;
      if ((((c).dtor_proposer__id).Sign != -1) && (((c).dtor_proposer__id) < (BigInteger.Parse("18446744073709551616")))) {
        _190_id = (ulong)((c).dtor_proposer__id);
      } else {
        _190_id = 18446744073709551615UL;
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Marshall CBallot seqno overflow\n")));
      }
      val = Common____GenericMarshalling__i_Compile.V.create_VTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements(Common____GenericMarshalling__i_Compile.V.create_VUint64(_189_seqno), Common____GenericMarshalling__i_Compile.V.create_VUint64(_190_id)));
      return val;
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallOperationNumber(BigInteger c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      ulong _191_opn;
      _191_opn = 0UL;
      if (((c).Sign != -1) && ((c) < (BigInteger.Parse("18446744073709551616")))) {
        _191_opn = (ulong)(c);
      } else {
        _191_opn = 18446744073709551615UL;
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Marshall CRequest seqno overflow\n")));
      }
      val = Common____GenericMarshalling__i_Compile.V.create_VUint64(_191_opn);
      return val;
    }
    public static bool VoteInRange(LiveByzRSL____CTypes__i_Compile._ICVote c) {
      return (true) && (LiveByzRSL____PacketParsing__i_Compile.__default.BallotInRange((c).dtor_max__value__bal));
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallVote(LiveByzRSL____CTypes__i_Compile._ICVote c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      Common____GenericMarshalling__i_Compile._IV _192_bal;
      Common____GenericMarshalling__i_Compile._IV _out84;
      _out84 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallBallot((c).dtor_max__value__bal);
      _192_bal = _out84;
      Common____GenericMarshalling__i_Compile._IV _193_v;
      Common____GenericMarshalling__i_Compile._IV _out85;
      _out85 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallRequestBatch((c).dtor_max__val);
      _193_v = _out85;
      val = Common____GenericMarshalling__i_Compile.V.create_VTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements(_192_bal, _193_v));
      return val;
    }
    public static bool Uint64InRange(BigInteger i) {
      return ((i).Sign != -1) && ((i) < (new BigInteger(18446744073709551615UL)));
    }
    public static bool VotesInRange(Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> c) {
      return (true) && (Dafny.Helpers.Id<Func<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, bool>>((_194_c) => Dafny.Helpers.Quantifier<BigInteger>((_194_c).Keys.Elements, true, (((_forall_var_2) => {
        BigInteger _195_i = (BigInteger)_forall_var_2;
        return !((_194_c).Contains((_195_i))) || (((LiveByzRSL____PacketParsing__i_Compile.__default.Uint64InRange(_195_i)) && (LiveByzRSL____PacketParsing__i_Compile.__default.VoteInRange(Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Select(_194_c,_195_i)))) && ((new BigInteger(((Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Select(_194_c,_195_i)).dtor_max__val).Count)) <= (LiveByzRSL____CTypes__i_Compile.__default.RequestBatchSizeLimit())));
      }))))(c));
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallVotes(Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      if (LiveByzRSL____PacketParsing__i_Compile.__default.VotesInRange(c)) {
        if ((new BigInteger((c).Count)).Sign == 0) {
          val = Common____GenericMarshalling__i_Compile.V.create_VArray(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements());
        } else {
          bool _196_b;
          _196_b = (new BigInteger((c).Count)) < (LiveByzRSL____CTypes__i_Compile.__default.max__votes__len());
          if (!(_196_b)) {
            Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("votes exceeds the max length")));
            return val;
          }
          BigInteger _197_op;
          foreach (BigInteger _assign_such_that_2 in (c).Keys.Elements) {
            _197_op = (BigInteger)_assign_such_that_2;
            if ((c).Contains((_197_op))) {
              goto after__ASSIGN_SUCH_THAT_2;
            }
          }
          throw new System.Exception("assign-such-that search produced no value (line 1084)");
        after__ASSIGN_SUCH_THAT_2: ;
          Common____GenericMarshalling__i_Compile._IV _198_marshalled__op;
          Common____GenericMarshalling__i_Compile._IV _out86;
          _out86 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallOperationNumber(_197_op);
          _198_marshalled__op = _out86;
          Common____GenericMarshalling__i_Compile._IV _199_marshalled__vote;
          Common____GenericMarshalling__i_Compile._IV _out87;
          _out87 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallVote(Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Select(c,_197_op));
          _199_marshalled__vote = _out87;
          Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> _200_remainder;
          _200_remainder = Collections____Maps__i_Compile.__default.RemoveElt<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>(c, _197_op);
          Common____GenericMarshalling__i_Compile._IV _201_marshalled__remainder;
          Common____GenericMarshalling__i_Compile._IV _out88;
          _out88 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallVotes(_200_remainder);
          _201_marshalled__remainder = _out88;
          val = Common____GenericMarshalling__i_Compile.V.create_VArray(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.Concat(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements(Common____GenericMarshalling__i_Compile.V.create_VTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements(_198_marshalled__op, _199_marshalled__vote))), (_201_marshalled__remainder).dtor_a));
        }
      } else {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Marshall CVotes overflow\n")));
      }
      return val;
    }
    public static bool MsgRequestInRange(LiveByzRSL____CMessage__i_Compile._ICMessage c) {
      return (true) && (LiveByzRSL____PacketParsing__i_Compile.__default.Uint64InRange((c).dtor_seqno__req));
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallMessage__Request(LiveByzRSL____CMessage__i_Compile._ICMessage c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      Common____GenericMarshalling__i_Compile._IV _202_v;
      Common____GenericMarshalling__i_Compile._IV _out89;
      _out89 = LiveByzRSL____AppInterface__i_Compile.__default.MarshallCAppMessage((c).dtor_val);
      _202_v = _out89;
      ulong _203_seqno;
      _203_seqno = 0UL;
      if (LiveByzRSL____PacketParsing__i_Compile.__default.MsgRequestInRange(c)) {
        _203_seqno = (ulong)((c).dtor_seqno__req);
      }
      val = Common____GenericMarshalling__i_Compile.V.create_VTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements(Common____GenericMarshalling__i_Compile.V.create_VUint64(_203_seqno), _202_v));
      return val;
    }
    public static bool Msg1aInRange(LiveByzRSL____CMessage__i_Compile._ICMessage c) {
      return (true) && (LiveByzRSL____PacketParsing__i_Compile.__default.BallotInRange((c).dtor_bal__1a));
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallMessage__1a(LiveByzRSL____CMessage__i_Compile._ICMessage c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      Common____GenericMarshalling__i_Compile._IV _out90;
      _out90 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallBallot((c).dtor_bal__1a);
      val = _out90;
      return val;
    }
    public static bool Msg1bInRange(LiveByzRSL____CMessage__i_Compile._ICMessage c) {
      return ((LiveByzRSL____PacketParsing__i_Compile.__default.BallotInRange((c).dtor_bal__1b)) && (LiveByzRSL____PacketParsing__i_Compile.__default.Uint64InRange((c).dtor_log__truncation__point))) && (LiveByzRSL____PacketParsing__i_Compile.__default.VotesInRange((c).dtor_votes));
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallMessage__1b(LiveByzRSL____CMessage__i_Compile._ICMessage c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      if (LiveByzRSL____PacketParsing__i_Compile.__default.Msg1bInRange(c)) {
        Common____GenericMarshalling__i_Compile._IV _204_bal;
        Common____GenericMarshalling__i_Compile._IV _out91;
        _out91 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallBallot((c).dtor_bal__1b);
        _204_bal = _out91;
        Common____GenericMarshalling__i_Compile._IV _205_log__truncation__point;
        Common____GenericMarshalling__i_Compile._IV _out92;
        _out92 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallOperationNumber((c).dtor_log__truncation__point);
        _205_log__truncation__point = _out92;
        Common____GenericMarshalling__i_Compile._IV _206_votes;
        Common____GenericMarshalling__i_Compile._IV _out93;
        _out93 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallVotes((c).dtor_votes);
        _206_votes = _out93;
        bool _207_b;
        _207_b = (new BigInteger(((c).dtor_votes).Count)) < (LiveByzRSL____CTypes__i_Compile.__default.max__votes__len());
        if (!(_207_b)) {
          Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("votes exceeds the max length")));
          return val;
        }
        val = Common____GenericMarshalling__i_Compile.V.create_VTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements(_204_bal, _205_log__truncation__point, _206_votes));
      } else {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Marshall 1b overflow\n")));
      }
      return val;
    }
    public static bool Msg1cInRange(LiveByzRSL____CMessage__i_Compile._ICMessage c) {
      return (LiveByzRSL____PacketParsing__i_Compile.__default.BallotInRange((c).dtor_bal__1c)) && (LiveByzRSL____PacketParsing__i_Compile.__default.Uint64InRange((c).dtor_opn__1c));
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallMessage__1c(LiveByzRSL____CMessage__i_Compile._ICMessage c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      if (LiveByzRSL____PacketParsing__i_Compile.__default.Msg1cInRange(c)) {
        Common____GenericMarshalling__i_Compile._IV _208_bal;
        Common____GenericMarshalling__i_Compile._IV _out94;
        _out94 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallBallot((c).dtor_bal__1c);
        _208_bal = _out94;
        Common____GenericMarshalling__i_Compile._IV _209_op;
        Common____GenericMarshalling__i_Compile._IV _out95;
        _out95 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallOperationNumber((c).dtor_opn__1c);
        _209_op = _out95;
        Common____GenericMarshalling__i_Compile._IV _210_v;
        Common____GenericMarshalling__i_Compile._IV _out96;
        _out96 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallRequestBatch((c).dtor_val__1c);
        _210_v = _out96;
        val = Common____GenericMarshalling__i_Compile.V.create_VTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements(_208_bal, _209_op, _210_v));
      } else {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Marshall 1c overflow\n")));
      }
      return val;
    }
    public static bool Msg2avInRange(LiveByzRSL____CMessage__i_Compile._ICMessage c) {
      return (LiveByzRSL____PacketParsing__i_Compile.__default.BallotInRange((c).dtor_bal__2av)) && (LiveByzRSL____PacketParsing__i_Compile.__default.Uint64InRange((c).dtor_opn__2av));
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallMessage__2av(LiveByzRSL____CMessage__i_Compile._ICMessage c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      if (LiveByzRSL____PacketParsing__i_Compile.__default.Msg2avInRange(c)) {
        Common____GenericMarshalling__i_Compile._IV _211_bal;
        Common____GenericMarshalling__i_Compile._IV _out97;
        _out97 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallBallot((c).dtor_bal__2av);
        _211_bal = _out97;
        Common____GenericMarshalling__i_Compile._IV _212_op;
        Common____GenericMarshalling__i_Compile._IV _out98;
        _out98 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallOperationNumber((c).dtor_opn__2av);
        _212_op = _out98;
        Common____GenericMarshalling__i_Compile._IV _213_v;
        Common____GenericMarshalling__i_Compile._IV _out99;
        _out99 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallRequestBatch((c).dtor_val__2av);
        _213_v = _out99;
        val = Common____GenericMarshalling__i_Compile.V.create_VTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements(_211_bal, _212_op, _213_v));
      } else {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Marshall 2av overflow\n")));
      }
      return val;
    }
    public static bool Msg2bInRange(LiveByzRSL____CMessage__i_Compile._ICMessage c) {
      return (LiveByzRSL____PacketParsing__i_Compile.__default.BallotInRange((c).dtor_bal__2b)) && (LiveByzRSL____PacketParsing__i_Compile.__default.Uint64InRange((c).dtor_opn__2b));
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallMessage__2b(LiveByzRSL____CMessage__i_Compile._ICMessage c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      if (LiveByzRSL____PacketParsing__i_Compile.__default.Msg2bInRange(c)) {
        Common____GenericMarshalling__i_Compile._IV _214_bal;
        Common____GenericMarshalling__i_Compile._IV _out100;
        _out100 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallBallot((c).dtor_bal__2b);
        _214_bal = _out100;
        Common____GenericMarshalling__i_Compile._IV _215_op;
        Common____GenericMarshalling__i_Compile._IV _out101;
        _out101 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallOperationNumber((c).dtor_opn__2b);
        _215_op = _out101;
        Common____GenericMarshalling__i_Compile._IV _216_v;
        Common____GenericMarshalling__i_Compile._IV _out102;
        _out102 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallRequestBatch((c).dtor_val__2b);
        _216_v = _out102;
        val = Common____GenericMarshalling__i_Compile.V.create_VTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements(_214_bal, _215_op, _216_v));
      } else {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Marshall 2b overflow\n")));
      }
      return val;
    }
    public static bool MsgHeartBeatInRange(LiveByzRSL____CMessage__i_Compile._ICMessage c) {
      return (LiveByzRSL____PacketParsing__i_Compile.__default.BallotInRange((c).dtor_bal__heartbeat)) && (LiveByzRSL____PacketParsing__i_Compile.__default.Uint64InRange((c).dtor_opn__ckpt));
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallMessage__Heartbeat(LiveByzRSL____CMessage__i_Compile._ICMessage c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      if (LiveByzRSL____PacketParsing__i_Compile.__default.MsgHeartBeatInRange(c)) {
        Common____GenericMarshalling__i_Compile._IV _217_ballot;
        Common____GenericMarshalling__i_Compile._IV _out103;
        _out103 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallBallot((c).dtor_bal__heartbeat);
        _217_ballot = _out103;
        Common____GenericMarshalling__i_Compile._IV _218_op;
        Common____GenericMarshalling__i_Compile._IV _out104;
        _out104 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallOperationNumber((c).dtor_opn__ckpt);
        _218_op = _out104;
        val = Common____GenericMarshalling__i_Compile.V.create_VTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements(_217_ballot, Common____GenericMarshalling__i_Compile.V.create_VUint64((((c).dtor_suspicious) ? (1UL) : (0UL))), _218_op));
      } else {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Marshall heartbeat overflow\n")));
      }
      return val;
    }
    public static bool MsgReplyInRange(LiveByzRSL____CMessage__i_Compile._ICMessage c) {
      return (true) && (LiveByzRSL____PacketParsing__i_Compile.__default.Uint64InRange((c).dtor_seqno__reply));
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallMessage__Reply(LiveByzRSL____CMessage__i_Compile._ICMessage c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      if (LiveByzRSL____PacketParsing__i_Compile.__default.MsgReplyInRange(c)) {
        Common____GenericMarshalling__i_Compile._IV _219_app__val;
        Common____GenericMarshalling__i_Compile._IV _out105;
        _out105 = LiveByzRSL____AppInterface__i_Compile.__default.MarshallCAppMessage((c).dtor_reply);
        _219_app__val = _out105;
        ulong _220_seqno;
        _220_seqno = 0UL;
        if (LiveByzRSL____PacketParsing__i_Compile.__default.MsgReplyInRange(c)) {
          _220_seqno = (ulong)((c).dtor_seqno__reply);
        }
        val = Common____GenericMarshalling__i_Compile.V.create_VTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements(Common____GenericMarshalling__i_Compile.V.create_VUint64(_220_seqno), _219_app__val));
      } else {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Marshall reply overflow\n")));
      }
      return val;
    }
    public static bool ReplyCacheInRange(Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> c) {
      return (true) && (Dafny.Helpers.Id<Func<Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>, bool>>((_221_c) => Dafny.Helpers.Quantifier<Native____Io__s_Compile._IEndPoint>((_221_c).Keys.Elements, true, (((_forall_var_3) => {
        Native____Io__s_Compile._IEndPoint _222_i = (Native____Io__s_Compile._IEndPoint)_forall_var_3;
        return !((_221_c).Contains((_222_i))) || (LiveByzRSL____PacketParsing__i_Compile.__default.ReplyInRange(Dafny.Map<Native____Io__s_Compile._IEndPoint, LiveByzRSL____CTypes__i_Compile._ICReply>.Select(_221_c,_222_i)));
      }))))(c));
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallReplyCache(Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      if (LiveByzRSL____PacketParsing__i_Compile.__default.ReplyCacheInRange(c)) {
        if ((new BigInteger((c).Count)).Sign == 0) {
          val = Common____GenericMarshalling__i_Compile.V.create_VArray(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements());
        } else {
          bool _223_b;
          _223_b = (new BigInteger((c).Count)) < (LiveByzRSL____CTypes__i_Compile.__default.max__reply__cache__size());
          if (!(_223_b)) {
            Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Reply cache exceeds size limit.\n")));
            return val;
          }
          Native____Io__s_Compile._IEndPoint _224_ep;
          foreach (Native____Io__s_Compile._IEndPoint _assign_such_that_3 in (c).Keys.Elements) {
            _224_ep = (Native____Io__s_Compile._IEndPoint)_assign_such_that_3;
            if ((c).Contains((_224_ep))) {
              goto after__ASSIGN_SUCH_THAT_3;
            }
          }
          throw new System.Exception("assign-such-that search produced no value (line 1438)");
        after__ASSIGN_SUCH_THAT_3: ;
          Common____GenericMarshalling__i_Compile._IV _225_marshalled__ep;
          Common____GenericMarshalling__i_Compile._IV _out106;
          _out106 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallEndPoint(_224_ep);
          _225_marshalled__ep = _out106;
          Common____GenericMarshalling__i_Compile._IV _226_marshalled__reply;
          Common____GenericMarshalling__i_Compile._IV _out107;
          _out107 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallReply(Dafny.Map<Native____Io__s_Compile._IEndPoint, LiveByzRSL____CTypes__i_Compile._ICReply>.Select(c,_224_ep));
          _226_marshalled__reply = _out107;
          Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> _227_remainder;
          _227_remainder = Collections____Maps__i_Compile.__default.RemoveElt<Native____Io__s_Compile._IEndPoint, LiveByzRSL____CTypes__i_Compile._ICReply>(c, _224_ep);
          Common____GenericMarshalling__i_Compile._IV _228_marshalled__remainder;
          Common____GenericMarshalling__i_Compile._IV _out108;
          _out108 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallReplyCache(_227_remainder);
          _228_marshalled__remainder = _out108;
          val = Common____GenericMarshalling__i_Compile.V.create_VArray(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.Concat(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements(Common____GenericMarshalling__i_Compile.V.create_VTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements(_225_marshalled__ep, _226_marshalled__reply))), (_228_marshalled__remainder).dtor_a));
        }
      } else {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Marshall replycache overflow\n")));
      }
      return val;
    }
    public static bool MsgStartPhase2InRange(LiveByzRSL____CMessage__i_Compile._ICMessage c) {
      return (LiveByzRSL____PacketParsing__i_Compile.__default.BallotInRange((c).dtor_bal__2)) && (LiveByzRSL____PacketParsing__i_Compile.__default.Uint64InRange((c).dtor_logTruncationPoint__2));
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallMessage__StartingPhase2(LiveByzRSL____CMessage__i_Compile._ICMessage c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      if (LiveByzRSL____PacketParsing__i_Compile.__default.MsgStartPhase2InRange(c)) {
        Common____GenericMarshalling__i_Compile._IV _229_bal;
        Common____GenericMarshalling__i_Compile._IV _out109;
        _out109 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallBallot((c).dtor_bal__2);
        _229_bal = _out109;
        Common____GenericMarshalling__i_Compile._IV _230_op;
        Common____GenericMarshalling__i_Compile._IV _out110;
        _out110 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallOperationNumber((c).dtor_logTruncationPoint__2);
        _230_op = _out110;
        val = Common____GenericMarshalling__i_Compile.V.create_VTuple(Dafny.Sequence<Common____GenericMarshalling__i_Compile._IV>.FromElements(_229_bal, _230_op));
      } else {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Marshall startphase2 overflow\n")));
      }
      return val;
    }
    public static bool MsgInRange(LiveByzRSL____CMessage__i_Compile._ICMessage c) {
      if ((c).is_CMessage__Request) {
        return LiveByzRSL____PacketParsing__i_Compile.__default.MsgRequestInRange(c);
      } else if ((c).is_CMessage__1a) {
        return LiveByzRSL____PacketParsing__i_Compile.__default.Msg1aInRange(c);
      } else if ((c).is_CMessage__1b) {
        return LiveByzRSL____PacketParsing__i_Compile.__default.Msg1bInRange(c);
      } else if ((c).is_CMessage__1c) {
        return LiveByzRSL____PacketParsing__i_Compile.__default.Msg1cInRange(c);
      } else if ((c).is_CMessage__2av) {
        return LiveByzRSL____PacketParsing__i_Compile.__default.Msg2avInRange(c);
      } else if ((c).is_CMessage__2b) {
        return LiveByzRSL____PacketParsing__i_Compile.__default.Msg2bInRange(c);
      } else if ((c).is_CMessage__Heartbeat) {
        return LiveByzRSL____PacketParsing__i_Compile.__default.MsgHeartBeatInRange(c);
      } else if ((c).is_CMessage__Reply) {
        return LiveByzRSL____PacketParsing__i_Compile.__default.MsgReplyInRange(c);
      } else if ((c).is_CMessage__StartingPhase2) {
        return LiveByzRSL____PacketParsing__i_Compile.__default.MsgStartPhase2InRange(c);
      } else {
        return true;
      }
    }
    public static Common____GenericMarshalling__i_Compile._IV MarshallMessage(LiveByzRSL____CMessage__i_Compile._ICMessage c)
    {
      Common____GenericMarshalling__i_Compile._IV val = Common____GenericMarshalling__i_Compile.V.Default();
      if (LiveByzRSL____PacketParsing__i_Compile.__default.MsgInRange(c)) {
        if ((c).is_CMessage__Request) {
          Common____GenericMarshalling__i_Compile._IV _231_msg;
          Common____GenericMarshalling__i_Compile._IV _out111;
          _out111 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallMessage__Request(c);
          _231_msg = _out111;
          val = Common____GenericMarshalling__i_Compile.V.create_VCase(0UL, _231_msg);
        } else if ((c).is_CMessage__1a) {
          Common____GenericMarshalling__i_Compile._IV _232_msg;
          Common____GenericMarshalling__i_Compile._IV _out112;
          _out112 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallMessage__1a(c);
          _232_msg = _out112;
          val = Common____GenericMarshalling__i_Compile.V.create_VCase(1UL, _232_msg);
        } else if ((c).is_CMessage__1b) {
          Common____GenericMarshalling__i_Compile._IV _233_msg;
          Common____GenericMarshalling__i_Compile._IV _out113;
          _out113 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallMessage__1b(c);
          _233_msg = _out113;
          val = Common____GenericMarshalling__i_Compile.V.create_VCase(2UL, _233_msg);
        } else if ((c).is_CMessage__1c) {
          Common____GenericMarshalling__i_Compile._IV _234_msg;
          Common____GenericMarshalling__i_Compile._IV _out114;
          _out114 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallMessage__1c(c);
          _234_msg = _out114;
          val = Common____GenericMarshalling__i_Compile.V.create_VCase(3UL, _234_msg);
        } else if ((c).is_CMessage__2av) {
          Common____GenericMarshalling__i_Compile._IV _235_msg;
          Common____GenericMarshalling__i_Compile._IV _out115;
          _out115 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallMessage__2av(c);
          _235_msg = _out115;
          val = Common____GenericMarshalling__i_Compile.V.create_VCase(4UL, _235_msg);
        } else if ((c).is_CMessage__2b) {
          Common____GenericMarshalling__i_Compile._IV _236_msg;
          Common____GenericMarshalling__i_Compile._IV _out116;
          _out116 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallMessage__2b(c);
          _236_msg = _out116;
          val = Common____GenericMarshalling__i_Compile.V.create_VCase(5UL, _236_msg);
        } else if ((c).is_CMessage__Heartbeat) {
          Common____GenericMarshalling__i_Compile._IV _237_msg;
          Common____GenericMarshalling__i_Compile._IV _out117;
          _out117 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallMessage__Heartbeat(c);
          _237_msg = _out117;
          val = Common____GenericMarshalling__i_Compile.V.create_VCase(6UL, _237_msg);
        } else if ((c).is_CMessage__Reply) {
          Common____GenericMarshalling__i_Compile._IV _238_msg;
          Common____GenericMarshalling__i_Compile._IV _out118;
          _out118 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallMessage__Reply(c);
          _238_msg = _out118;
          val = Common____GenericMarshalling__i_Compile.V.create_VCase(7UL, _238_msg);
        } else if ((c).is_CMessage__StartingPhase2) {
          Common____GenericMarshalling__i_Compile._IV _239_msg;
          Common____GenericMarshalling__i_Compile._IV _out119;
          _out119 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallMessage__StartingPhase2(c);
          _239_msg = _out119;
          val = Common____GenericMarshalling__i_Compile.V.create_VCase(8UL, _239_msg);
        }
      }
      return val;
    }
    public static byte[] PaxosMarshall(LiveByzRSL____CMessage__i_Compile._ICMessage msg)
    {
      byte[] data = new byte[0];
      Common____GenericMarshalling__i_Compile._IV _240_val;
      Common____GenericMarshalling__i_Compile._IV _out120;
      _out120 = LiveByzRSL____PacketParsing__i_Compile.__default.MarshallMessage(msg);
      _240_val = _out120;
      byte[] _out121;
      _out121 = Common____GenericMarshalling__i_Compile.__default.Marshall(_240_val, LiveByzRSL____PacketParsing__i_Compile.__default.CMessage__grammar());
      data = _out121;
      return data;
    }
  }
} // end of namespace LiveByzRSL____PacketParsing__i_Compile
namespace Impl____LiveByzRSL____Broadcast__i_Compile {

  public partial class __default {
    public static LiveByzRSL____CMessage__i_Compile._ICBroadcast BuildBroadcastToEveryone(Dafny.ISequence<Native____Io__s_Compile._IEndPoint> config, BigInteger my__index, LiveByzRSL____CMessage__i_Compile._ICMessage msg)
    {
      if ((my__index) < (new BigInteger(((config)).Count))) {
        return LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcast(((config)).Select(my__index), (config), msg);
      } else {
        return LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop();
      }
    }
  }
} // end of namespace Impl____LiveByzRSL____Broadcast__i_Compile
namespace LiveByzRSL____AcceptorModel__i_Compile {

  public interface _ICAcceptorTuple {
    bool is_CAcceptorTuple { get; }
    Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> dtor_received__2av__packets { get; }
  }
  public class CAcceptorTuple : _ICAcceptorTuple {
    public readonly Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _received__2av__packets;
    public CAcceptorTuple(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> received__2av__packets) {
      this._received__2av__packets = received__2av__packets;
    }
    public static Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> DowncastClone(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _this) {
      return _this;
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____AcceptorModel__i_Compile.CAcceptorTuple;
      return oth != null && object.Equals(this._received__2av__packets, oth._received__2av__packets);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._received__2av__packets));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____AcceptorModel__i_Compile.CAcceptorTuple.CAcceptorTuple";
      s += "(";
      s += Dafny.Helpers.ToString(this._received__2av__packets);
      s += ")";
      return s;
    }
    private static readonly Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> theDefault = Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.Empty;
    public static Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICAcceptorTuple create(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> received__2av__packets) {
      return new CAcceptorTuple(received__2av__packets);
    }
    public static _ICAcceptorTuple create_CAcceptorTuple(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> received__2av__packets) {
      return create(received__2av__packets);
    }
    public bool is_CAcceptorTuple { get { return true; } }
    public Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> dtor_received__2av__packets {
      get {
        return this._received__2av__packets;
      }
    }
  }

  public interface _ICValToBeSent2b {
    bool is_CValToBeSent2bKnown { get; }
    bool is_CValToBeSent2bUnknown { get; }
    Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_v { get; }
    LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal { get; }
    _ICValToBeSent2b DowncastClone();
  }
  public abstract class CValToBeSent2b : _ICValToBeSent2b {
    public CValToBeSent2b() { }
    private static readonly LiveByzRSL____AcceptorModel__i_Compile._ICValToBeSent2b theDefault = create_CValToBeSent2bKnown(Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.Empty, LiveByzRSL____CTypes__i_Compile.CBallot.Default());
    public static LiveByzRSL____AcceptorModel__i_Compile._ICValToBeSent2b Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____AcceptorModel__i_Compile._ICValToBeSent2b> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____AcceptorModel__i_Compile._ICValToBeSent2b>(LiveByzRSL____AcceptorModel__i_Compile.CValToBeSent2b.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____AcceptorModel__i_Compile._ICValToBeSent2b> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICValToBeSent2b create_CValToBeSent2bKnown(Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> v, LiveByzRSL____CTypes__i_Compile._ICBallot bal) {
      return new CValToBeSent2b_CValToBeSent2bKnown(v, bal);
    }
    public static _ICValToBeSent2b create_CValToBeSent2bUnknown() {
      return new CValToBeSent2b_CValToBeSent2bUnknown();
    }
    public bool is_CValToBeSent2bKnown { get { return this is CValToBeSent2b_CValToBeSent2bKnown; } }
    public bool is_CValToBeSent2bUnknown { get { return this is CValToBeSent2b_CValToBeSent2bUnknown; } }
    public Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_v {
      get {
        var d = this;
        return ((CValToBeSent2b_CValToBeSent2bKnown)d)._v;
      }
    }
    public LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal {
      get {
        var d = this;
        return ((CValToBeSent2b_CValToBeSent2bKnown)d)._bal;
      }
    }
    public abstract _ICValToBeSent2b DowncastClone();
  }
  public class CValToBeSent2b_CValToBeSent2bKnown : CValToBeSent2b {
    public readonly Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _v;
    public readonly LiveByzRSL____CTypes__i_Compile._ICBallot _bal;
    public CValToBeSent2b_CValToBeSent2bKnown(Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> v, LiveByzRSL____CTypes__i_Compile._ICBallot bal) {
      this._v = v;
      this._bal = bal;
    }
    public override _ICValToBeSent2b DowncastClone() {
      if (this is _ICValToBeSent2b dt) { return dt; }
      return new CValToBeSent2b_CValToBeSent2bKnown(_v, _bal);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____AcceptorModel__i_Compile.CValToBeSent2b_CValToBeSent2bKnown;
      return oth != null && object.Equals(this._v, oth._v) && object.Equals(this._bal, oth._bal);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._v));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____AcceptorModel__i_Compile.CValToBeSent2b.CValToBeSent2bKnown";
      s += "(";
      s += Dafny.Helpers.ToString(this._v);
      s += ", ";
      s += Dafny.Helpers.ToString(this._bal);
      s += ")";
      return s;
    }
  }
  public class CValToBeSent2b_CValToBeSent2bUnknown : CValToBeSent2b {
    public CValToBeSent2b_CValToBeSent2bUnknown() {
    }
    public override _ICValToBeSent2b DowncastClone() {
      if (this is _ICValToBeSent2b dt) { return dt; }
      return new CValToBeSent2b_CValToBeSent2bUnknown();
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____AcceptorModel__i_Compile.CValToBeSent2b_CValToBeSent2bUnknown;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____AcceptorModel__i_Compile.CValToBeSent2b.CValToBeSent2bUnknown";
      return s;
    }
  }

  public interface _ICAcceptor {
    bool is_CAcceptor { get; }
    LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants dtor_constants { get; }
    LiveByzRSL____CTypes__i_Compile._ICBallot dtor_max__bal { get; }
    Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> dtor_votes { get; }
    Dafny.ISequence<BigInteger> dtor_last__checkpointed__operation { get; }
    BigInteger dtor_log__truncation__point { get; }
    Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> dtor_received__1b__packets { get; }
    Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> dtor_received__2avs { get; }
    BigInteger dtor_opn__to__be__send__2b { get; }
    LiveByzRSL____AcceptorModel__i_Compile._ICValToBeSent2b dtor_val__to__be__sent__2b { get; }
    _ICAcceptor DowncastClone();
  }
  public class CAcceptor : _ICAcceptor {
    public readonly LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants _constants;
    public readonly LiveByzRSL____CTypes__i_Compile._ICBallot _max__bal;
    public readonly Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> _votes;
    public readonly Dafny.ISequence<BigInteger> _last__checkpointed__operation;
    public readonly BigInteger _log__truncation__point;
    public readonly Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _received__1b__packets;
    public readonly Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> _received__2avs;
    public readonly BigInteger _opn__to__be__send__2b;
    public readonly LiveByzRSL____AcceptorModel__i_Compile._ICValToBeSent2b _val__to__be__sent__2b;
    public CAcceptor(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, LiveByzRSL____CTypes__i_Compile._ICBallot max__bal, Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> votes, Dafny.ISequence<BigInteger> last__checkpointed__operation, BigInteger log__truncation__point, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> received__1b__packets, Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> received__2avs, BigInteger opn__to__be__send__2b, LiveByzRSL____AcceptorModel__i_Compile._ICValToBeSent2b val__to__be__sent__2b) {
      this._constants = constants;
      this._max__bal = max__bal;
      this._votes = votes;
      this._last__checkpointed__operation = last__checkpointed__operation;
      this._log__truncation__point = log__truncation__point;
      this._received__1b__packets = received__1b__packets;
      this._received__2avs = received__2avs;
      this._opn__to__be__send__2b = opn__to__be__send__2b;
      this._val__to__be__sent__2b = val__to__be__sent__2b;
    }
    public _ICAcceptor DowncastClone() {
      if (this is _ICAcceptor dt) { return dt; }
      return new CAcceptor(_constants, _max__bal, _votes, _last__checkpointed__operation, _log__truncation__point, _received__1b__packets, _received__2avs, _opn__to__be__send__2b, _val__to__be__sent__2b);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____AcceptorModel__i_Compile.CAcceptor;
      return oth != null && object.Equals(this._constants, oth._constants) && object.Equals(this._max__bal, oth._max__bal) && object.Equals(this._votes, oth._votes) && object.Equals(this._last__checkpointed__operation, oth._last__checkpointed__operation) && this._log__truncation__point == oth._log__truncation__point && object.Equals(this._received__1b__packets, oth._received__1b__packets) && object.Equals(this._received__2avs, oth._received__2avs) && this._opn__to__be__send__2b == oth._opn__to__be__send__2b && object.Equals(this._val__to__be__sent__2b, oth._val__to__be__sent__2b);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._constants));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__bal));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._votes));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._last__checkpointed__operation));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._log__truncation__point));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._received__1b__packets));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._received__2avs));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._opn__to__be__send__2b));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._val__to__be__sent__2b));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.CAcceptor";
      s += "(";
      s += Dafny.Helpers.ToString(this._constants);
      s += ", ";
      s += Dafny.Helpers.ToString(this._max__bal);
      s += ", ";
      s += Dafny.Helpers.ToString(this._votes);
      s += ", ";
      s += Dafny.Helpers.ToString(this._last__checkpointed__operation);
      s += ", ";
      s += Dafny.Helpers.ToString(this._log__truncation__point);
      s += ", ";
      s += Dafny.Helpers.ToString(this._received__1b__packets);
      s += ", ";
      s += Dafny.Helpers.ToString(this._received__2avs);
      s += ", ";
      s += Dafny.Helpers.ToString(this._opn__to__be__send__2b);
      s += ", ";
      s += Dafny.Helpers.ToString(this._val__to__be__sent__2b);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor theDefault = create(LiveByzRSL____ConstantsState__i_Compile.CReplicaConstants.Default(), LiveByzRSL____CTypes__i_Compile.CBallot.Default(), Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Empty, Dafny.Sequence<BigInteger>.Empty, BigInteger.Zero, Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.Empty, Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Empty, BigInteger.Zero, LiveByzRSL____AcceptorModel__i_Compile.CValToBeSent2b.Default());
    public static LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICAcceptor create(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, LiveByzRSL____CTypes__i_Compile._ICBallot max__bal, Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> votes, Dafny.ISequence<BigInteger> last__checkpointed__operation, BigInteger log__truncation__point, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> received__1b__packets, Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> received__2avs, BigInteger opn__to__be__send__2b, LiveByzRSL____AcceptorModel__i_Compile._ICValToBeSent2b val__to__be__sent__2b) {
      return new CAcceptor(constants, max__bal, votes, last__checkpointed__operation, log__truncation__point, received__1b__packets, received__2avs, opn__to__be__send__2b, val__to__be__sent__2b);
    }
    public static _ICAcceptor create_CAcceptor(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, LiveByzRSL____CTypes__i_Compile._ICBallot max__bal, Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> votes, Dafny.ISequence<BigInteger> last__checkpointed__operation, BigInteger log__truncation__point, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> received__1b__packets, Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> received__2avs, BigInteger opn__to__be__send__2b, LiveByzRSL____AcceptorModel__i_Compile._ICValToBeSent2b val__to__be__sent__2b) {
      return create(constants, max__bal, votes, last__checkpointed__operation, log__truncation__point, received__1b__packets, received__2avs, opn__to__be__send__2b, val__to__be__sent__2b);
    }
    public bool is_CAcceptor { get { return true; } }
    public LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants dtor_constants {
      get {
        return this._constants;
      }
    }
    public LiveByzRSL____CTypes__i_Compile._ICBallot dtor_max__bal {
      get {
        return this._max__bal;
      }
    }
    public Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> dtor_votes {
      get {
        return this._votes;
      }
    }
    public Dafny.ISequence<BigInteger> dtor_last__checkpointed__operation {
      get {
        return this._last__checkpointed__operation;
      }
    }
    public BigInteger dtor_log__truncation__point {
      get {
        return this._log__truncation__point;
      }
    }
    public Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> dtor_received__1b__packets {
      get {
        return this._received__1b__packets;
      }
    }
    public Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> dtor_received__2avs {
      get {
        return this._received__2avs;
      }
    }
    public BigInteger dtor_opn__to__be__send__2b {
      get {
        return this._opn__to__be__send__2b;
      }
    }
    public LiveByzRSL____AcceptorModel__i_Compile._ICValToBeSent2b dtor_val__to__be__sent__2b {
      get {
        return this._val__to__be__sent__2b;
      }
    }
  }

  public partial class __default {
    public static BigInteger CCountMatchedValInReceived2avs(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> s, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> v)
    {
      BigInteger _241___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return (BigInteger.Zero) + (_241___accumulator);
      } else {
        _241___accumulator = (((((((s).Select((new BigInteger((s).Count)) - (BigInteger.One))).dtor_msg).dtor_val__2av).Equals((v))) ? (BigInteger.One) : (BigInteger.Zero))) + (_241___accumulator);
        Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _in2 = (s).Take((new BigInteger((s).Count)) - (BigInteger.One));
        Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _in3 = v;
        s = _in2;
        v = _in3;
        goto TAIL_CALL_START;
      }
    }
    public static BigInteger CCountMatchedInRequestBatches(Dafny.ISequence<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>> s, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> v)
    {
      BigInteger _242___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return (BigInteger.Zero) + (_242___accumulator);
      } else {
        _242___accumulator = (((((s).Select((new BigInteger((s).Count)) - (BigInteger.One))).Equals((v))) ? (BigInteger.One) : (BigInteger.Zero))) + (_242___accumulator);
        Dafny.ISequence<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>> _in4 = (s).Take((new BigInteger((s).Count)) - (BigInteger.One));
        Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _in5 = v;
        s = _in4;
        v = _in5;
        goto TAIL_CALL_START;
      }
    }
    public static bool CHasReceivedSame2avFromByzQuorum(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> r2avs, BigInteger n)
    {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, BigInteger, bool>>((_243_r2avs, _244_n) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>(((_243_r2avs)).UniqueElements, false, (((_exists_var_0) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _245_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_exists_var_0;
        return (((_243_r2avs)).Contains((_245_p))) && ((LiveByzRSL____AcceptorModel__i_Compile.__default.CCountMatchedValInReceived2avs((_243_r2avs), ((_245_p).dtor_msg).dtor_val__2av)) >= (_244_n));
      }))))(r2avs, n);
    }
    public static bool CIsByzQuorumSendSame2av(Dafny.ISequence<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>> vals, BigInteger n)
    {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>, BigInteger, bool>>((_246_vals, _247_n) => Dafny.Helpers.Quantifier<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>((_246_vals).UniqueElements, false, (((_exists_var_1) => {
        Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _248_v = (Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>)_exists_var_1;
        return ((_246_vals).Contains((_248_v))) && ((LiveByzRSL____AcceptorModel__i_Compile.__default.CCountMatchedInRequestBatches(_246_vals, _248_v)) >= (_247_n));
      }))))(vals, n);
    }
    public static bool CHasReceived2avOfOpn(Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> received__2avs, BigInteger opn)
    {
      return (received__2avs).Contains((opn));
    }
    public static bool CAcceptorTupleIsUniqueSeq(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> tup) {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, bool>>((_249_tup) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger(((_249_tup)).Count)), true, (((_forall_var_4) => {
        BigInteger _250_i = (BigInteger)_forall_var_4;
        return Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger(((_249_tup)).Count)), true, (((_forall_var_5) => {
          BigInteger _251_j = (BigInteger)_forall_var_5;
          return !(((((_250_i).Sign != -1) && ((_250_i) < (new BigInteger(((_249_tup)).Count)))) && (((_251_j).Sign != -1) && ((_251_j) < (new BigInteger(((_249_tup)).Count))))) && ((_250_i) != (_251_j))) || ((!object.Equals(((_249_tup)).Select(_250_i), ((_249_tup)).Select(_251_j))) && (!object.Equals((((_249_tup)).Select(_250_i)).dtor_src, (((_249_tup)).Select(_251_j)).dtor_src)));
        })));
      }))))(tup);
    }
    public static bool CReceived2avSetCorrect(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> r2avs, LiveByzRSL____CTypes__i_Compile._ICBallot bal, BigInteger opn, Dafny.ISequence<Native____Io__s_Compile._IEndPoint> c)
    {
      return ((new BigInteger(((r2avs)).Count)) <= (new BigInteger(((c)).Count))) && (Dafny.Helpers.Id<Func<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, BigInteger, LiveByzRSL____CTypes__i_Compile._ICBallot, Dafny.ISequence<Native____Io__s_Compile._IEndPoint>, bool>>((_252_r2avs, _253_opn, _254_bal, _255_c) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>(((_252_r2avs)).UniqueElements, true, (((_forall_var_6) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _256_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_forall_var_6;
        return !(((_252_r2avs)).Contains((_256_p))) || ((((((_256_p).dtor_msg).is_CMessage__2av) && ((((_256_p).dtor_msg).dtor_opn__2av) == (_253_opn))) && (object.Equals(((_256_p).dtor_msg).dtor_bal__2av, _254_bal))) && (((_255_c)).Contains(((_256_p).dtor_src))));
      }))))(r2avs, opn, bal, c));
    }
    public static bool CAcceptorStateCorrect(Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> r2avs, LiveByzRSL____CTypes__i_Compile._ICBallot bal, Dafny.ISequence<Native____Io__s_Compile._IEndPoint> c)
    {
      return Dafny.Helpers.Id<Func<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____CTypes__i_Compile._ICBallot, Dafny.ISequence<Native____Io__s_Compile._IEndPoint>, bool>>((_257_r2avs, _258_bal, _259_c) => Dafny.Helpers.Quantifier<BigInteger>((_257_r2avs).Keys.Elements, true, (((_forall_var_7) => {
        BigInteger _260_opn = (BigInteger)_forall_var_7;
        return !((_257_r2avs).Contains((_260_opn))) || ((LiveByzRSL____AcceptorModel__i_Compile.__default.CReceived2avSetCorrect(Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select(_257_r2avs,_260_opn), _258_bal, _260_opn, _259_c)) && (LiveByzRSL____AcceptorModel__i_Compile.__default.CAcceptorTupleIsUniqueSeq(Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select(_257_r2avs,_260_opn))));
      }))))(r2avs, bal, c);
    }
    public static bool CIsLogTruncationPointValid(BigInteger log__truncation__point, Dafny.ISequence<BigInteger> last__checkpointed__operation, Dafny.ISequence<Native____Io__s_Compile._IEndPoint> config)
    {
      return Collections____CountMatches__i_Compile.__default.IsNthHighestValueInSequence(log__truncation__point, last__checkpointed__operation, LiveByzRSL____CConfiguration__i_Compile.__default.CByzQuorumSize(config));
    }
    public static Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> CRemoveVotesBeforeLogTruncationPoint(Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> votes, BigInteger log__truncation__point)
    {
      Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> _261_t1 = Dafny.Helpers.Id<Func<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, BigInteger, Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>>>((_262_votes, _263_log__truncation__point) => ((System.Func<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>>)(() => {
        var _coll5 = new System.Collections.Generic.List<Dafny.Pair<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>>();
        foreach (BigInteger _compr_5 in (_262_votes).Keys.Elements) {
          BigInteger _264_opn = (BigInteger)_compr_5;
          if (((_262_votes).Contains((_264_opn))) && ((_264_opn) >= (_263_log__truncation__point))) {
            _coll5.Add(new Dafny.Pair<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>(_264_opn, Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Select(_262_votes,_264_opn)));
          }
        }
        return Dafny.Map<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>.FromCollection(_coll5);
      }))())(votes, log__truncation__point);
      return _261_t1;
    }
    public static Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> CAddVoteAndRemoveOldOnes(Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> votes, BigInteger new__opn, LiveByzRSL____CTypes__i_Compile._ICVote new__vote, BigInteger log__truncation__point)
    {
      Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> _265_t1 = Dafny.Helpers.Id<Func<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, BigInteger, BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote, Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>>>((_266_votes, _267_new__opn, _268_log__truncation__point, _269_new__vote) => ((System.Func<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>>)(() => {
        var _coll6 = new System.Collections.Generic.List<Dafny.Pair<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>>();
        foreach (BigInteger _compr_6 in (Dafny.Set<BigInteger>.Union((_266_votes).Keys, Dafny.Set<BigInteger>.FromElements(_267_new__opn))).Elements) {
          BigInteger _270_opn = (BigInteger)_compr_6;
          if (((Dafny.Set<BigInteger>.Union((_266_votes).Keys, Dafny.Set<BigInteger>.FromElements(_267_new__opn))).Contains((_270_opn))) && ((_270_opn) >= (_268_log__truncation__point))) {
            _coll6.Add(new Dafny.Pair<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>(_270_opn, (((_270_opn) == (_267_new__opn)) ? (_269_new__vote) : (Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Select(_266_votes,_270_opn)))));
          }
        }
        return Dafny.Map<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>.FromCollection(_coll6);
      }))())(votes, new__opn, log__truncation__point, new__vote);
      return _265_t1;
    }
    public static LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor CAcceptorInit(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants c) {
      LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants _271_t1 = c;
      LiveByzRSL____CTypes__i_Compile._ICBallot _272_t2 = LiveByzRSL____CTypes__i_Compile.CBallot.create(BigInteger.Zero, BigInteger.Zero);
      Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote> _273_t3 = Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.FromElements();
      Dafny.ISequence<BigInteger> _274_t4 = ((System.Func<Dafny.ISequence<BigInteger>>) (() => {
        BigInteger dim0 = new BigInteger(((((c).dtor_all).dtor_config)).Count);
        var arr0 = new BigInteger[Dafny.Helpers.ToIntChecked(dim0, "array size exceeds memory limit")];
        for (int i0 = 0; i0 < dim0; i0++) {
          var _275_idx = (BigInteger) i0;
          arr0[(int)(_275_idx)] = BigInteger.Zero;
        }
        return Dafny.Sequence<BigInteger>.FromArray(arr0);
      }))();
      BigInteger _276_t5 = BigInteger.Zero;
      Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> _277_t6 = Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.FromElements();
      Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _278_t7 = Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements();
      BigInteger _279_t8 = BigInteger.Zero;
      LiveByzRSL____AcceptorModel__i_Compile._ICValToBeSent2b _280_t9 = LiveByzRSL____AcceptorModel__i_Compile.CValToBeSent2b.create_CValToBeSent2bUnknown();
      return LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.create(_271_t1, _272_t2, _273_t3, _274_t4, _276_t5, _278_t7, _277_t6, _279_t8, _280_t9);
    }
    public static LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor CAcceptorMaybeEnterNewView(LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor s) {
      LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor _281_t1 = Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(s, _pat_let0_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let0_0, _282_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements(), _pat_let1_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let1_0, _283_dt__update_hreceived__1b__packets_h0 => LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.create((_282_dt__update__tmp_h0).dtor_constants, (_282_dt__update__tmp_h0).dtor_max__bal, (_282_dt__update__tmp_h0).dtor_votes, (_282_dt__update__tmp_h0).dtor_last__checkpointed__operation, (_282_dt__update__tmp_h0).dtor_log__truncation__point, _283_dt__update_hreceived__1b__packets_h0, (_282_dt__update__tmp_h0).dtor_received__2avs, (_282_dt__update__tmp_h0).dtor_opn__to__be__send__2b, (_282_dt__update__tmp_h0).dtor_val__to__be__sent__2b)))));
      return _281_t1;
    }
    public static _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CAcceptorProcess1a(LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor s, LiveByzRSL____CMessage__i_Compile._ICPacket inp)
    {
      var _pat_let_tv0 = s;
      var _pat_let_tv1 = s;
      var _pat_let_tv2 = s;
      var _pat_let_tv3 = s;
      var _pat_let_tv4 = s;
      var _pat_let_tv5 = s;
      var _pat_let_tv6 = s;
      var _pat_let_tv7 = inp;
      var _pat_let_tv8 = s;
      var _pat_let_tv9 = s;
      _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor> _284_t1 = Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._ICMessage, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>>((inp).dtor_msg, _pat_let2_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._ICMessage, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>>(_pat_let2_0, _285_m => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>>((((((((((_pat_let_tv6).dtor_constants).dtor_all).dtor_config)).Contains(((_pat_let_tv7).dtor_src))) && (LiveByzRSL____CTypes__i_Compile.__default.CBalLt((_pat_let_tv8).dtor_max__bal, (_285_m).dtor_bal__1a))) && (LiveByzRSL____ConstantsState__i_Compile.__default.CReplicaConstantsValid((_pat_let_tv9).dtor_constants))) ? (Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(Impl____LiveByzRSL____Broadcast__i_Compile.__default.BuildBroadcastToEveryone((((_pat_let_tv0).dtor_constants).dtor_all).dtor_config, ((_pat_let_tv1).dtor_constants).dtor_my__index, LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__1b((_285_m).dtor_bal__1a, (_pat_let_tv2).dtor_log__truncation__point, (_pat_let_tv3).dtor_votes))), _pat_let4_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let4_0, _286_t1 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let_tv4, _pat_let6_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let6_0, _287_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>((_285_m).dtor_bal__1a, _pat_let7_0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let7_0, _288_dt__update_hmax__bal_h0 => LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.create((_287_dt__update__tmp_h0).dtor_constants, _288_dt__update_hmax__bal_h0, (_287_dt__update__tmp_h0).dtor_votes, (_287_dt__update__tmp_h0).dtor_last__checkpointed__operation, (_287_dt__update__tmp_h0).dtor_log__truncation__point, (_287_dt__update__tmp_h0).dtor_received__1b__packets, (_287_dt__update__tmp_h0).dtor_received__2avs, (_287_dt__update__tmp_h0).dtor_opn__to__be__send__2b, (_287_dt__update__tmp_h0).dtor_val__to__be__sent__2b))))), _pat_let5_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let5_0, _289_t2 => _System.Tuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_289_t2, _286_t1)))))) : (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let_tv5, _pat_let8_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let8_0, _290_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop()), _pat_let9_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let9_0, _291_t2 => _System.Tuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_290_t1, _291_t2))))))), _pat_let3_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>>(_pat_let3_0, _292_t1 => _System.Tuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>.create((_292_t1).dtor__1, (_292_t1).dtor__0)))));
      return _System.Tuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_284_t1).dtor__1, (_284_t1).dtor__0);
    }
    public static LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor CAcceptorProcess1b(LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor s, LiveByzRSL____CMessage__i_Compile._ICPacket p)
    {
      var _pat_let_tv10 = s;
      var _pat_let_tv11 = p;
      LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor _293_t1 = Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(s, _pat_let10_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let10_0, _294_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.Concat((_pat_let_tv10).dtor_received__1b__packets, Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements(_pat_let_tv11)), _pat_let11_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let11_0, _295_dt__update_hreceived__1b__packets_h0 => LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.create((_294_dt__update__tmp_h0).dtor_constants, (_294_dt__update__tmp_h0).dtor_max__bal, (_294_dt__update__tmp_h0).dtor_votes, (_294_dt__update__tmp_h0).dtor_last__checkpointed__operation, (_294_dt__update__tmp_h0).dtor_log__truncation__point, _295_dt__update_hreceived__1b__packets_h0, (_294_dt__update__tmp_h0).dtor_received__2avs, (_294_dt__update__tmp_h0).dtor_opn__to__be__send__2b, (_294_dt__update__tmp_h0).dtor_val__to__be__sent__2b)))));
      return _293_t1;
    }
    public static _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CAcceptorProcess1c(LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor s, LiveByzRSL____CMessage__i_Compile._ICPacket inp)
    {
      var _pat_let_tv12 = inp;
      var _pat_let_tv13 = s;
      var _pat_let_tv14 = s;
      var _pat_let_tv15 = inp;
      var _pat_let_tv16 = s;
      var _pat_let_tv17 = s;
      var _pat_let_tv18 = s;
      var _pat_let_tv19 = s;
      var _pat_let_tv20 = s;
      var _pat_let_tv21 = s;
      var _pat_let_tv22 = s;
      var _pat_let_tv23 = inp;
      var _pat_let_tv24 = s;
      _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor> _296_t1 = Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._ICMessage, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>>((inp).dtor_msg, _pat_let12_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._ICMessage, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>>(_pat_let12_0, _297_m => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>>(Dafny.Helpers.Let<BigInteger, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>((((((((_pat_let_tv15).dtor_msg).dtor_opn__1c) - (((((_pat_let_tv16).dtor_constants).dtor_all).dtor_params).dtor_max__log__length)) + (BigInteger.One)) > ((_pat_let_tv17).dtor_log__truncation__point)) ? (((((_pat_let_tv12).dtor_msg).dtor_opn__1c) - (((((_pat_let_tv13).dtor_constants).dtor_all).dtor_params).dtor_max__log__length)) + (BigInteger.One)) : ((_pat_let_tv14).dtor_log__truncation__point)), _pat_let14_0 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let14_0, _298_newLogTruncationPoint => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(Impl____LiveByzRSL____Broadcast__i_Compile.__default.BuildBroadcastToEveryone((((_pat_let_tv18).dtor_constants).dtor_all).dtor_config, ((_pat_let_tv19).dtor_constants).dtor_my__index, LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__2av((_297_m).dtor_bal__1c, (_297_m).dtor_opn__1c, (_297_m).dtor_val__1c))), _pat_let15_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let15_0, _299_t1 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(((((_pat_let_tv22).dtor_log__truncation__point) <= (((_pat_let_tv23).dtor_msg).dtor_opn__1c)) ? (Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>>(LiveByzRSL____AcceptorModel__i_Compile.__default.CAddVoteAndRemoveOldOnes((_pat_let_tv20).dtor_votes, (_297_m).dtor_opn__1c, LiveByzRSL____CTypes__i_Compile.CVote.create((_297_m).dtor_bal__1c, (_297_m).dtor_val__1c), _298_newLogTruncationPoint), _pat_let17_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>>(_pat_let17_0, _300_t1 => _300_t1))) : (Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>>((_pat_let_tv21).dtor_votes, _pat_let18_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>>(_pat_let18_0, _301_t1 => _301_t1)))), _pat_let16_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let16_0, _302_t2 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let_tv24, _pat_let20_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let20_0, _303_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_302_t2, _pat_let21_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let21_0, _304_dt__update_hvotes_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_298_newLogTruncationPoint, _pat_let22_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let22_0, _305_dt__update_hlog__truncation__point_h0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>((_297_m).dtor_bal__1c, _pat_let23_0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let23_0, _306_dt__update_hmax__bal_h0 => LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.create((_303_dt__update__tmp_h0).dtor_constants, _306_dt__update_hmax__bal_h0, _304_dt__update_hvotes_h0, (_303_dt__update__tmp_h0).dtor_last__checkpointed__operation, _305_dt__update_hlog__truncation__point_h0, (_303_dt__update__tmp_h0).dtor_received__1b__packets, (_303_dt__update__tmp_h0).dtor_received__2avs, (_303_dt__update__tmp_h0).dtor_opn__to__be__send__2b, (_303_dt__update__tmp_h0).dtor_val__to__be__sent__2b))))))))), _pat_let19_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let19_0, _307_t3 => _System.Tuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_307_t3, _299_t1))))))))), _pat_let13_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>>(_pat_let13_0, _308_t1 => _System.Tuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>.create((_308_t1).dtor__1, (_308_t1).dtor__0)))));
      return _System.Tuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_296_t1).dtor__1, (_296_t1).dtor__0);
    }
    public static LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor CAcceptorProcess2av(LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor s, LiveByzRSL____CMessage__i_Compile._ICPacket inp)
    {
      var _pat_let_tv25 = s;
      var _pat_let_tv26 = inp;
      var _pat_let_tv27 = s;
      var _pat_let_tv28 = inp;
      var _pat_let_tv29 = s;
      var _pat_let_tv30 = s;
      var _pat_let_tv31 = s;
      var _pat_let_tv32 = s;
      var _pat_let_tv33 = inp;
      var _pat_let_tv34 = s;
      var _pat_let_tv35 = s;
      var _pat_let_tv36 = s;
      var _pat_let_tv37 = inp;
      var _pat_let_tv38 = s;
      var _pat_let_tv39 = s;
      var _pat_let_tv40 = s;
      var _pat_let_tv41 = inp;
      var _pat_let_tv42 = s;
      LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor _309_t1 = Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._ICMessage, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>((inp).dtor_msg, _pat_let24_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._ICMessage, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let24_0, _310_m => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Helpers.Let<BigInteger, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>((_310_m).dtor_opn__2av, _pat_let26_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let26_0, _311_opn => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>((((!(((((_pat_let_tv40).dtor_constants).dtor_all).dtor_config)).Contains(((_pat_let_tv41).dtor_src))) || (LiveByzRSL____CTypes__i_Compile.__default.CBalLt((_310_m).dtor_bal__2av, (_pat_let_tv42).dtor_max__bal))) ? (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let_tv25, _pat_let28_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let28_0, _312_t1 => _312_t1))) : (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(((LiveByzRSL____CTypes__i_Compile.__default.CBalLt((_pat_let_tv39).dtor_max__bal, (_310_m).dtor_bal__2av)) ? (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements(_pat_let_tv26), _pat_let31_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let31_0, _313_tup_k => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let_tv27, _pat_let33_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let33_0, _314_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.FromElements(new Dafny.Pair<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>(_311_opn, _313_tup_k)), _pat_let34_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let34_0, _315_dt__update_hreceived__2avs_h0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>((_310_m).dtor_bal__2av, _pat_let35_0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let35_0, _316_dt__update_hmax__bal_h0 => LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.create((_314_dt__update__tmp_h0).dtor_constants, _316_dt__update_hmax__bal_h0, (_314_dt__update__tmp_h0).dtor_votes, (_314_dt__update__tmp_h0).dtor_last__checkpointed__operation, (_314_dt__update__tmp_h0).dtor_log__truncation__point, (_314_dt__update__tmp_h0).dtor_received__1b__packets, _315_dt__update_hreceived__2avs_h0, (_314_dt__update__tmp_h0).dtor_opn__to__be__send__2b, (_314_dt__update__tmp_h0).dtor_val__to__be__sent__2b))))))), _pat_let32_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let32_0, _317_t1 => _317_t1)))), _pat_let30_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let30_0, _318_t1 => _318_t1))) : (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(((!((_pat_let_tv38).dtor_received__2avs).Contains((_311_opn))) ? (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements(_pat_let_tv28), _pat_let38_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let38_0, _319_tup_k => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let_tv29, _pat_let40_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let40_0, _320_dt__update__tmp_h1 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Update((_pat_let_tv30).dtor_received__2avs, _311_opn, _319_tup_k), _pat_let41_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let41_0, _321_dt__update_hreceived__2avs_h1 => LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.create((_320_dt__update__tmp_h1).dtor_constants, (_320_dt__update__tmp_h1).dtor_max__bal, (_320_dt__update__tmp_h1).dtor_votes, (_320_dt__update__tmp_h1).dtor_last__checkpointed__operation, (_320_dt__update__tmp_h1).dtor_log__truncation__point, (_320_dt__update__tmp_h1).dtor_received__1b__packets, _321_dt__update_hreceived__2avs_h1, (_320_dt__update__tmp_h1).dtor_opn__to__be__send__2b, (_320_dt__update__tmp_h1).dtor_val__to__be__sent__2b))))), _pat_let39_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let39_0, _322_t1 => _322_t1)))), _pat_let37_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let37_0, _323_t1 => _323_t1))) : (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(((Dafny.Helpers.Id<Func<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, BigInteger, LiveByzRSL____CMessage__i_Compile._ICPacket, bool>>((_332_s, _333_opn, _334_inp) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>(((Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select((_332_s).dtor_received__2avs,_333_opn))).UniqueElements, false, (((_exists_var_2) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _335_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_exists_var_2;
        return (((Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select((_332_s).dtor_received__2avs,_333_opn))).Contains((_335_p))) && (object.Equals((_335_p).dtor_src, (_334_inp).dtor_src));
      }))))(_pat_let_tv36, _311_opn, _pat_let_tv37)) ? (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let_tv31, _pat_let43_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let43_0, _324_t1 => _324_t1))) : (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select((_pat_let_tv32).dtor_received__2avs,_311_opn), _pat_let45_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let45_0, _325_tup => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.Concat((_325_tup), Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements(_pat_let_tv33)), _pat_let47_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let47_0, _326_tup_k => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let_tv34, _pat_let49_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let49_0, _327_dt__update__tmp_h4 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Update((_pat_let_tv35).dtor_received__2avs, _311_opn, _326_tup_k), _pat_let50_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let50_0, _328_dt__update_hreceived__2avs_h2 => LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.create((_327_dt__update__tmp_h4).dtor_constants, (_327_dt__update__tmp_h4).dtor_max__bal, (_327_dt__update__tmp_h4).dtor_votes, (_327_dt__update__tmp_h4).dtor_last__checkpointed__operation, (_327_dt__update__tmp_h4).dtor_log__truncation__point, (_327_dt__update__tmp_h4).dtor_received__1b__packets, _328_dt__update_hreceived__2avs_h2, (_327_dt__update__tmp_h4).dtor_opn__to__be__send__2b, (_327_dt__update__tmp_h4).dtor_val__to__be__sent__2b))))), _pat_let48_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let48_0, _329_t1 => _329_t1)))), _pat_let46_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let46_0, _330_t1 => _330_t1)))), _pat_let44_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let44_0, _331_t1 => _331_t1)))), _pat_let42_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let42_0, _336_t1 => _336_t1)))), _pat_let36_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let36_0, _337_t1 => _337_t1)))), _pat_let29_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let29_0, _338_t1 => _338_t1)))), _pat_let27_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let27_0, _339_t1 => _339_t1)))), _pat_let25_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let25_0, _340_t1 => _340_t1))));
      return _309_t1;
    }
    public static LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor CAcceptorDecide2bVal(LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor s, LiveByzRSL____CTypes__i_Compile._ICBallot bal, BigInteger opn, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> v)
    {
      var _pat_let_tv43 = v;
      var _pat_let_tv44 = bal;
      LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor _341_t1 = Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(s, _pat_let51_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let51_0, _342_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICValToBeSent2b, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(LiveByzRSL____AcceptorModel__i_Compile.CValToBeSent2b.create_CValToBeSent2bKnown(_pat_let_tv43, _pat_let_tv44), _pat_let52_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICValToBeSent2b, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let52_0, _343_dt__update_hval__to__be__sent__2b_h0 => LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.create((_342_dt__update__tmp_h0).dtor_constants, (_342_dt__update__tmp_h0).dtor_max__bal, (_342_dt__update__tmp_h0).dtor_votes, (_342_dt__update__tmp_h0).dtor_last__checkpointed__operation, (_342_dt__update__tmp_h0).dtor_log__truncation__point, (_342_dt__update__tmp_h0).dtor_received__1b__packets, (_342_dt__update__tmp_h0).dtor_received__2avs, (_342_dt__update__tmp_h0).dtor_opn__to__be__send__2b, _343_dt__update_hval__to__be__sent__2b_h0)))));
      return _341_t1;
    }
    public static _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CAcceptorSent2b(LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor s) {
      var _pat_let_tv45 = s;
      var _pat_let_tv46 = s;
      var _pat_let_tv47 = s;
      var _pat_let_tv48 = s;
      var _pat_let_tv49 = s;
      var _pat_let_tv50 = s;
      var _pat_let_tv51 = s;
      var _pat_let_tv52 = s;
      var _pat_let_tv53 = s;
      var _pat_let_tv54 = s;
      var _pat_let_tv55 = s;
      var _pat_let_tv56 = s;
      var _pat_let_tv57 = s;
      var _pat_let_tv58 = s;
      _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor> _344_t1 = Dafny.Helpers.Let<BigInteger, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>>((s).dtor_opn__to__be__send__2b, _pat_let53_0 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>>(_pat_let53_0, _345_opn => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>>(Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(((_pat_let_tv45).dtor_val__to__be__sent__2b).dtor_v, _pat_let55_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let55_0, _346_v => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>>(((_pat_let_tv46).dtor_val__to__be__sent__2b).dtor_bal, _pat_let57_0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>>(_pat_let57_0, _347_bal => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>>(Dafny.Helpers.Let<BigInteger, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>((((((_345_opn) - (((((_pat_let_tv49).dtor_constants).dtor_all).dtor_params).dtor_max__log__length)) + (BigInteger.One)) > ((_pat_let_tv50).dtor_log__truncation__point)) ? (((_345_opn) - (((((_pat_let_tv47).dtor_constants).dtor_all).dtor_params).dtor_max__log__length)) + (BigInteger.One)) : ((_pat_let_tv48).dtor_log__truncation__point)), _pat_let59_0 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let59_0, _348_newLogTruncationPoint => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(Impl____LiveByzRSL____Broadcast__i_Compile.__default.BuildBroadcastToEveryone((((_pat_let_tv51).dtor_constants).dtor_all).dtor_config, ((_pat_let_tv52).dtor_constants).dtor_my__index, LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__2b(_347_bal, _345_opn, _346_v))), _pat_let60_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let60_0, _349_t1 => Dafny.Helpers.Let<_System._ITuple2<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, BigInteger>, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(((((_pat_let_tv56).dtor_log__truncation__point) <= (_345_opn)) ? (Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, _System._ITuple2<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, BigInteger>>(LiveByzRSL____AcceptorModel__i_Compile.__default.CAddVoteAndRemoveOldOnes((_pat_let_tv53).dtor_votes, _345_opn, LiveByzRSL____CTypes__i_Compile.CVote.create(_347_bal, _346_v), _348_newLogTruncationPoint), _pat_let62_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, _System._ITuple2<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, BigInteger>>(_pat_let62_0, _350_t1 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, BigInteger>>(_348_newLogTruncationPoint, _pat_let63_0 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, BigInteger>>(_pat_let63_0, _351_t2 => _System.Tuple2<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, BigInteger>.create(_350_t1, _351_t2)))))) : (Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, _System._ITuple2<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, BigInteger>>((_pat_let_tv54).dtor_votes, _pat_let64_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, _System._ITuple2<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, BigInteger>>(_pat_let64_0, _352_t1 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, BigInteger>>((_pat_let_tv55).dtor_log__truncation__point, _pat_let65_0 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, BigInteger>>(_pat_let65_0, _353_t2 => _System.Tuple2<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, BigInteger>.create(_352_t1, _353_t2))))))), _pat_let61_0 => Dafny.Helpers.Let<_System._ITuple2<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, BigInteger>, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let61_0, _354_t2 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let_tv57, _pat_let67_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let67_0, _355_dt__update__tmp_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>((_354_t2).dtor__1, _pat_let68_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let68_0, _356_dt__update_hlog__truncation__point_h0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>((_354_t2).dtor__0, _pat_let69_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let69_0, _357_dt__update_hvotes_h0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICValToBeSent2b, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(LiveByzRSL____AcceptorModel__i_Compile.CValToBeSent2b.create_CValToBeSent2bUnknown(), _pat_let70_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICValToBeSent2b, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let70_0, _358_dt__update_hval__to__be__sent__2b_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(((_pat_let_tv58).dtor_opn__to__be__send__2b) + (BigInteger.One), _pat_let71_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let71_0, _359_dt__update_hopn__to__be__send__2b_h0 => LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.create((_355_dt__update__tmp_h0).dtor_constants, (_355_dt__update__tmp_h0).dtor_max__bal, _357_dt__update_hvotes_h0, (_355_dt__update__tmp_h0).dtor_last__checkpointed__operation, _356_dt__update_hlog__truncation__point_h0, (_355_dt__update__tmp_h0).dtor_received__1b__packets, (_355_dt__update__tmp_h0).dtor_received__2avs, _359_dt__update_hopn__to__be__send__2b_h0, _358_dt__update_hval__to__be__sent__2b_h0))))))))))), _pat_let66_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let66_0, _360_t3 => _System.Tuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_360_t3, _349_t1))))))))), _pat_let58_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>>(_pat_let58_0, _361_t1 => _System.Tuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>.create((_361_t1).dtor__1, (_361_t1).dtor__0))))), _pat_let56_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>, _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let56_0, _362_t1 => _System.Tuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_362_t1).dtor__1, (_362_t1).dtor__0))))), _pat_let54_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>>(_pat_let54_0, _363_t1 => _System.Tuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>.create((_363_t1).dtor__1, (_363_t1).dtor__0)))));
      return _System.Tuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_344_t1).dtor__1, (_344_t1).dtor__0);
    }
    public static LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor CAcceptorForgetReceived2avs(LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor s, BigInteger opn)
    {
      var _pat_let_tv59 = s;
      var _pat_let_tv60 = opn;
      LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor _364_t1 = ((((s).dtor_received__2avs).Contains((opn))) ? (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(s, _pat_let73_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let73_0, _365_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Collections____Maps__i_Compile.__default.RemoveElt<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>((_pat_let_tv59).dtor_received__2avs, _pat_let_tv60), _pat_let74_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let74_0, _366_dt__update_hreceived__2avs_h0 => LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.create((_365_dt__update__tmp_h0).dtor_constants, (_365_dt__update__tmp_h0).dtor_max__bal, (_365_dt__update__tmp_h0).dtor_votes, (_365_dt__update__tmp_h0).dtor_last__checkpointed__operation, (_365_dt__update__tmp_h0).dtor_log__truncation__point, (_365_dt__update__tmp_h0).dtor_received__1b__packets, _366_dt__update_hreceived__2avs_h0, (_365_dt__update__tmp_h0).dtor_opn__to__be__send__2b, (_365_dt__update__tmp_h0).dtor_val__to__be__sent__2b))))), _pat_let72_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let72_0, _367_t1 => _367_t1))) : (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(s, _pat_let75_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let75_0, _368_t1 => _368_t1))));
      return _364_t1;
    }
    public static LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor CAcceptorProcessHeartbeat(LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor s, LiveByzRSL____CMessage__i_Compile._ICPacket inp)
    {
      var _pat_let_tv61 = s;
      var _pat_let_tv62 = s;
      var _pat_let_tv63 = inp;
      var _pat_let_tv64 = s;
      var _pat_let_tv65 = s;
      var _pat_let_tv66 = inp;
      var _pat_let_tv67 = s;
      LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor _369_t1 = (((((((s).dtor_constants).dtor_all).dtor_config)).Contains(((inp).dtor_src))) ? (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Helpers.Let<BigInteger, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(LiveByzRSL____CConfiguration__i_Compile.__default.CGetReplicaIndex((inp).dtor_src, (((s).dtor_constants).dtor_all).dtor_config), _pat_let77_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let77_0, _370_sender__index => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>((((((_370_sender__index).Sign != -1) && ((_370_sender__index) < (new BigInteger(((_pat_let_tv65).dtor_last__checkpointed__operation).Count)))) && ((((_pat_let_tv66).dtor_msg).dtor_opn__ckpt) > (((_pat_let_tv67).dtor_last__checkpointed__operation).Select(_370_sender__index)))) ? (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let_tv61, _pat_let80_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let80_0, _371_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.ISequence<BigInteger>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Sequence<BigInteger>.Update((_pat_let_tv62).dtor_last__checkpointed__operation, _370_sender__index, ((_pat_let_tv63).dtor_msg).dtor_opn__ckpt), _pat_let81_0 => Dafny.Helpers.Let<Dafny.ISequence<BigInteger>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let81_0, _372_dt__update_hlast__checkpointed__operation_h0 => LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.create((_371_dt__update__tmp_h0).dtor_constants, (_371_dt__update__tmp_h0).dtor_max__bal, (_371_dt__update__tmp_h0).dtor_votes, _372_dt__update_hlast__checkpointed__operation_h0, (_371_dt__update__tmp_h0).dtor_log__truncation__point, (_371_dt__update__tmp_h0).dtor_received__1b__packets, (_371_dt__update__tmp_h0).dtor_received__2avs, (_371_dt__update__tmp_h0).dtor_opn__to__be__send__2b, (_371_dt__update__tmp_h0).dtor_val__to__be__sent__2b))))), _pat_let79_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let79_0, _373_t1 => _373_t1))) : (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let_tv64, _pat_let82_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let82_0, _374_t1 => _374_t1)))), _pat_let78_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let78_0, _375_t1 => _375_t1)))), _pat_let76_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let76_0, _376_t1 => _376_t1))) : (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(s, _pat_let83_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let83_0, _377_t1 => _377_t1))));
      return _369_t1;
    }
    public static LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor CAcceptorTruncateLog(LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor s, BigInteger opn)
    {
      var _pat_let_tv68 = s;
      var _pat_let_tv69 = opn;
      LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor _378_t1 = (((opn) <= ((s).dtor_log__truncation__point)) ? (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(s, _pat_let84_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let84_0, _379_t1 => _379_t1))) : (Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(LiveByzRSL____AcceptorModel__i_Compile.__default.CRemoveVotesBeforeLogTruncationPoint((s).dtor_votes, opn), _pat_let85_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let85_0, _380_t1 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let_tv68, _pat_let87_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let87_0, _381_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_380_t1, _pat_let88_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,LiveByzRSL____CTypes__i_Compile._ICVote>, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let88_0, _382_dt__update_hvotes_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let_tv69, _pat_let89_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let89_0, _383_dt__update_hlog__truncation__point_h0 => LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.create((_381_dt__update__tmp_h0).dtor_constants, (_381_dt__update__tmp_h0).dtor_max__bal, _382_dt__update_hvotes_h0, (_381_dt__update__tmp_h0).dtor_last__checkpointed__operation, _383_dt__update_hlog__truncation__point_h0, (_381_dt__update__tmp_h0).dtor_received__1b__packets, (_381_dt__update__tmp_h0).dtor_received__2avs, (_381_dt__update__tmp_h0).dtor_opn__to__be__send__2b, (_381_dt__update__tmp_h0).dtor_val__to__be__sent__2b))))))), _pat_let86_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor>(_pat_let86_0, _384_t2 => _384_t2))))));
      return _378_t1;
    }
  }
} // end of namespace LiveByzRSL____AcceptorModel__i_Compile
namespace LiveByzRSL____CClockReading__i_Compile {

  public interface _ICClockReading {
    bool is_CClockReading { get; }
    BigInteger dtor_t { get; }
  }
  public class CClockReading : _ICClockReading {
    public readonly BigInteger _t;
    public CClockReading(BigInteger t) {
      this._t = t;
    }
    public static BigInteger DowncastClone(BigInteger _this) {
      return _this;
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____CClockReading__i_Compile.CClockReading;
      return oth != null && this._t == oth._t;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._t));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____CClockReading__i_Compile.CClockReading.CClockReading";
      s += "(";
      s += Dafny.Helpers.ToString(this._t);
      s += ")";
      return s;
    }
    private static readonly BigInteger theDefault = BigInteger.Zero;
    public static BigInteger Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<BigInteger> _TYPE = new Dafny.TypeDescriptor<BigInteger>(BigInteger.Zero);
    public static Dafny.TypeDescriptor<BigInteger> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICClockReading create(BigInteger t) {
      return new CClockReading(t);
    }
    public static _ICClockReading create_CClockReading(BigInteger t) {
      return create(t);
    }
    public bool is_CClockReading { get { return true; } }
    public BigInteger dtor_t {
      get {
        return this._t;
      }
    }
  }

} // end of namespace LiveByzRSL____CClockReading__i_Compile
namespace LiveByzRSL____ElectionModel__i_Compile {

  public interface _ICElectionState {
    bool is_CElectionState { get; }
    LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants dtor_constants { get; }
    LiveByzRSL____CTypes__i_Compile._ICBallot dtor_current__view { get; }
    Dafny.ISet<BigInteger> dtor_current__view__suspectors { get; }
    BigInteger dtor_epoch__end__time { get; }
    BigInteger dtor_epoch__length { get; }
    Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_requests__received__this__epoch { get; }
    Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_requests__received__prev__epochs { get; }
    _ICElectionState DowncastClone();
  }
  public class CElectionState : _ICElectionState {
    public readonly LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants _constants;
    public readonly LiveByzRSL____CTypes__i_Compile._ICBallot _current__view;
    public readonly Dafny.ISet<BigInteger> _current__view__suspectors;
    public readonly BigInteger _epoch__end__time;
    public readonly BigInteger _epoch__length;
    public readonly Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _requests__received__this__epoch;
    public readonly Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _requests__received__prev__epochs;
    public CElectionState(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, LiveByzRSL____CTypes__i_Compile._ICBallot current__view, Dafny.ISet<BigInteger> current__view__suspectors, BigInteger epoch__end__time, BigInteger epoch__length, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> requests__received__this__epoch, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> requests__received__prev__epochs) {
      this._constants = constants;
      this._current__view = current__view;
      this._current__view__suspectors = current__view__suspectors;
      this._epoch__end__time = epoch__end__time;
      this._epoch__length = epoch__length;
      this._requests__received__this__epoch = requests__received__this__epoch;
      this._requests__received__prev__epochs = requests__received__prev__epochs;
    }
    public _ICElectionState DowncastClone() {
      if (this is _ICElectionState dt) { return dt; }
      return new CElectionState(_constants, _current__view, _current__view__suspectors, _epoch__end__time, _epoch__length, _requests__received__this__epoch, _requests__received__prev__epochs);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____ElectionModel__i_Compile.CElectionState;
      return oth != null && object.Equals(this._constants, oth._constants) && object.Equals(this._current__view, oth._current__view) && object.Equals(this._current__view__suspectors, oth._current__view__suspectors) && this._epoch__end__time == oth._epoch__end__time && this._epoch__length == oth._epoch__length && object.Equals(this._requests__received__this__epoch, oth._requests__received__this__epoch) && object.Equals(this._requests__received__prev__epochs, oth._requests__received__prev__epochs);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._constants));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._current__view));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._current__view__suspectors));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._epoch__end__time));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._epoch__length));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._requests__received__this__epoch));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._requests__received__prev__epochs));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____ElectionModel__i_Compile.CElectionState.CElectionState";
      s += "(";
      s += Dafny.Helpers.ToString(this._constants);
      s += ", ";
      s += Dafny.Helpers.ToString(this._current__view);
      s += ", ";
      s += Dafny.Helpers.ToString(this._current__view__suspectors);
      s += ", ";
      s += Dafny.Helpers.ToString(this._epoch__end__time);
      s += ", ";
      s += Dafny.Helpers.ToString(this._epoch__length);
      s += ", ";
      s += Dafny.Helpers.ToString(this._requests__received__this__epoch);
      s += ", ";
      s += Dafny.Helpers.ToString(this._requests__received__prev__epochs);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____ElectionModel__i_Compile._ICElectionState theDefault = create(LiveByzRSL____ConstantsState__i_Compile.CReplicaConstants.Default(), LiveByzRSL____CTypes__i_Compile.CBallot.Default(), Dafny.Set<BigInteger>.Empty, BigInteger.Zero, BigInteger.Zero, Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.Empty, Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.Empty);
    public static LiveByzRSL____ElectionModel__i_Compile._ICElectionState Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____ElectionModel__i_Compile._ICElectionState> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(LiveByzRSL____ElectionModel__i_Compile.CElectionState.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____ElectionModel__i_Compile._ICElectionState> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICElectionState create(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, LiveByzRSL____CTypes__i_Compile._ICBallot current__view, Dafny.ISet<BigInteger> current__view__suspectors, BigInteger epoch__end__time, BigInteger epoch__length, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> requests__received__this__epoch, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> requests__received__prev__epochs) {
      return new CElectionState(constants, current__view, current__view__suspectors, epoch__end__time, epoch__length, requests__received__this__epoch, requests__received__prev__epochs);
    }
    public static _ICElectionState create_CElectionState(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, LiveByzRSL____CTypes__i_Compile._ICBallot current__view, Dafny.ISet<BigInteger> current__view__suspectors, BigInteger epoch__end__time, BigInteger epoch__length, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> requests__received__this__epoch, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> requests__received__prev__epochs) {
      return create(constants, current__view, current__view__suspectors, epoch__end__time, epoch__length, requests__received__this__epoch, requests__received__prev__epochs);
    }
    public bool is_CElectionState { get { return true; } }
    public LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants dtor_constants {
      get {
        return this._constants;
      }
    }
    public LiveByzRSL____CTypes__i_Compile._ICBallot dtor_current__view {
      get {
        return this._current__view;
      }
    }
    public Dafny.ISet<BigInteger> dtor_current__view__suspectors {
      get {
        return this._current__view__suspectors;
      }
    }
    public BigInteger dtor_epoch__end__time {
      get {
        return this._epoch__end__time;
      }
    }
    public BigInteger dtor_epoch__length {
      get {
        return this._epoch__length;
      }
    }
    public Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_requests__received__this__epoch {
      get {
        return this._requests__received__this__epoch;
      }
    }
    public Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_requests__received__prev__epochs {
      get {
        return this._requests__received__prev__epochs;
      }
    }
  }

  public partial class __default {
    public static LiveByzRSL____CTypes__i_Compile._ICBallot CComputeSuccessorView(LiveByzRSL____CTypes__i_Compile._ICBallot b, LiveByzRSL____ConstantsState__i_Compile._ICConstants c)
    {
      if ((((b).dtor_proposer__id) + (BigInteger.One)) < (new BigInteger((((c).dtor_config)).Count))) {
        return LiveByzRSL____CTypes__i_Compile.CBallot.create((b).dtor_seqno, ((b).dtor_proposer__id) + (BigInteger.One));
      } else {
        return LiveByzRSL____CTypes__i_Compile.CBallot.create(((b).dtor_seqno) + (BigInteger.One), BigInteger.Zero);
      }
    }
    public static Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> CBoundRequestSequence(Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> s, Common____UpperBound__i_Compile._ICUpperBound lengthBound)
    {
      if ((((lengthBound).is_CUpperBoundFinite) && (((lengthBound).dtor_n).Sign != -1)) && (((lengthBound).dtor_n) < (new BigInteger((s).Count)))) {
        return (s).Take((lengthBound).dtor_n);
      } else {
        return s;
      }
    }
    public static bool CRequestsMatch(LiveByzRSL____CTypes__i_Compile._ICRequest r1, LiveByzRSL____CTypes__i_Compile._ICRequest r2)
    {
      return (((true) && (true)) && (object.Equals((r1).dtor_client, (r2).dtor_client))) && (((r1).dtor_seqno) == ((r2).dtor_seqno));
    }
    public static bool CRequestSatisfiedBy(LiveByzRSL____CTypes__i_Compile._ICRequest r1, LiveByzRSL____CTypes__i_Compile._ICRequest r2)
    {
      return (((true) && (true)) && (object.Equals((r1).dtor_client, (r2).dtor_client))) && (((r1).dtor_seqno) <= ((r2).dtor_seqno));
    }
    public static Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> CRemoveAllSatisfiedRequestsInSequence(Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> s, LiveByzRSL____CTypes__i_Compile._ICRequest r)
    {
      Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _385___accumulator = Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.Concat(_385___accumulator, Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements());
      } else if (LiveByzRSL____ElectionModel__i_Compile.__default.CRequestSatisfiedBy((s).Select(BigInteger.Zero), r)) {
        Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _in6 = (s).Drop(BigInteger.One);
        LiveByzRSL____CTypes__i_Compile._ICRequest _in7 = r;
        s = _in6;
        r = _in7;
        goto TAIL_CALL_START;
      } else {
        _385___accumulator = Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.Concat(_385___accumulator, Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements((s).Select(BigInteger.Zero)));
        Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _in8 = (s).Drop(BigInteger.One);
        LiveByzRSL____CTypes__i_Compile._ICRequest _in9 = r;
        s = _in8;
        r = _in9;
        goto TAIL_CALL_START;
      }
    }
    public static bool CCheckRequestValidInReqSeq(Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> s, LiveByzRSL____CTypes__i_Compile._ICRequest r)
    {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____CTypes__i_Compile._ICRequest, bool>>((_386_s, _387_r) => Dafny.Helpers.Quantifier<LiveByzRSL____CTypes__i_Compile._ICRequest>((_386_s).UniqueElements, false, (((_exists_var_3) => {
        LiveByzRSL____CTypes__i_Compile._ICRequest _388_i = (LiveByzRSL____CTypes__i_Compile._ICRequest)_exists_var_3;
        return (((_386_s).Contains((_388_i))) && (LiveByzRSL____ElectionModel__i_Compile.__default.CRequestsMatch(_388_i, _387_r))) && (object.Equals((_388_i).dtor_request, (_387_r).dtor_request));
      }))))(s, r);
    }
    public static bool CCheckRequestValid(LiveByzRSL____ElectionModel__i_Compile._ICElectionState s, LiveByzRSL____CTypes__i_Compile._ICRequest r)
    {
      return (LiveByzRSL____ElectionModel__i_Compile.__default.CCheckRequestValidInReqSeq((s).dtor_requests__received__this__epoch, r)) || (LiveByzRSL____ElectionModel__i_Compile.__default.CCheckRequestValidInReqSeq((s).dtor_requests__received__prev__epochs, r));
    }
    public static LiveByzRSL____ElectionModel__i_Compile._ICElectionState CElectionStateInit(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants c) {
      LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants _389_t1 = c;
      LiveByzRSL____CTypes__i_Compile._ICBallot _390_t2 = LiveByzRSL____CTypes__i_Compile.CBallot.create(BigInteger.One, BigInteger.Zero);
      Dafny.ISet<BigInteger> _391_t3 = Dafny.Set<BigInteger>.FromElements();
      BigInteger _392_t4 = BigInteger.Zero;
      BigInteger _393_t5 = (((c).dtor_all).dtor_params).dtor_baseline__view__timeout__period;
      Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _394_t6 = Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements();
      Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _395_t7 = Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements();
      return LiveByzRSL____ElectionModel__i_Compile.CElectionState.create(_389_t1, _390_t2, _391_t3, _392_t4, _393_t5, _394_t6, _395_t7);
    }
    public static LiveByzRSL____ElectionModel__i_Compile._ICElectionState CElectionStateProcessHeartbeat(LiveByzRSL____ElectionModel__i_Compile._ICElectionState es, LiveByzRSL____CMessage__i_Compile._ICPacket p, BigInteger clock)
    {
      var _pat_let_tv70 = es;
      var _pat_let_tv71 = es;
      var _pat_let_tv72 = es;
      var _pat_let_tv73 = es;
      var _pat_let_tv74 = es;
      var _pat_let_tv75 = es;
      var _pat_let_tv76 = es;
      var _pat_let_tv77 = es;
      var _pat_let_tv78 = es;
      var _pat_let_tv79 = clock;
      var _pat_let_tv80 = es;
      var _pat_let_tv81 = p;
      var _pat_let_tv82 = p;
      var _pat_let_tv83 = es;
      var _pat_let_tv84 = es;
      var _pat_let_tv85 = p;
      var _pat_let_tv86 = p;
      var _pat_let_tv87 = es;
      var _pat_let_tv88 = p;
      LiveByzRSL____ElectionModel__i_Compile._ICElectionState _396_t1 = ((!(((((es).dtor_constants).dtor_all).dtor_config)).Contains(((p).dtor_src))) ? (Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(es, _pat_let90_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let90_0, _397_t1 => _397_t1))) : (Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(LiveByzRSL____CConfiguration__i_Compile.__default.CGetReplicaIndex((p).dtor_src, (((es).dtor_constants).dtor_all).dtor_config), _pat_let92_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let92_0, _398_sender__index => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>((((object.Equals(((_pat_let_tv86).dtor_msg).dtor_bal__heartbeat, (_pat_let_tv87).dtor_current__view)) && (((_pat_let_tv88).dtor_msg).dtor_suspicious)) ? (Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let_tv70, _pat_let95_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let95_0, _399_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.ISet<BigInteger>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Set<BigInteger>.Union((_pat_let_tv71).dtor_current__view__suspectors, Dafny.Set<BigInteger>.FromElements(_398_sender__index)), _pat_let96_0 => Dafny.Helpers.Let<Dafny.ISet<BigInteger>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let96_0, _400_dt__update_hcurrent__view__suspectors_h0 => LiveByzRSL____ElectionModel__i_Compile.CElectionState.create((_399_dt__update__tmp_h0).dtor_constants, (_399_dt__update__tmp_h0).dtor_current__view, _400_dt__update_hcurrent__view__suspectors_h0, (_399_dt__update__tmp_h0).dtor_epoch__end__time, (_399_dt__update__tmp_h0).dtor_epoch__length, (_399_dt__update__tmp_h0).dtor_requests__received__this__epoch, (_399_dt__update__tmp_h0).dtor_requests__received__prev__epochs))))), _pat_let94_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let94_0, _401_t1 => _401_t1))) : (Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(((LiveByzRSL____CTypes__i_Compile.__default.CBalLt((_pat_let_tv84).dtor_current__view, ((_pat_let_tv85).dtor_msg).dtor_bal__heartbeat)) ? (Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Common____UpperBound__i_Compile.__default.UpperBoundedAdditionImpl((_pat_let_tv72).dtor_epoch__length, (_pat_let_tv73).dtor_epoch__length, ((((_pat_let_tv74).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val), _pat_let99_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let99_0, _402_new__epoch__length => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let_tv75, _pat_let101_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let101_0, _403_dt__update__tmp_h1 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements(), _pat_let102_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let102_0, _404_dt__update_hrequests__received__this__epoch_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(LiveByzRSL____ElectionModel__i_Compile.__default.CBoundRequestSequence(Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.Concat((_pat_let_tv76).dtor_requests__received__prev__epochs, (_pat_let_tv77).dtor_requests__received__this__epoch), ((((_pat_let_tv78).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val), _pat_let103_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let103_0, _405_dt__update_hrequests__received__prev__epochs_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Common____UpperBound__i_Compile.__default.UpperBoundedAdditionImpl(_pat_let_tv79, _402_new__epoch__length, ((((_pat_let_tv80).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val), _pat_let104_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let104_0, _406_dt__update_hepoch__end__time_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_402_new__epoch__length, _pat_let105_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let105_0, _407_dt__update_hepoch__length_h0 => Dafny.Helpers.Let<Dafny.ISet<BigInteger>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(((((_pat_let_tv81).dtor_msg).dtor_suspicious) ? (Dafny.Set<BigInteger>.FromElements(_398_sender__index)) : (Dafny.Set<BigInteger>.FromElements())), _pat_let106_0 => Dafny.Helpers.Let<Dafny.ISet<BigInteger>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let106_0, _408_dt__update_hcurrent__view__suspectors_h1 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(((_pat_let_tv82).dtor_msg).dtor_bal__heartbeat, _pat_let107_0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let107_0, _409_dt__update_hcurrent__view_h0 => LiveByzRSL____ElectionModel__i_Compile.CElectionState.create((_403_dt__update__tmp_h1).dtor_constants, _409_dt__update_hcurrent__view_h0, _408_dt__update_hcurrent__view__suspectors_h1, _406_dt__update_hepoch__end__time_h0, _407_dt__update_hepoch__length_h0, _404_dt__update_hrequests__received__this__epoch_h0, _405_dt__update_hrequests__received__prev__epochs_h0))))))))))))))), _pat_let100_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let100_0, _410_t1 => _410_t1)))), _pat_let98_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let98_0, _411_t1 => _411_t1))) : (Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let_tv83, _pat_let108_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let108_0, _412_t1 => _412_t1)))), _pat_let97_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let97_0, _413_t1 => _413_t1)))), _pat_let93_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let93_0, _414_t1 => _414_t1)))), _pat_let91_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let91_0, _415_t1 => _415_t1))));
      return _396_t1;
    }
    public static LiveByzRSL____ElectionModel__i_Compile._ICElectionState CElectionStateCheckForViewTimeout(LiveByzRSL____ElectionModel__i_Compile._ICElectionState es, BigInteger clock)
    {
      var _pat_let_tv89 = es;
      var _pat_let_tv90 = es;
      var _pat_let_tv91 = clock;
      var _pat_let_tv92 = es;
      var _pat_let_tv93 = es;
      var _pat_let_tv94 = es;
      var _pat_let_tv95 = es;
      var _pat_let_tv96 = clock;
      var _pat_let_tv97 = es;
      var _pat_let_tv98 = es;
      var _pat_let_tv99 = es;
      var _pat_let_tv100 = es;
      LiveByzRSL____ElectionModel__i_Compile._ICElectionState _416_t1 = (((clock) < ((es).dtor_epoch__end__time)) ? (Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(es, _pat_let109_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let109_0, _417_t1 => _417_t1))) : (Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>((((new BigInteger(((es).dtor_requests__received__prev__epochs).Count)).Sign == 0) ? (Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(((((es).dtor_constants).dtor_all).dtor_params).dtor_baseline__view__timeout__period, _pat_let112_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let112_0, _418_new__epoch__length => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let_tv89, _pat_let114_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let114_0, _419_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements(), _pat_let115_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let115_0, _420_dt__update_hrequests__received__this__epoch_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>((_pat_let_tv90).dtor_requests__received__this__epoch, _pat_let116_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let116_0, _421_dt__update_hrequests__received__prev__epochs_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Common____UpperBound__i_Compile.__default.UpperBoundedAdditionImpl(_pat_let_tv91, _418_new__epoch__length, ((((_pat_let_tv92).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val), _pat_let117_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let117_0, _422_dt__update_hepoch__end__time_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_418_new__epoch__length, _pat_let118_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let118_0, _423_dt__update_hepoch__length_h0 => LiveByzRSL____ElectionModel__i_Compile.CElectionState.create((_419_dt__update__tmp_h0).dtor_constants, (_419_dt__update__tmp_h0).dtor_current__view, (_419_dt__update__tmp_h0).dtor_current__view__suspectors, _422_dt__update_hepoch__end__time_h0, _423_dt__update_hepoch__length_h0, _420_dt__update_hrequests__received__this__epoch_h0, _421_dt__update_hrequests__received__prev__epochs_h0))))))))))), _pat_let113_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let113_0, _424_t1 => _424_t1)))), _pat_let111_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let111_0, _425_t1 => _425_t1))) : (Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(es, _pat_let120_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let120_0, _426_dt__update__tmp_h1 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements(), _pat_let121_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let121_0, _427_dt__update_hrequests__received__this__epoch_h1 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(LiveByzRSL____ElectionModel__i_Compile.__default.CBoundRequestSequence(Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.Concat((_pat_let_tv93).dtor_requests__received__prev__epochs, (_pat_let_tv94).dtor_requests__received__this__epoch), ((((_pat_let_tv95).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val), _pat_let122_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let122_0, _428_dt__update_hrequests__received__prev__epochs_h1 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Common____UpperBound__i_Compile.__default.UpperBoundedAdditionImpl(_pat_let_tv96, (_pat_let_tv97).dtor_epoch__length, ((((_pat_let_tv98).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val), _pat_let123_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let123_0, _429_dt__update_hepoch__end__time_h1 => Dafny.Helpers.Let<Dafny.ISet<BigInteger>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Set<BigInteger>.Union((_pat_let_tv99).dtor_current__view__suspectors, Dafny.Set<BigInteger>.FromElements(((_pat_let_tv100).dtor_constants).dtor_my__index)), _pat_let124_0 => Dafny.Helpers.Let<Dafny.ISet<BigInteger>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let124_0, _430_dt__update_hcurrent__view__suspectors_h0 => LiveByzRSL____ElectionModel__i_Compile.CElectionState.create((_426_dt__update__tmp_h1).dtor_constants, (_426_dt__update__tmp_h1).dtor_current__view, _430_dt__update_hcurrent__view__suspectors_h0, _429_dt__update_hepoch__end__time_h1, (_426_dt__update__tmp_h1).dtor_epoch__length, _427_dt__update_hrequests__received__this__epoch_h1, _428_dt__update_hrequests__received__prev__epochs_h1))))))))))), _pat_let119_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let119_0, _431_t1 => _431_t1)))), _pat_let110_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let110_0, _432_t1 => _432_t1))));
      return _416_t1;
    }
    public static LiveByzRSL____ElectionModel__i_Compile._ICElectionState CElectionStateCheckForQuorumOfViewSuspicions(LiveByzRSL____ElectionModel__i_Compile._ICElectionState es, BigInteger clock)
    {
      var _pat_let_tv101 = es;
      var _pat_let_tv102 = es;
      var _pat_let_tv103 = es;
      var _pat_let_tv104 = es;
      var _pat_let_tv105 = clock;
      var _pat_let_tv106 = es;
      var _pat_let_tv107 = es;
      var _pat_let_tv108 = es;
      LiveByzRSL____ElectionModel__i_Compile._ICElectionState _433_t1 = ((((new BigInteger(((es).dtor_current__view__suspectors).Count)) < (LiveByzRSL____CConfiguration__i_Compile.__default.CMinQuorumSize((((es).dtor_constants).dtor_all).dtor_config))) || (!(Common____UpperBound__i_Compile.__default.CLtUpperBound(((es).dtor_current__view).dtor_seqno, ((((es).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val)))) ? (Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(es, _pat_let125_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let125_0, _434_t1 => _434_t1))) : (Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Common____UpperBound__i_Compile.__default.UpperBoundedAdditionImpl((es).dtor_epoch__length, (es).dtor_epoch__length, ((((es).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val), _pat_let127_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let127_0, _435_new__epoch__length => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let_tv101, _pat_let129_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let129_0, _436_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements(), _pat_let130_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let130_0, _437_dt__update_hrequests__received__this__epoch_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(LiveByzRSL____ElectionModel__i_Compile.__default.CBoundRequestSequence(Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.Concat((_pat_let_tv102).dtor_requests__received__prev__epochs, (_pat_let_tv103).dtor_requests__received__this__epoch), ((((_pat_let_tv104).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val), _pat_let131_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let131_0, _438_dt__update_hrequests__received__prev__epochs_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Common____UpperBound__i_Compile.__default.UpperBoundedAdditionImpl(_pat_let_tv105, _435_new__epoch__length, ((((_pat_let_tv106).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val), _pat_let132_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let132_0, _439_dt__update_hepoch__end__time_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_435_new__epoch__length, _pat_let133_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let133_0, _440_dt__update_hepoch__length_h0 => Dafny.Helpers.Let<Dafny.ISet<BigInteger>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Set<BigInteger>.FromElements(), _pat_let134_0 => Dafny.Helpers.Let<Dafny.ISet<BigInteger>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let134_0, _441_dt__update_hcurrent__view__suspectors_h0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(LiveByzRSL____ElectionModel__i_Compile.__default.CComputeSuccessorView((_pat_let_tv107).dtor_current__view, ((_pat_let_tv108).dtor_constants).dtor_all), _pat_let135_0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let135_0, _442_dt__update_hcurrent__view_h0 => LiveByzRSL____ElectionModel__i_Compile.CElectionState.create((_436_dt__update__tmp_h0).dtor_constants, _442_dt__update_hcurrent__view_h0, _441_dt__update_hcurrent__view__suspectors_h0, _439_dt__update_hepoch__end__time_h0, _440_dt__update_hepoch__length_h0, _437_dt__update_hrequests__received__this__epoch_h0, _438_dt__update_hrequests__received__prev__epochs_h0))))))))))))))), _pat_let128_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let128_0, _443_t1 => _443_t1)))), _pat_let126_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let126_0, _444_t1 => _444_t1))));
      return _433_t1;
    }
    public static LiveByzRSL____ElectionModel__i_Compile._ICElectionState CElectionStateReflectReceivedRequest(LiveByzRSL____ElectionModel__i_Compile._ICElectionState es, LiveByzRSL____CTypes__i_Compile._ICRequest req)
    {
      var _pat_let_tv109 = es;
      var _pat_let_tv110 = req;
      var _pat_let_tv111 = es;
      LiveByzRSL____ElectionModel__i_Compile._ICElectionState _445_t1 = ((Dafny.Helpers.Id<Func<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____CTypes__i_Compile._ICRequest, bool>>((_455_es, _456_req) => Dafny.Helpers.Quantifier<LiveByzRSL____CTypes__i_Compile._ICRequest>(((_455_es).dtor_requests__received__prev__epochs).UniqueElements, false, (((_exists_var_5) => {
        LiveByzRSL____CTypes__i_Compile._ICRequest _457_earlier__req = (LiveByzRSL____CTypes__i_Compile._ICRequest)_exists_var_5;
        return (((_455_es).dtor_requests__received__prev__epochs).Contains((_457_earlier__req))) && (LiveByzRSL____ElectionModel__i_Compile.__default.CRequestsMatch(_457_earlier__req, _456_req));
      }))))(es, req)) ? (Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(es, _pat_let136_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let136_0, _446_t1 => _446_t1))) : (Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(((Dafny.Helpers.Id<Func<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____CTypes__i_Compile._ICRequest, bool>>((_451_es, _452_req) => Dafny.Helpers.Quantifier<LiveByzRSL____CTypes__i_Compile._ICRequest>(((_451_es).dtor_requests__received__this__epoch).UniqueElements, false, (((_exists_var_4) => {
        LiveByzRSL____CTypes__i_Compile._ICRequest _453_earlier__req = (LiveByzRSL____CTypes__i_Compile._ICRequest)_exists_var_4;
        return (((_451_es).dtor_requests__received__this__epoch).Contains((_453_earlier__req))) && (LiveByzRSL____ElectionModel__i_Compile.__default.CRequestsMatch(_453_earlier__req, _452_req));
      }))))(es, req)) ? (Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(es, _pat_let138_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let138_0, _447_t1 => _447_t1))) : (Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(es, _pat_let140_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let140_0, _448_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(LiveByzRSL____ElectionModel__i_Compile.__default.CBoundRequestSequence(Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.Concat((_pat_let_tv109).dtor_requests__received__this__epoch, Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements(_pat_let_tv110)), ((((_pat_let_tv111).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val), _pat_let141_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let141_0, _449_dt__update_hrequests__received__this__epoch_h0 => LiveByzRSL____ElectionModel__i_Compile.CElectionState.create((_448_dt__update__tmp_h0).dtor_constants, (_448_dt__update__tmp_h0).dtor_current__view, (_448_dt__update__tmp_h0).dtor_current__view__suspectors, (_448_dt__update__tmp_h0).dtor_epoch__end__time, (_448_dt__update__tmp_h0).dtor_epoch__length, _449_dt__update_hrequests__received__this__epoch_h0, (_448_dt__update__tmp_h0).dtor_requests__received__prev__epochs))))), _pat_let139_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let139_0, _450_t1 => _450_t1)))), _pat_let137_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let137_0, _454_t1 => _454_t1))));
      return _445_t1;
    }
    public static Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> CRemoveExecutedRequestBatch(Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> reqs, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> batch)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((batch).Count)).Sign == 0) {
        return reqs;
      } else {
        Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _in10 = LiveByzRSL____ElectionModel__i_Compile.__default.CRemoveAllSatisfiedRequestsInSequence(reqs, (batch).Select(BigInteger.Zero));
        Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _in11 = (batch).Drop(BigInteger.One);
        reqs = _in10;
        batch = _in11;
        goto TAIL_CALL_START;
      }
    }
    public static LiveByzRSL____ElectionModel__i_Compile._ICElectionState CElectionStateReflectExecutedRequestBatch(LiveByzRSL____ElectionModel__i_Compile._ICElectionState es, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> batch)
    {
      var _pat_let_tv112 = es;
      var _pat_let_tv113 = batch;
      var _pat_let_tv114 = es;
      var _pat_let_tv115 = batch;
      LiveByzRSL____ElectionModel__i_Compile._ICElectionState _458_t1 = Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(es, _pat_let142_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let142_0, _459_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(LiveByzRSL____ElectionModel__i_Compile.__default.CRemoveExecutedRequestBatch((_pat_let_tv112).dtor_requests__received__this__epoch, _pat_let_tv113), _pat_let143_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let143_0, _460_dt__update_hrequests__received__this__epoch_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(LiveByzRSL____ElectionModel__i_Compile.__default.CRemoveExecutedRequestBatch((_pat_let_tv114).dtor_requests__received__prev__epochs, _pat_let_tv115), _pat_let144_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ElectionModel__i_Compile._ICElectionState>(_pat_let144_0, _461_dt__update_hrequests__received__prev__epochs_h0 => LiveByzRSL____ElectionModel__i_Compile.CElectionState.create((_459_dt__update__tmp_h0).dtor_constants, (_459_dt__update__tmp_h0).dtor_current__view, (_459_dt__update__tmp_h0).dtor_current__view__suspectors, (_459_dt__update__tmp_h0).dtor_epoch__end__time, (_459_dt__update__tmp_h0).dtor_epoch__length, _460_dt__update_hrequests__received__this__epoch_h0, _461_dt__update_hrequests__received__prev__epochs_h0)))))));
      return _458_t1;
    }
  }
} // end of namespace LiveByzRSL____ElectionModel__i_Compile
namespace LiveByzRSL____CStateMachine__i_Compile {

  public partial class __default {
    public static _System._ITuple2<ulong, LiveByzRSL____CTypes__i_Compile._ICReply> CHandleRequest(ulong state, LiveByzRSL____CTypes__i_Compile._ICRequest request)
    {
      _System._ITuple2<ulong, LiveByzRSL____AppInterface__i_Compile._ICAppMessage> _let_tmp_rhs10 = LiveByzRSL____AppInterface__i_Compile.__default.HandleAppRequest(state, (request).dtor_request);
      ulong _462_new__state = _let_tmp_rhs10.dtor__0;
      LiveByzRSL____AppInterface__i_Compile._ICAppMessage _463_reply = _let_tmp_rhs10.dtor__1;
      return _System.Tuple2<ulong, LiveByzRSL____CTypes__i_Compile._ICReply>.create(_462_new__state, LiveByzRSL____CTypes__i_Compile.CReply.create((request).dtor_client, (request).dtor_seqno, _463_reply));
    }
    public static _System._ITuple2<Dafny.ISequence<ulong>, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply>> CHandleRequestBatchHidden(ulong state, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> batch)
    {
      if ((new BigInteger((batch).Count)).Sign == 0) {
        Dafny.ISequence<ulong> _464_states = Dafny.Sequence<ulong>.FromElements(state);
        Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply> _465_replies = Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICReply>.FromElements();
        return _System.Tuple2<Dafny.ISequence<ulong>, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply>>.create(Dafny.Sequence<ulong>.FromElements(state), Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICReply>.FromElements());
      } else {
        _System._ITuple2<Dafny.ISequence<ulong>, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply>> _let_tmp_rhs11 = LiveByzRSL____CStateMachine__i_Compile.__default.CHandleRequestBatchHidden(state, (batch).Take((new BigInteger((batch).Count)) - (BigInteger.One)));
        Dafny.ISequence<ulong> _466_restStates = _let_tmp_rhs11.dtor__0;
        Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply> _467_restReplies = _let_tmp_rhs11.dtor__1;
        _System._ITuple2<ulong, LiveByzRSL____AppInterface__i_Compile._ICAppMessage> _let_tmp_rhs12 = LiveByzRSL____AppInterface__i_Compile.__default.HandleAppRequest((_466_restStates).Select((new BigInteger((_466_restStates).Count)) - (BigInteger.One)), ((batch).Select((new BigInteger((batch).Count)) - (BigInteger.One))).dtor_request);
        ulong _468_new__state = _let_tmp_rhs12.dtor__0;
        LiveByzRSL____AppInterface__i_Compile._ICAppMessage _469_reply = _let_tmp_rhs12.dtor__1;
        Dafny.ISequence<ulong> _470_states = Dafny.Sequence<ulong>.Concat(_466_restStates, Dafny.Sequence<ulong>.FromElements(_468_new__state));
        Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply> _471_replies = Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICReply>.Concat(_467_restReplies, Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICReply>.FromElements(LiveByzRSL____CTypes__i_Compile.CReply.create(((batch).Select((new BigInteger((batch).Count)) - (BigInteger.One))).dtor_client, ((batch).Select((new BigInteger((batch).Count)) - (BigInteger.One))).dtor_seqno, _469_reply)));
        return _System.Tuple2<Dafny.ISequence<ulong>, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply>>.create(Dafny.Sequence<ulong>.Concat(_466_restStates, Dafny.Sequence<ulong>.FromElements(_468_new__state)), Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICReply>.Concat(_467_restReplies, Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICReply>.FromElements(LiveByzRSL____CTypes__i_Compile.CReply.create(((batch).Select((new BigInteger((batch).Count)) - (BigInteger.One))).dtor_client, ((batch).Select((new BigInteger((batch).Count)) - (BigInteger.One))).dtor_seqno, _469_reply))));
      }
    }
    public static _System._ITuple2<Dafny.ISequence<ulong>, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply>> CHandleRequestBatch(ulong state, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> batch)
    {
      _System._ITuple2<Dafny.ISequence<ulong>, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply>> _let_tmp_rhs13 = LiveByzRSL____CStateMachine__i_Compile.__default.CHandleRequestBatchHidden(state, batch);
      Dafny.ISequence<ulong> _472_states = _let_tmp_rhs13.dtor__0;
      Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply> _473_replies = _let_tmp_rhs13.dtor__1;
      return _System.Tuple2<Dafny.ISequence<ulong>, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply>>.create(_472_states, _473_replies);
    }
  }
} // end of namespace LiveByzRSL____CStateMachine__i_Compile
namespace LiveByzRSL____ExecutorModel__i_Compile {

  public interface _ICOutstandingOperation {
    bool is_COutstandingOpKnown { get; }
    bool is_COutstandingOpUnknown { get; }
    Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_v { get; }
    LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal { get; }
    _ICOutstandingOperation DowncastClone();
  }
  public abstract class COutstandingOperation : _ICOutstandingOperation {
    public COutstandingOperation() { }
    private static readonly LiveByzRSL____ExecutorModel__i_Compile._ICOutstandingOperation theDefault = create_COutstandingOpKnown(Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.Empty, LiveByzRSL____CTypes__i_Compile.CBallot.Default());
    public static LiveByzRSL____ExecutorModel__i_Compile._ICOutstandingOperation Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____ExecutorModel__i_Compile._ICOutstandingOperation> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____ExecutorModel__i_Compile._ICOutstandingOperation>(LiveByzRSL____ExecutorModel__i_Compile.COutstandingOperation.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____ExecutorModel__i_Compile._ICOutstandingOperation> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICOutstandingOperation create_COutstandingOpKnown(Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> v, LiveByzRSL____CTypes__i_Compile._ICBallot bal) {
      return new COutstandingOperation_COutstandingOpKnown(v, bal);
    }
    public static _ICOutstandingOperation create_COutstandingOpUnknown() {
      return new COutstandingOperation_COutstandingOpUnknown();
    }
    public bool is_COutstandingOpKnown { get { return this is COutstandingOperation_COutstandingOpKnown; } }
    public bool is_COutstandingOpUnknown { get { return this is COutstandingOperation_COutstandingOpUnknown; } }
    public Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_v {
      get {
        var d = this;
        return ((COutstandingOperation_COutstandingOpKnown)d)._v;
      }
    }
    public LiveByzRSL____CTypes__i_Compile._ICBallot dtor_bal {
      get {
        var d = this;
        return ((COutstandingOperation_COutstandingOpKnown)d)._bal;
      }
    }
    public abstract _ICOutstandingOperation DowncastClone();
  }
  public class COutstandingOperation_COutstandingOpKnown : COutstandingOperation {
    public readonly Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _v;
    public readonly LiveByzRSL____CTypes__i_Compile._ICBallot _bal;
    public COutstandingOperation_COutstandingOpKnown(Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> v, LiveByzRSL____CTypes__i_Compile._ICBallot bal) {
      this._v = v;
      this._bal = bal;
    }
    public override _ICOutstandingOperation DowncastClone() {
      if (this is _ICOutstandingOperation dt) { return dt; }
      return new COutstandingOperation_COutstandingOpKnown(_v, _bal);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____ExecutorModel__i_Compile.COutstandingOperation_COutstandingOpKnown;
      return oth != null && object.Equals(this._v, oth._v) && object.Equals(this._bal, oth._bal);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._v));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____ExecutorModel__i_Compile.COutstandingOperation.COutstandingOpKnown";
      s += "(";
      s += Dafny.Helpers.ToString(this._v);
      s += ", ";
      s += Dafny.Helpers.ToString(this._bal);
      s += ")";
      return s;
    }
  }
  public class COutstandingOperation_COutstandingOpUnknown : COutstandingOperation {
    public COutstandingOperation_COutstandingOpUnknown() {
    }
    public override _ICOutstandingOperation DowncastClone() {
      if (this is _ICOutstandingOperation dt) { return dt; }
      return new COutstandingOperation_COutstandingOpUnknown();
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____ExecutorModel__i_Compile.COutstandingOperation_COutstandingOpUnknown;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____ExecutorModel__i_Compile.COutstandingOperation.COutstandingOpUnknown";
      return s;
    }
  }

  public interface _ICExecutor {
    bool is_CExecutor { get; }
    LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants dtor_constants { get; }
    ulong dtor_app { get; }
    BigInteger dtor_ops__complete { get; }
    LiveByzRSL____CTypes__i_Compile._ICBallot dtor_max__bal__reflected { get; }
    LiveByzRSL____ExecutorModel__i_Compile._ICOutstandingOperation dtor_next__op__to__execute { get; }
    Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> dtor_reply__cache { get; }
    _ICExecutor DowncastClone();
  }
  public class CExecutor : _ICExecutor {
    public readonly LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants _constants;
    public readonly ulong _app;
    public readonly BigInteger _ops__complete;
    public readonly LiveByzRSL____CTypes__i_Compile._ICBallot _max__bal__reflected;
    public readonly LiveByzRSL____ExecutorModel__i_Compile._ICOutstandingOperation _next__op__to__execute;
    public readonly Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> _reply__cache;
    public CExecutor(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, ulong app, BigInteger ops__complete, LiveByzRSL____CTypes__i_Compile._ICBallot max__bal__reflected, LiveByzRSL____ExecutorModel__i_Compile._ICOutstandingOperation next__op__to__execute, Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> reply__cache) {
      this._constants = constants;
      this._app = app;
      this._ops__complete = ops__complete;
      this._max__bal__reflected = max__bal__reflected;
      this._next__op__to__execute = next__op__to__execute;
      this._reply__cache = reply__cache;
    }
    public _ICExecutor DowncastClone() {
      if (this is _ICExecutor dt) { return dt; }
      return new CExecutor(_constants, _app, _ops__complete, _max__bal__reflected, _next__op__to__execute, _reply__cache);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____ExecutorModel__i_Compile.CExecutor;
      return oth != null && object.Equals(this._constants, oth._constants) && this._app == oth._app && this._ops__complete == oth._ops__complete && object.Equals(this._max__bal__reflected, oth._max__bal__reflected) && object.Equals(this._next__op__to__execute, oth._next__op__to__execute) && object.Equals(this._reply__cache, oth._reply__cache);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._constants));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._app));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ops__complete));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__bal__reflected));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._next__op__to__execute));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._reply__cache));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____ExecutorModel__i_Compile.CExecutor.CExecutor";
      s += "(";
      s += Dafny.Helpers.ToString(this._constants);
      s += ", ";
      s += Dafny.Helpers.ToString(this._app);
      s += ", ";
      s += Dafny.Helpers.ToString(this._ops__complete);
      s += ", ";
      s += Dafny.Helpers.ToString(this._max__bal__reflected);
      s += ", ";
      s += Dafny.Helpers.ToString(this._next__op__to__execute);
      s += ", ";
      s += Dafny.Helpers.ToString(this._reply__cache);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____ExecutorModel__i_Compile._ICExecutor theDefault = create(LiveByzRSL____ConstantsState__i_Compile.CReplicaConstants.Default(), 0, BigInteger.Zero, LiveByzRSL____CTypes__i_Compile.CBallot.Default(), LiveByzRSL____ExecutorModel__i_Compile.COutstandingOperation.Default(), Dafny.Map<Native____Io__s_Compile._IEndPoint, LiveByzRSL____CTypes__i_Compile._ICReply>.Empty);
    public static LiveByzRSL____ExecutorModel__i_Compile._ICExecutor Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>(LiveByzRSL____ExecutorModel__i_Compile.CExecutor.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICExecutor create(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, ulong app, BigInteger ops__complete, LiveByzRSL____CTypes__i_Compile._ICBallot max__bal__reflected, LiveByzRSL____ExecutorModel__i_Compile._ICOutstandingOperation next__op__to__execute, Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> reply__cache) {
      return new CExecutor(constants, app, ops__complete, max__bal__reflected, next__op__to__execute, reply__cache);
    }
    public static _ICExecutor create_CExecutor(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, ulong app, BigInteger ops__complete, LiveByzRSL____CTypes__i_Compile._ICBallot max__bal__reflected, LiveByzRSL____ExecutorModel__i_Compile._ICOutstandingOperation next__op__to__execute, Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> reply__cache) {
      return create(constants, app, ops__complete, max__bal__reflected, next__op__to__execute, reply__cache);
    }
    public bool is_CExecutor { get { return true; } }
    public LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants dtor_constants {
      get {
        return this._constants;
      }
    }
    public ulong dtor_app {
      get {
        return this._app;
      }
    }
    public BigInteger dtor_ops__complete {
      get {
        return this._ops__complete;
      }
    }
    public LiveByzRSL____CTypes__i_Compile._ICBallot dtor_max__bal__reflected {
      get {
        return this._max__bal__reflected;
      }
    }
    public LiveByzRSL____ExecutorModel__i_Compile._ICOutstandingOperation dtor_next__op__to__execute {
      get {
        return this._next__op__to__execute;
      }
    }
    public Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> dtor_reply__cache {
      get {
        return this._reply__cache;
      }
    }
  }

  public partial class __default {
    public static LiveByzRSL____ExecutorModel__i_Compile._ICExecutor CExecutorInit(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants c) {
      LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants _474_t1 = c;
      ulong _475_t2 = LiveByzRSL____AppInterface__i_Compile.__default.CAppStateInit();
      BigInteger _476_t3 = BigInteger.Zero;
      LiveByzRSL____CTypes__i_Compile._ICBallot _477_t4 = LiveByzRSL____CTypes__i_Compile.CBallot.create(BigInteger.Zero, BigInteger.Zero);
      LiveByzRSL____ExecutorModel__i_Compile._ICOutstandingOperation _478_t5 = LiveByzRSL____ExecutorModel__i_Compile.COutstandingOperation.create_COutstandingOpUnknown();
      Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> _479_t6 = Dafny.Map<Native____Io__s_Compile._IEndPoint, LiveByzRSL____CTypes__i_Compile._ICReply>.FromElements();
      return LiveByzRSL____ExecutorModel__i_Compile.CExecutor.create(_474_t1, _475_t2, _476_t3, _477_t4, _478_t5, _479_t6);
    }
    public static LiveByzRSL____ExecutorModel__i_Compile._ICExecutor CExecutorGetDecision(LiveByzRSL____ExecutorModel__i_Compile._ICExecutor s, LiveByzRSL____CTypes__i_Compile._ICBallot bal, BigInteger opn, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> v)
    {
      var _pat_let_tv116 = v;
      var _pat_let_tv117 = bal;
      LiveByzRSL____ExecutorModel__i_Compile._ICExecutor _480_t1 = Dafny.Helpers.Let<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>(s, _pat_let145_0 => Dafny.Helpers.Let<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>(_pat_let145_0, _481_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____ExecutorModel__i_Compile._ICOutstandingOperation, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>(LiveByzRSL____ExecutorModel__i_Compile.COutstandingOperation.create_COutstandingOpKnown(_pat_let_tv116, _pat_let_tv117), _pat_let146_0 => Dafny.Helpers.Let<LiveByzRSL____ExecutorModel__i_Compile._ICOutstandingOperation, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>(_pat_let146_0, _482_dt__update_hnext__op__to__execute_h0 => LiveByzRSL____ExecutorModel__i_Compile.CExecutor.create((_481_dt__update__tmp_h0).dtor_constants, (_481_dt__update__tmp_h0).dtor_app, (_481_dt__update__tmp_h0).dtor_ops__complete, (_481_dt__update__tmp_h0).dtor_max__bal__reflected, _482_dt__update_hnext__op__to__execute_h0, (_481_dt__update__tmp_h0).dtor_reply__cache)))));
      return _480_t1;
    }
    public static Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> CGetPacketsFromReplies(Native____Io__s_Compile._IEndPoint me, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> requests, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply> replies)
    {
      Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _483___accumulator = Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((requests).Count)).Sign == 0) {
        return Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.Concat(_483___accumulator, Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements());
      } else {
        _483___accumulator = Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.Concat(_483___accumulator, Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements(LiveByzRSL____CMessage__i_Compile.CPacket.create(((requests).Select(BigInteger.Zero)).dtor_client, me, LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__Reply(((requests).Select(BigInteger.Zero)).dtor_seqno, ((replies).Select(BigInteger.Zero)).dtor_reply))));
        Native____Io__s_Compile._IEndPoint _in12 = me;
        Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _in13 = (requests).Drop(BigInteger.One);
        Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply> _in14 = (replies).Drop(BigInteger.One);
        me = _in12;
        requests = _in13;
        replies = _in14;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> CClientsInReplies(Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply> replies) {
      Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> _484_r = (((new BigInteger((replies).Count)).Sign == 0) ? (Dafny.Map<Native____Io__s_Compile._IEndPoint, LiveByzRSL____CTypes__i_Compile._ICReply>.FromElements()) : (Dafny.Map<Native____Io__s_Compile._IEndPoint, LiveByzRSL____CTypes__i_Compile._ICReply>.Update(LiveByzRSL____ExecutorModel__i_Compile.__default.CClientsInReplies((replies).Drop(BigInteger.One)), ((replies).Select(BigInteger.Zero)).dtor_client, (replies).Select(BigInteger.Zero))));
      return _484_r;
    }
    public static Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> CUpdateNewCache(Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> c, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply> replies)
    {
      var _pat_let_tv118 = c;
      Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply> _485_t1 = Dafny.Helpers.Let<Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>, Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>>(LiveByzRSL____ExecutorModel__i_Compile.__default.CClientsInReplies(replies), _pat_let147_0 => Dafny.Helpers.Let<Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>, Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>>(_pat_let147_0, _486_nc => Dafny.Helpers.Let<Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>, Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>>(Dafny.Helpers.Id<Func<Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>, Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>, Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>>>((_487_c, _488_nc) => ((System.Func<Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>>)(() => {
        var _coll7 = new System.Collections.Generic.List<Dafny.Pair<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>>();
        foreach (Native____Io__s_Compile._IEndPoint _compr_7 in (Dafny.Set<Native____Io__s_Compile._IEndPoint>.Union((_487_c).Keys, (_488_nc).Keys)).Elements) {
          Native____Io__s_Compile._IEndPoint _489_client = (Native____Io__s_Compile._IEndPoint)_compr_7;
          if ((Dafny.Set<Native____Io__s_Compile._IEndPoint>.Union((_487_c).Keys, (_488_nc).Keys)).Contains((_489_client))) {
            _coll7.Add(new Dafny.Pair<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>(_489_client, (((_487_c).Contains((_489_client))) ? (Dafny.Map<Native____Io__s_Compile._IEndPoint, LiveByzRSL____CTypes__i_Compile._ICReply>.Select(_487_c,_489_client)) : (Dafny.Map<Native____Io__s_Compile._IEndPoint, LiveByzRSL____CTypes__i_Compile._ICReply>.Select(_488_nc,_489_client)))));
          }
        }
        return Dafny.Map<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>.FromCollection(_coll7);
      }))())(_pat_let_tv118, _486_nc), _pat_let148_0 => Dafny.Helpers.Let<Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>, Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>>(_pat_let148_0, _490_t1 => _490_t1))));
      return _485_t1;
    }
    public static _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CExecutorExecute(LiveByzRSL____ExecutorModel__i_Compile._ICExecutor s) {
      var _pat_let_tv119 = s;
      var _pat_let_tv120 = s;
      var _pat_let_tv121 = s;
      var _pat_let_tv122 = s;
      var _pat_let_tv123 = s;
      var _pat_let_tv124 = s;
      var _pat_let_tv125 = s;
      var _pat_let_tv126 = s;
      var _pat_let_tv127 = s;
      var _pat_let_tv128 = s;
      _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor> _491_t1 = Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>>(((s).dtor_next__op__to__execute).dtor_v, _pat_let149_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>>(_pat_let149_0, _492_batch => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>>(Dafny.Helpers.Let<_System._ITuple2<Dafny.ISequence<ulong>, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply>>, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CStateMachine__i_Compile.__default.CHandleRequestBatch((_pat_let_tv119).dtor_app, _492_batch), _pat_let151_0 => Dafny.Helpers.Let<_System._ITuple2<Dafny.ISequence<ulong>, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply>>, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let151_0, _493_temp => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<ulong, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>>(((_493_temp).dtor__0).Select((new BigInteger(((_493_temp).dtor__0).Count)) - (BigInteger.One)), _pat_let153_0 => Dafny.Helpers.Let<ulong, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>>(_pat_let153_0, _494_new__state => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>>(Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply>, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>((_493_temp).dtor__1, _pat_let155_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICReply>, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let155_0, _495_replies => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____ExecutorModel__i_Compile.__default.CClientsInReplies(_495_replies), _pat_let157_0 => Dafny.Helpers.Let<Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let157_0, _496_clients => Dafny.Helpers.Let<LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>((_pat_let_tv120).dtor_constants, _pat_let158_0 => Dafny.Helpers.Let<LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let158_0, _497_t1 => Dafny.Helpers.Let<ulong, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_494_new__state, _pat_let159_0 => Dafny.Helpers.Let<ulong, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let159_0, _498_t2 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(((_pat_let_tv121).dtor_ops__complete) + (BigInteger.One), _pat_let160_0 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let160_0, _499_t3 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(((LiveByzRSL____CTypes__i_Compile.__default.CBalLeq((_pat_let_tv124).dtor_max__bal__reflected, ((_pat_let_tv125).dtor_next__op__to__execute).dtor_bal)) ? (((_pat_let_tv122).dtor_next__op__to__execute).dtor_bal) : ((_pat_let_tv123).dtor_max__bal__reflected)), _pat_let161_0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let161_0, _500_t4 => Dafny.Helpers.Let<LiveByzRSL____ExecutorModel__i_Compile._ICOutstandingOperation, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____ExecutorModel__i_Compile.COutstandingOperation.create_COutstandingOpUnknown(), _pat_let162_0 => Dafny.Helpers.Let<LiveByzRSL____ExecutorModel__i_Compile._ICOutstandingOperation, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let162_0, _501_t5 => Dafny.Helpers.Let<Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____ExecutorModel__i_Compile.__default.CUpdateNewCache((_pat_let_tv126).dtor_reply__cache, _495_replies), _pat_let163_0 => Dafny.Helpers.Let<Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____CTypes__i_Compile._ICReply>, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let163_0, _502_t6 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_PacketSequence(LiveByzRSL____ExecutorModel__i_Compile.__default.CGetPacketsFromReplies((((((_pat_let_tv127).dtor_constants).dtor_all).dtor_config)).Select(((_pat_let_tv128).dtor_constants).dtor_my__index), _492_batch, _495_replies)), _pat_let164_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let164_0, _503_t7 => _System.Tuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(LiveByzRSL____ExecutorModel__i_Compile.CExecutor.create(_497_t1, _498_t2, _499_t3, _500_t4, _501_t5, _502_t6), _503_t7))))))))))))))))), _pat_let156_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let156_0, _504_t1 => _System.Tuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_504_t1).dtor__0, (_504_t1).dtor__1))))), _pat_let154_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>>(_pat_let154_0, _505_t1 => _System.Tuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>.create((_505_t1).dtor__1, (_505_t1).dtor__0))))), _pat_let152_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let152_0, _506_t1 => _System.Tuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_506_t1).dtor__1, (_506_t1).dtor__0))))), _pat_let150_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>>(_pat_let150_0, _507_t1 => _System.Tuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor>.create((_507_t1).dtor__1, (_507_t1).dtor__0)))));
      return _System.Tuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_491_t1).dtor__1, (_491_t1).dtor__0);
    }
    public static _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CExecutorProcessStartingPhase2(LiveByzRSL____ExecutorModel__i_Compile._ICExecutor s, LiveByzRSL____CMessage__i_Compile._ICPacket inp)
    {
      _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _508_t1 = ((((((((s).dtor_constants).dtor_all).dtor_config)).Contains(((inp).dtor_src))) && ((((inp).dtor_msg).dtor_logTruncationPoint__2) > ((s).dtor_ops__complete))) ? (Dafny.Helpers.Let<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(s, _pat_let165_0 => Dafny.Helpers.Let<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let165_0, _509_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop()), _pat_let166_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let166_0, _510_t2 => _System.Tuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_509_t1, _510_t2)))))) : (Dafny.Helpers.Let<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(s, _pat_let167_0 => Dafny.Helpers.Let<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let167_0, _511_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop()), _pat_let168_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let168_0, _512_t2 => _System.Tuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_511_t1, _512_t2)))))));
      return _System.Tuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_508_t1).dtor__0, (_508_t1).dtor__1);
    }
    public static LiveByzRSL____CMessage__i_Compile._IOutboundPackets CExecutorProcessRequest(LiveByzRSL____ExecutorModel__i_Compile._ICExecutor s, LiveByzRSL____CMessage__i_Compile._ICPacket inp)
    {
      var _pat_let_tv129 = s;
      var _pat_let_tv130 = s;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _513_t1 = ((((((inp).dtor_msg).dtor_seqno__req) == ((Dafny.Map<Native____Io__s_Compile._IEndPoint, LiveByzRSL____CTypes__i_Compile._ICReply>.Select((s).dtor_reply__cache,(inp).dtor_src)).dtor_seqno)) && (LiveByzRSL____ConstantsState__i_Compile.__default.CReplicaConstantsValid((s).dtor_constants))) ? (Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>(Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICReply, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>(Dafny.Map<Native____Io__s_Compile._IEndPoint, LiveByzRSL____CTypes__i_Compile._ICReply>.Select((s).dtor_reply__cache,(inp).dtor_src), _pat_let170_0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICReply, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>(_pat_let170_0, _514_r => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_PacketSequence(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements(LiveByzRSL____CMessage__i_Compile.CPacket.create((_514_r).dtor_client, (((((_pat_let_tv129).dtor_constants).dtor_all).dtor_config)).Select(((_pat_let_tv130).dtor_constants).dtor_my__index), LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__Reply((_514_r).dtor_seqno, (_514_r).dtor_reply)))), _pat_let171_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>(_pat_let171_0, _515_t1 => _515_t1)))), _pat_let169_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>(_pat_let169_0, _516_t1 => _516_t1))) : (Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_PacketSequence(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements()), _pat_let172_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>(_pat_let172_0, _517_t1 => _517_t1))));
      return _513_t1;
    }
  }
} // end of namespace LiveByzRSL____ExecutorModel__i_Compile
namespace LiveByzRSL____LearnerModel__i_Compile {

  public interface _ICLearnerTuple {
    bool is_CLearnerTuple { get; }
    Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> dtor_received__2bs { get; }
  }
  public class CLearnerTuple : _ICLearnerTuple {
    public readonly Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _received__2bs;
    public CLearnerTuple(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> received__2bs) {
      this._received__2bs = received__2bs;
    }
    public static Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> DowncastClone(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _this) {
      return _this;
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____LearnerModel__i_Compile.CLearnerTuple;
      return oth != null && object.Equals(this._received__2bs, oth._received__2bs);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._received__2bs));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____LearnerModel__i_Compile.CLearnerTuple.CLearnerTuple";
      s += "(";
      s += Dafny.Helpers.ToString(this._received__2bs);
      s += ")";
      return s;
    }
    private static readonly Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> theDefault = Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.Empty;
    public static Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICLearnerTuple create(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> received__2bs) {
      return new CLearnerTuple(received__2bs);
    }
    public static _ICLearnerTuple create_CLearnerTuple(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> received__2bs) {
      return create(received__2bs);
    }
    public bool is_CLearnerTuple { get { return true; } }
    public Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> dtor_received__2bs {
      get {
        return this._received__2bs;
      }
    }
  }

  public interface _ICLearner {
    bool is_CLearner { get; }
    LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants dtor_constants { get; }
    LiveByzRSL____CTypes__i_Compile._ICBallot dtor_max__ballot__seen { get; }
    Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> dtor_unexecuted__learner__state { get; }
    _ICLearner DowncastClone();
  }
  public class CLearner : _ICLearner {
    public readonly LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants _constants;
    public readonly LiveByzRSL____CTypes__i_Compile._ICBallot _max__ballot__seen;
    public readonly Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> _unexecuted__learner__state;
    public CLearner(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, LiveByzRSL____CTypes__i_Compile._ICBallot max__ballot__seen, Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> unexecuted__learner__state) {
      this._constants = constants;
      this._max__ballot__seen = max__ballot__seen;
      this._unexecuted__learner__state = unexecuted__learner__state;
    }
    public _ICLearner DowncastClone() {
      if (this is _ICLearner dt) { return dt; }
      return new CLearner(_constants, _max__ballot__seen, _unexecuted__learner__state);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____LearnerModel__i_Compile.CLearner;
      return oth != null && object.Equals(this._constants, oth._constants) && object.Equals(this._max__ballot__seen, oth._max__ballot__seen) && object.Equals(this._unexecuted__learner__state, oth._unexecuted__learner__state);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._constants));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__ballot__seen));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._unexecuted__learner__state));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____LearnerModel__i_Compile.CLearner.CLearner";
      s += "(";
      s += Dafny.Helpers.ToString(this._constants);
      s += ", ";
      s += Dafny.Helpers.ToString(this._max__ballot__seen);
      s += ", ";
      s += Dafny.Helpers.ToString(this._unexecuted__learner__state);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____LearnerModel__i_Compile._ICLearner theDefault = create(LiveByzRSL____ConstantsState__i_Compile.CReplicaConstants.Default(), LiveByzRSL____CTypes__i_Compile.CBallot.Default(), Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Empty);
    public static LiveByzRSL____LearnerModel__i_Compile._ICLearner Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____LearnerModel__i_Compile._ICLearner> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____LearnerModel__i_Compile._ICLearner>(LiveByzRSL____LearnerModel__i_Compile.CLearner.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____LearnerModel__i_Compile._ICLearner> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICLearner create(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, LiveByzRSL____CTypes__i_Compile._ICBallot max__ballot__seen, Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> unexecuted__learner__state) {
      return new CLearner(constants, max__ballot__seen, unexecuted__learner__state);
    }
    public static _ICLearner create_CLearner(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, LiveByzRSL____CTypes__i_Compile._ICBallot max__ballot__seen, Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> unexecuted__learner__state) {
      return create(constants, max__ballot__seen, unexecuted__learner__state);
    }
    public bool is_CLearner { get { return true; } }
    public LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants dtor_constants {
      get {
        return this._constants;
      }
    }
    public LiveByzRSL____CTypes__i_Compile._ICBallot dtor_max__ballot__seen {
      get {
        return this._max__ballot__seen;
      }
    }
    public Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> dtor_unexecuted__learner__state {
      get {
        return this._unexecuted__learner__state;
      }
    }
  }

  public partial class __default {
    public static BigInteger CCountMatchedValInReceived2bs(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> s, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> v)
    {
      BigInteger _518___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return (BigInteger.Zero) + (_518___accumulator);
      } else {
        _518___accumulator = (((((((s).Select((new BigInteger((s).Count)) - (BigInteger.One))).dtor_msg).dtor_val__2b).Equals((v))) ? (BigInteger.One) : (BigInteger.Zero))) + (_518___accumulator);
        Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _in15 = (s).Take((new BigInteger((s).Count)) - (BigInteger.One));
        Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _in16 = v;
        s = _in15;
        v = _in16;
        goto TAIL_CALL_START;
      }
    }
    public static bool CIsWeakQuorumSendSame2b(Dafny.ISequence<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>> vals, BigInteger n)
    {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>, BigInteger, bool>>((_519_vals, _520_n) => Dafny.Helpers.Quantifier<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>((_519_vals).UniqueElements, false, (((_exists_var_6) => {
        Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _521_v = (Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>)_exists_var_6;
        return ((_519_vals).Contains((_521_v))) && ((LiveByzRSL____AcceptorModel__i_Compile.__default.CCountMatchedInRequestBatches(_519_vals, _521_v)) >= (_520_n));
      }))))(vals, n);
    }
    public static bool CHasReceivedSame2bFromWeakQuorum(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> tup, BigInteger n)
    {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, BigInteger, bool>>((_522_tup, _523_n) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>(((_522_tup)).UniqueElements, false, (((_exists_var_7) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _524_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_exists_var_7;
        return (((_522_tup)).Contains((_524_p))) && ((LiveByzRSL____LearnerModel__i_Compile.__default.CCountMatchedValInReceived2bs((_522_tup), ((_524_p).dtor_msg).dtor_val__2b)) >= (_523_n));
      }))))(tup, n);
    }
    public static bool CLearnerTupleIsUniqueSeq(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> tup) {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, bool>>((_525_tup) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger(((_525_tup)).Count)), true, (((_forall_var_8) => {
        BigInteger _526_i = (BigInteger)_forall_var_8;
        return Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger(((_525_tup)).Count)), true, (((_forall_var_9) => {
          BigInteger _527_j = (BigInteger)_forall_var_9;
          return !(((((_526_i).Sign != -1) && ((_526_i) < (new BigInteger(((_525_tup)).Count)))) && (((_527_j).Sign != -1) && ((_527_j) < (new BigInteger(((_525_tup)).Count))))) && ((_526_i) != (_527_j))) || ((!object.Equals(((_525_tup)).Select(_526_i), ((_525_tup)).Select(_527_j))) && (!object.Equals((((_525_tup)).Select(_526_i)).dtor_src, (((_525_tup)).Select(_527_j)).dtor_src)));
        })));
      }))))(tup);
    }
    public static bool CLearnerTupleCorrect(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> tup, LiveByzRSL____CTypes__i_Compile._ICBallot bal, BigInteger opn, Dafny.ISequence<Native____Io__s_Compile._IEndPoint> c)
    {
      return ((new BigInteger(((tup)).Count)) <= (new BigInteger(((c)).Count))) && (Dafny.Helpers.Id<Func<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, BigInteger, LiveByzRSL____CTypes__i_Compile._ICBallot, Dafny.ISequence<Native____Io__s_Compile._IEndPoint>, bool>>((_528_tup, _529_opn, _530_bal, _531_c) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>(((_528_tup)).UniqueElements, true, (((_forall_var_10) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _532_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_forall_var_10;
        return !(((_528_tup)).Contains((_532_p))) || ((((((_532_p).dtor_msg).is_CMessage__2b) && ((((_532_p).dtor_msg).dtor_opn__2b) == (_529_opn))) && (object.Equals(((_532_p).dtor_msg).dtor_bal__2b, _530_bal))) && (((_531_c)).Contains(((_532_p).dtor_src))));
      }))))(tup, opn, bal, c));
    }
    public static bool CLearnerStateCorrect(Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> ls, LiveByzRSL____CTypes__i_Compile._ICBallot bal, Dafny.ISequence<Native____Io__s_Compile._IEndPoint> c)
    {
      return Dafny.Helpers.Id<Func<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____CTypes__i_Compile._ICBallot, Dafny.ISequence<Native____Io__s_Compile._IEndPoint>, bool>>((_533_ls, _534_bal, _535_c) => Dafny.Helpers.Quantifier<BigInteger>((_533_ls).Keys.Elements, true, (((_forall_var_11) => {
        BigInteger _536_opn = (BigInteger)_forall_var_11;
        return !((_533_ls).Contains((_536_opn))) || ((LiveByzRSL____LearnerModel__i_Compile.__default.CLearnerTupleCorrect(Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select(_533_ls,_536_opn), _534_bal, _536_opn, _535_c)) && (LiveByzRSL____LearnerModel__i_Compile.__default.CLearnerTupleIsUniqueSeq(Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select(_533_ls,_536_opn))));
      }))))(ls, bal, c);
    }
    public static LiveByzRSL____LearnerModel__i_Compile._ICLearner CLearnerInit(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants c) {
      LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants _537_t1 = c;
      LiveByzRSL____CTypes__i_Compile._ICBallot _538_t2 = LiveByzRSL____CTypes__i_Compile.CBallot.create(BigInteger.Zero, BigInteger.Zero);
      Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>> _539_t3 = Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.FromElements();
      return LiveByzRSL____LearnerModel__i_Compile.CLearner.create(_537_t1, _538_t2, _539_t3);
    }
    public static LiveByzRSL____LearnerModel__i_Compile._ICLearner CLearnerProcess2b(LiveByzRSL____LearnerModel__i_Compile._ICLearner s, LiveByzRSL____CMessage__i_Compile._ICPacket packet)
    {
      var _pat_let_tv131 = s;
      var _pat_let_tv132 = packet;
      var _pat_let_tv133 = s;
      var _pat_let_tv134 = packet;
      var _pat_let_tv135 = s;
      var _pat_let_tv136 = s;
      var _pat_let_tv137 = s;
      var _pat_let_tv138 = s;
      var _pat_let_tv139 = packet;
      var _pat_let_tv140 = s;
      var _pat_let_tv141 = s;
      var _pat_let_tv142 = s;
      var _pat_let_tv143 = packet;
      var _pat_let_tv144 = s;
      var _pat_let_tv145 = s;
      var _pat_let_tv146 = s;
      var _pat_let_tv147 = packet;
      var _pat_let_tv148 = s;
      LiveByzRSL____LearnerModel__i_Compile._ICLearner _540_t1 = Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._ICMessage, LiveByzRSL____LearnerModel__i_Compile._ICLearner>((packet).dtor_msg, _pat_let173_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._ICMessage, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let173_0, _541_m => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Helpers.Let<BigInteger, LiveByzRSL____LearnerModel__i_Compile._ICLearner>((_541_m).dtor_opn__2b, _pat_let175_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let175_0, _542_opn => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>((((!(((((_pat_let_tv146).dtor_constants).dtor_all).dtor_config)).Contains(((_pat_let_tv147).dtor_src))) || (LiveByzRSL____CTypes__i_Compile.__default.CBalLt((_541_m).dtor_bal__2b, (_pat_let_tv148).dtor_max__ballot__seen))) ? (Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let_tv131, _pat_let177_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let177_0, _543_t1 => _543_t1))) : (Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(((LiveByzRSL____CTypes__i_Compile.__default.CBalLt((_pat_let_tv145).dtor_max__ballot__seen, (_541_m).dtor_bal__2b)) ? (Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements(_pat_let_tv132), _pat_let180_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let180_0, _544_tup_k => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let_tv133, _pat_let182_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let182_0, _545_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.FromElements(new Dafny.Pair<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>(_542_opn, _544_tup_k)), _pat_let183_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let183_0, _546_dt__update_hunexecuted__learner__state_h0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, LiveByzRSL____LearnerModel__i_Compile._ICLearner>((_541_m).dtor_bal__2b, _pat_let184_0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let184_0, _547_dt__update_hmax__ballot__seen_h0 => LiveByzRSL____LearnerModel__i_Compile.CLearner.create((_545_dt__update__tmp_h0).dtor_constants, _547_dt__update_hmax__ballot__seen_h0, _546_dt__update_hunexecuted__learner__state_h0))))))), _pat_let181_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let181_0, _548_t1 => _548_t1)))), _pat_let179_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let179_0, _549_t1 => _549_t1))) : (Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(((!((_pat_let_tv144).dtor_unexecuted__learner__state).Contains((_542_opn))) ? (Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements(_pat_let_tv134), _pat_let187_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let187_0, _550_tup_k => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let_tv135, _pat_let189_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let189_0, _551_dt__update__tmp_h1 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Update((_pat_let_tv136).dtor_unexecuted__learner__state, _542_opn, _550_tup_k), _pat_let190_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let190_0, _552_dt__update_hunexecuted__learner__state_h1 => LiveByzRSL____LearnerModel__i_Compile.CLearner.create((_551_dt__update__tmp_h1).dtor_constants, (_551_dt__update__tmp_h1).dtor_max__ballot__seen, _552_dt__update_hunexecuted__learner__state_h1))))), _pat_let188_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let188_0, _553_t1 => _553_t1)))), _pat_let186_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let186_0, _554_t1 => _554_t1))) : (Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(((Dafny.Helpers.Id<Func<LiveByzRSL____LearnerModel__i_Compile._ICLearner, BigInteger, LiveByzRSL____CMessage__i_Compile._ICPacket, bool>>((_563_s, _564_opn, _565_packet) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>(((Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select((_563_s).dtor_unexecuted__learner__state,_564_opn))).UniqueElements, false, (((_exists_var_8) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _566_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_exists_var_8;
        return (((Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select((_563_s).dtor_unexecuted__learner__state,_564_opn))).Contains((_566_p))) && (object.Equals((_566_p).dtor_src, (_565_packet).dtor_src));
      }))))(_pat_let_tv142, _542_opn, _pat_let_tv143)) ? (Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let_tv137, _pat_let192_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let192_0, _555_t1 => _555_t1))) : (Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select((_pat_let_tv138).dtor_unexecuted__learner__state,_542_opn), _pat_let194_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let194_0, _556_tup => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.Concat((_556_tup), Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements(_pat_let_tv139)), _pat_let196_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let196_0, _557_tup_k => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let_tv140, _pat_let198_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let198_0, _558_dt__update__tmp_h4 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Update((_pat_let_tv141).dtor_unexecuted__learner__state, _542_opn, _557_tup_k), _pat_let199_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let199_0, _559_dt__update_hunexecuted__learner__state_h2 => LiveByzRSL____LearnerModel__i_Compile.CLearner.create((_558_dt__update__tmp_h4).dtor_constants, (_558_dt__update__tmp_h4).dtor_max__ballot__seen, _559_dt__update_hunexecuted__learner__state_h2))))), _pat_let197_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let197_0, _560_t1 => _560_t1)))), _pat_let195_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let195_0, _561_t1 => _561_t1)))), _pat_let193_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let193_0, _562_t1 => _562_t1)))), _pat_let191_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let191_0, _567_t1 => _567_t1)))), _pat_let185_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let185_0, _568_t1 => _568_t1)))), _pat_let178_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let178_0, _569_t1 => _569_t1)))), _pat_let176_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let176_0, _570_t1 => _570_t1)))), _pat_let174_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let174_0, _571_t1 => _571_t1))));
      return _540_t1;
    }
    public static LiveByzRSL____LearnerModel__i_Compile._ICLearner CLearnerForgetDecision(LiveByzRSL____LearnerModel__i_Compile._ICLearner s, BigInteger opn)
    {
      var _pat_let_tv149 = s;
      var _pat_let_tv150 = opn;
      LiveByzRSL____LearnerModel__i_Compile._ICLearner _572_t1 = ((((s).dtor_unexecuted__learner__state).Contains((opn))) ? (Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(s, _pat_let201_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let201_0, _573_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Collections____Maps__i_Compile.__default.RemoveElt<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>((_pat_let_tv149).dtor_unexecuted__learner__state, _pat_let_tv150), _pat_let202_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let202_0, _574_dt__update_hunexecuted__learner__state_h0 => LiveByzRSL____LearnerModel__i_Compile.CLearner.create((_573_dt__update__tmp_h0).dtor_constants, (_573_dt__update__tmp_h0).dtor_max__ballot__seen, _574_dt__update_hunexecuted__learner__state_h0))))), _pat_let200_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let200_0, _575_t1 => _575_t1))) : (Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(s, _pat_let203_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let203_0, _576_t1 => _576_t1))));
      return _572_t1;
    }
    public static LiveByzRSL____LearnerModel__i_Compile._ICLearner CLearnerForgetOperationsBefore(LiveByzRSL____LearnerModel__i_Compile._ICLearner s, BigInteger ops__complete)
    {
      var _pat_let_tv151 = s;
      var _pat_let_tv152 = ops__complete;
      LiveByzRSL____LearnerModel__i_Compile._ICLearner _577_t1 = Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(s, _pat_let204_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let204_0, _578_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(Dafny.Helpers.Id<Func<LiveByzRSL____LearnerModel__i_Compile._ICLearner, BigInteger, Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>>>((_579_s, _580_ops__complete) => ((System.Func<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>>)(() => {
        var _coll8 = new System.Collections.Generic.List<Dafny.Pair<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>>();
        foreach (BigInteger _compr_8 in ((_579_s).dtor_unexecuted__learner__state).Keys.Elements) {
          BigInteger _581_op = (BigInteger)_compr_8;
          if ((((_579_s).dtor_unexecuted__learner__state).Contains((_581_op))) && ((_581_op) >= (_580_ops__complete))) {
            _coll8.Add(new Dafny.Pair<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>(_581_op, Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select((_579_s).dtor_unexecuted__learner__state,_581_op)));
          }
        }
        return Dafny.Map<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.FromCollection(_coll8);
      }))())(_pat_let_tv151, _pat_let_tv152), _pat_let205_0 => Dafny.Helpers.Let<Dafny.IMap<BigInteger,Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>, LiveByzRSL____LearnerModel__i_Compile._ICLearner>(_pat_let205_0, _582_dt__update_hunexecuted__learner__state_h0 => LiveByzRSL____LearnerModel__i_Compile.CLearner.create((_578_dt__update__tmp_h0).dtor_constants, (_578_dt__update__tmp_h0).dtor_max__ballot__seen, _582_dt__update_hunexecuted__learner__state_h0)))));
      return _577_t1;
    }
  }
} // end of namespace LiveByzRSL____LearnerModel__i_Compile
namespace LiveByzRSL____CheckValSafetyImpl__i_Compile {

  public partial class __default {
    public static Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICMessage> CConvert1bPacketsSeqToMsgSeq(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> S) {
      Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICMessage> _583___accumulator = Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICMessage>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((S).Count)).Sign == 0) {
        return Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICMessage>.Concat(_583___accumulator, Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICMessage>.FromElements());
      } else {
        _583___accumulator = Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICMessage>.Concat(_583___accumulator, Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICMessage>.FromElements(((S).Select(BigInteger.Zero)).dtor_msg));
        Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _in17 = (S).Drop(BigInteger.One);
        S = _in17;
        goto TAIL_CALL_START;
      }
    }
    public static bool CSeqOfMessage1b(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> S) {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, bool>>((_584_S) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>((_584_S).UniqueElements, true, (((_forall_var_12) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _585_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_forall_var_12;
        return !((_584_S).Contains((_585_p))) || (((_585_p).dtor_msg).is_CMessage__1b);
      }))))(S);
    }
    public static bool CSetOfMessage1bAboutBallot(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> S, LiveByzRSL____CTypes__i_Compile._ICBallot b)
    {
      return (LiveByzRSL____CheckValSafetyImpl__i_Compile.__default.CSeqOfMessage1b(S)) && (Dafny.Helpers.Id<Func<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____CTypes__i_Compile._ICBallot, bool>>((_586_S, _587_b) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>((_586_S).UniqueElements, true, (((_forall_var_13) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _588_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_forall_var_13;
        return !((_586_S).Contains((_588_p))) || (object.Equals(((_588_p).dtor_msg).dtor_bal__1b, _587_b));
      }))))(S, b));
    }
    public static bool CAllAcceptorsHadNoProposal(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> S, BigInteger opn)
    {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, BigInteger, bool>>((_589_S, _590_opn) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>((_589_S).UniqueElements, true, (((_forall_var_14) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _591_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_forall_var_14;
        return !((_589_S).Contains((_591_p))) || (!((((_591_p).dtor_msg).dtor_votes).Contains((_590_opn))));
      }))))(S, opn);
    }
    public static BigInteger CCountInVotes(Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> v, LiveByzRSL____CTypes__i_Compile._ICBallot c, BigInteger opn, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> S)
    {
      BigInteger _592___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if ((new BigInteger((S).Count)).Sign == 0) {
        return (BigInteger.Zero) + (_592___accumulator);
      } else {
        _592___accumulator = (((((((((S).Select(BigInteger.Zero)).dtor_msg).dtor_votes).Contains((opn))) && (LiveByzRSL____CTypes__i_Compile.__default.CBalLeq(c, (Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Select((((S).Select(BigInteger.Zero)).dtor_msg).dtor_votes,opn)).dtor_max__value__bal))) && (((Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Select((((S).Select(BigInteger.Zero)).dtor_msg).dtor_votes,opn)).dtor_max__val).Equals((v)))) ? (BigInteger.One) : (BigInteger.Zero))) + (_592___accumulator);
        Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _in18 = v;
        LiveByzRSL____CTypes__i_Compile._ICBallot _in19 = c;
        BigInteger _in20 = opn;
        Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _in21 = (S).Drop(BigInteger.One);
        v = _in18;
        c = _in19;
        opn = _in20;
        S = _in21;
        goto TAIL_CALL_START;
      }
    }
    public static bool CSetOfMessage1b(Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> S) {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, bool>>((_593_S) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>((_593_S).UniqueElements, true, (((_forall_var_15) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _594_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_forall_var_15;
        return !((_593_S).Contains((_594_p))) || (((_594_p).dtor_msg).is_CMessage__1b);
      }))))(S);
    }
    public static bool Cmax__balInS(LiveByzRSL____CTypes__i_Compile._ICBallot c, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> S, BigInteger opn)
    {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, BigInteger, LiveByzRSL____CTypes__i_Compile._ICBallot, bool>>((_595_S, _596_opn, _597_c) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>((_595_S).UniqueElements, true, (((_forall_var_16) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _598_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_forall_var_16;
        return !(((_595_S).Contains((_598_p))) && ((((_598_p).dtor_msg).dtor_votes).Contains((_596_opn)))) || (LiveByzRSL____CTypes__i_Compile.__default.CBalLeq((Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Select(((_598_p).dtor_msg).dtor_votes,_596_opn)).dtor_max__value__bal, _597_c));
      }))))(S, opn, c);
    }
    public static bool CAllVotesWithLargerBalHasSameValue(Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> v, LiveByzRSL____CTypes__i_Compile._ICBallot b, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> p1bs, BigInteger opn)
    {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, BigInteger, LiveByzRSL____CTypes__i_Compile._ICBallot, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, bool>>((_599_p1bs, _600_opn, _601_b, _602_v) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>((_599_p1bs).UniqueElements, true, (((_forall_var_17) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _603_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_forall_var_17;
        return !((((_599_p1bs).Contains((_603_p))) && ((((_603_p).dtor_msg).dtor_votes).Contains((_600_opn)))) && (LiveByzRSL____CTypes__i_Compile.__default.CBalLeq(_601_b, (Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Select(((_603_p).dtor_msg).dtor_votes,_600_opn)).dtor_max__value__bal))) || (((Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Select(((_603_p).dtor_msg).dtor_votes,_600_opn)).dtor_max__val).Equals((_602_v)));
      }))))(p1bs, opn, b, v);
    }
    public static bool CValIsSafeAt(Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> v, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> p1bs, BigInteger opn, BigInteger byzq, BigInteger wq)
    {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, BigInteger, bool>>((_604_p1bs, _605_opn, _606_v, _607_wq) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>((_604_p1bs).UniqueElements, false, (((_exists_var_9) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _608_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_exists_var_9;
        return ((((_604_p1bs).Contains((_608_p))) && ((((_608_p).dtor_msg).dtor_votes).Contains((_605_opn)))) && ((LiveByzRSL____CheckValSafetyImpl__i_Compile.__default.CCountInVotes(_606_v, (Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Select(((_608_p).dtor_msg).dtor_votes,_605_opn)).dtor_max__value__bal, _605_opn, _604_p1bs)) >= (_607_wq))) && (LiveByzRSL____CheckValSafetyImpl__i_Compile.__default.CAllVotesWithLargerBalHasSameValue(_606_v, (Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Select(((_608_p).dtor_msg).dtor_votes,_605_opn)).dtor_max__value__bal, _604_p1bs, _605_opn));
      }))))(p1bs, opn, v, wq);
    }
  }
} // end of namespace LiveByzRSL____CheckValSafetyImpl__i_Compile
namespace LiveByzRSL____ProposerModel__i_Compile {

  public interface _ICIncompleteBatchTimer {
    bool is_CIncompleteBatchTimerOn { get; }
    bool is_CIncompleteBatchTimerOff { get; }
    BigInteger dtor_when { get; }
    _ICIncompleteBatchTimer DowncastClone();
  }
  public abstract class CIncompleteBatchTimer : _ICIncompleteBatchTimer {
    public CIncompleteBatchTimer() { }
    private static readonly LiveByzRSL____ProposerModel__i_Compile._ICIncompleteBatchTimer theDefault = create_CIncompleteBatchTimerOn(BigInteger.Zero);
    public static LiveByzRSL____ProposerModel__i_Compile._ICIncompleteBatchTimer Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____ProposerModel__i_Compile._ICIncompleteBatchTimer> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____ProposerModel__i_Compile._ICIncompleteBatchTimer>(LiveByzRSL____ProposerModel__i_Compile.CIncompleteBatchTimer.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____ProposerModel__i_Compile._ICIncompleteBatchTimer> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICIncompleteBatchTimer create_CIncompleteBatchTimerOn(BigInteger @when) {
      return new CIncompleteBatchTimer_CIncompleteBatchTimerOn(@when);
    }
    public static _ICIncompleteBatchTimer create_CIncompleteBatchTimerOff() {
      return new CIncompleteBatchTimer_CIncompleteBatchTimerOff();
    }
    public bool is_CIncompleteBatchTimerOn { get { return this is CIncompleteBatchTimer_CIncompleteBatchTimerOn; } }
    public bool is_CIncompleteBatchTimerOff { get { return this is CIncompleteBatchTimer_CIncompleteBatchTimerOff; } }
    public BigInteger dtor_when {
      get {
        var d = this;
        return ((CIncompleteBatchTimer_CIncompleteBatchTimerOn)d)._when;
      }
    }
    public abstract _ICIncompleteBatchTimer DowncastClone();
  }
  public class CIncompleteBatchTimer_CIncompleteBatchTimerOn : CIncompleteBatchTimer {
    public readonly BigInteger _when;
    public CIncompleteBatchTimer_CIncompleteBatchTimerOn(BigInteger @when) {
      this._when = @when;
    }
    public override _ICIncompleteBatchTimer DowncastClone() {
      if (this is _ICIncompleteBatchTimer dt) { return dt; }
      return new CIncompleteBatchTimer_CIncompleteBatchTimerOn(_when);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____ProposerModel__i_Compile.CIncompleteBatchTimer_CIncompleteBatchTimerOn;
      return oth != null && this._when == oth._when;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._when));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____ProposerModel__i_Compile.CIncompleteBatchTimer.CIncompleteBatchTimerOn";
      s += "(";
      s += Dafny.Helpers.ToString(this._when);
      s += ")";
      return s;
    }
  }
  public class CIncompleteBatchTimer_CIncompleteBatchTimerOff : CIncompleteBatchTimer {
    public CIncompleteBatchTimer_CIncompleteBatchTimerOff() {
    }
    public override _ICIncompleteBatchTimer DowncastClone() {
      if (this is _ICIncompleteBatchTimer dt) { return dt; }
      return new CIncompleteBatchTimer_CIncompleteBatchTimerOff();
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____ProposerModel__i_Compile.CIncompleteBatchTimer_CIncompleteBatchTimerOff;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____ProposerModel__i_Compile.CIncompleteBatchTimer.CIncompleteBatchTimerOff";
      return s;
    }
  }

  public interface _ICProposer {
    bool is_CProposer { get; }
    LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants dtor_constants { get; }
    BigInteger dtor_current__state { get; }
    Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_request__queue { get; }
    LiveByzRSL____CTypes__i_Compile._ICBallot dtor_max__ballot__i__sent__1a { get; }
    BigInteger dtor_next__operation__number__to__propose { get; }
    Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> dtor_received__1b__packets { get; }
    Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger> dtor_highest__seqno__requested__by__client__this__view { get; }
    LiveByzRSL____ProposerModel__i_Compile._ICIncompleteBatchTimer dtor_incomplete__batch__timer { get; }
    LiveByzRSL____ElectionModel__i_Compile._ICElectionState dtor_election__state { get; }
    _ICProposer DowncastClone();
  }
  public class CProposer : _ICProposer {
    public readonly LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants _constants;
    public readonly BigInteger _current__state;
    public readonly Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _request__queue;
    public readonly LiveByzRSL____CTypes__i_Compile._ICBallot _max__ballot__i__sent__1a;
    public readonly BigInteger _next__operation__number__to__propose;
    public readonly Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _received__1b__packets;
    public readonly Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger> _highest__seqno__requested__by__client__this__view;
    public readonly LiveByzRSL____ProposerModel__i_Compile._ICIncompleteBatchTimer _incomplete__batch__timer;
    public readonly LiveByzRSL____ElectionModel__i_Compile._ICElectionState _election__state;
    public CProposer(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, BigInteger current__state, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> request__queue, LiveByzRSL____CTypes__i_Compile._ICBallot max__ballot__i__sent__1a, BigInteger next__operation__number__to__propose, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> received__1b__packets, Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger> highest__seqno__requested__by__client__this__view, LiveByzRSL____ProposerModel__i_Compile._ICIncompleteBatchTimer incomplete__batch__timer, LiveByzRSL____ElectionModel__i_Compile._ICElectionState election__state) {
      this._constants = constants;
      this._current__state = current__state;
      this._request__queue = request__queue;
      this._max__ballot__i__sent__1a = max__ballot__i__sent__1a;
      this._next__operation__number__to__propose = next__operation__number__to__propose;
      this._received__1b__packets = received__1b__packets;
      this._highest__seqno__requested__by__client__this__view = highest__seqno__requested__by__client__this__view;
      this._incomplete__batch__timer = incomplete__batch__timer;
      this._election__state = election__state;
    }
    public _ICProposer DowncastClone() {
      if (this is _ICProposer dt) { return dt; }
      return new CProposer(_constants, _current__state, _request__queue, _max__ballot__i__sent__1a, _next__operation__number__to__propose, _received__1b__packets, _highest__seqno__requested__by__client__this__view, _incomplete__batch__timer, _election__state);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____ProposerModel__i_Compile.CProposer;
      return oth != null && object.Equals(this._constants, oth._constants) && this._current__state == oth._current__state && object.Equals(this._request__queue, oth._request__queue) && object.Equals(this._max__ballot__i__sent__1a, oth._max__ballot__i__sent__1a) && this._next__operation__number__to__propose == oth._next__operation__number__to__propose && object.Equals(this._received__1b__packets, oth._received__1b__packets) && object.Equals(this._highest__seqno__requested__by__client__this__view, oth._highest__seqno__requested__by__client__this__view) && object.Equals(this._incomplete__batch__timer, oth._incomplete__batch__timer) && object.Equals(this._election__state, oth._election__state);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._constants));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._current__state));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._request__queue));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._max__ballot__i__sent__1a));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._next__operation__number__to__propose));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._received__1b__packets));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._highest__seqno__requested__by__client__this__view));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._incomplete__batch__timer));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._election__state));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____ProposerModel__i_Compile.CProposer.CProposer";
      s += "(";
      s += Dafny.Helpers.ToString(this._constants);
      s += ", ";
      s += Dafny.Helpers.ToString(this._current__state);
      s += ", ";
      s += Dafny.Helpers.ToString(this._request__queue);
      s += ", ";
      s += Dafny.Helpers.ToString(this._max__ballot__i__sent__1a);
      s += ", ";
      s += Dafny.Helpers.ToString(this._next__operation__number__to__propose);
      s += ", ";
      s += Dafny.Helpers.ToString(this._received__1b__packets);
      s += ", ";
      s += Dafny.Helpers.ToString(this._highest__seqno__requested__by__client__this__view);
      s += ", ";
      s += Dafny.Helpers.ToString(this._incomplete__batch__timer);
      s += ", ";
      s += Dafny.Helpers.ToString(this._election__state);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____ProposerModel__i_Compile._ICProposer theDefault = create(LiveByzRSL____ConstantsState__i_Compile.CReplicaConstants.Default(), BigInteger.Zero, Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.Empty, LiveByzRSL____CTypes__i_Compile.CBallot.Default(), BigInteger.Zero, Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.Empty, Dafny.Map<Native____Io__s_Compile._IEndPoint, BigInteger>.Empty, LiveByzRSL____ProposerModel__i_Compile.CIncompleteBatchTimer.Default(), LiveByzRSL____ElectionModel__i_Compile.CElectionState.Default());
    public static LiveByzRSL____ProposerModel__i_Compile._ICProposer Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____ProposerModel__i_Compile._ICProposer> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____ProposerModel__i_Compile._ICProposer>(LiveByzRSL____ProposerModel__i_Compile.CProposer.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____ProposerModel__i_Compile._ICProposer> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICProposer create(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, BigInteger current__state, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> request__queue, LiveByzRSL____CTypes__i_Compile._ICBallot max__ballot__i__sent__1a, BigInteger next__operation__number__to__propose, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> received__1b__packets, Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger> highest__seqno__requested__by__client__this__view, LiveByzRSL____ProposerModel__i_Compile._ICIncompleteBatchTimer incomplete__batch__timer, LiveByzRSL____ElectionModel__i_Compile._ICElectionState election__state) {
      return new CProposer(constants, current__state, request__queue, max__ballot__i__sent__1a, next__operation__number__to__propose, received__1b__packets, highest__seqno__requested__by__client__this__view, incomplete__batch__timer, election__state);
    }
    public static _ICProposer create_CProposer(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, BigInteger current__state, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> request__queue, LiveByzRSL____CTypes__i_Compile._ICBallot max__ballot__i__sent__1a, BigInteger next__operation__number__to__propose, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> received__1b__packets, Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger> highest__seqno__requested__by__client__this__view, LiveByzRSL____ProposerModel__i_Compile._ICIncompleteBatchTimer incomplete__batch__timer, LiveByzRSL____ElectionModel__i_Compile._ICElectionState election__state) {
      return create(constants, current__state, request__queue, max__ballot__i__sent__1a, next__operation__number__to__propose, received__1b__packets, highest__seqno__requested__by__client__this__view, incomplete__batch__timer, election__state);
    }
    public bool is_CProposer { get { return true; } }
    public LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants dtor_constants {
      get {
        return this._constants;
      }
    }
    public BigInteger dtor_current__state {
      get {
        return this._current__state;
      }
    }
    public Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> dtor_request__queue {
      get {
        return this._request__queue;
      }
    }
    public LiveByzRSL____CTypes__i_Compile._ICBallot dtor_max__ballot__i__sent__1a {
      get {
        return this._max__ballot__i__sent__1a;
      }
    }
    public BigInteger dtor_next__operation__number__to__propose {
      get {
        return this._next__operation__number__to__propose;
      }
    }
    public Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> dtor_received__1b__packets {
      get {
        return this._received__1b__packets;
      }
    }
    public Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger> dtor_highest__seqno__requested__by__client__this__view {
      get {
        return this._highest__seqno__requested__by__client__this__view;
      }
    }
    public LiveByzRSL____ProposerModel__i_Compile._ICIncompleteBatchTimer dtor_incomplete__batch__timer {
      get {
        return this._incomplete__batch__timer;
      }
    }
    public LiveByzRSL____ElectionModel__i_Compile._ICElectionState dtor_election__state {
      get {
        return this._election__state;
      }
    }
  }

  public partial class __default {
    public static bool CIsAfterLogTruncationPoint(BigInteger opn, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> S)
    {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, BigInteger, bool>>((_609_S, _610_opn) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>((_609_S).UniqueElements, true, (((_forall_var_18) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _611_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_forall_var_18;
        return !(((_609_S).Contains((_611_p))) && (((_611_p).dtor_msg).is_CMessage__1b)) || ((((_611_p).dtor_msg).dtor_log__truncation__point) <= (_610_opn));
      }))))(S, opn);
    }
    public static bool CProposerCanNominateUsingOperationNumber(LiveByzRSL____ProposerModel__i_Compile._ICProposer s, BigInteger log__truncation__point, BigInteger opn)
    {
      return (((((((object.Equals(((s).dtor_election__state).dtor_current__view, (s).dtor_max__ballot__i__sent__1a)) && (((s).dtor_current__state) == (new BigInteger(2)))) && ((new BigInteger(((s).dtor_received__1b__packets).Count)) >= (LiveByzRSL____CConfiguration__i_Compile.__default.CByzQuorumSize((((s).dtor_constants).dtor_all).dtor_config)))) && (LiveByzRSL____CheckValSafetyImpl__i_Compile.__default.CSetOfMessage1bAboutBallot((s).dtor_received__1b__packets, (s).dtor_max__ballot__i__sent__1a))) && (LiveByzRSL____ProposerModel__i_Compile.__default.CIsAfterLogTruncationPoint(opn, (s).dtor_received__1b__packets))) && ((opn) < (Common____UpperBound__i_Compile.__default.UpperBoundedAdditionImpl(log__truncation__point, ((((s).dtor_constants).dtor_all).dtor_params).dtor_max__log__length, ((((s).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val)))) && ((opn).Sign != -1)) && (Common____UpperBound__i_Compile.__default.CLtUpperBound(opn, ((((s).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val));
    }
    public static LiveByzRSL____ProposerModel__i_Compile._ICProposer CProposerInit(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants c) {
      LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants _612_t1 = c;
      BigInteger _613_t2 = BigInteger.Zero;
      Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> _614_t3 = Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements();
      LiveByzRSL____CTypes__i_Compile._ICBallot _615_t4 = LiveByzRSL____CTypes__i_Compile.CBallot.create(BigInteger.Zero, (c).dtor_my__index);
      BigInteger _616_t5 = BigInteger.Zero;
      Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _617_t6 = Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements();
      Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger> _618_t7 = Dafny.Map<Native____Io__s_Compile._IEndPoint, BigInteger>.FromElements();
      LiveByzRSL____ElectionModel__i_Compile._ICElectionState _619_t8 = LiveByzRSL____ElectionModel__i_Compile.__default.CElectionStateInit(c);
      LiveByzRSL____ProposerModel__i_Compile._ICIncompleteBatchTimer _620_t9 = LiveByzRSL____ProposerModel__i_Compile.CIncompleteBatchTimer.create_CIncompleteBatchTimerOff();
      return LiveByzRSL____ProposerModel__i_Compile.CProposer.create(_612_t1, _613_t2, _614_t3, _615_t4, _616_t5, _617_t6, _618_t7, _620_t9, _619_t8);
    }
    public static LiveByzRSL____ProposerModel__i_Compile._ICProposer CProposerProcessRequest(LiveByzRSL____ProposerModel__i_Compile._ICProposer s, LiveByzRSL____CMessage__i_Compile._ICPacket packet)
    {
      var _pat_let_tv153 = s;
      var _pat_let_tv154 = s;
      var _pat_let_tv155 = s;
      var _pat_let_tv156 = s;
      var _pat_let_tv157 = s;
      var _pat_let_tv158 = s;
      var _pat_let_tv159 = s;
      var _pat_let_tv160 = s;
      LiveByzRSL____ProposerModel__i_Compile._ICProposer _621_t1 = Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICRequest, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(LiveByzRSL____CTypes__i_Compile.CRequest.create((packet).dtor_src, ((packet).dtor_msg).dtor_seqno__req, ((packet).dtor_msg).dtor_val), _pat_let206_0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICRequest, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let206_0, _622_val => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(LiveByzRSL____ElectionModel__i_Compile.__default.CElectionStateReflectReceivedRequest((_pat_let_tv153).dtor_election__state, _622_val), _pat_let207_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let207_0, _623_t1 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>((((((_pat_let_tv158).dtor_current__state).Sign != 0) && ((!((_pat_let_tv159).dtor_highest__seqno__requested__by__client__this__view).Contains(((_622_val).dtor_client))) || (((_622_val).dtor_seqno) > (Dafny.Map<Native____Io__s_Compile._IEndPoint, BigInteger>.Select((_pat_let_tv160).dtor_highest__seqno__requested__by__client__this__view,(_622_val).dtor_client))))) ? (Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let_tv154, _pat_let210_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let210_0, _624_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(Dafny.Map<Native____Io__s_Compile._IEndPoint, BigInteger>.Update((_pat_let_tv155).dtor_highest__seqno__requested__by__client__this__view, (_622_val).dtor_client, (_622_val).dtor_seqno), _pat_let211_0 => Dafny.Helpers.Let<Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let211_0, _625_dt__update_hhighest__seqno__requested__by__client__this__view_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.Concat((_pat_let_tv156).dtor_request__queue, Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements(_622_val)), _pat_let212_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let212_0, _626_dt__update_hrequest__queue_h0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_623_t1, _pat_let213_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let213_0, _627_dt__update_helection__state_h0 => LiveByzRSL____ProposerModel__i_Compile.CProposer.create((_624_dt__update__tmp_h0).dtor_constants, (_624_dt__update__tmp_h0).dtor_current__state, _626_dt__update_hrequest__queue_h0, (_624_dt__update__tmp_h0).dtor_max__ballot__i__sent__1a, (_624_dt__update__tmp_h0).dtor_next__operation__number__to__propose, (_624_dt__update__tmp_h0).dtor_received__1b__packets, _625_dt__update_hhighest__seqno__requested__by__client__this__view_h0, (_624_dt__update__tmp_h0).dtor_incomplete__batch__timer, _627_dt__update_helection__state_h0))))))))), _pat_let209_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let209_0, _628_t1 => _628_t1))) : (Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let_tv157, _pat_let215_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let215_0, _629_dt__update__tmp_h1 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_623_t1, _pat_let216_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let216_0, _630_dt__update_helection__state_h1 => LiveByzRSL____ProposerModel__i_Compile.CProposer.create((_629_dt__update__tmp_h1).dtor_constants, (_629_dt__update__tmp_h1).dtor_current__state, (_629_dt__update__tmp_h1).dtor_request__queue, (_629_dt__update__tmp_h1).dtor_max__ballot__i__sent__1a, (_629_dt__update__tmp_h1).dtor_next__operation__number__to__propose, (_629_dt__update__tmp_h1).dtor_received__1b__packets, (_629_dt__update__tmp_h1).dtor_highest__seqno__requested__by__client__this__view, (_629_dt__update__tmp_h1).dtor_incomplete__batch__timer, _630_dt__update_helection__state_h1))))), _pat_let214_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let214_0, _631_t1 => _631_t1)))), _pat_let208_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let208_0, _632_t2 => _632_t2))))));
      return _621_t1;
    }
    public static _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CProposerMaybeEnterNewViewAndSend1a(LiveByzRSL____ProposerModel__i_Compile._ICProposer s) {
      var _pat_let_tv161 = s;
      var _pat_let_tv162 = s;
      var _pat_let_tv163 = s;
      var _pat_let_tv164 = s;
      var _pat_let_tv165 = s;
      var _pat_let_tv166 = s;
      _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _633_t1 = (((((((s).dtor_election__state).dtor_current__view).dtor_proposer__id) == (((s).dtor_constants).dtor_my__index)) && (LiveByzRSL____CTypes__i_Compile.__default.CBalLt((s).dtor_max__ballot__i__sent__1a, ((s).dtor_election__state).dtor_current__view))) ? (Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(s, _pat_let218_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let218_0, _634_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.Concat(((_pat_let_tv161).dtor_election__state).dtor_requests__received__prev__epochs, ((_pat_let_tv162).dtor_election__state).dtor_requests__received__this__epoch), _pat_let219_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let219_0, _635_dt__update_hrequest__queue_h0 => Dafny.Helpers.Let<Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(Dafny.Map<Native____Io__s_Compile._IEndPoint, BigInteger>.FromElements(), _pat_let220_0 => Dafny.Helpers.Let<Dafny.IMap<Native____Io__s_Compile._IEndPoint,BigInteger>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let220_0, _636_dt__update_hhighest__seqno__requested__by__client__this__view_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements(), _pat_let221_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let221_0, _637_dt__update_hreceived__1b__packets_h0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(((_pat_let_tv163).dtor_election__state).dtor_current__view, _pat_let222_0 => Dafny.Helpers.Let<LiveByzRSL____CTypes__i_Compile._ICBallot, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let222_0, _638_dt__update_hmax__ballot__i__sent__1a_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(BigInteger.One, _pat_let223_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let223_0, _639_dt__update_hcurrent__state_h0 => LiveByzRSL____ProposerModel__i_Compile.CProposer.create((_634_dt__update__tmp_h0).dtor_constants, _639_dt__update_hcurrent__state_h0, _635_dt__update_hrequest__queue_h0, _638_dt__update_hmax__ballot__i__sent__1a_h0, (_634_dt__update__tmp_h0).dtor_next__operation__number__to__propose, _637_dt__update_hreceived__1b__packets_h0, _636_dt__update_hhighest__seqno__requested__by__client__this__view_h0, (_634_dt__update__tmp_h0).dtor_incomplete__batch__timer, (_634_dt__update__tmp_h0).dtor_election__state))))))))))))), _pat_let217_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let217_0, _640_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(Impl____LiveByzRSL____Broadcast__i_Compile.__default.BuildBroadcastToEveryone((((_pat_let_tv164).dtor_constants).dtor_all).dtor_config, ((_pat_let_tv165).dtor_constants).dtor_my__index, LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__1a(((_pat_let_tv166).dtor_election__state).dtor_current__view))), _pat_let224_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let224_0, _641_t2 => _System.Tuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_640_t1, _641_t2)))))) : (Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(s, _pat_let225_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let225_0, _642_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop()), _pat_let226_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let226_0, _643_t2 => _System.Tuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_642_t1, _643_t2)))))));
      return _System.Tuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_633_t1).dtor__0, (_633_t1).dtor__1);
    }
    public static LiveByzRSL____ProposerModel__i_Compile._ICProposer CProposerProcess1b(LiveByzRSL____ProposerModel__i_Compile._ICProposer s, LiveByzRSL____CMessage__i_Compile._ICPacket p)
    {
      var _pat_let_tv167 = s;
      var _pat_let_tv168 = p;
      LiveByzRSL____ProposerModel__i_Compile._ICProposer _644_t1 = Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(s, _pat_let227_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let227_0, _645_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.Concat((_pat_let_tv167).dtor_received__1b__packets, Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements(_pat_let_tv168)), _pat_let228_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let228_0, _646_dt__update_hreceived__1b__packets_h0 => LiveByzRSL____ProposerModel__i_Compile.CProposer.create((_645_dt__update__tmp_h0).dtor_constants, (_645_dt__update__tmp_h0).dtor_current__state, (_645_dt__update__tmp_h0).dtor_request__queue, (_645_dt__update__tmp_h0).dtor_max__ballot__i__sent__1a, (_645_dt__update__tmp_h0).dtor_next__operation__number__to__propose, _646_dt__update_hreceived__1b__packets_h0, (_645_dt__update__tmp_h0).dtor_highest__seqno__requested__by__client__this__view, (_645_dt__update__tmp_h0).dtor_incomplete__batch__timer, (_645_dt__update__tmp_h0).dtor_election__state)))));
      return _644_t1;
    }
    public static _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CProposerMaybeEnterPhase2(LiveByzRSL____ProposerModel__i_Compile._ICProposer s, BigInteger log__truncation__point)
    {
      var _pat_let_tv169 = log__truncation__point;
      var _pat_let_tv170 = s;
      var _pat_let_tv171 = s;
      var _pat_let_tv172 = s;
      var _pat_let_tv173 = log__truncation__point;
      _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _647_t1 = (((((new BigInteger(((s).dtor_received__1b__packets).Count)) >= (LiveByzRSL____CConfiguration__i_Compile.__default.CByzQuorumSize((((s).dtor_constants).dtor_all).dtor_config))) && (LiveByzRSL____CheckValSafetyImpl__i_Compile.__default.CSetOfMessage1bAboutBallot((s).dtor_received__1b__packets, (s).dtor_max__ballot__i__sent__1a))) && (((s).dtor_current__state) == (BigInteger.One))) ? (Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(s, _pat_let230_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let230_0, _648_dt__update__tmp_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let_tv169, _pat_let231_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let231_0, _649_dt__update_hnext__operation__number__to__propose_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(new BigInteger(2), _pat_let232_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let232_0, _650_dt__update_hcurrent__state_h0 => LiveByzRSL____ProposerModel__i_Compile.CProposer.create((_648_dt__update__tmp_h0).dtor_constants, _650_dt__update_hcurrent__state_h0, (_648_dt__update__tmp_h0).dtor_request__queue, (_648_dt__update__tmp_h0).dtor_max__ballot__i__sent__1a, _649_dt__update_hnext__operation__number__to__propose_h0, (_648_dt__update__tmp_h0).dtor_received__1b__packets, (_648_dt__update__tmp_h0).dtor_highest__seqno__requested__by__client__this__view, (_648_dt__update__tmp_h0).dtor_incomplete__batch__timer, (_648_dt__update__tmp_h0).dtor_election__state))))))), _pat_let229_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let229_0, _651_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(Impl____LiveByzRSL____Broadcast__i_Compile.__default.BuildBroadcastToEveryone((((_pat_let_tv170).dtor_constants).dtor_all).dtor_config, ((_pat_let_tv171).dtor_constants).dtor_my__index, LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__StartingPhase2((_pat_let_tv172).dtor_max__ballot__i__sent__1a, _pat_let_tv173))), _pat_let233_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let233_0, _652_t2 => _System.Tuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_651_t1, _652_t2)))))) : (Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(s, _pat_let234_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let234_0, _653_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop()), _pat_let235_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let235_0, _654_t2 => _System.Tuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_653_t1, _654_t2)))))));
      return _System.Tuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_647_t1).dtor__0, (_647_t1).dtor__1);
    }
    public static _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CProposerNominateNewValueAndSend1c(LiveByzRSL____ProposerModel__i_Compile._ICProposer s, BigInteger clock, BigInteger log__truncation__point)
    {
      var _pat_let_tv174 = s;
      var _pat_let_tv175 = s;
      var _pat_let_tv176 = clock;
      var _pat_let_tv177 = s;
      var _pat_let_tv178 = s;
      var _pat_let_tv179 = s;
      var _pat_let_tv180 = s;
      var _pat_let_tv181 = s;
      var _pat_let_tv182 = s;
      var _pat_let_tv183 = s;
      var _pat_let_tv184 = s;
      BigInteger _655_batchSize = ((((new BigInteger(((s).dtor_request__queue).Count)) <= (((((s).dtor_constants).dtor_all).dtor_params).dtor_max__batch__size)) || ((((((s).dtor_constants).dtor_all).dtor_params).dtor_max__batch__size).Sign == -1)) ? (new BigInteger(((s).dtor_request__queue).Count)) : (((((s).dtor_constants).dtor_all).dtor_params).dtor_max__batch__size));
      _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _656_t1 = Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ProposerModel__i_Compile._ICProposer>, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ProposerModel__i_Compile._ICProposer>>(((s).dtor_request__queue).Take(_655_batchSize), _pat_let237_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ProposerModel__i_Compile._ICProposer>>(_pat_let237_0, _657_v => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ProposerModel__i_Compile._ICProposer>>(Dafny.Helpers.Let<BigInteger, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>((_pat_let_tv174).dtor_next__operation__number__to__propose, _pat_let239_0 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let239_0, _658_opn => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let_tv175, _pat_let241_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let241_0, _659_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICIncompleteBatchTimer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>((((new BigInteger(((_pat_let_tv179).dtor_request__queue).Count)) > (_655_batchSize)) ? (LiveByzRSL____ProposerModel__i_Compile.CIncompleteBatchTimer.create_CIncompleteBatchTimerOn(Common____UpperBound__i_Compile.__default.UpperBoundedAdditionImpl(_pat_let_tv176, ((((_pat_let_tv177).dtor_constants).dtor_all).dtor_params).dtor_max__batch__delay, ((((_pat_let_tv178).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val))) : (LiveByzRSL____ProposerModel__i_Compile.CIncompleteBatchTimer.create_CIncompleteBatchTimerOff())), _pat_let242_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICIncompleteBatchTimer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let242_0, _660_dt__update_hincomplete__batch__timer_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(((_pat_let_tv180).dtor_next__operation__number__to__propose) + (BigInteger.One), _pat_let243_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let243_0, _661_dt__update_hnext__operation__number__to__propose_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(((_pat_let_tv181).dtor_request__queue).Drop(_655_batchSize), _pat_let244_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let244_0, _662_dt__update_hrequest__queue_h0 => LiveByzRSL____ProposerModel__i_Compile.CProposer.create((_659_dt__update__tmp_h0).dtor_constants, (_659_dt__update__tmp_h0).dtor_current__state, _662_dt__update_hrequest__queue_h0, (_659_dt__update__tmp_h0).dtor_max__ballot__i__sent__1a, _661_dt__update_hnext__operation__number__to__propose_h0, (_659_dt__update__tmp_h0).dtor_received__1b__packets, (_659_dt__update__tmp_h0).dtor_highest__seqno__requested__by__client__this__view, _660_dt__update_hincomplete__batch__timer_h0, (_659_dt__update__tmp_h0).dtor_election__state))))))))), _pat_let240_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let240_0, _663_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(Impl____LiveByzRSL____Broadcast__i_Compile.__default.BuildBroadcastToEveryone((((_pat_let_tv182).dtor_constants).dtor_all).dtor_config, ((_pat_let_tv183).dtor_constants).dtor_my__index, LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__1c((_pat_let_tv184).dtor_max__ballot__i__sent__1a, _658_opn, _657_v))), _pat_let245_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let245_0, _664_t2 => _System.Tuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_663_t1, _664_t2))))))), _pat_let238_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ProposerModel__i_Compile._ICProposer>>(_pat_let238_0, _665_t1 => _System.Tuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ProposerModel__i_Compile._ICProposer>.create((_665_t1).dtor__1, (_665_t1).dtor__0))))), _pat_let236_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ProposerModel__i_Compile._ICProposer>, _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let236_0, _666_t1 => _System.Tuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_666_t1).dtor__1, (_666_t1).dtor__0)));
      return _System.Tuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_656_t1).dtor__0, (_656_t1).dtor__1);
    }
    public static LiveByzRSL____ProposerModel__i_Compile._ICProposer CProposerProcessHeartbeat(LiveByzRSL____ProposerModel__i_Compile._ICProposer s, LiveByzRSL____CMessage__i_Compile._ICPacket p, BigInteger clock)
    {
      var _pat_let_tv185 = s;
      LiveByzRSL____ElectionModel__i_Compile._ICElectionState _667_t1 = LiveByzRSL____ElectionModel__i_Compile.__default.CElectionStateProcessHeartbeat((s).dtor_election__state, p, clock);
      _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>> _668_t2 = ((LiveByzRSL____CTypes__i_Compile.__default.CBalLt(((s).dtor_election__state).dtor_current__view, (_667_t1).dtor_current__view)) ? (Dafny.Helpers.Let<BigInteger, _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>>(BigInteger.Zero, _pat_let246_0 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>>(_pat_let246_0, _669_t1 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>>(Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements(), _pat_let247_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>>(_pat_let247_0, _670_t2 => _System.Tuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>.create(_669_t1, _670_t2)))))) : (Dafny.Helpers.Let<BigInteger, _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>>((s).dtor_current__state, _pat_let248_0 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>>(_pat_let248_0, _671_t1 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>>((_pat_let_tv185).dtor_request__queue, _pat_let249_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>>(_pat_let249_0, _672_t2 => _System.Tuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>.create(_671_t1, _672_t2)))))));
      LiveByzRSL____ProposerModel__i_Compile._ICProposer _673_t3 = Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(s, _pat_let250_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let250_0, _674_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>((_668_t2).dtor__1, _pat_let251_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let251_0, _675_dt__update_hrequest__queue_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ProposerModel__i_Compile._ICProposer>((_668_t2).dtor__0, _pat_let252_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let252_0, _676_dt__update_hcurrent__state_h0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_667_t1, _pat_let253_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let253_0, _677_dt__update_helection__state_h0 => LiveByzRSL____ProposerModel__i_Compile.CProposer.create((_674_dt__update__tmp_h0).dtor_constants, _676_dt__update_hcurrent__state_h0, _675_dt__update_hrequest__queue_h0, (_674_dt__update__tmp_h0).dtor_max__ballot__i__sent__1a, (_674_dt__update__tmp_h0).dtor_next__operation__number__to__propose, (_674_dt__update__tmp_h0).dtor_received__1b__packets, (_674_dt__update__tmp_h0).dtor_highest__seqno__requested__by__client__this__view, (_674_dt__update__tmp_h0).dtor_incomplete__batch__timer, _677_dt__update_helection__state_h0)))))))));
      return _673_t3;
    }
    public static LiveByzRSL____ProposerModel__i_Compile._ICProposer CProposerCheckForViewTimeout(LiveByzRSL____ProposerModel__i_Compile._ICProposer s, BigInteger clock)
    {
      LiveByzRSL____ElectionModel__i_Compile._ICElectionState _678_t1 = LiveByzRSL____ElectionModel__i_Compile.__default.CElectionStateCheckForViewTimeout((s).dtor_election__state, clock);
      LiveByzRSL____ProposerModel__i_Compile._ICProposer _679_t2 = Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(s, _pat_let254_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let254_0, _680_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_678_t1, _pat_let255_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let255_0, _681_dt__update_helection__state_h0 => LiveByzRSL____ProposerModel__i_Compile.CProposer.create((_680_dt__update__tmp_h0).dtor_constants, (_680_dt__update__tmp_h0).dtor_current__state, (_680_dt__update__tmp_h0).dtor_request__queue, (_680_dt__update__tmp_h0).dtor_max__ballot__i__sent__1a, (_680_dt__update__tmp_h0).dtor_next__operation__number__to__propose, (_680_dt__update__tmp_h0).dtor_received__1b__packets, (_680_dt__update__tmp_h0).dtor_highest__seqno__requested__by__client__this__view, (_680_dt__update__tmp_h0).dtor_incomplete__batch__timer, _681_dt__update_helection__state_h0)))));
      return _679_t2;
    }
    public static LiveByzRSL____ProposerModel__i_Compile._ICProposer CProposerCheckForQuorumOfViewSuspicions(LiveByzRSL____ProposerModel__i_Compile._ICProposer s, BigInteger clock)
    {
      var _pat_let_tv186 = s;
      LiveByzRSL____ElectionModel__i_Compile._ICElectionState _682_t1 = LiveByzRSL____ElectionModel__i_Compile.__default.CElectionStateCheckForQuorumOfViewSuspicions((s).dtor_election__state, clock);
      _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>> _683_t2 = ((LiveByzRSL____CTypes__i_Compile.__default.CBalLt(((s).dtor_election__state).dtor_current__view, (_682_t1).dtor_current__view)) ? (Dafny.Helpers.Let<BigInteger, _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>>(BigInteger.Zero, _pat_let256_0 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>>(_pat_let256_0, _684_t1 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>>(Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements(), _pat_let257_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>>(_pat_let257_0, _685_t2 => _System.Tuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>.create(_684_t1, _685_t2)))))) : (Dafny.Helpers.Let<BigInteger, _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>>((s).dtor_current__state, _pat_let258_0 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>>(_pat_let258_0, _686_t1 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>>((_pat_let_tv186).dtor_request__queue, _pat_let259_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, _System._ITuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>>(_pat_let259_0, _687_t2 => _System.Tuple2<BigInteger, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>>.create(_686_t1, _687_t2)))))));
      LiveByzRSL____ProposerModel__i_Compile._ICProposer _688_t3 = Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(s, _pat_let260_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let260_0, _689_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>((_683_t2).dtor__1, _pat_let261_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let261_0, _690_dt__update_hrequest__queue_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ProposerModel__i_Compile._ICProposer>((_683_t2).dtor__0, _pat_let262_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let262_0, _691_dt__update_hcurrent__state_h0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_682_t1, _pat_let263_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let263_0, _692_dt__update_helection__state_h0 => LiveByzRSL____ProposerModel__i_Compile.CProposer.create((_689_dt__update__tmp_h0).dtor_constants, _691_dt__update_hcurrent__state_h0, _690_dt__update_hrequest__queue_h0, (_689_dt__update__tmp_h0).dtor_max__ballot__i__sent__1a, (_689_dt__update__tmp_h0).dtor_next__operation__number__to__propose, (_689_dt__update__tmp_h0).dtor_received__1b__packets, (_689_dt__update__tmp_h0).dtor_highest__seqno__requested__by__client__this__view, (_689_dt__update__tmp_h0).dtor_incomplete__batch__timer, _692_dt__update_helection__state_h0)))))))));
      return _688_t3;
    }
    public static LiveByzRSL____ProposerModel__i_Compile._ICProposer CProposerResetViewTimerDueToExecution(LiveByzRSL____ProposerModel__i_Compile._ICProposer s, Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest> val)
    {
      LiveByzRSL____ElectionModel__i_Compile._ICElectionState _693_t1 = LiveByzRSL____ElectionModel__i_Compile.__default.CElectionStateReflectExecutedRequestBatch((s).dtor_election__state, val);
      LiveByzRSL____ProposerModel__i_Compile._ICProposer _694_t2 = Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(s, _pat_let264_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let264_0, _695_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_693_t1, _pat_let265_0 => Dafny.Helpers.Let<LiveByzRSL____ElectionModel__i_Compile._ICElectionState, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let265_0, _696_dt__update_helection__state_h0 => LiveByzRSL____ProposerModel__i_Compile.CProposer.create((_695_dt__update__tmp_h0).dtor_constants, (_695_dt__update__tmp_h0).dtor_current__state, (_695_dt__update__tmp_h0).dtor_request__queue, (_695_dt__update__tmp_h0).dtor_max__ballot__i__sent__1a, (_695_dt__update__tmp_h0).dtor_next__operation__number__to__propose, (_695_dt__update__tmp_h0).dtor_received__1b__packets, (_695_dt__update__tmp_h0).dtor_highest__seqno__requested__by__client__this__view, (_695_dt__update__tmp_h0).dtor_incomplete__batch__timer, _696_dt__update_helection__state_h0)))));
      return _694_t2;
    }
    public static void CProposerNominateOldValueAndSend1c(LiveByzRSL____ProposerModel__i_Compile._ICProposer s, BigInteger log__truncation__point, out LiveByzRSL____ProposerModel__i_Compile._ICProposer s_k, out LiveByzRSL____CMessage__i_Compile._IOutboundPackets sent__packets)
    {
      s_k = LiveByzRSL____ProposerModel__i_Compile.CProposer.Default();
      sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      BigInteger _697_opn;
      _697_opn = (s).dtor_next__operation__number__to__propose;
      BigInteger _698_byzq;
      _698_byzq = LiveByzRSL____CConfiguration__i_Compile.__default.CByzQuorumSize((((s).dtor_constants).dtor_all).dtor_config);
      BigInteger _699_wq;
      _699_wq = LiveByzRSL____CConfiguration__i_Compile.__default.CMinQuorumSize((((s).dtor_constants).dtor_all).dtor_config);
      if (Dafny.Helpers.Id<Func<LiveByzRSL____ProposerModel__i_Compile._ICProposer, BigInteger, BigInteger, BigInteger, bool>>((_700_s, _701_opn, _702_byzq, _703_wq) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>(((_700_s).dtor_received__1b__packets).UniqueElements, false, (((_exists_var_10) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _704_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_exists_var_10;
        return ((((_700_s).dtor_received__1b__packets).Contains((_704_p))) && ((((_704_p).dtor_msg).dtor_votes).Contains((_701_opn)))) && (LiveByzRSL____CheckValSafetyImpl__i_Compile.__default.CValIsSafeAt((Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Select(((_704_p).dtor_msg).dtor_votes,_701_opn)).dtor_max__val, (_700_s).dtor_received__1b__packets, _701_opn, _702_byzq, _703_wq));
      }))))(s, _697_opn, _698_byzq, _699_wq)) {
        LiveByzRSL____CMessage__i_Compile._ICPacket _705_p;
        foreach (LiveByzRSL____CMessage__i_Compile._ICPacket _assign_such_that_4 in ((s).dtor_received__1b__packets).Elements) {
          _705_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_assign_such_that_4;
          if (((((s).dtor_received__1b__packets).Contains((_705_p))) && ((((_705_p).dtor_msg).dtor_votes).Contains((_697_opn)))) && (LiveByzRSL____CheckValSafetyImpl__i_Compile.__default.CValIsSafeAt((Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Select(((_705_p).dtor_msg).dtor_votes,_697_opn)).dtor_max__val, (s).dtor_received__1b__packets, _697_opn, _698_byzq, _699_wq))) {
            goto after__ASSIGN_SUCH_THAT_4;
          }
        }
        throw new System.Exception("assign-such-that search produced no value (line 459)");
      after__ASSIGN_SUCH_THAT_4: ;
        var _pat_let_tv187 = s;
        s_k = Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(s, _pat_let266_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let266_0, _706_dt__update__tmp_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(((_pat_let_tv187).dtor_next__operation__number__to__propose) + (BigInteger.One), _pat_let267_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let267_0, _707_dt__update_hnext__operation__number__to__propose_h0 => LiveByzRSL____ProposerModel__i_Compile.CProposer.create((_706_dt__update__tmp_h0).dtor_constants, (_706_dt__update__tmp_h0).dtor_current__state, (_706_dt__update__tmp_h0).dtor_request__queue, (_706_dt__update__tmp_h0).dtor_max__ballot__i__sent__1a, _707_dt__update_hnext__operation__number__to__propose_h0, (_706_dt__update__tmp_h0).dtor_received__1b__packets, (_706_dt__update__tmp_h0).dtor_highest__seqno__requested__by__client__this__view, (_706_dt__update__tmp_h0).dtor_incomplete__batch__timer, (_706_dt__update__tmp_h0).dtor_election__state)))));
        sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(Impl____LiveByzRSL____Broadcast__i_Compile.__default.BuildBroadcastToEveryone((((s).dtor_constants).dtor_all).dtor_config, ((s).dtor_constants).dtor_my__index, LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__1c((s).dtor_max__ballot__i__sent__1a, _697_opn, (Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.Select(((_705_p).dtor_msg).dtor_votes,_697_opn)).dtor_max__val)));
      } else {
        s_k = s;
        sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop());
      }
    }
    public static void CProposerMaybeNominateValueAndSend1c(LiveByzRSL____ProposerModel__i_Compile._ICProposer proposer, BigInteger clock, BigInteger log__truncation__point, out LiveByzRSL____ProposerModel__i_Compile._ICProposer proposer_k, out LiveByzRSL____CMessage__i_Compile._IOutboundPackets sent__packets)
    {
      proposer_k = LiveByzRSL____ProposerModel__i_Compile.CProposer.Default();
      sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      if (!(LiveByzRSL____ProposerModel__i_Compile.__default.CProposerCanNominateUsingOperationNumber(proposer, log__truncation__point, (proposer).dtor_next__operation__number__to__propose))) {
        proposer_k = proposer;
        sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop());
      } else if (!(LiveByzRSL____CheckValSafetyImpl__i_Compile.__default.CAllAcceptorsHadNoProposal((proposer).dtor_received__1b__packets, (proposer).dtor_next__operation__number__to__propose))) {
        LiveByzRSL____ProposerModel__i_Compile._ICProposer _out122;
        LiveByzRSL____CMessage__i_Compile._IOutboundPackets _out123;
        LiveByzRSL____ProposerModel__i_Compile.__default.CProposerNominateOldValueAndSend1c(proposer, log__truncation__point, out _out122, out _out123);
        proposer_k = _out122;
        sent__packets = _out123;
      } else if (((new BigInteger(((proposer).dtor_request__queue).Count)) >= (((((proposer).dtor_constants).dtor_all).dtor_params).dtor_max__batch__size)) || ((((new BigInteger(((proposer).dtor_request__queue).Count)).Sign == 1) && (((proposer).dtor_incomplete__batch__timer).is_CIncompleteBatchTimerOn)) && ((clock) >= (((proposer).dtor_incomplete__batch__timer).dtor_when)))) {
        _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _let_tmp_rhs14 = LiveByzRSL____ProposerModel__i_Compile.__default.CProposerNominateNewValueAndSend1c(proposer, clock, log__truncation__point);
        LiveByzRSL____ProposerModel__i_Compile._ICProposer _708_proposer_k__ = _let_tmp_rhs14.dtor__0;
        LiveByzRSL____CMessage__i_Compile._IOutboundPackets _709_sent__packets__ = _let_tmp_rhs14.dtor__1;
        proposer_k = _708_proposer_k__;
        sent__packets = _709_sent__packets__;
      } else if (((new BigInteger(((proposer).dtor_request__queue).Count)).Sign == 1) && (((proposer).dtor_incomplete__batch__timer).is_CIncompleteBatchTimerOff)) {
        var _pat_let_tv188 = clock;
        var _pat_let_tv189 = proposer;
        var _pat_let_tv190 = proposer;
        proposer_k = Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(proposer, _pat_let268_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let268_0, _710_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICIncompleteBatchTimer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(LiveByzRSL____ProposerModel__i_Compile.CIncompleteBatchTimer.create_CIncompleteBatchTimerOn(Common____UpperBound__i_Compile.__default.UpperBoundedAdditionImpl(_pat_let_tv188, ((((_pat_let_tv189).dtor_constants).dtor_all).dtor_params).dtor_max__batch__delay, ((((_pat_let_tv190).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val)), _pat_let269_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICIncompleteBatchTimer, LiveByzRSL____ProposerModel__i_Compile._ICProposer>(_pat_let269_0, _711_dt__update_hincomplete__batch__timer_h0 => LiveByzRSL____ProposerModel__i_Compile.CProposer.create((_710_dt__update__tmp_h0).dtor_constants, (_710_dt__update__tmp_h0).dtor_current__state, (_710_dt__update__tmp_h0).dtor_request__queue, (_710_dt__update__tmp_h0).dtor_max__ballot__i__sent__1a, (_710_dt__update__tmp_h0).dtor_next__operation__number__to__propose, (_710_dt__update__tmp_h0).dtor_received__1b__packets, (_710_dt__update__tmp_h0).dtor_highest__seqno__requested__by__client__this__view, _711_dt__update_hincomplete__batch__timer_h0, (_710_dt__update__tmp_h0).dtor_election__state)))));
        sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop());
      } else {
        proposer_k = proposer;
        sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop());
      }
    }
  }
} // end of namespace LiveByzRSL____ProposerModel__i_Compile
namespace LiveByzRSL____ReplicaModel__i_Compile {

  public interface _ICReplica {
    bool is_CReplica { get; }
    LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants dtor_constants { get; }
    BigInteger dtor_nextHeartbeatTime { get; }
    LiveByzRSL____ProposerModel__i_Compile._ICProposer dtor_proposer { get; }
    LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor dtor_acceptor { get; }
    LiveByzRSL____LearnerModel__i_Compile._ICLearner dtor_learner { get; }
    LiveByzRSL____ExecutorModel__i_Compile._ICExecutor dtor_executor { get; }
    _ICReplica DowncastClone();
  }
  public class CReplica : _ICReplica {
    public readonly LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants _constants;
    public readonly BigInteger _nextHeartbeatTime;
    public readonly LiveByzRSL____ProposerModel__i_Compile._ICProposer _proposer;
    public readonly LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor _acceptor;
    public readonly LiveByzRSL____LearnerModel__i_Compile._ICLearner _learner;
    public readonly LiveByzRSL____ExecutorModel__i_Compile._ICExecutor _executor;
    public CReplica(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, BigInteger nextHeartbeatTime, LiveByzRSL____ProposerModel__i_Compile._ICProposer proposer, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor acceptor, LiveByzRSL____LearnerModel__i_Compile._ICLearner learner, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor executor) {
      this._constants = constants;
      this._nextHeartbeatTime = nextHeartbeatTime;
      this._proposer = proposer;
      this._acceptor = acceptor;
      this._learner = learner;
      this._executor = executor;
    }
    public _ICReplica DowncastClone() {
      if (this is _ICReplica dt) { return dt; }
      return new CReplica(_constants, _nextHeartbeatTime, _proposer, _acceptor, _learner, _executor);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____ReplicaModel__i_Compile.CReplica;
      return oth != null && object.Equals(this._constants, oth._constants) && this._nextHeartbeatTime == oth._nextHeartbeatTime && object.Equals(this._proposer, oth._proposer) && object.Equals(this._acceptor, oth._acceptor) && object.Equals(this._learner, oth._learner) && object.Equals(this._executor, oth._executor);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._constants));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._nextHeartbeatTime));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._proposer));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._acceptor));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._learner));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._executor));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____ReplicaModel__i_Compile.CReplica.CReplica";
      s += "(";
      s += Dafny.Helpers.ToString(this._constants);
      s += ", ";
      s += Dafny.Helpers.ToString(this._nextHeartbeatTime);
      s += ", ";
      s += Dafny.Helpers.ToString(this._proposer);
      s += ", ";
      s += Dafny.Helpers.ToString(this._acceptor);
      s += ", ";
      s += Dafny.Helpers.ToString(this._learner);
      s += ", ";
      s += Dafny.Helpers.ToString(this._executor);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____ReplicaModel__i_Compile._ICReplica theDefault = create(LiveByzRSL____ConstantsState__i_Compile.CReplicaConstants.Default(), BigInteger.Zero, LiveByzRSL____ProposerModel__i_Compile.CProposer.Default(), LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.Default(), LiveByzRSL____LearnerModel__i_Compile.CLearner.Default(), LiveByzRSL____ExecutorModel__i_Compile.CExecutor.Default());
    public static LiveByzRSL____ReplicaModel__i_Compile._ICReplica Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____ReplicaModel__i_Compile._ICReplica> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(LiveByzRSL____ReplicaModel__i_Compile.CReplica.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____ReplicaModel__i_Compile._ICReplica> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICReplica create(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, BigInteger nextHeartbeatTime, LiveByzRSL____ProposerModel__i_Compile._ICProposer proposer, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor acceptor, LiveByzRSL____LearnerModel__i_Compile._ICLearner learner, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor executor) {
      return new CReplica(constants, nextHeartbeatTime, proposer, acceptor, learner, executor);
    }
    public static _ICReplica create_CReplica(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, BigInteger nextHeartbeatTime, LiveByzRSL____ProposerModel__i_Compile._ICProposer proposer, LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor acceptor, LiveByzRSL____LearnerModel__i_Compile._ICLearner learner, LiveByzRSL____ExecutorModel__i_Compile._ICExecutor executor) {
      return create(constants, nextHeartbeatTime, proposer, acceptor, learner, executor);
    }
    public bool is_CReplica { get { return true; } }
    public LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants dtor_constants {
      get {
        return this._constants;
      }
    }
    public BigInteger dtor_nextHeartbeatTime {
      get {
        return this._nextHeartbeatTime;
      }
    }
    public LiveByzRSL____ProposerModel__i_Compile._ICProposer dtor_proposer {
      get {
        return this._proposer;
      }
    }
    public LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor dtor_acceptor {
      get {
        return this._acceptor;
      }
    }
    public LiveByzRSL____LearnerModel__i_Compile._ICLearner dtor_learner {
      get {
        return this._learner;
      }
    }
    public LiveByzRSL____ExecutorModel__i_Compile._ICExecutor dtor_executor {
      get {
        return this._executor;
      }
    }
  }

  public partial class __default {
    public static LiveByzRSL____ReplicaModel__i_Compile._ICReplica CReplicaInit(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants c) {
      LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants _712_t1 = c;
      BigInteger _713_t2 = BigInteger.Zero;
      LiveByzRSL____ProposerModel__i_Compile._ICProposer _714_t3 = LiveByzRSL____ProposerModel__i_Compile.__default.CProposerInit(c);
      LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor _715_t4 = LiveByzRSL____AcceptorModel__i_Compile.__default.CAcceptorInit(c);
      LiveByzRSL____LearnerModel__i_Compile._ICLearner _716_t5 = LiveByzRSL____LearnerModel__i_Compile.__default.CLearnerInit(c);
      LiveByzRSL____ExecutorModel__i_Compile._ICExecutor _717_t6 = LiveByzRSL____ExecutorModel__i_Compile.__default.CExecutorInit(c);
      return LiveByzRSL____ReplicaModel__i_Compile.CReplica.create(_712_t1, _713_t2, _714_t3, _715_t4, _716_t5, _717_t6);
    }
    public static _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CReplicaNextProcessInvalid(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, LiveByzRSL____CMessage__i_Compile._ICPacket received__packet)
    {
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _718_t1 = s;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _719_t2 = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_PacketSequence(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements());
      return _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_718_t1, _719_t2);
    }
    public static _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CReplicaNextProcessRequest(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, LiveByzRSL____CMessage__i_Compile._ICPacket received__packet)
    {
      var _pat_let_tv191 = s;
      var _pat_let_tv192 = s;
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _720_t1 = (((((((s).dtor_executor).dtor_reply__cache).Contains(((received__packet).dtor_src))) && (true)) && ((((received__packet).dtor_msg).dtor_seqno__req) <= ((Dafny.Map<Native____Io__s_Compile._IEndPoint, LiveByzRSL____CTypes__i_Compile._ICReply>.Select(((s).dtor_executor).dtor_reply__cache,(received__packet).dtor_src)).dtor_seqno))) ? (Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____ExecutorModel__i_Compile.__default.CExecutorProcessRequest((s).dtor_executor, received__packet), _pat_let270_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let270_0, _721_t1 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let_tv191, _pat_let271_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let271_0, _722_t2 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_722_t2, _721_t1)))))) : (Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____ProposerModel__i_Compile.__default.CProposerProcessRequest((s).dtor_proposer, received__packet), _pat_let272_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let272_0, _723_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_PacketSequence(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements()), _pat_let273_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let273_0, _724_t2 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let_tv192, _pat_let275_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let275_0, _725_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_723_t1, _pat_let276_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let276_0, _726_dt__update_hproposer_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_725_dt__update__tmp_h0).dtor_constants, (_725_dt__update__tmp_h0).dtor_nextHeartbeatTime, _726_dt__update_hproposer_h0, (_725_dt__update__tmp_h0).dtor_acceptor, (_725_dt__update__tmp_h0).dtor_learner, (_725_dt__update__tmp_h0).dtor_executor))))), _pat_let274_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let274_0, _727_t3 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_727_t3, _724_t2)))))))));
      return _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_720_t1).dtor__0, (_720_t1).dtor__1);
    }
    public static _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CReplicaNextProcess1a(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, LiveByzRSL____CMessage__i_Compile._ICPacket received__packet)
    {
      _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _728_t1 = LiveByzRSL____AcceptorModel__i_Compile.__default.CAcceptorProcess1a((s).dtor_acceptor, received__packet);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _729_t2 = Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(s, _pat_let277_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let277_0, _730_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>((_728_t1).dtor__0, _pat_let278_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let278_0, _731_dt__update_hacceptor_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_730_dt__update__tmp_h0).dtor_constants, (_730_dt__update__tmp_h0).dtor_nextHeartbeatTime, (_730_dt__update__tmp_h0).dtor_proposer, _731_dt__update_hacceptor_h0, (_730_dt__update__tmp_h0).dtor_learner, (_730_dt__update__tmp_h0).dtor_executor)))));
      return _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_729_t2, (_728_t1).dtor__1);
    }
    public static _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CReplicaNextProcess1b(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, LiveByzRSL____CMessage__i_Compile._ICPacket received__packet)
    {
      var _pat_let_tv193 = s;
      var _pat_let_tv194 = received__packet;
      var _pat_let_tv195 = s;
      var _pat_let_tv196 = s;
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _732_t1 = (((((((((((s).dtor_proposer).dtor_constants).dtor_all).dtor_config)).Contains(((received__packet).dtor_src))) && (object.Equals(((received__packet).dtor_msg).dtor_bal__1b, ((s).dtor_proposer).dtor_max__ballot__i__sent__1a))) && ((((s).dtor_proposer).dtor_current__state) == (BigInteger.One))) && (Dafny.Helpers.Id<Func<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._ICPacket, bool>>((_751_s, _752_received__packet) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>((((_751_s).dtor_proposer).dtor_received__1b__packets).UniqueElements, true, (((_forall_var_20) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _753_other__packet = (LiveByzRSL____CMessage__i_Compile._ICPacket)_forall_var_20;
        return !((((_751_s).dtor_proposer).dtor_received__1b__packets).Contains((_753_other__packet))) || (!object.Equals((_753_other__packet).dtor_src, (_752_received__packet).dtor_src));
      }))))(s, received__packet))) ? (Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____ProposerModel__i_Compile.__default.CProposerProcess1b((s).dtor_proposer, received__packet), _pat_let279_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let279_0, _733_t1 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____AcceptorModel__i_Compile.__default.CAcceptorTruncateLog((_pat_let_tv193).dtor_acceptor, ((_pat_let_tv194).dtor_msg).dtor_log__truncation__point), _pat_let280_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let280_0, _734_t2 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_PacketSequence(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements()), _pat_let281_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let281_0, _735_t3 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let_tv195, _pat_let283_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let283_0, _736_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_734_t2, _pat_let284_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let284_0, _737_dt__update_hacceptor_h0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_733_t1, _pat_let285_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let285_0, _738_dt__update_hproposer_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_736_dt__update__tmp_h0).dtor_constants, (_736_dt__update__tmp_h0).dtor_nextHeartbeatTime, _738_dt__update_hproposer_h0, _737_dt__update_hacceptor_h0, (_736_dt__update__tmp_h0).dtor_learner, (_736_dt__update__tmp_h0).dtor_executor))))))), _pat_let282_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let282_0, _739_t4 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_739_t4, _735_t3)))))))))) : (Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>((((((((((s).dtor_acceptor).dtor_constants).dtor_all).dtor_config)).Contains(((received__packet).dtor_src))) && (Dafny.Helpers.Id<Func<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._ICPacket, bool>>((_747_s, _748_received__packet) => Dafny.Helpers.Quantifier<LiveByzRSL____CMessage__i_Compile._ICPacket>((((_747_s).dtor_acceptor).dtor_received__1b__packets).UniqueElements, true, (((_forall_var_19) => {
        LiveByzRSL____CMessage__i_Compile._ICPacket _749_other__packet = (LiveByzRSL____CMessage__i_Compile._ICPacket)_forall_var_19;
        return !((((_747_s).dtor_acceptor).dtor_received__1b__packets).Contains((_749_other__packet))) || (!object.Equals((_749_other__packet).dtor_src, (_748_received__packet).dtor_src));
      }))))(s, received__packet))) ? (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____AcceptorModel__i_Compile.__default.CAcceptorProcess1b((s).dtor_acceptor, received__packet), _pat_let287_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let287_0, _740_t1 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let_tv196, _pat_let289_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let289_0, _741_dt__update__tmp_h1 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_740_t1, _pat_let290_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let290_0, _742_dt__update_hacceptor_h1 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_741_dt__update__tmp_h1).dtor_constants, (_741_dt__update__tmp_h1).dtor_nextHeartbeatTime, (_741_dt__update__tmp_h1).dtor_proposer, _742_dt__update_hacceptor_h1, (_741_dt__update__tmp_h1).dtor_learner, (_741_dt__update__tmp_h1).dtor_executor))))), _pat_let288_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let288_0, _743_t2 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_PacketSequence(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements()), _pat_let291_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let291_0, _744_t3 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_743_t2, _744_t3)))))))) : (Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(s, _pat_let292_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let292_0, _745_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_PacketSequence(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements()), _pat_let293_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let293_0, _746_t2 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_745_t1, _746_t2))))))), _pat_let286_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let286_0, _750_t1 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_750_t1).dtor__0, (_750_t1).dtor__1)))));
      return _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_732_t1).dtor__0, (_732_t1).dtor__1);
    }
    public static _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CReplicaNextProcessStartingPhase2(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, LiveByzRSL____CMessage__i_Compile._ICPacket received__packet)
    {
      _System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _754_t1 = LiveByzRSL____ExecutorModel__i_Compile.__default.CExecutorProcessStartingPhase2((s).dtor_executor, received__packet);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _755_t2 = Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(s, _pat_let294_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let294_0, _756_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>((_754_t1).dtor__0, _pat_let295_0 => Dafny.Helpers.Let<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let295_0, _757_dt__update_hexecutor_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_756_dt__update__tmp_h0).dtor_constants, (_756_dt__update__tmp_h0).dtor_nextHeartbeatTime, (_756_dt__update__tmp_h0).dtor_proposer, (_756_dt__update__tmp_h0).dtor_acceptor, (_756_dt__update__tmp_h0).dtor_learner, _757_dt__update_hexecutor_h0)))));
      return _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_755_t2, (_754_t1).dtor__1);
    }
    public static _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CReplicaNextProcess2av(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, LiveByzRSL____CMessage__i_Compile._ICPacket received__packet)
    {
      var _pat_let_tv197 = received__packet;
      var _pat_let_tv198 = s;
      var _pat_let_tv199 = s;
      var _pat_let_tv200 = s;
      var _pat_let_tv201 = s;
      var _pat_let_tv202 = received__packet;
      var _pat_let_tv203 = s;
      var _pat_let_tv204 = s;
      var _pat_let_tv205 = s;
      _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ReplicaModel__i_Compile._ICReplica> _758_t1 = Dafny.Helpers.Let<BigInteger, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>>(((received__packet).dtor_msg).dtor_opn__2av, _pat_let296_0 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>>(_pat_let296_0, _759_opn => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>>(Dafny.Helpers.Let<Native____Io__s_Compile._IEndPoint, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>((_pat_let_tv197).dtor_src, _pat_let298_0 => Dafny.Helpers.Let<Native____Io__s_Compile._IEndPoint, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let298_0, _760_src => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<bool, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>>(((((_pat_let_tv198).dtor_acceptor).dtor_opn__to__be__send__2b) < (_759_opn)) || (((((_pat_let_tv199).dtor_acceptor).dtor_opn__to__be__send__2b) == (_759_opn)) && ((((_pat_let_tv200).dtor_acceptor).dtor_val__to__be__sent__2b).is_CValToBeSent2bUnknown)), _pat_let300_0 => Dafny.Helpers.Let<bool, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>>(_pat_let300_0, _761_op__sendable => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>>((((_761_op__sendable) && (((((((_pat_let_tv205).dtor_acceptor).dtor_constants).dtor_all).dtor_config)).Contains((_760_src)))) ? (Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____AcceptorModel__i_Compile.__default.CAcceptorProcess2av((_pat_let_tv201).dtor_acceptor, _pat_let_tv202), _pat_let302_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let302_0, _762_t1 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let_tv203, _pat_let304_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let304_0, _763_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_762_t1, _pat_let305_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let305_0, _764_dt__update_hacceptor_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_763_dt__update__tmp_h0).dtor_constants, (_763_dt__update__tmp_h0).dtor_nextHeartbeatTime, (_763_dt__update__tmp_h0).dtor_proposer, _764_dt__update_hacceptor_h0, (_763_dt__update__tmp_h0).dtor_learner, (_763_dt__update__tmp_h0).dtor_executor))))), _pat_let303_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let303_0, _765_t2 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop()), _pat_let306_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let306_0, _766_t3 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_765_t2, _766_t3)))))))) : (Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let_tv204, _pat_let307_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let307_0, _767_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop()), _pat_let308_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let308_0, _768_t2 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_767_t1, _768_t2))))))), _pat_let301_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>>(_pat_let301_0, _769_t1 => _System.Tuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>.create((_769_t1).dtor__1, (_769_t1).dtor__0))))), _pat_let299_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let299_0, _770_t1 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_770_t1).dtor__1, (_770_t1).dtor__0))))), _pat_let297_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>>(_pat_let297_0, _771_t1 => _System.Tuple2<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>.create((_771_t1).dtor__1, (_771_t1).dtor__0)))));
      return _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_758_t1).dtor__1, (_758_t1).dtor__0);
    }
    public static _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CReplicaNextSpontaneousMaybeSend2b(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s) {
      var _pat_let_tv206 = s;
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _772_t1 = ((((((s).dtor_acceptor).dtor_val__to__be__sent__2b).is_CValToBeSent2bKnown) && (object.Equals((((s).dtor_acceptor).dtor_val__to__be__sent__2b).dtor_bal, ((s).dtor_acceptor).dtor_max__bal))) ? (Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____AcceptorModel__i_Compile.__default.CAcceptorSent2b((s).dtor_acceptor), _pat_let309_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let309_0, _773_t1 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let_tv206, _pat_let311_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let311_0, _774_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>((_773_t1).dtor__0, _pat_let312_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let312_0, _775_dt__update_hacceptor_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_774_dt__update__tmp_h0).dtor_constants, (_774_dt__update__tmp_h0).dtor_nextHeartbeatTime, (_774_dt__update__tmp_h0).dtor_proposer, _775_dt__update_hacceptor_h0, (_774_dt__update__tmp_h0).dtor_learner, (_774_dt__update__tmp_h0).dtor_executor))))), _pat_let310_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let310_0, _776_t2 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_776_t2, (_773_t1).dtor__1)))))) : (Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(s, _pat_let313_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let313_0, _777_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop()), _pat_let314_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let314_0, _778_t2 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_777_t1, _778_t2)))))));
      return _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_772_t1).dtor__0, (_772_t1).dtor__1);
    }
    public static _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CReplicaNextProcess2b(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, LiveByzRSL____CMessage__i_Compile._ICPacket received__packet)
    {
      var _pat_let_tv207 = s;
      var _pat_let_tv208 = s;
      var _pat_let_tv209 = s;
      var _pat_let_tv210 = s;
      var _pat_let_tv211 = received__packet;
      var _pat_let_tv212 = s;
      var _pat_let_tv213 = s;
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _779_t1 = Dafny.Helpers.Let<BigInteger, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(((received__packet).dtor_msg).dtor_opn__2b, _pat_let315_0 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let315_0, _780_opn => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<bool, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(((((_pat_let_tv207).dtor_executor).dtor_ops__complete) < (_780_opn)) || (((((_pat_let_tv208).dtor_executor).dtor_ops__complete) == (_780_opn)) && ((((_pat_let_tv209).dtor_executor).dtor_next__op__to__execute).is_COutstandingOpUnknown)), _pat_let317_0 => Dafny.Helpers.Let<bool, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let317_0, _781_op__learnable => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(((_781_op__learnable) ? (Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____LearnerModel__i_Compile.__default.CLearnerProcess2b((_pat_let_tv210).dtor_learner, _pat_let_tv211), _pat_let319_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let319_0, _782_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_PacketSequence(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements()), _pat_let320_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let320_0, _783_t2 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let_tv212, _pat_let322_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let322_0, _784_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_782_t1, _pat_let323_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let323_0, _785_dt__update_hlearner_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_784_dt__update__tmp_h0).dtor_constants, (_784_dt__update__tmp_h0).dtor_nextHeartbeatTime, (_784_dt__update__tmp_h0).dtor_proposer, (_784_dt__update__tmp_h0).dtor_acceptor, _785_dt__update_hlearner_h0, (_784_dt__update__tmp_h0).dtor_executor))))), _pat_let321_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let321_0, _786_t3 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_786_t3, _783_t2)))))))) : (Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let_tv213, _pat_let324_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let324_0, _787_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_PacketSequence(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements()), _pat_let325_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let325_0, _788_t2 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_787_t1, _788_t2))))))), _pat_let318_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let318_0, _789_t1 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_789_t1).dtor__0, (_789_t1).dtor__1))))), _pat_let316_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let316_0, _790_t1 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_790_t1).dtor__0, (_790_t1).dtor__1)))));
      return _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_779_t1).dtor__0, (_779_t1).dtor__1);
    }
    public static _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CReplicaNextProcessReply(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, LiveByzRSL____CMessage__i_Compile._ICPacket received__packet)
    {
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _791_t1 = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_PacketSequence(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements());
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _792_t2 = s;
      return _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_792_t2, _791_t1);
    }
    public static _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CReplicaNextProcessHeartbeat(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, LiveByzRSL____CMessage__i_Compile._ICPacket received__packet, BigInteger clock)
    {
      LiveByzRSL____ProposerModel__i_Compile._ICProposer _793_t1 = LiveByzRSL____ProposerModel__i_Compile.__default.CProposerProcessHeartbeat((s).dtor_proposer, received__packet, clock);
      LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor _794_t2 = LiveByzRSL____AcceptorModel__i_Compile.__default.CAcceptorProcessHeartbeat((s).dtor_acceptor, received__packet);
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _795_t3 = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_PacketSequence(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements());
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _796_t4 = Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(s, _pat_let326_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let326_0, _797_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_794_t2, _pat_let327_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let327_0, _798_dt__update_hacceptor_h0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_793_t1, _pat_let328_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let328_0, _799_dt__update_hproposer_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_797_dt__update__tmp_h0).dtor_constants, (_797_dt__update__tmp_h0).dtor_nextHeartbeatTime, _799_dt__update_hproposer_h0, _798_dt__update_hacceptor_h0, (_797_dt__update__tmp_h0).dtor_learner, (_797_dt__update__tmp_h0).dtor_executor)))))));
      return _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_796_t4, _795_t3);
    }
    public static _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CReplicaNextSpontaneousMaybeEnterNewViewAndSend1a(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s) {
      _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _800_t1 = LiveByzRSL____ProposerModel__i_Compile.__default.CProposerMaybeEnterNewViewAndSend1a((s).dtor_proposer);
      LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor _801_t2 = LiveByzRSL____AcceptorModel__i_Compile.__default.CAcceptorMaybeEnterNewView((s).dtor_acceptor);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _802_t3 = Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(s, _pat_let329_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let329_0, _803_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_801_t2, _pat_let330_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let330_0, _804_dt__update_hacceptor_h0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>((_800_t1).dtor__0, _pat_let331_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let331_0, _805_dt__update_hproposer_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_803_dt__update__tmp_h0).dtor_constants, (_803_dt__update__tmp_h0).dtor_nextHeartbeatTime, _805_dt__update_hproposer_h0, _804_dt__update_hacceptor_h0, (_803_dt__update__tmp_h0).dtor_learner, (_803_dt__update__tmp_h0).dtor_executor)))))));
      return _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_802_t3, (_800_t1).dtor__1);
    }
    public static _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CReplicaNextSpontaneousMaybeEnterPhase2(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s) {
      _System._ITuple2<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _806_t1 = LiveByzRSL____ProposerModel__i_Compile.__default.CProposerMaybeEnterPhase2((s).dtor_proposer, ((s).dtor_acceptor).dtor_log__truncation__point);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _807_t2 = Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(s, _pat_let332_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let332_0, _808_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>((_806_t1).dtor__0, _pat_let333_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let333_0, _809_dt__update_hproposer_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_808_dt__update__tmp_h0).dtor_constants, (_808_dt__update__tmp_h0).dtor_nextHeartbeatTime, _809_dt__update_hproposer_h0, (_808_dt__update__tmp_h0).dtor_acceptor, (_808_dt__update__tmp_h0).dtor_learner, (_808_dt__update__tmp_h0).dtor_executor)))));
      return _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_807_t2, (_806_t1).dtor__1);
    }
    public static _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CReplicaNextSpontaneousMaybeExecute(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s) {
      var _pat_let_tv214 = s;
      var _pat_let_tv215 = s;
      var _pat_let_tv216 = s;
      var _pat_let_tv217 = s;
      var _pat_let_tv218 = s;
      var _pat_let_tv219 = s;
      var _pat_let_tv220 = s;
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _810_t1 = (((((((s).dtor_executor).dtor_next__op__to__execute).is_COutstandingOpKnown) && (Common____UpperBound__i_Compile.__default.CLtUpperBound(((s).dtor_executor).dtor_ops__complete, (((((s).dtor_executor).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val))) && (LiveByzRSL____ConstantsState__i_Compile.__default.CReplicaConstantsValid(((s).dtor_executor).dtor_constants))) ? (Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>((((s).dtor_executor).dtor_next__op__to__execute).dtor_v, _pat_let335_0 => Dafny.Helpers.Let<Dafny.ISequence<LiveByzRSL____CTypes__i_Compile._ICRequest>, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let335_0, _811_v => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____ProposerModel__i_Compile.__default.CProposerResetViewTimerDueToExecution((_pat_let_tv214).dtor_proposer, _811_v), _pat_let336_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let336_0, _812_t1 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____LearnerModel__i_Compile.__default.CLearnerForgetDecision((_pat_let_tv215).dtor_learner, ((_pat_let_tv216).dtor_executor).dtor_ops__complete), _pat_let337_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let337_0, _813_t2 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____AcceptorModel__i_Compile.__default.CAcceptorForgetReceived2avs((_pat_let_tv217).dtor_acceptor, ((_pat_let_tv218).dtor_executor).dtor_ops__complete), _pat_let338_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let338_0, _814_t3 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____ExecutorModel__i_Compile.__default.CExecutorExecute((_pat_let_tv219).dtor_executor), _pat_let339_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let339_0, _815_t4 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let_tv220, _pat_let341_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let341_0, _816_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>((_815_t4).dtor__0, _pat_let342_0 => Dafny.Helpers.Let<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let342_0, _817_dt__update_hexecutor_h0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_813_t2, _pat_let343_0 => Dafny.Helpers.Let<LiveByzRSL____LearnerModel__i_Compile._ICLearner, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let343_0, _818_dt__update_hlearner_h0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_812_t1, _pat_let344_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let344_0, _819_dt__update_hproposer_h0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_814_t3, _pat_let345_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let345_0, _820_dt__update_hacceptor_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_816_dt__update__tmp_h0).dtor_constants, (_816_dt__update__tmp_h0).dtor_nextHeartbeatTime, _819_dt__update_hproposer_h0, _820_dt__update_hacceptor_h0, _818_dt__update_hlearner_h0, _817_dt__update_hexecutor_h0))))))))))), _pat_let340_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let340_0, _821_t5 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_821_t5, (_815_t4).dtor__1))))))))))))), _pat_let334_0 => Dafny.Helpers.Let<_System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let334_0, _822_t1 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_822_t1).dtor__0, (_822_t1).dtor__1)))) : (Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(s, _pat_let346_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let346_0, _823_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_PacketSequence(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements()), _pat_let347_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let347_0, _824_t2 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_823_t1, _824_t2)))))));
      return _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_810_t1).dtor__0, (_810_t1).dtor__1);
    }
    public static _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CReplicaNextReadClockMaybeSendHeartbeat(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, BigInteger clock)
    {
      var _pat_let_tv221 = s;
      var _pat_let_tv222 = s;
      var _pat_let_tv223 = s;
      var _pat_let_tv224 = s;
      var _pat_let_tv225 = s;
      var _pat_let_tv226 = s;
      var _pat_let_tv227 = s;
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _825_t1 = ((((clock)) < ((s).dtor_nextHeartbeatTime)) ? (Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(s, _pat_let348_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let348_0, _826_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_PacketSequence(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements()), _pat_let349_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let349_0, _827_t2 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_826_t1, _827_t2)))))) : (Dafny.Helpers.Let<BigInteger, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Common____UpperBound__i_Compile.__default.UpperBoundedAdditionImpl((clock), ((((s).dtor_constants).dtor_all).dtor_params).dtor_heartbeat__period, ((((s).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val), _pat_let350_0 => Dafny.Helpers.Let<BigInteger, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let350_0, _828_t1 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(Impl____LiveByzRSL____Broadcast__i_Compile.__default.BuildBroadcastToEveryone((((_pat_let_tv221).dtor_constants).dtor_all).dtor_config, ((_pat_let_tv222).dtor_constants).dtor_my__index, LiveByzRSL____CMessage__i_Compile.CMessage.create_CMessage__Heartbeat((((_pat_let_tv223).dtor_proposer).dtor_election__state).dtor_current__view, ((((_pat_let_tv224).dtor_proposer).dtor_election__state).dtor_current__view__suspectors).Contains((((_pat_let_tv225).dtor_constants).dtor_my__index)), ((_pat_let_tv226).dtor_executor).dtor_ops__complete))), _pat_let351_0 => Dafny.Helpers.Let<LiveByzRSL____CMessage__i_Compile._IOutboundPackets, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let351_0, _829_t2 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let_tv227, _pat_let353_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let353_0, _830_dt__update__tmp_h0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_828_t1, _pat_let354_0 => Dafny.Helpers.Let<BigInteger, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let354_0, _831_dt__update_hnextHeartbeatTime_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_830_dt__update__tmp_h0).dtor_constants, _831_dt__update_hnextHeartbeatTime_h0, (_830_dt__update__tmp_h0).dtor_proposer, (_830_dt__update__tmp_h0).dtor_acceptor, (_830_dt__update__tmp_h0).dtor_learner, (_830_dt__update__tmp_h0).dtor_executor))))), _pat_let352_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>>(_pat_let352_0, _832_t3 => _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_832_t3, _829_t2)))))))));
      return _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create((_825_t1).dtor__0, (_825_t1).dtor__1);
    }
    public static _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CReplicaNextReadClockCheckForViewTimeout(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, BigInteger clock)
    {
      LiveByzRSL____ProposerModel__i_Compile._ICProposer _833_t1 = LiveByzRSL____ProposerModel__i_Compile.__default.CProposerCheckForViewTimeout((s).dtor_proposer, (clock));
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _834_t2 = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_PacketSequence(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements());
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _835_t3 = Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(s, _pat_let355_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let355_0, _836_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_833_t1, _pat_let356_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let356_0, _837_dt__update_hproposer_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_836_dt__update__tmp_h0).dtor_constants, (_836_dt__update__tmp_h0).dtor_nextHeartbeatTime, _837_dt__update_hproposer_h0, (_836_dt__update__tmp_h0).dtor_acceptor, (_836_dt__update__tmp_h0).dtor_learner, (_836_dt__update__tmp_h0).dtor_executor)))));
      return _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_835_t3, _834_t2);
    }
    public static _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> CReplicaNextReadClockCheckForQuorumOfViewSuspicions(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, BigInteger clock)
    {
      LiveByzRSL____ProposerModel__i_Compile._ICProposer _838_t1 = LiveByzRSL____ProposerModel__i_Compile.__default.CProposerCheckForQuorumOfViewSuspicions((s).dtor_proposer, (clock));
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _839_t2 = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_PacketSequence(Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements());
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _840_t3 = Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(s, _pat_let357_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let357_0, _841_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_838_t1, _pat_let358_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let358_0, _842_dt__update_hproposer_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_841_dt__update__tmp_h0).dtor_constants, (_841_dt__update__tmp_h0).dtor_nextHeartbeatTime, _842_dt__update_hproposer_h0, (_841_dt__update__tmp_h0).dtor_acceptor, (_841_dt__update__tmp_h0).dtor_learner, (_841_dt__update__tmp_h0).dtor_executor)))));
      return _System.Tuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets>.create(_840_t3, _839_t2);
    }
    public static void CReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, out LiveByzRSL____ReplicaModel__i_Compile._ICReplica s_k, out LiveByzRSL____CMessage__i_Compile._IOutboundPackets sequential__sent__packets)
    {
      s_k = LiveByzRSL____ReplicaModel__i_Compile.CReplica.Default();
      sequential__sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      if (Dafny.Helpers.Id<Func<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, bool>>((_843_s) => Dafny.Helpers.Quantifier<BigInteger>((((_843_s).dtor_acceptor).dtor_last__checkpointed__operation).UniqueElements, false, (((_exists_var_11) => {
        BigInteger _844_opn = (BigInteger)_exists_var_11;
        return (((((_843_s).dtor_acceptor).dtor_last__checkpointed__operation).Contains((_844_opn))) && ((_844_opn) > (((_843_s).dtor_acceptor).dtor_log__truncation__point))) && (LiveByzRSL____AcceptorModel__i_Compile.__default.CIsLogTruncationPointValid(_844_opn, ((_843_s).dtor_acceptor).dtor_last__checkpointed__operation, (((_843_s).dtor_constants).dtor_all).dtor_config));
      }))))(s)) {
        BigInteger _845_opn;
        foreach (BigInteger _assign_such_that_5 in Dafny.Helpers.IntegerRange((((s).dtor_acceptor).dtor_log__truncation__point) + (BigInteger.One), null)) {
          _845_opn = (BigInteger)_assign_such_that_5;
          if (((_845_opn) > (((s).dtor_acceptor).dtor_log__truncation__point)) && (LiveByzRSL____AcceptorModel__i_Compile.__default.CIsLogTruncationPointValid(_845_opn, ((s).dtor_acceptor).dtor_last__checkpointed__operation, (((s).dtor_constants).dtor_all).dtor_config))) {
            goto after__ASSIGN_SUCH_THAT_5;
          }
        }
        throw new System.Exception("assign-such-that search produced no value (line 551)");
      after__ASSIGN_SUCH_THAT_5: ;
        LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor _846_newAcceptor;
        _846_newAcceptor = LiveByzRSL____AcceptorModel__i_Compile.__default.CAcceptorTruncateLog((s).dtor_acceptor, _845_opn);
        var _pat_let_tv228 = _846_newAcceptor;
        s_k = Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(s, _pat_let359_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let359_0, _847_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let_tv228, _pat_let360_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let360_0, _848_dt__update_hacceptor_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_847_dt__update__tmp_h0).dtor_constants, (_847_dt__update__tmp_h0).dtor_nextHeartbeatTime, (_847_dt__update__tmp_h0).dtor_proposer, _848_dt__update_hacceptor_h0, (_847_dt__update__tmp_h0).dtor_learner, (_847_dt__update__tmp_h0).dtor_executor)))));
        sequential__sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop());
      } else if (Dafny.Helpers.Id<Func<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, bool>>((_849_s) => Dafny.Helpers.Quantifier<BigInteger>((((_849_s).dtor_acceptor).dtor_last__checkpointed__operation).UniqueElements, false, (((_exists_var_12) => {
        BigInteger _850_opn = (BigInteger)_exists_var_12;
        return (((((_849_s).dtor_acceptor).dtor_last__checkpointed__operation).Contains((_850_opn))) && ((_850_opn) <= (((_849_s).dtor_acceptor).dtor_log__truncation__point))) && (LiveByzRSL____AcceptorModel__i_Compile.__default.CIsLogTruncationPointValid(_850_opn, ((_849_s).dtor_acceptor).dtor_last__checkpointed__operation, (((_849_s).dtor_constants).dtor_all).dtor_config));
      }))))(s)) {
        s_k = s;
        sequential__sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop());
      } else {
        s_k = s;
        sequential__sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop());
      }
    }
    public static void CReplicaNextProcess1c(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, LiveByzRSL____CMessage__i_Compile._ICPacket received__packet, out LiveByzRSL____ReplicaModel__i_Compile._ICReplica s_k, out LiveByzRSL____CMessage__i_Compile._IOutboundPackets @out)
    {
      s_k = LiveByzRSL____ReplicaModel__i_Compile.CReplica.Default();
      @out = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      LiveByzRSL____CMessage__i_Compile._ICMessage _851_m;
      _851_m = (received__packet).dtor_msg;
      Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _852_packets__1b;
      _852_packets__1b = ((s).dtor_acceptor).dtor_received__1b__packets;
      BigInteger _853_byzq;
      _853_byzq = LiveByzRSL____CConfiguration__i_Compile.__default.CByzQuorumSize((((s).dtor_constants).dtor_all).dtor_config);
      BigInteger _854_wq;
      _854_wq = LiveByzRSL____CConfiguration__i_Compile.__default.CMinQuorumSize((((s).dtor_constants).dtor_all).dtor_config);
      bool _855_req__is__valid__from__client;
      _855_req__is__valid__from__client = true;
      bool _856_req__is__safe;
      _856_req__is__safe = (((((s).dtor_proposer).dtor_current__state) == (new BigInteger(2))) ? (true) : (((LiveByzRSL____CheckValSafetyImpl__i_Compile.__default.CSeqOfMessage1b(_852_packets__1b)) ? ((LiveByzRSL____CheckValSafetyImpl__i_Compile.__default.CAllAcceptorsHadNoProposal(_852_packets__1b, (_851_m).dtor_opn__1c)) || (LiveByzRSL____CheckValSafetyImpl__i_Compile.__default.CValIsSafeAt((_851_m).dtor_val__1c, _852_packets__1b, (_851_m).dtor_opn__1c, _853_byzq, _854_wq))) : (false))));
      if (((((((((((s).dtor_acceptor).dtor_constants).dtor_all).dtor_config)).Contains(((received__packet).dtor_src))) && (_855_req__is__valid__from__client)) && (_856_req__is__safe)) && (LiveByzRSL____CTypes__i_Compile.__default.CBalLeq(((s).dtor_acceptor).dtor_max__bal, (_851_m).dtor_bal__1c))) && (Common____UpperBound__i_Compile.__default.CLeqUpperBound((_851_m).dtor_opn__1c, (((((s).dtor_acceptor).dtor_constants).dtor_all).dtor_params).dtor_max__integer__val))) {
        _System._ITuple2<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _let_tmp_rhs15 = LiveByzRSL____AcceptorModel__i_Compile.__default.CAcceptorProcess1c((s).dtor_acceptor, received__packet);
        LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor _857_newAcceptor = _let_tmp_rhs15.dtor__0;
        LiveByzRSL____CMessage__i_Compile._IOutboundPackets _858_outs = _let_tmp_rhs15.dtor__1;
        var _pat_let_tv229 = _857_newAcceptor;
        s_k = Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(s, _pat_let361_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let361_0, _859_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let_tv229, _pat_let362_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let362_0, _860_dt__update_hacceptor_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_859_dt__update__tmp_h0).dtor_constants, (_859_dt__update__tmp_h0).dtor_nextHeartbeatTime, (_859_dt__update__tmp_h0).dtor_proposer, _860_dt__update_hacceptor_h0, (_859_dt__update__tmp_h0).dtor_learner, (_859_dt__update__tmp_h0).dtor_executor)))));
        @out = _858_outs;
      } else {
        s_k = s;
        @out = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop());
      }
    }
    public static void CReplicaNextSpontaneousMaybeDecide2bVal(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, out LiveByzRSL____ReplicaModel__i_Compile._ICReplica s_k, out LiveByzRSL____CMessage__i_Compile._IOutboundPackets sent__packets)
    {
      s_k = LiveByzRSL____ReplicaModel__i_Compile.CReplica.Default();
      sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      BigInteger _861_opn;
      _861_opn = ((s).dtor_acceptor).dtor_opn__to__be__send__2b;
      BigInteger _862_quorum;
      _862_quorum = LiveByzRSL____CConfiguration__i_Compile.__default.CByzQuorumSize(((((s).dtor_acceptor).dtor_constants).dtor_all).dtor_config);
      if ((((((((s).dtor_acceptor).dtor_val__to__be__sent__2b).is_CValToBeSent2bUnknown) && ((((s).dtor_acceptor).dtor_received__2avs).Contains((_861_opn)))) && ((new BigInteger(((Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select(((s).dtor_acceptor).dtor_received__2avs,_861_opn))).Count)) >= (_862_quorum))) && (LiveByzRSL____AcceptorModel__i_Compile.__default.CAcceptorStateCorrect(((s).dtor_acceptor).dtor_received__2avs, ((s).dtor_acceptor).dtor_max__bal, (((s).dtor_constants).dtor_all).dtor_config))) && (LiveByzRSL____AcceptorModel__i_Compile.__default.CHasReceivedSame2avFromByzQuorum(Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select(((s).dtor_acceptor).dtor_received__2avs,_861_opn), _862_quorum))) {
        Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _863_p2avs;
        _863_p2avs = Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select(((s).dtor_acceptor).dtor_received__2avs,_861_opn);
        LiveByzRSL____CMessage__i_Compile._ICPacket _864_p;
        foreach (LiveByzRSL____CMessage__i_Compile._ICPacket _assign_such_that_6 in ((_863_p2avs)).Elements) {
          _864_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_assign_such_that_6;
          if ((((_863_p2avs)).Contains((_864_p))) && ((LiveByzRSL____AcceptorModel__i_Compile.__default.CCountMatchedValInReceived2avs((_863_p2avs), ((_864_p).dtor_msg).dtor_val__2av)) >= (_862_quorum))) {
            goto after__ASSIGN_SUCH_THAT_6;
          }
        }
        throw new System.Exception("assign-such-that search produced no value (line 737)");
      after__ASSIGN_SUCH_THAT_6: ;
        LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor _865_newAcceptor;
        _865_newAcceptor = LiveByzRSL____AcceptorModel__i_Compile.__default.CAcceptorDecide2bVal((s).dtor_acceptor, ((s).dtor_acceptor).dtor_max__bal, _861_opn, ((_864_p).dtor_msg).dtor_val__2av);
        var _pat_let_tv230 = _865_newAcceptor;
        s_k = Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(s, _pat_let363_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let363_0, _866_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let_tv230, _pat_let364_0 => Dafny.Helpers.Let<LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let364_0, _867_dt__update_hacceptor_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_866_dt__update__tmp_h0).dtor_constants, (_866_dt__update__tmp_h0).dtor_nextHeartbeatTime, (_866_dt__update__tmp_h0).dtor_proposer, _867_dt__update_hacceptor_h0, (_866_dt__update__tmp_h0).dtor_learner, (_866_dt__update__tmp_h0).dtor_executor)))));
        sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop());
      } else {
        s_k = s;
        sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop());
      }
    }
    public static void CReplicaNextSpontaneousMaybeMakeDecision(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, out LiveByzRSL____ReplicaModel__i_Compile._ICReplica s_k, out LiveByzRSL____CMessage__i_Compile._IOutboundPackets sent__packets)
    {
      s_k = LiveByzRSL____ReplicaModel__i_Compile.CReplica.Default();
      sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      BigInteger _868_opn;
      _868_opn = ((s).dtor_executor).dtor_ops__complete;
      BigInteger _869_quorum;
      _869_quorum = LiveByzRSL____CConfiguration__i_Compile.__default.CMinQuorumSize(((((s).dtor_acceptor).dtor_constants).dtor_all).dtor_config);
      if ((((((((s).dtor_executor).dtor_next__op__to__execute).is_COutstandingOpUnknown) && ((((s).dtor_learner).dtor_unexecuted__learner__state).Contains((_868_opn)))) && (LiveByzRSL____LearnerModel__i_Compile.__default.CLearnerStateCorrect(((s).dtor_learner).dtor_unexecuted__learner__state, ((s).dtor_learner).dtor_max__ballot__seen, (((s).dtor_constants).dtor_all).dtor_config))) && ((new BigInteger(((Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select(((s).dtor_learner).dtor_unexecuted__learner__state,_868_opn))).Count)) >= (_869_quorum))) && (LiveByzRSL____LearnerModel__i_Compile.__default.CHasReceivedSame2bFromWeakQuorum(Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select(((s).dtor_learner).dtor_unexecuted__learner__state,_868_opn), _869_quorum))) {
        Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _870_p2bs;
        _870_p2bs = Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select(((s).dtor_learner).dtor_unexecuted__learner__state,_868_opn);
        LiveByzRSL____CMessage__i_Compile._ICPacket _871_p;
        foreach (LiveByzRSL____CMessage__i_Compile._ICPacket _assign_such_that_7 in ((Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select(((s).dtor_learner).dtor_unexecuted__learner__state,_868_opn))).Elements) {
          _871_p = (LiveByzRSL____CMessage__i_Compile._ICPacket)_assign_such_that_7;
          if ((((Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select(((s).dtor_learner).dtor_unexecuted__learner__state,_868_opn))).Contains((_871_p))) && ((LiveByzRSL____LearnerModel__i_Compile.__default.CCountMatchedValInReceived2bs((Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.Select(((s).dtor_learner).dtor_unexecuted__learner__state,_868_opn)), ((_871_p).dtor_msg).dtor_val__2b)) >= (_869_quorum))) {
            goto after__ASSIGN_SUCH_THAT_7;
          }
        }
        throw new System.Exception("assign-such-that search produced no value (line 799)");
      after__ASSIGN_SUCH_THAT_7: ;
        LiveByzRSL____ExecutorModel__i_Compile._ICExecutor _872_newExecutor;
        _872_newExecutor = LiveByzRSL____ExecutorModel__i_Compile.__default.CExecutorGetDecision((s).dtor_executor, ((s).dtor_learner).dtor_max__ballot__seen, _868_opn, ((_871_p).dtor_msg).dtor_val__2b);
        var _pat_let_tv231 = _872_newExecutor;
        s_k = Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(s, _pat_let365_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let365_0, _873_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let_tv231, _pat_let366_0 => Dafny.Helpers.Let<LiveByzRSL____ExecutorModel__i_Compile._ICExecutor, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let366_0, _874_dt__update_hexecutor_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_873_dt__update__tmp_h0).dtor_constants, (_873_dt__update__tmp_h0).dtor_nextHeartbeatTime, (_873_dt__update__tmp_h0).dtor_proposer, (_873_dt__update__tmp_h0).dtor_acceptor, (_873_dt__update__tmp_h0).dtor_learner, _874_dt__update_hexecutor_h0)))));
        sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop());
      } else {
        s_k = s;
        sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop());
      }
    }
    public static void CReplicaNextReadClockMaybeNominateValueAndSend1c(LiveByzRSL____ReplicaModel__i_Compile._ICReplica s, BigInteger clock, out LiveByzRSL____ReplicaModel__i_Compile._ICReplica s_k, out LiveByzRSL____CMessage__i_Compile._IOutboundPackets sequential__sent__packets)
    {
      s_k = LiveByzRSL____ReplicaModel__i_Compile.CReplica.Default();
      sequential__sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      LiveByzRSL____ProposerModel__i_Compile._ICProposer _875_newProposer;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _876_packets;
      LiveByzRSL____ProposerModel__i_Compile._ICProposer _out124;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _out125;
      LiveByzRSL____ProposerModel__i_Compile.__default.CProposerMaybeNominateValueAndSend1c((s).dtor_proposer, (clock), ((s).dtor_acceptor).dtor_log__truncation__point, out _out124, out _out125);
      _875_newProposer = _out124;
      _876_packets = _out125;
      var _pat_let_tv232 = _875_newProposer;
      s_k = Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(s, _pat_let367_0 => Dafny.Helpers.Let<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let367_0, _877_dt__update__tmp_h0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let_tv232, _pat_let368_0 => Dafny.Helpers.Let<LiveByzRSL____ProposerModel__i_Compile._ICProposer, LiveByzRSL____ReplicaModel__i_Compile._ICReplica>(_pat_let368_0, _878_dt__update_hproposer_h0 => LiveByzRSL____ReplicaModel__i_Compile.CReplica.create((_877_dt__update__tmp_h0).dtor_constants, (_877_dt__update__tmp_h0).dtor_nextHeartbeatTime, _878_dt__update_hproposer_h0, (_877_dt__update__tmp_h0).dtor_acceptor, (_877_dt__update__tmp_h0).dtor_learner, (_877_dt__update__tmp_h0).dtor_executor)))));
      sequential__sent__packets = _876_packets;
    }
  }
} // end of namespace LiveByzRSL____ReplicaModel__i_Compile
namespace LiveByzRSL____UdpRSL__i_Compile {

  public interface _IReceiveResult {
    bool is_RRFail { get; }
    bool is_RRTimeout { get; }
    bool is_RRPacket { get; }
    LiveByzRSL____CMessage__i_Compile._ICPacket dtor_cpacket { get; }
    _IReceiveResult DowncastClone();
  }
  public abstract class ReceiveResult : _IReceiveResult {
    public ReceiveResult() { }
    private static readonly LiveByzRSL____UdpRSL__i_Compile._IReceiveResult theDefault = create_RRFail();
    public static LiveByzRSL____UdpRSL__i_Compile._IReceiveResult Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____UdpRSL__i_Compile._IReceiveResult> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____UdpRSL__i_Compile._IReceiveResult>(LiveByzRSL____UdpRSL__i_Compile.ReceiveResult.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____UdpRSL__i_Compile._IReceiveResult> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IReceiveResult create_RRFail() {
      return new ReceiveResult_RRFail();
    }
    public static _IReceiveResult create_RRTimeout() {
      return new ReceiveResult_RRTimeout();
    }
    public static _IReceiveResult create_RRPacket(LiveByzRSL____CMessage__i_Compile._ICPacket cpacket) {
      return new ReceiveResult_RRPacket(cpacket);
    }
    public bool is_RRFail { get { return this is ReceiveResult_RRFail; } }
    public bool is_RRTimeout { get { return this is ReceiveResult_RRTimeout; } }
    public bool is_RRPacket { get { return this is ReceiveResult_RRPacket; } }
    public LiveByzRSL____CMessage__i_Compile._ICPacket dtor_cpacket {
      get {
        var d = this;
        return ((ReceiveResult_RRPacket)d)._cpacket;
      }
    }
    public abstract _IReceiveResult DowncastClone();
  }
  public class ReceiveResult_RRFail : ReceiveResult {
    public ReceiveResult_RRFail() {
    }
    public override _IReceiveResult DowncastClone() {
      if (this is _IReceiveResult dt) { return dt; }
      return new ReceiveResult_RRFail();
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____UdpRSL__i_Compile.ReceiveResult_RRFail;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____UdpRSL__i_Compile.ReceiveResult.RRFail";
      return s;
    }
  }
  public class ReceiveResult_RRTimeout : ReceiveResult {
    public ReceiveResult_RRTimeout() {
    }
    public override _IReceiveResult DowncastClone() {
      if (this is _IReceiveResult dt) { return dt; }
      return new ReceiveResult_RRTimeout();
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____UdpRSL__i_Compile.ReceiveResult_RRTimeout;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____UdpRSL__i_Compile.ReceiveResult.RRTimeout";
      return s;
    }
  }
  public class ReceiveResult_RRPacket : ReceiveResult {
    public readonly LiveByzRSL____CMessage__i_Compile._ICPacket _cpacket;
    public ReceiveResult_RRPacket(LiveByzRSL____CMessage__i_Compile._ICPacket cpacket) {
      this._cpacket = cpacket;
    }
    public override _IReceiveResult DowncastClone() {
      if (this is _IReceiveResult dt) { return dt; }
      return new ReceiveResult_RRPacket(_cpacket);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____UdpRSL__i_Compile.ReceiveResult_RRPacket;
      return oth != null && object.Equals(this._cpacket, oth._cpacket);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cpacket));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____UdpRSL__i_Compile.ReceiveResult.RRPacket";
      s += "(";
      s += Dafny.Helpers.ToString(this._cpacket);
      s += ")";
      return s;
    }
  }

  public partial class __default {
    public static Native____Io__s_Compile._IEndPoint GetEndPoint(Native____Io__s_Compile.IPEndPoint ipe)
    {
      Native____Io__s_Compile._IEndPoint ep = Native____Io__s_Compile.EndPoint.Default();
      byte[] _879_addr;
      byte[] _out126;
      _out126 = (ipe).GetAddress();
      _879_addr = _out126;
      ushort _880_port;
      _880_port = (ipe).GetPort();
      ep = Native____Io__s_Compile.EndPoint.create(Dafny.Helpers.SeqFromArray(_879_addr), _880_port);
      return ep;
    }
    public static LiveByzRSL____UdpRSL__i_Compile._IReceiveResult Receive(Native____Io__s_Compile.UdpClient udpClient, Native____Io__s_Compile._IEndPoint localAddr, Dafny.ISequence<Native____Io__s_Compile._IEndPoint> config, Common____GenericMarshalling__i_Compile._IG msg__grammar)
    {
      LiveByzRSL____UdpRSL__i_Compile._IReceiveResult rr = LiveByzRSL____UdpRSL__i_Compile.ReceiveResult.Default();
      int _881_timeout;
      _881_timeout = 0;
      bool _882_ok;
      bool _883_timedOut;
      Native____Io__s_Compile.IPEndPoint _884_remote;
      byte[] _885_buffer;
      bool _out127;
      bool _out128;
      Native____Io__s_Compile.IPEndPoint _out129;
      byte[] _out130;
      (udpClient).Receive(_881_timeout, out _out127, out _out128, out _out129, out _out130);
      _882_ok = _out127;
      _883_timedOut = _out128;
      _884_remote = _out129;
      _885_buffer = _out130;
      if (!(_882_ok)) {
        rr = LiveByzRSL____UdpRSL__i_Compile.ReceiveResult.create_RRFail();
        return rr;
      }
      if (_883_timedOut) {
        rr = LiveByzRSL____UdpRSL__i_Compile.ReceiveResult.create_RRTimeout();
        return rr;
      }
      ulong _886_start__time;
      ulong _out131;
      _out131 = Native____Io__s_Compile.Time.GetDebugTimeTicks();
      _886_start__time = _out131;
      LiveByzRSL____CMessage__i_Compile._ICMessage _887_cmessage;
      LiveByzRSL____CMessage__i_Compile._ICMessage _out132;
      _out132 = LiveByzRSL____PacketParsing__i_Compile.__default.PaxosDemarshallDataMethod(_885_buffer, msg__grammar);
      _887_cmessage = _out132;
      ulong _888_end__time;
      ulong _out133;
      _out133 = Native____Io__s_Compile.Time.GetDebugTimeTicks();
      _888_end__time = _out133;
      Common____Util__i_Compile.__default.RecordTimingSeq(Dafny.Sequence<char>.FromString("PaxosDemarshallDataMethod"), _886_start__time, _888_end__time);
      Native____Io__s_Compile._IEndPoint _889_srcEp;
      Native____Io__s_Compile._IEndPoint _out134;
      _out134 = LiveByzRSL____UdpRSL__i_Compile.__default.GetEndPoint(_884_remote);
      _889_srcEp = _out134;
      LiveByzRSL____CMessage__i_Compile._ICPacket _890_cpacket;
      _890_cpacket = LiveByzRSL____CMessage__i_Compile.CPacket.create(localAddr, _889_srcEp, _887_cmessage);
      rr = LiveByzRSL____UdpRSL__i_Compile.ReceiveResult.create_RRPacket(_890_cpacket);
      if ((_887_cmessage).is_CMessage__Invalid) {
        Common____Util__i_Compile.__default.RecordTimingSeq(Dafny.Sequence<char>.FromString("DemarshallMessage_Invalid"), _886_start__time, _888_end__time);
      } else if ((_887_cmessage).is_CMessage__Request) {
        Common____Util__i_Compile.__default.RecordTimingSeq(Dafny.Sequence<char>.FromString("DemarshallMessage_Request"), _886_start__time, _888_end__time);
      } else if ((_887_cmessage).is_CMessage__1a) {
        Common____Util__i_Compile.__default.RecordTimingSeq(Dafny.Sequence<char>.FromString("DemarshallMessage_1a"), _886_start__time, _888_end__time);
      } else if ((_887_cmessage).is_CMessage__1b) {
        Common____Util__i_Compile.__default.RecordTimingSeq(Dafny.Sequence<char>.FromString("DemarshallMessage_1b"), _886_start__time, _888_end__time);
      } else if ((_887_cmessage).is_CMessage__1c) {
        Common____Util__i_Compile.__default.RecordTimingSeq(Dafny.Sequence<char>.FromString("DemarshallMessage_1c"), _886_start__time, _888_end__time);
      } else if ((_887_cmessage).is_CMessage__2av) {
        Common____Util__i_Compile.__default.RecordTimingSeq(Dafny.Sequence<char>.FromString("DemarshallMessage_2av"), _886_start__time, _888_end__time);
      } else if ((_887_cmessage).is_CMessage__2b) {
        Common____Util__i_Compile.__default.RecordTimingSeq(Dafny.Sequence<char>.FromString("DemarshallMessage_2b"), _886_start__time, _888_end__time);
      } else if ((_887_cmessage).is_CMessage__Heartbeat) {
        Common____Util__i_Compile.__default.RecordTimingSeq(Dafny.Sequence<char>.FromString("DemarshallMessage_Heartbeat"), _886_start__time, _888_end__time);
      } else if ((_887_cmessage).is_CMessage__Reply) {
        Common____Util__i_Compile.__default.RecordTimingSeq(Dafny.Sequence<char>.FromString("DemarshallMessage_Reply"), _886_start__time, _888_end__time);
      } else if ((_887_cmessage).is_CMessage__StartingPhase2) {
        Common____Util__i_Compile.__default.RecordTimingSeq(Dafny.Sequence<char>.FromString("DemarshallMessage_StartingPhase2"), _886_start__time, _888_end__time);
      }
      return rr;
    }
    public static BigInteger ReadClock(Native____Io__s_Compile.UdpClient udpClient)
    {
      BigInteger clock = BigInteger.Zero;
      ulong _891_t;
      ulong _out135;
      _out135 = Native____Io__s_Compile.Time.GetTime();
      _891_t = _out135;
      clock = new BigInteger(_891_t);
      return clock;
    }
    public static bool SendBroadcast(Native____Io__s_Compile.UdpClient udpClient, LiveByzRSL____CMessage__i_Compile._ICBroadcast broadcast)
    {
      bool ok = false;
      ok = true;
      if ((broadcast).is_CBroadcastNop) {
      } else {
        byte[] _892_buffer;
        byte[] _out136;
        _out136 = LiveByzRSL____PacketParsing__i_Compile.__default.PaxosMarshall((broadcast).dtor_msg);
        _892_buffer = _out136;
        ulong _893_i;
        _893_i = 0UL;
        while ((_893_i) < ((ulong)((broadcast).dtor_dsts).LongCount)) {
          Native____Io__s_Compile._IEndPoint _894_dstEp;
          _894_dstEp = ((broadcast).dtor_dsts).Select(_893_i);
          byte[] _895_dstAddrAry;
          byte[] _out137;
          _out137 = Common____Util__i_Compile.__default.seqToArrayOpt<byte>(Native____NativeTypes__s_Compile.@byte._TypeDescriptor(), (_894_dstEp).dtor_addr);
          _895_dstAddrAry = _out137;
          Native____Io__s_Compile.IPEndPoint _896_remote = default(Native____Io__s_Compile.IPEndPoint);
          bool _out138;
          Native____Io__s_Compile.IPEndPoint _out139;
          Native____Io__s_Compile.IPEndPoint.Construct(_895_dstAddrAry, (_894_dstEp).dtor_port, out _out138, out _out139);
          ok = _out138;
          _896_remote = _out139;
          if (!(ok)) {
            return ok;
          }
          bool _out140;
          _out140 = (udpClient).Send(_896_remote, _892_buffer);
          ok = _out140;
          if (!(ok)) {
            return ok;
          }
          _893_i = (_893_i) + (1UL);
        }
      }
      return ok;
    }
    public static bool SendPacket(Native____Io__s_Compile.UdpClient udpClient, LiveByzRSL____CMessage__i_Compile._IOutboundPackets packets)
    {
      bool ok = false;
      ulong _897_j;
      _897_j = 0UL;
      ok = true;
      Logic____Option__i_Compile._IOption<LiveByzRSL____CMessage__i_Compile._ICPacket> _898_opt__packet;
      _898_opt__packet = (packets).dtor_p;
      if ((_898_opt__packet).is_None) {
      } else {
        LiveByzRSL____CMessage__i_Compile._ICPacket _899_cpacket;
        _899_cpacket = (_898_opt__packet).dtor_v;
        Native____Io__s_Compile._IEndPoint _900_dstEp;
        _900_dstEp = (_899_cpacket).dtor_dst;
        byte[] _901_dstAddrAry;
        byte[] _out141;
        _out141 = Common____Util__i_Compile.__default.seqToArrayOpt<byte>(Native____NativeTypes__s_Compile.@byte._TypeDescriptor(), (_900_dstEp).dtor_addr);
        _901_dstAddrAry = _out141;
        Native____Io__s_Compile.IPEndPoint _902_remote = default(Native____Io__s_Compile.IPEndPoint);
        bool _out142;
        Native____Io__s_Compile.IPEndPoint _out143;
        Native____Io__s_Compile.IPEndPoint.Construct(_901_dstAddrAry, (_900_dstEp).dtor_port, out _out142, out _out143);
        ok = _out142;
        _902_remote = _out143;
        if (!(ok)) {
          return ok;
        }
        ulong _903_marshall__start__time;
        ulong _out144;
        _out144 = Native____Io__s_Compile.Time.GetDebugTimeTicks();
        _903_marshall__start__time = _out144;
        byte[] _904_buffer;
        byte[] _out145;
        _out145 = LiveByzRSL____PacketParsing__i_Compile.__default.PaxosMarshall((_899_cpacket).dtor_msg);
        _904_buffer = _out145;
        ulong _905_marshall__end__time;
        ulong _out146;
        _out146 = Native____Io__s_Compile.Time.GetDebugTimeTicks();
        _905_marshall__end__time = _out146;
        Common____Util__i_Compile.__default.RecordTimingSeq(Dafny.Sequence<char>.FromString("SendBatch_PaxosMarshall"), _903_marshall__start__time, _905_marshall__end__time);
        bool _out147;
        _out147 = (udpClient).Send(_902_remote, _904_buffer);
        ok = _out147;
        if (!(ok)) {
          return ok;
        }
      }
      return ok;
    }
    public static bool SendPacketSequence(Native____Io__s_Compile.UdpClient udpClient, LiveByzRSL____CMessage__i_Compile._IOutboundPackets packets)
    {
      bool ok = false;
      Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _906_cpackets;
      _906_cpackets = (packets).dtor_s;
      BigInteger _907_j;
      _907_j = BigInteger.Zero;
      ok = true;
      BigInteger _908_i;
      _908_i = BigInteger.Zero;
      while ((_908_i) < (new BigInteger((_906_cpackets).Count))) {
        LiveByzRSL____CMessage__i_Compile._ICPacket _909_cpacket;
        _909_cpacket = (_906_cpackets).Select(_908_i);
        Native____Io__s_Compile._IEndPoint _910_dstEp;
        _910_dstEp = (_909_cpacket).dtor_dst;
        byte[] _911_dstAddrAry;
        byte[] _out148;
        _out148 = Common____Util__i_Compile.__default.seqToArrayOpt<byte>(Native____NativeTypes__s_Compile.@byte._TypeDescriptor(), (_910_dstEp).dtor_addr);
        _911_dstAddrAry = _out148;
        Native____Io__s_Compile.IPEndPoint _912_remote = default(Native____Io__s_Compile.IPEndPoint);
        bool _out149;
        Native____Io__s_Compile.IPEndPoint _out150;
        Native____Io__s_Compile.IPEndPoint.Construct(_911_dstAddrAry, (_910_dstEp).dtor_port, out _out149, out _out150);
        ok = _out149;
        _912_remote = _out150;
        if (!(ok)) {
          return ok;
        }
        byte[] _913_buffer;
        byte[] _out151;
        _out151 = LiveByzRSL____PacketParsing__i_Compile.__default.PaxosMarshall((_909_cpacket).dtor_msg);
        _913_buffer = _out151;
        bool _out152;
        _out152 = (udpClient).Send(_912_remote, _913_buffer);
        ok = _out152;
        if (!(ok)) {
          return ok;
        }
        _908_i = (_908_i) + (BigInteger.One);
      }
      return ok;
    }
  }
} // end of namespace LiveByzRSL____UdpRSL__i_Compile
namespace LiveByzRSL____ReplicaImplClass__i_Compile {

  public partial class ReplicaImpl {
    public ReplicaImpl() {
      this.replica = LiveByzRSL____ReplicaModel__i_Compile.CReplica.Default();
      this.nextActionIndex = 0;
      this.netClient = ((Native____Io__s_Compile.UdpClient)null);
      this.localAddr = Native____Io__s_Compile.EndPoint.Default();
      this.msg__grammar = Common____GenericMarshalling__i_Compile.G.Default();
    }
    public LiveByzRSL____ReplicaModel__i_Compile._ICReplica replica {get; set;}
    public ulong nextActionIndex {get; set;}
    public Native____Io__s_Compile.UdpClient netClient {get; set;}
    public Native____Io__s_Compile._IEndPoint localAddr {get; set;}
    public Common____GenericMarshalling__i_Compile._IG msg__grammar {get; set;}
    public void __ctor()
    {
      (this).netClient = (Native____Io__s_Compile.UdpClient)null;
      LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants _914_rcs;
      _914_rcs = LiveByzRSL____ConstantsState__i_Compile.CReplicaConstants.create(BigInteger.Zero, LiveByzRSL____ConstantsState__i_Compile.CConstants.create(Dafny.Sequence<Native____Io__s_Compile._IEndPoint>.FromElements(), LiveByzRSL____ParametersState__i_Compile.CParameters.create(BigInteger.Zero, BigInteger.Zero, BigInteger.Zero, Common____UpperBound__i_Compile.CUpperBound.create_CUpperBoundInfinite(), BigInteger.Zero, BigInteger.Zero)));
      LiveByzRSL____ElectionModel__i_Compile._ICElectionState _915_election__state;
      _915_election__state = LiveByzRSL____ElectionModel__i_Compile.CElectionState.create(_914_rcs, LiveByzRSL____CTypes__i_Compile.CBallot.create(BigInteger.Zero, BigInteger.Zero), Dafny.Set<BigInteger>.FromElements(), BigInteger.Zero, BigInteger.Zero, Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements(), Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements());
      LiveByzRSL____ProposerModel__i_Compile._ICProposer _916_proposer__state;
      _916_proposer__state = LiveByzRSL____ProposerModel__i_Compile.CProposer.create(_914_rcs, BigInteger.Zero, Dafny.Sequence<LiveByzRSL____CTypes__i_Compile._ICRequest>.FromElements(), LiveByzRSL____CTypes__i_Compile.CBallot.create(BigInteger.Zero, BigInteger.Zero), BigInteger.Zero, Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements(), Dafny.Map<Native____Io__s_Compile._IEndPoint, BigInteger>.FromElements(), LiveByzRSL____ProposerModel__i_Compile.CIncompleteBatchTimer.create_CIncompleteBatchTimerOff(), _915_election__state);
      LiveByzRSL____AcceptorModel__i_Compile._ICAcceptor _917_acceptor__state;
      _917_acceptor__state = LiveByzRSL____AcceptorModel__i_Compile.CAcceptor.create(_914_rcs, LiveByzRSL____CTypes__i_Compile.CBallot.create(BigInteger.Zero, BigInteger.Zero), Dafny.Map<BigInteger, LiveByzRSL____CTypes__i_Compile._ICVote>.FromElements(), Dafny.Sequence<BigInteger>.FromElements(), BigInteger.Zero, Dafny.Sequence<LiveByzRSL____CMessage__i_Compile._ICPacket>.FromElements(), Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.FromElements(), BigInteger.Zero, LiveByzRSL____AcceptorModel__i_Compile.CValToBeSent2b.create_CValToBeSent2bUnknown());
      LiveByzRSL____LearnerModel__i_Compile._ICLearner _918_learner__state;
      _918_learner__state = LiveByzRSL____LearnerModel__i_Compile.CLearner.create(_914_rcs, LiveByzRSL____CTypes__i_Compile.CBallot.create(BigInteger.Zero, BigInteger.Zero), Dafny.Map<BigInteger, Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket>>.FromElements());
      ulong _919_app__state;
      _919_app__state = LiveByzRSL____AppInterface__i_Compile.__default.CAppStateInit();
      LiveByzRSL____ExecutorModel__i_Compile._ICExecutor _920_executor__state;
      _920_executor__state = LiveByzRSL____ExecutorModel__i_Compile.CExecutor.create(_914_rcs, _919_app__state, BigInteger.Zero, LiveByzRSL____CTypes__i_Compile.CBallot.create(BigInteger.Zero, BigInteger.Zero), LiveByzRSL____ExecutorModel__i_Compile.COutstandingOperation.create_COutstandingOpUnknown(), Dafny.Map<Native____Io__s_Compile._IEndPoint, LiveByzRSL____CTypes__i_Compile._ICReply>.FromElements());
      (this).replica = LiveByzRSL____ReplicaModel__i_Compile.CReplica.create(_914_rcs, BigInteger.Zero, _916_proposer__state, _917_acceptor__state, _918_learner__state, _920_executor__state);
    }
    public void ConstructUdpClient(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants, out bool ok, out Native____Io__s_Compile.UdpClient client)
    {
      ok = false;
      client = ((Native____Io__s_Compile.UdpClient)null);
      Native____Io__s_Compile._IEndPoint _921_my__ep;
      _921_my__ep = ((((constants).dtor_all).dtor_config)).Select((constants).dtor_my__index);
      byte[] _922_ip__byte__array;
      byte[] _nw10 = new byte[Dafny.Helpers.ToIntChecked(new BigInteger(((_921_my__ep).dtor_addr).Count), "array size exceeds memory limit")];
      _922_ip__byte__array = _nw10;
      Common____Util__i_Compile.__default.seqIntoArrayOpt<byte>((_921_my__ep).dtor_addr, _922_ip__byte__array);
      Native____Io__s_Compile.IPEndPoint _923_ip__endpoint = default(Native____Io__s_Compile.IPEndPoint);
      bool _out153;
      Native____Io__s_Compile.IPEndPoint _out154;
      Native____Io__s_Compile.IPEndPoint.Construct(_922_ip__byte__array, (_921_my__ep).dtor_port, out _out153, out _out154);
      ok = _out153;
      _923_ip__endpoint = _out154;
      if (!(ok)) {
        return ;
      }
      bool _out155;
      Native____Io__s_Compile.UdpClient _out156;
      Native____Io__s_Compile.UdpClient.Construct(_923_ip__endpoint, out _out155, out _out156);
      ok = _out155;
      client = _out156;
    }
    public bool Replica__Init(LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants constants)
    {
      bool ok = false;
      bool _out157;
      Native____Io__s_Compile.UdpClient _out158;
      (this).ConstructUdpClient(constants, out _out157, out _out158);
      ok = _out157;
      (this).netClient = _out158;
      if (ok) {
        (this).replica = LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaInit(constants);
        (this).nextActionIndex = 0UL;
        (this).localAddr = (((((this.replica).dtor_constants).dtor_all).dtor_config)).Select(((this.replica).dtor_constants).dtor_my__index);
        (this).msg__grammar = LiveByzRSL____PacketParsing__i_Compile.__default.CMessage__grammar();
      }
      return ok;
    }
  }

} // end of namespace LiveByzRSL____ReplicaImplClass__i_Compile
namespace LiveByzRSL____CMessageRefinements__i_Compile {

} // end of namespace LiveByzRSL____CMessageRefinements__i_Compile
namespace LiveBysRSL__ReplicaImplConditions__i_Compile {

} // end of namespace LiveBysRSL__ReplicaImplConditions__i_Compile
namespace LiveByzRSL____ReplicaImplLemmas__i_Compile {

} // end of namespace LiveByzRSL____ReplicaImplLemmas__i_Compile
namespace LiveByzRSL____ReplicaImplDelivery__i_Compile {

  public partial class __default {
    public static bool DeliverPacket(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____CMessage__i_Compile._IOutboundPackets packets)
    {
      bool ok = false;
      bool _out159;
      _out159 = LiveByzRSL____UdpRSL__i_Compile.__default.SendPacket(r.netClient, packets);
      ok = _out159;
      if (!(ok)) {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("ReplicaImplDelivery: send packet fail\n")));
        return ok;
      }
      return ok;
    }
    public static bool DeliverPacketSequence(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____CMessage__i_Compile._IOutboundPackets packets)
    {
      bool ok = false;
      bool _out160;
      _out160 = LiveByzRSL____UdpRSL__i_Compile.__default.SendPacketSequence(r.netClient, packets);
      ok = _out160;
      if (!(ok)) {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("ReplicaImplDelivery: send packetseq fail\n")));
        return ok;
      }
      return ok;
    }
    public static bool DeliverBroadcast(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____CMessage__i_Compile._ICBroadcast broadcast)
    {
      bool ok = false;
      bool _out161;
      _out161 = LiveByzRSL____UdpRSL__i_Compile.__default.SendBroadcast(r.netClient, broadcast);
      ok = _out161;
      if (!(ok)) {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("ReplicaImplDelivery: send broadcast fail\n")));
        return ok;
      }
      return ok;
    }
    public static bool DeliverOutboundPackets(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____CMessage__i_Compile._IOutboundPackets packets)
    {
      bool ok = false;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _source7 = packets;
      if (_source7.is_Broadcast) {
        LiveByzRSL____CMessage__i_Compile._ICBroadcast _924___mcc_h0 = _source7.dtor_broadcast;
        LiveByzRSL____CMessage__i_Compile._ICBroadcast _925_broadcast = _924___mcc_h0;
        bool _out162;
        _out162 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverBroadcast(r, _925_broadcast);
        ok = _out162;
      } else if (_source7.is_OutboundPacket) {
        Logic____Option__i_Compile._IOption<LiveByzRSL____CMessage__i_Compile._ICPacket> _926___mcc_h1 = _source7.dtor_p;
        Logic____Option__i_Compile._IOption<LiveByzRSL____CMessage__i_Compile._ICPacket> _927_p = _926___mcc_h1;
        bool _out163;
        _out163 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverPacket(r, packets);
        ok = _out163;
      } else {
        Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _928___mcc_h2 = _source7.dtor_s;
        Dafny.ISequence<LiveByzRSL____CMessage__i_Compile._ICPacket> _929_s = _928___mcc_h2;
        bool _out164;
        _out164 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverPacketSequence(r, packets);
        ok = _out164;
      }
      return ok;
    }
  }
} // end of namespace LiveByzRSL____ReplicaImplDelivery__i_Compile
namespace LiveByzRSL____ReplicaImplNoReceiveClock__i_Compile {

  public partial class __default {
    public static bool ReplicaNoReceiveReadClockNextMaybeNominateValueAndSend1c(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      BigInteger _930_clock;
      BigInteger _out165;
      _out165 = LiveByzRSL____UdpRSL__i_Compile.__default.ReadClock(r.netClient);
      _930_clock = _out165;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _931_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _out166;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _out167;
      LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextReadClockMaybeNominateValueAndSend1c(r.replica, _930_clock, out _out166, out _out167);
      (r).replica = _out166;
      _931_sent__packets = _out167;
      bool _out168;
      _out168 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _931_sent__packets);
      ok = _out168;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool ReplicaNoReceiveReadClockNextCheckForViewTimeout(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      BigInteger _932_clock;
      BigInteger _out169;
      _out169 = LiveByzRSL____UdpRSL__i_Compile.__default.ReadClock(r.netClient);
      _932_clock = _out169;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _933_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _let_tmp_rhs16 = LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextReadClockCheckForViewTimeout(r.replica, _932_clock);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _934_t0 = _let_tmp_rhs16.dtor__0;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _935_t1 = _let_tmp_rhs16.dtor__1;
      (r).replica = _934_t0;
      _933_sent__packets = _935_t1;
      bool _out170;
      _out170 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _933_sent__packets);
      ok = _out170;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool ReplicaNoReceiveReadClockNextCheckForQuorumOfViewSuspicions(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      BigInteger _936_clock;
      BigInteger _out171;
      _out171 = LiveByzRSL____UdpRSL__i_Compile.__default.ReadClock(r.netClient);
      _936_clock = _out171;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _937_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _let_tmp_rhs17 = LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextReadClockCheckForQuorumOfViewSuspicions(r.replica, _936_clock);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _938_t0 = _let_tmp_rhs17.dtor__0;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _939_t1 = _let_tmp_rhs17.dtor__1;
      (r).replica = _938_t0;
      _937_sent__packets = _939_t1;
      bool _out172;
      _out172 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _937_sent__packets);
      ok = _out172;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool ReplicaNoReceiveReadClockNextMaybeSendHeartbat(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      BigInteger _940_clock;
      BigInteger _out173;
      _out173 = LiveByzRSL____UdpRSL__i_Compile.__default.ReadClock(r.netClient);
      _940_clock = _out173;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _941_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _let_tmp_rhs18 = LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextReadClockMaybeSendHeartbeat(r.replica, _940_clock);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _942_t0 = _let_tmp_rhs18.dtor__0;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _943_t1 = _let_tmp_rhs18.dtor__1;
      (r).replica = _942_t0;
      _941_sent__packets = _943_t1;
      bool _out174;
      _out174 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _941_sent__packets);
      ok = _out174;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool Replica__NoReceive__ReadClock__Next(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      if ((r.nextActionIndex) == (3UL)) {
        bool _out175;
        _out175 = LiveByzRSL____ReplicaImplNoReceiveClock__i_Compile.__default.ReplicaNoReceiveReadClockNextMaybeNominateValueAndSend1c(r);
        ok = _out175;
      } else if ((r.nextActionIndex) == (9UL)) {
        bool _out176;
        _out176 = LiveByzRSL____ReplicaImplNoReceiveClock__i_Compile.__default.ReplicaNoReceiveReadClockNextCheckForViewTimeout(r);
        ok = _out176;
      } else if ((r.nextActionIndex) == (10UL)) {
        bool _out177;
        _out177 = LiveByzRSL____ReplicaImplNoReceiveClock__i_Compile.__default.ReplicaNoReceiveReadClockNextCheckForQuorumOfViewSuspicions(r);
        ok = _out177;
      } else if ((r.nextActionIndex) == (11UL)) {
        bool _out178;
        _out178 = LiveByzRSL____ReplicaImplNoReceiveClock__i_Compile.__default.ReplicaNoReceiveReadClockNextMaybeSendHeartbat(r);
        ok = _out178;
      }
      return ok;
    }
  }
} // end of namespace LiveByzRSL____ReplicaImplNoReceiveClock__i_Compile
namespace LiveByzRSL____ReplicaImplNoReceiveNoClock__i_Compile {

  public partial class __default {
    public static bool ReplicaNoReceiveNoClockNextSpontaneousMaybeEnterNewViewAndSend1a(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _944_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _let_tmp_rhs19 = LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextSpontaneousMaybeEnterNewViewAndSend1a(r.replica);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _945_t0 = _let_tmp_rhs19.dtor__0;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _946_t1 = _let_tmp_rhs19.dtor__1;
      (r).replica = _945_t0;
      _944_sent__packets = _946_t1;
      bool _out179;
      _out179 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _944_sent__packets);
      ok = _out179;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool ReplicaNoReceiveNoClockNextSpontaneousMaybeEnterPhase2(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _947_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _let_tmp_rhs20 = LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextSpontaneousMaybeEnterPhase2(r.replica);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _948_t0 = _let_tmp_rhs20.dtor__0;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _949_t1 = _let_tmp_rhs20.dtor__1;
      (r).replica = _948_t0;
      _947_sent__packets = _949_t1;
      bool _out180;
      _out180 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _947_sent__packets);
      ok = _out180;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool ReplicaNoReceiveNoClockNextSpontaneousMaybeDecide2bVal(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _950_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _951_replica = LiveByzRSL____ReplicaModel__i_Compile.CReplica.Default();
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _out181;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _out182;
      LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextSpontaneousMaybeDecide2bVal(r.replica, out _out181, out _out182);
      _951_replica = _out181;
      _950_sent__packets = _out182;
      (r).replica = _951_replica;
      bool _out183;
      _out183 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _950_sent__packets);
      ok = _out183;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool ReplicaNoReceiveNoClockNextSpontaneousMaybeSend2b(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _952_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _let_tmp_rhs21 = LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextSpontaneousMaybeSend2b(r.replica);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _953_t0 = _let_tmp_rhs21.dtor__0;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _954_t1 = _let_tmp_rhs21.dtor__1;
      (r).replica = _953_t0;
      _952_sent__packets = _954_t1;
      bool _out184;
      _out184 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _952_sent__packets);
      ok = _out184;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool ReplicaNoReceiveNoClockNextSpontaneousTruncateLogBasedOnCheckpoints(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _955_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _956_replica = LiveByzRSL____ReplicaModel__i_Compile.CReplica.Default();
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _out185;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _out186;
      LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextSpontaneousTruncateLogBasedOnCheckpoints(r.replica, out _out185, out _out186);
      _956_replica = _out185;
      _955_sent__packets = _out186;
      (r).replica = _956_replica;
      bool _out187;
      _out187 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _955_sent__packets);
      ok = _out187;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool ReplicaNoReceiveNoClockNextSpontaneousMaybeMakeDecision(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _957_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _958_replica = LiveByzRSL____ReplicaModel__i_Compile.CReplica.Default();
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _out188;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _out189;
      LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextSpontaneousMaybeMakeDecision(r.replica, out _out188, out _out189);
      _958_replica = _out188;
      _957_sent__packets = _out189;
      (r).replica = _958_replica;
      bool _out190;
      _out190 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _957_sent__packets);
      ok = _out190;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool ReplicaNoReceiveNoClockNextSpontaneousMaybeExecute(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _959_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _let_tmp_rhs22 = LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextSpontaneousMaybeExecute(r.replica);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _960_t0 = _let_tmp_rhs22.dtor__0;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _961_t1 = _let_tmp_rhs22.dtor__1;
      (r).replica = _960_t0;
      _959_sent__packets = _961_t1;
      bool _out191;
      _out191 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _959_sent__packets);
      ok = _out191;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool Replica__NoReceive__NoClock__Next(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      if ((r.nextActionIndex) == (1UL)) {
        bool _out192;
        _out192 = LiveByzRSL____ReplicaImplNoReceiveNoClock__i_Compile.__default.ReplicaNoReceiveNoClockNextSpontaneousMaybeEnterNewViewAndSend1a(r);
        ok = _out192;
      } else if ((r.nextActionIndex) == (2UL)) {
        bool _out193;
        _out193 = LiveByzRSL____ReplicaImplNoReceiveNoClock__i_Compile.__default.ReplicaNoReceiveNoClockNextSpontaneousMaybeEnterPhase2(r);
        ok = _out193;
      } else if ((r.nextActionIndex) == (4UL)) {
        bool _out194;
        _out194 = LiveByzRSL____ReplicaImplNoReceiveNoClock__i_Compile.__default.ReplicaNoReceiveNoClockNextSpontaneousMaybeDecide2bVal(r);
        ok = _out194;
      } else if ((r.nextActionIndex) == (5UL)) {
        bool _out195;
        _out195 = LiveByzRSL____ReplicaImplNoReceiveNoClock__i_Compile.__default.ReplicaNoReceiveNoClockNextSpontaneousMaybeSend2b(r);
        ok = _out195;
      } else if ((r.nextActionIndex) == (6UL)) {
        bool _out196;
        _out196 = LiveByzRSL____ReplicaImplNoReceiveNoClock__i_Compile.__default.ReplicaNoReceiveNoClockNextSpontaneousTruncateLogBasedOnCheckpoints(r);
        ok = _out196;
      } else if ((r.nextActionIndex) == (7UL)) {
        bool _out197;
        _out197 = LiveByzRSL____ReplicaImplNoReceiveNoClock__i_Compile.__default.ReplicaNoReceiveNoClockNextSpontaneousMaybeMakeDecision(r);
        ok = _out197;
      } else if ((r.nextActionIndex) == (8UL)) {
        bool _out198;
        _out198 = LiveByzRSL____ReplicaImplNoReceiveNoClock__i_Compile.__default.ReplicaNoReceiveNoClockNextSpontaneousMaybeExecute(r);
        ok = _out198;
      }
      return ok;
    }
  }
} // end of namespace LiveByzRSL____ReplicaImplNoReceiveNoClock__i_Compile
namespace LiveByzRSL____ReplicaImplReadClock__i_Compile {

  public partial class __default {
    public static bool Replica__Next__ReadClockAndProcessPacket(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____CMessage__i_Compile._ICPacket cpacket)
    {
      bool ok = false;
      BigInteger _962_clock;
      BigInteger _out199;
      _out199 = LiveByzRSL____UdpRSL__i_Compile.__default.ReadClock(r.netClient);
      _962_clock = _out199;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _963_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _let_tmp_rhs23 = LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextProcessHeartbeat(r.replica, cpacket, (_962_clock));
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _964_t0 = _let_tmp_rhs23.dtor__0;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _965_t1 = _let_tmp_rhs23.dtor__1;
      (r).replica = _964_t0;
      _963_sent__packets = _965_t1;
      bool _out200;
      _out200 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _963_sent__packets);
      ok = _out200;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
  }
} // end of namespace LiveByzRSL____ReplicaImplReadClock__i_Compile
namespace LiveByzRSL____ReplicaImplProcessPacketNoClock__i_Compile {

  public partial class __default {
    public static void ReplicaNextProcessPacketInvalid(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____CMessage__i_Compile._ICPacket cpacket)
    {
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _966_sent__packets;
      _966_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_OutboundPacket(Logic____Option__i_Compile.Option<LiveByzRSL____CMessage__i_Compile._ICPacket>.create_None());
    }
    public static bool ReplicaNextProcessPacketRequest(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____CMessage__i_Compile._ICPacket cpacket)
    {
      bool ok = false;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _967_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _let_tmp_rhs24 = LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextProcessRequest(r.replica, cpacket);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _968_ta = _let_tmp_rhs24.dtor__0;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _969_tb = _let_tmp_rhs24.dtor__1;
      (r).replica = _968_ta;
      _967_sent__packets = _969_tb;
      bool _out201;
      _out201 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _967_sent__packets);
      ok = _out201;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool ReplicaNextProcessPacket1a(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____CMessage__i_Compile._ICPacket cpacket)
    {
      bool ok = false;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _970_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _let_tmp_rhs25 = LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextProcess1a(r.replica, cpacket);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _971_t0 = _let_tmp_rhs25.dtor__0;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _972_t1 = _let_tmp_rhs25.dtor__1;
      (r).replica = _971_t0;
      _970_sent__packets = _972_t1;
      bool _out202;
      _out202 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _970_sent__packets);
      ok = _out202;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool ReplicaNextProcessPacket1b(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____CMessage__i_Compile._ICPacket cpacket)
    {
      bool ok = false;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _973_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _let_tmp_rhs26 = LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextProcess1b(r.replica, cpacket);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _974_t0 = _let_tmp_rhs26.dtor__0;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _975_t1 = _let_tmp_rhs26.dtor__1;
      (r).replica = _974_t0;
      _973_sent__packets = _975_t1;
      bool _out203;
      _out203 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _973_sent__packets);
      ok = _out203;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool ReplicaNextProcessPacketStartingPhase2(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____CMessage__i_Compile._ICPacket cpacket)
    {
      bool ok = false;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _976_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _let_tmp_rhs27 = LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextProcessStartingPhase2(r.replica, cpacket);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _977_t0 = _let_tmp_rhs27.dtor__0;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _978_t1 = _let_tmp_rhs27.dtor__1;
      (r).replica = _977_t0;
      _976_sent__packets = _978_t1;
      bool _out204;
      _out204 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _976_sent__packets);
      ok = _out204;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool ReplicaNextProcessPacket1c(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____CMessage__i_Compile._ICPacket cpacket)
    {
      bool ok = false;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _979_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _980_t0;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _981_t1;
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _out205;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _out206;
      LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextProcess1c(r.replica, cpacket, out _out205, out _out206);
      _980_t0 = _out205;
      _981_t1 = _out206;
      (r).replica = _980_t0;
      _979_sent__packets = _981_t1;
      bool _out207;
      _out207 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _979_sent__packets);
      ok = _out207;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool ReplicaNextProcessPacket2av(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____CMessage__i_Compile._ICPacket cpacket)
    {
      bool ok = false;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _982_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _let_tmp_rhs28 = LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextProcess2av(r.replica, cpacket);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _983_t0 = _let_tmp_rhs28.dtor__0;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _984_t1 = _let_tmp_rhs28.dtor__1;
      (r).replica = _983_t0;
      _982_sent__packets = _984_t1;
      bool _out208;
      _out208 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _982_sent__packets);
      ok = _out208;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static bool ReplicaNextProcessPacket2b(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____CMessage__i_Compile._ICPacket cpacket)
    {
      bool ok = false;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _985_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.Default();
      _System._ITuple2<LiveByzRSL____ReplicaModel__i_Compile._ICReplica, LiveByzRSL____CMessage__i_Compile._IOutboundPackets> _let_tmp_rhs29 = LiveByzRSL____ReplicaModel__i_Compile.__default.CReplicaNextProcess2b(r.replica, cpacket);
      LiveByzRSL____ReplicaModel__i_Compile._ICReplica _986_t0 = _let_tmp_rhs29.dtor__0;
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _987_t1 = _let_tmp_rhs29.dtor__1;
      (r).replica = _986_t0;
      _985_sent__packets = _987_t1;
      bool _out209;
      _out209 = LiveByzRSL____ReplicaImplDelivery__i_Compile.__default.DeliverOutboundPackets(r, _985_sent__packets);
      ok = _out209;
      if (!(ok)) {
        return ok;
      }
      return ok;
    }
    public static void ReplicaNextProcessPacketReply(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____CMessage__i_Compile._ICPacket cpacket)
    {
      LiveByzRSL____CMessage__i_Compile._IOutboundPackets _988_sent__packets;
      _988_sent__packets = LiveByzRSL____CMessage__i_Compile.OutboundPackets.create_Broadcast(LiveByzRSL____CMessage__i_Compile.CBroadcast.create_CBroadcastNop());
    }
    public static bool Replica__Next__ProcessPacketWithoutReadingClock__body(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____CMessage__i_Compile._ICPacket cpacket)
    {
      bool ok = false;
      if (((cpacket).dtor_msg).is_CMessage__Invalid) {
        ok = true;
        LiveByzRSL____ReplicaImplProcessPacketNoClock__i_Compile.__default.ReplicaNextProcessPacketInvalid(r, cpacket);
      } else if (((cpacket).dtor_msg).is_CMessage__Request) {
        bool _out210;
        _out210 = LiveByzRSL____ReplicaImplProcessPacketNoClock__i_Compile.__default.ReplicaNextProcessPacketRequest(r, cpacket);
        ok = _out210;
      } else if (((cpacket).dtor_msg).is_CMessage__1a) {
        bool _out211;
        _out211 = LiveByzRSL____ReplicaImplProcessPacketNoClock__i_Compile.__default.ReplicaNextProcessPacket1a(r, cpacket);
        ok = _out211;
      } else if (((cpacket).dtor_msg).is_CMessage__1b) {
        bool _out212;
        _out212 = LiveByzRSL____ReplicaImplProcessPacketNoClock__i_Compile.__default.ReplicaNextProcessPacket1b(r, cpacket);
        ok = _out212;
      } else if (((cpacket).dtor_msg).is_CMessage__StartingPhase2) {
        bool _out213;
        _out213 = LiveByzRSL____ReplicaImplProcessPacketNoClock__i_Compile.__default.ReplicaNextProcessPacketStartingPhase2(r, cpacket);
        ok = _out213;
      } else if (((cpacket).dtor_msg).is_CMessage__1c) {
        bool _out214;
        _out214 = LiveByzRSL____ReplicaImplProcessPacketNoClock__i_Compile.__default.ReplicaNextProcessPacket1c(r, cpacket);
        ok = _out214;
      } else if (((cpacket).dtor_msg).is_CMessage__2av) {
        bool _out215;
        _out215 = LiveByzRSL____ReplicaImplProcessPacketNoClock__i_Compile.__default.ReplicaNextProcessPacket2av(r, cpacket);
        ok = _out215;
      } else if (((cpacket).dtor_msg).is_CMessage__2b) {
        bool _out216;
        _out216 = LiveByzRSL____ReplicaImplProcessPacketNoClock__i_Compile.__default.ReplicaNextProcessPacket2b(r, cpacket);
        ok = _out216;
      } else if (((cpacket).dtor_msg).is_CMessage__Reply) {
        ok = true;
        LiveByzRSL____ReplicaImplProcessPacketNoClock__i_Compile.__default.ReplicaNextProcessPacketReply(r, cpacket);
      } else {
      }
      return ok;
    }
  }
} // end of namespace LiveByzRSL____ReplicaImplProcessPacketNoClock__i_Compile
namespace LiveByzRSL____Unsendable__i_Compile {

} // end of namespace LiveByzRSL____Unsendable__i_Compile
namespace LiveByzRSL____ReplicaImplProcessPacketX__i_Compile {

  public partial class __default {
    public static void ReplicaNextProcessPacketTimeout(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
    }
    public static void ReplicaNextProcessPacketUnmarshallable(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____UdpRSL__i_Compile._IReceiveResult rr)
    {
    }
    public static bool ReplicaNextProcessPacketHeartbeat(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____UdpRSL__i_Compile._IReceiveResult rr)
    {
      bool ok = false;
      ok = true;
      bool _out217;
      _out217 = LiveByzRSL____ReplicaImplReadClock__i_Compile.__default.Replica__Next__ReadClockAndProcessPacket(r, (rr).dtor_cpacket);
      ok = _out217;
      return ok;
    }
    public static bool ReplicaNextProcessPacketNonHeartbeat(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r, LiveByzRSL____UdpRSL__i_Compile._IReceiveResult rr)
    {
      bool ok = false;
      ok = true;
      bool _out218;
      _out218 = LiveByzRSL____ReplicaImplProcessPacketNoClock__i_Compile.__default.Replica__Next__ProcessPacketWithoutReadingClock__body(r, (rr).dtor_cpacket);
      ok = _out218;
      return ok;
    }
    public static bool Replica__Next__ProcessPacketX(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      LiveByzRSL____UdpRSL__i_Compile._IReceiveResult _989_rr = LiveByzRSL____UdpRSL__i_Compile.ReceiveResult.Default();
      LiveByzRSL____UdpRSL__i_Compile._IReceiveResult _out219;
      _out219 = LiveByzRSL____UdpRSL__i_Compile.__default.Receive(r.netClient, r.localAddr, (((r.replica).dtor_constants).dtor_all).dtor_config, r.msg__grammar);
      _989_rr = _out219;
      if ((_989_rr).is_RRFail) {
        ok = false;
        return ok;
      } else if ((_989_rr).is_RRTimeout) {
        ok = true;
        LiveByzRSL____ReplicaImplProcessPacketX__i_Compile.__default.ReplicaNextProcessPacketTimeout(r);
      } else {
        bool _990_marshallable;
        bool _out220;
        _out220 = LiveByzRSL____PacketParsing__i_Compile.__default.DetermineIfMessageMarshallable(((_989_rr).dtor_cpacket).dtor_msg);
        _990_marshallable = _out220;
        if (!(_990_marshallable)) {
          ok = true;
          LiveByzRSL____ReplicaImplProcessPacketX__i_Compile.__default.ReplicaNextProcessPacketUnmarshallable(r, _989_rr);
        } else if ((((_989_rr).dtor_cpacket).dtor_msg).is_CMessage__Heartbeat) {
          bool _out221;
          _out221 = LiveByzRSL____ReplicaImplProcessPacketX__i_Compile.__default.ReplicaNextProcessPacketHeartbeat(r, _989_rr);
          ok = _out221;
        } else {
          bool _out222;
          _out222 = LiveByzRSL____ReplicaImplProcessPacketX__i_Compile.__default.ReplicaNextProcessPacketNonHeartbeat(r, _989_rr);
          ok = _out222;
        }
      }
      return ok;
    }
  }
} // end of namespace LiveByzRSL____ReplicaImplProcessPacketX__i_Compile
namespace LiveByzRSL____ReplicaImplMain__i_Compile {

  public partial class __default {
    public static ulong rollActionIndex(ulong a)
    {
      ulong a_k = 0;
      if ((a) >= (11UL)) {
        a_k = 0UL;
      } else {
        a_k = (a) + (1UL);
      }
      return a_k;
    }
    public static bool ReplicaNextMainProcessPacketX(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      bool _out223;
      _out223 = LiveByzRSL____ReplicaImplProcessPacketX__i_Compile.__default.Replica__Next__ProcessPacketX(r);
      ok = _out223;
      if (!(ok)) {
        return ok;
      }
      (r).nextActionIndex = 1UL;
      return ok;
    }
    public static bool ReplicaNextMainNoClock(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      ulong _991_curActionIndex;
      _991_curActionIndex = r.nextActionIndex;
      bool _out224;
      _out224 = LiveByzRSL____ReplicaImplNoReceiveNoClock__i_Compile.__default.Replica__NoReceive__NoClock__Next(r);
      ok = _out224;
      if (!(ok)) {
        return ok;
      }
      ulong _992_nextActionIndex_k;
      _992_nextActionIndex_k = (r.nextActionIndex) + (1UL);
      (r).nextActionIndex = _992_nextActionIndex_k;
      return ok;
    }
    public static bool ReplicaNextMainReadClock(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      ulong _993_curActionIndex;
      _993_curActionIndex = r.nextActionIndex;
      bool _out225;
      _out225 = LiveByzRSL____ReplicaImplNoReceiveClock__i_Compile.__default.Replica__NoReceive__ReadClock__Next(r);
      ok = _out225;
      if (!(ok)) {
        return ok;
      }
      ulong _994_nextActionIndex_k;
      ulong _out226;
      _out226 = LiveByzRSL____ReplicaImplMain__i_Compile.__default.rollActionIndex(r.nextActionIndex);
      _994_nextActionIndex_k = _out226;
      (r).nextActionIndex = _994_nextActionIndex_k;
      return ok;
    }
    public static bool Replica__Next__main(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl r)
    {
      bool ok = false;
      if ((r.nextActionIndex) == (0UL)) {
        bool _out227;
        _out227 = LiveByzRSL____ReplicaImplMain__i_Compile.__default.ReplicaNextMainProcessPacketX(r);
        ok = _out227;
      } else if ((((((((r.nextActionIndex) == (1UL)) || ((r.nextActionIndex) == (2UL))) || ((r.nextActionIndex) == (4UL))) || ((r.nextActionIndex) == (5UL))) || ((r.nextActionIndex) == (6UL))) || ((r.nextActionIndex) == (7UL))) || ((r.nextActionIndex) == (8UL))) {
        bool _out228;
        _out228 = LiveByzRSL____ReplicaImplMain__i_Compile.__default.ReplicaNextMainNoClock(r);
        ok = _out228;
      } else if (((r.nextActionIndex) == (3UL)) || (((9UL) <= (r.nextActionIndex)) && ((r.nextActionIndex) <= (11UL)))) {
        bool _out229;
        _out229 = LiveByzRSL____ReplicaImplMain__i_Compile.__default.ReplicaNextMainReadClock(r);
        ok = _out229;
      }
      return ok;
    }
  }
} // end of namespace LiveByzRSL____ReplicaImplMain__i_Compile
namespace CmdLineParser__i_Compile {

  public partial class __default {
    public static _System._ITuple2<bool, byte> ascii__to__int(ushort @short) {
      if ((((ushort)(48)) <= (@short)) && ((@short) <= ((ushort)(57)))) {
        return _System.Tuple2<bool, byte>.create(true, (byte)((ushort)((@short) - ((ushort)(48)))));
      } else {
        return _System.Tuple2<bool, byte>.create(false, (byte)(0));
      }
    }
    public static BigInteger power10(BigInteger e)
    {
      BigInteger val = BigInteger.Zero;
      if ((e).Sign == 0) {
        val = BigInteger.One;
        return val;
      } else {
        BigInteger _995_tmp;
        BigInteger _out230;
        _out230 = CmdLineParser__i_Compile.__default.power10((e) - (BigInteger.One));
        _995_tmp = _out230;
        val = (new BigInteger(10)) * (_995_tmp);
        return val;
      }
      return val;
    }
    public static _System._ITuple2<bool, Dafny.ISequence<byte>> shorts__to__bytes(Dafny.ISequence<ushort> shorts) {
      if ((new BigInteger((shorts).Count)).Sign == 0) {
        return _System.Tuple2<bool, Dafny.ISequence<byte>>.create(true, Dafny.Sequence<byte>.FromElements());
      } else {
        _System._ITuple2<bool, Dafny.ISequence<byte>> _996_tuple = CmdLineParser__i_Compile.__default.shorts__to__bytes((shorts).Drop(BigInteger.One));
        bool _997_ok = (_996_tuple).dtor__0;
        Dafny.ISequence<byte> _998_rest = (_996_tuple).dtor__1;
        _System._ITuple2<bool, byte> _999_tuple_k = CmdLineParser__i_Compile.__default.ascii__to__int((shorts).Select(BigInteger.Zero));
        bool _1000_ok_k = (_999_tuple_k).dtor__0;
        byte _1001_a__byte = (_999_tuple_k).dtor__1;
        if ((_997_ok) && (_1000_ok_k)) {
          return _System.Tuple2<bool, Dafny.ISequence<byte>>.create(true, Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.FromElements(_1001_a__byte), _998_rest));
        } else {
          return _System.Tuple2<bool, Dafny.ISequence<byte>>.create(false, Dafny.Sequence<byte>.FromElements());
        }
      }
    }
    public static BigInteger bytes__to__decimal(Dafny.ISequence<byte> bytes) {
      if ((new BigInteger((bytes).Count)).Sign == 0) {
        return BigInteger.Zero;
      } else {
        return (new BigInteger((bytes).Select((new BigInteger((bytes).Count)) - (BigInteger.One)))) + ((new BigInteger(10)) * (CmdLineParser__i_Compile.__default.bytes__to__decimal((bytes).Subsequence(BigInteger.Zero, (new BigInteger((bytes).Count)) - (BigInteger.One)))));
      }
    }
    public static _System._ITuple2<bool, BigInteger> shorts__to__nat(Dafny.ISequence<ushort> shorts) {
      if ((new BigInteger((shorts).Count)).Sign == 0) {
        return _System.Tuple2<bool, BigInteger>.create(false, BigInteger.Zero);
      } else {
        _System._ITuple2<bool, Dafny.ISequence<byte>> _1002_tuple = CmdLineParser__i_Compile.__default.shorts__to__bytes(shorts);
        bool _1003_ok = (_1002_tuple).dtor__0;
        Dafny.ISequence<byte> _1004_bytes = (_1002_tuple).dtor__1;
        if (!(_1003_ok)) {
          return _System.Tuple2<bool, BigInteger>.create(false, BigInteger.Zero);
        } else {
          return _System.Tuple2<bool, BigInteger>.create(true, CmdLineParser__i_Compile.__default.bytes__to__decimal(_1004_bytes));
        }
      }
    }
    public static _System._ITuple2<bool, byte> shorts__to__byte(Dafny.ISequence<ushort> shorts) {
      _System._ITuple2<bool, BigInteger> _1005_tuple = CmdLineParser__i_Compile.__default.shorts__to__nat(shorts);
      bool _1006_ok = (_1005_tuple).dtor__0;
      BigInteger _1007_val = (_1005_tuple).dtor__1;
      if (((_1007_val).Sign != -1) && ((_1007_val) < (new BigInteger(256)))) {
        return _System.Tuple2<bool, byte>.create(true, (byte)(_1007_val));
      } else {
        return _System.Tuple2<bool, byte>.create(false, (byte)(0));
      }
    }
    public static _System._ITuple2<bool, ushort> shorts__to__uint16(Dafny.ISequence<ushort> shorts) {
      _System._ITuple2<bool, BigInteger> _1008_tuple = CmdLineParser__i_Compile.__default.shorts__to__nat(shorts);
      bool _1009_ok = (_1008_tuple).dtor__0;
      BigInteger _1010_val = (_1008_tuple).dtor__1;
      if (((_1010_val).Sign != -1) && ((_1010_val) < (new BigInteger(65536)))) {
        return _System.Tuple2<bool, ushort>.create(true, (ushort)(_1010_val));
      } else {
        return _System.Tuple2<bool, ushort>.create(false, (ushort)(0));
      }
    }
    public static _System._ITuple2<bool, uint> shorts__to__uint32(Dafny.ISequence<ushort> shorts) {
      _System._ITuple2<bool, BigInteger> _1011_tuple = CmdLineParser__i_Compile.__default.shorts__to__nat(shorts);
      bool _1012_ok = (_1011_tuple).dtor__0;
      BigInteger _1013_val = (_1011_tuple).dtor__1;
      if (((_1013_val).Sign != -1) && ((_1013_val) < (new BigInteger(4294967296L)))) {
        return _System.Tuple2<bool, uint>.create(true, (uint)(_1013_val));
      } else {
        return _System.Tuple2<bool, uint>.create(false, 0U);
      }
    }
    public static bool is__ascii__period(ushort @short) {
      return (@short) == ((ushort)(46));
    }
    public static _System._ITuple2<bool, Dafny.ISequence<byte>> parse__ip__addr__helper(Dafny.ISequence<ushort> ip__shorts, Dafny.ISequence<ushort> current__octet__shorts)
    {
      if ((new BigInteger((ip__shorts).Count)).Sign == 0) {
        _System._ITuple2<bool, byte> _1014_tuple = CmdLineParser__i_Compile.__default.shorts__to__byte(current__octet__shorts);
        bool _1015_okay = (_1014_tuple).dtor__0;
        byte _1016_b = (_1014_tuple).dtor__1;
        if (!(_1015_okay)) {
          return _System.Tuple2<bool, Dafny.ISequence<byte>>.create(false, Dafny.Sequence<byte>.FromElements());
        } else {
          return _System.Tuple2<bool, Dafny.ISequence<byte>>.create(true, Dafny.Sequence<byte>.FromElements(_1016_b));
        }
      } else if (CmdLineParser__i_Compile.__default.is__ascii__period((ip__shorts).Select(BigInteger.Zero))) {
        _System._ITuple2<bool, byte> _1017_tuple = CmdLineParser__i_Compile.__default.shorts__to__byte(current__octet__shorts);
        bool _1018_okay = (_1017_tuple).dtor__0;
        byte _1019_b = (_1017_tuple).dtor__1;
        if (!(_1018_okay)) {
          return _System.Tuple2<bool, Dafny.ISequence<byte>>.create(false, Dafny.Sequence<byte>.FromElements());
        } else {
          _System._ITuple2<bool, Dafny.ISequence<byte>> _1020_tuple_k = CmdLineParser__i_Compile.__default.parse__ip__addr__helper((ip__shorts).Drop(BigInteger.One), Dafny.Sequence<ushort>.FromElements());
          bool _1021_ok = (_1020_tuple_k).dtor__0;
          Dafny.ISequence<byte> _1022_ip__bytes = (_1020_tuple_k).dtor__1;
          if (!(_1021_ok)) {
            return _System.Tuple2<bool, Dafny.ISequence<byte>>.create(false, Dafny.Sequence<byte>.FromElements());
          } else {
            return _System.Tuple2<bool, Dafny.ISequence<byte>>.create(true, Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.FromElements(_1019_b), _1022_ip__bytes));
          }
        }
      } else {
        return CmdLineParser__i_Compile.__default.parse__ip__addr__helper((ip__shorts).Drop(BigInteger.One), Dafny.Sequence<ushort>.Concat(current__octet__shorts, Dafny.Sequence<ushort>.FromElements((ip__shorts).Select(BigInteger.Zero))));
      }
    }
    public static _System._ITuple2<bool, Dafny.ISequence<byte>> parse__ip__addr(Dafny.ISequence<ushort> ip__shorts) {
      _System._ITuple2<bool, Dafny.ISequence<byte>> _1023_tuple = CmdLineParser__i_Compile.__default.parse__ip__addr__helper(ip__shorts, Dafny.Sequence<ushort>.FromElements());
      bool _1024_ok = (_1023_tuple).dtor__0;
      Dafny.ISequence<byte> _1025_ip__bytes = (_1023_tuple).dtor__1;
      if ((_1024_ok) && ((new BigInteger((_1025_ip__bytes).Count)) == (new BigInteger(4)))) {
        return _System.Tuple2<bool, Dafny.ISequence<byte>>.create(true, _1025_ip__bytes);
      } else {
        return _System.Tuple2<bool, Dafny.ISequence<byte>>.create(false, Dafny.Sequence<byte>.FromElements());
      }
    }
    public static _System._ITuple2<bool, Native____Io__s_Compile._IEndPoint> parse__end__point(Dafny.ISequence<ushort> ip__shorts, Dafny.ISequence<ushort> port__shorts)
    {
      _System._ITuple2<bool, Dafny.ISequence<byte>> _1026_tuple = CmdLineParser__i_Compile.__default.parse__ip__addr(ip__shorts);
      bool _1027_okay = (_1026_tuple).dtor__0;
      Dafny.ISequence<byte> _1028_ip__bytes = (_1026_tuple).dtor__1;
      if (!(_1027_okay)) {
        return _System.Tuple2<bool, Native____Io__s_Compile._IEndPoint>.create(false, Native____Io__s_Compile.EndPoint.create(Dafny.Sequence<byte>.FromElements((byte)(0), (byte)(0), (byte)(0), (byte)(0)), (ushort)(0)));
      } else {
        _System._ITuple2<bool, ushort> _1029_tuple_k = CmdLineParser__i_Compile.__default.shorts__to__uint16(port__shorts);
        bool _1030_okay_k = (_1029_tuple_k).dtor__0;
        ushort _1031_port = (_1029_tuple_k).dtor__1;
        if (!(_1030_okay_k)) {
          return _System.Tuple2<bool, Native____Io__s_Compile._IEndPoint>.create(false, Native____Io__s_Compile.EndPoint.create(Dafny.Sequence<byte>.FromElements((byte)(0), (byte)(0), (byte)(0), (byte)(0)), (ushort)(0)));
        } else {
          return _System.Tuple2<bool, Native____Io__s_Compile._IEndPoint>.create(true, Native____Io__s_Compile.EndPoint.create(_1028_ip__bytes, _1031_port));
        }
      }
    }
    public static bool test__unique_k(Dafny.ISequence<Native____Io__s_Compile._IEndPoint> endpoints)
    {
      bool unique = false;
      unique = true;
      BigInteger _1032_i;
      _1032_i = BigInteger.Zero;
      while ((_1032_i) < (new BigInteger((endpoints).Count))) {
        BigInteger _1033_j;
        _1033_j = BigInteger.Zero;
        while ((_1033_j) < (new BigInteger((endpoints).Count))) {
          if (((_1032_i) != (_1033_j)) && (object.Equals((endpoints).Select(_1032_i), (endpoints).Select(_1033_j)))) {
            unique = false;
            return unique;
          }
          _1033_j = (_1033_j) + (BigInteger.One);
        }
        _1032_i = (_1032_i) + (BigInteger.One);
      }
      return unique;
    }
    public static _System._ITuple2<bool, Dafny.ISequence<Native____Io__s_Compile._IEndPoint>> parse__end__points(Dafny.ISequence<Dafny.ISequence<ushort>> args) {
      if ((new BigInteger((args).Count)).Sign == 0) {
        return _System.Tuple2<bool, Dafny.ISequence<Native____Io__s_Compile._IEndPoint>>.create(true, Dafny.Sequence<Native____Io__s_Compile._IEndPoint>.FromElements());
      } else {
        _System._ITuple2<bool, Native____Io__s_Compile._IEndPoint> _let_tmp_rhs30 = CmdLineParser__i_Compile.__default.parse__end__point((args).Select(BigInteger.Zero), (args).Select(BigInteger.One));
        bool _1034_ok1 = _let_tmp_rhs30.dtor__0;
        Native____Io__s_Compile._IEndPoint _1035_ep = _let_tmp_rhs30.dtor__1;
        _System._ITuple2<bool, Dafny.ISequence<Native____Io__s_Compile._IEndPoint>> _let_tmp_rhs31 = CmdLineParser__i_Compile.__default.parse__end__points((args).Drop(new BigInteger(2)));
        bool _1036_ok2 = _let_tmp_rhs31.dtor__0;
        Dafny.ISequence<Native____Io__s_Compile._IEndPoint> _1037_rest = _let_tmp_rhs31.dtor__1;
        if (!((_1034_ok1) && (_1036_ok2))) {
          return _System.Tuple2<bool, Dafny.ISequence<Native____Io__s_Compile._IEndPoint>>.create(false, Dafny.Sequence<Native____Io__s_Compile._IEndPoint>.FromElements());
        } else {
          return _System.Tuple2<bool, Dafny.ISequence<Native____Io__s_Compile._IEndPoint>>.create(true, Dafny.Sequence<Native____Io__s_Compile._IEndPoint>.Concat(Dafny.Sequence<Native____Io__s_Compile._IEndPoint>.FromElements(_1035_ep), _1037_rest));
        }
      }
    }
    public static Dafny.ISequence<Dafny.ISequence<ushort>> collect__cmd__line__args()
    {
      Dafny.ISequence<Dafny.ISequence<ushort>> args = Dafny.Sequence<Dafny.ISequence<ushort>>.Empty;
      uint _1038_num__args;
      uint _out231;
      _out231 = Native____Io__s_Compile.HostConstants.NumCommandLineArgs();
      _1038_num__args = _out231;
      uint _1039_i;
      _1039_i = 0U;
      args = Dafny.Sequence<Dafny.ISequence<ushort>>.FromElements();
      while ((_1039_i) < (_1038_num__args)) {
        ushort[] _1040_arg;
        ushort[] _out232;
        _out232 = Native____Io__s_Compile.HostConstants.GetCommandLineArg((ulong)(_1039_i));
        _1040_arg = _out232;
        args = Dafny.Sequence<Dafny.ISequence<ushort>>.Concat(args, Dafny.Sequence<Dafny.ISequence<ushort>>.FromElements(Dafny.Helpers.SeqFromArray(_1040_arg)));
        _1039_i = (_1039_i) + (1U);
      }
      return args;
    }
  }
} // end of namespace CmdLineParser__i_Compile
namespace LiveByzRSL____CmdLineParser__i_Compile {

  public partial class __default {
    public static void parse__cmd__line(out bool ok, out Dafny.ISequence<Native____Io__s_Compile._IEndPoint> config, out BigInteger my__index)
    {
      ok = false;
      config = Dafny.Sequence<Native____Io__s_Compile._IEndPoint>.Empty;
      my__index = BigInteger.Zero;
      ok = false;
      uint _1041_num__args;
      uint _out233;
      _out233 = Native____Io__s_Compile.HostConstants.NumCommandLineArgs();
      _1041_num__args = _out233;
      if (((_1041_num__args) < (4U)) || (((_1041_num__args) % (2U)) != (1U))) {
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Incorrect number of command line arguments.\n")));
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("Expected: ./Main.exe [IP port]+ [IP port]\n")));
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("  where the final argument is one of the IP-port pairs provided earlier \n")));
        return ;
      }
      Dafny.ISequence<Dafny.ISequence<ushort>> _1042_args;
      Dafny.ISequence<Dafny.ISequence<ushort>> _out234;
      _out234 = CmdLineParser__i_Compile.__default.collect__cmd__line__args();
      _1042_args = _out234;
      _System._ITuple2<bool, Dafny.ISequence<Native____Io__s_Compile._IEndPoint>> _1043_tuple1;
      _1043_tuple1 = CmdLineParser__i_Compile.__default.parse__end__points((_1042_args).Subsequence(BigInteger.One, (new BigInteger((_1042_args).Count)) - (new BigInteger(2))));
      ok = (_1043_tuple1).dtor__0;
      Dafny.ISequence<Native____Io__s_Compile._IEndPoint> _1044_endpoints;
      _1044_endpoints = (_1043_tuple1).dtor__1;
      if ((!(ok)) || ((new BigInteger((_1044_endpoints).Count)) >= (new BigInteger(18446744073709551615UL)))) {
        ok = false;
        return ;
      }
      _System._ITuple2<bool, Native____Io__s_Compile._IEndPoint> _1045_tuple2;
      _1045_tuple2 = CmdLineParser__i_Compile.__default.parse__end__point((_1042_args).Select((new BigInteger((_1042_args).Count)) - (new BigInteger(2))), (_1042_args).Select((new BigInteger((_1042_args).Count)) - (BigInteger.One)));
      ok = (_1045_tuple2).dtor__0;
      if (!(ok)) {
        return ;
      }
      bool _1046_unique;
      bool _out235;
      _out235 = CmdLineParser__i_Compile.__default.test__unique_k(_1044_endpoints);
      _1046_unique = _out235;
      if (!(_1046_unique)) {
        ok = false;
        return ;
      }
      config = _1044_endpoints;
      my__index = LiveByzRSL____CConfiguration__i_Compile.__default.CGetReplicaIndex((_1045_tuple2).dtor__1, config);
      if (!(ok)) {
        return ;
      }
    }
  }
} // end of namespace LiveByzRSL____CmdLineParser__i_Compile
namespace Host__i_Compile {

  public interface _ICScheduler {
    bool is_CScheduler { get; }
    LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl dtor_replica__impl { get; }
  }
  public class CScheduler : _ICScheduler {
    public readonly LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl _replica__impl;
    public CScheduler(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl replica__impl) {
      this._replica__impl = replica__impl;
    }
    public static LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl DowncastClone(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl _this) {
      return _this;
    }
    public override bool Equals(object other) {
      var oth = other as Host__i_Compile.CScheduler;
      return oth != null && this._replica__impl == oth._replica__impl;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._replica__impl));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Host__i_Compile.CScheduler.CScheduler";
      s += "(";
      s += Dafny.Helpers.ToString(this._replica__impl);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl theDefault = default(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl);
    public static LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl>(default(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl));
    public static Dafny.TypeDescriptor<LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICScheduler create(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl replica__impl) {
      return new CScheduler(replica__impl);
    }
    public static _ICScheduler create_CScheduler(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl replica__impl) {
      return create(replica__impl);
    }
    public bool is_CScheduler { get { return true; } }
    public LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl dtor_replica__impl {
      get {
        return this._replica__impl;
      }
    }
  }

  public partial class __default {
    public static void HostInitImpl(out bool ok, out LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl host__state, out LiveByzRSL____ConstantsState__i_Compile._ICConstants config, out Native____Io__s_Compile._IEndPoint id)
    {
      ok = false;
      host__state = default(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl);
      config = LiveByzRSL____ConstantsState__i_Compile.CConstants.Default();
      id = Native____Io__s_Compile.EndPoint.Default();
      Dafny.ISequence<Native____Io__s_Compile._IEndPoint> _1047_pconfig = Dafny.Sequence<Native____Io__s_Compile._IEndPoint>.Empty;
      BigInteger _1048_my__index = BigInteger.Zero;
      bool _out236;
      Dafny.ISequence<Native____Io__s_Compile._IEndPoint> _out237;
      BigInteger _out238;
      LiveByzRSL____CmdLineParser__i_Compile.__default.parse__cmd__line(out _out236, out _out237, out _out238);
      ok = _out236;
      _1047_pconfig = _out237;
      _1048_my__index = _out238;
      LiveByzRSL____Replica__i_Compile._ILScheduler _1049_lschedule = LiveByzRSL____Replica__i_Compile.LScheduler.Default();
      LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl _1050_repImpl;
      LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl _nw11 = new LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl();
      _nw11.__ctor();
      _1050_repImpl = _nw11;
      host__state = _1050_repImpl;
      if (!(ok)) {
        return ;
      }
      id = ((_1047_pconfig)).Select(_1048_my__index);
      LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl _1051_scheduler;
      LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl _nw12 = new LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl();
      _nw12.__ctor();
      _1051_scheduler = _nw12;
      LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants _1052_constants;
      LiveByzRSL____ConstantsState__i_Compile._ICReplicaConstants _out239;
      _out239 = LiveByzRSL____ConstantsState__i_Compile.__default.InitReplicaConstantsState(id, _1047_pconfig);
      _1052_constants = _out239;
      bool _out240;
      _out240 = (_1051_scheduler).Replica__Init(_1052_constants);
      ok = _out240;
      if (!(ok)) {
        return ;
      }
      host__state = _1051_scheduler;
      config = (_1052_constants).dtor_all;
    }
    public static void HostNextImpl(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl host__state, out bool ok, out LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl host__state_k)
    {
      ok = false;
      host__state_k = default(LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl);
      LiveByzRSL____Replica__i_Compile._ILScheduler _1053_lschedule = LiveByzRSL____Replica__i_Compile.LScheduler.Default();
      LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl _1054_repImpl;
      LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl _nw13 = new LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl();
      _nw13.__ctor();
      _1054_repImpl = _nw13;
      host__state_k = _1054_repImpl;
      bool _1055_okay;
      bool _out241;
      _out241 = LiveByzRSL____ReplicaImplMain__i_Compile.__default.Replica__Next__main((host__state));
      _1055_okay = _out241;
      if (_1055_okay) {
        host__state_k = (host__state);
      } else {
      }
      ok = _1055_okay;
    }
  }
} // end of namespace Host__i_Compile
namespace RSL__DistributedSystem__i_Compile {


  public interface _IDS__State {
    bool is_DS__State { get; }
    LiveByzRSL____ConstantsState__i_Compile._ICConstants dtor_config { get; }
    Environment__s_Compile._ILEnvironment<Native____Io__s_Compile._IEndPoint, Dafny.ISequence<byte>> dtor_environment { get; }
    Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl> dtor_servers { get; }
    Dafny.ISet<Native____Io__s_Compile._IEndPoint> dtor_clients { get; }
    _IDS__State DowncastClone();
  }
  public class DS__State : _IDS__State {
    public readonly LiveByzRSL____ConstantsState__i_Compile._ICConstants _config;
    public readonly Environment__s_Compile._ILEnvironment<Native____Io__s_Compile._IEndPoint, Dafny.ISequence<byte>> _environment;
    public readonly Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl> _servers;
    public readonly Dafny.ISet<Native____Io__s_Compile._IEndPoint> _clients;
    public DS__State(LiveByzRSL____ConstantsState__i_Compile._ICConstants config, Environment__s_Compile._ILEnvironment<Native____Io__s_Compile._IEndPoint, Dafny.ISequence<byte>> environment, Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl> servers, Dafny.ISet<Native____Io__s_Compile._IEndPoint> clients) {
      this._config = config;
      this._environment = environment;
      this._servers = servers;
      this._clients = clients;
    }
    public _IDS__State DowncastClone() {
      if (this is _IDS__State dt) { return dt; }
      return new DS__State(_config, _environment, _servers, _clients);
    }
    public override bool Equals(object other) {
      var oth = other as RSL__DistributedSystem__i_Compile.DS__State;
      return oth != null && object.Equals(this._config, oth._config) && object.Equals(this._environment, oth._environment) && object.Equals(this._servers, oth._servers) && object.Equals(this._clients, oth._clients);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._config));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._environment));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._servers));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._clients));
      return (int) hash;
    }
    public override string ToString() {
      string s = "RSL__DistributedSystem__i_Compile.DS_State.DS_State";
      s += "(";
      s += Dafny.Helpers.ToString(this._config);
      s += ", ";
      s += Dafny.Helpers.ToString(this._environment);
      s += ", ";
      s += Dafny.Helpers.ToString(this._servers);
      s += ", ";
      s += Dafny.Helpers.ToString(this._clients);
      s += ")";
      return s;
    }
    private static readonly RSL__DistributedSystem__i_Compile._IDS__State theDefault = create(LiveByzRSL____ConstantsState__i_Compile.CConstants.Default(), Environment__s_Compile.LEnvironment<Native____Io__s_Compile._IEndPoint, Dafny.ISequence<byte>>.Default(), Dafny.Map<Native____Io__s_Compile._IEndPoint, LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl>.Empty, Dafny.Set<Native____Io__s_Compile._IEndPoint>.Empty);
    public static RSL__DistributedSystem__i_Compile._IDS__State Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<RSL__DistributedSystem__i_Compile._IDS__State> _TYPE = new Dafny.TypeDescriptor<RSL__DistributedSystem__i_Compile._IDS__State>(RSL__DistributedSystem__i_Compile.DS__State.Default());
    public static Dafny.TypeDescriptor<RSL__DistributedSystem__i_Compile._IDS__State> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDS__State create(LiveByzRSL____ConstantsState__i_Compile._ICConstants config, Environment__s_Compile._ILEnvironment<Native____Io__s_Compile._IEndPoint, Dafny.ISequence<byte>> environment, Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl> servers, Dafny.ISet<Native____Io__s_Compile._IEndPoint> clients) {
      return new DS__State(config, environment, servers, clients);
    }
    public static _IDS__State create_DS__State(LiveByzRSL____ConstantsState__i_Compile._ICConstants config, Environment__s_Compile._ILEnvironment<Native____Io__s_Compile._IEndPoint, Dafny.ISequence<byte>> environment, Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl> servers, Dafny.ISet<Native____Io__s_Compile._IEndPoint> clients) {
      return create(config, environment, servers, clients);
    }
    public bool is_DS__State { get { return true; } }
    public LiveByzRSL____ConstantsState__i_Compile._ICConstants dtor_config {
      get {
        return this._config;
      }
    }
    public Environment__s_Compile._ILEnvironment<Native____Io__s_Compile._IEndPoint, Dafny.ISequence<byte>> dtor_environment {
      get {
        return this._environment;
      }
    }
    public Dafny.IMap<Native____Io__s_Compile._IEndPoint,LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl> dtor_servers {
      get {
        return this._servers;
      }
    }
    public Dafny.ISet<Native____Io__s_Compile._IEndPoint> dtor_clients {
      get {
        return this._clients;
      }
    }
  }
} // end of namespace RSL__DistributedSystem__i_Compile
namespace Collections____Maps2__i_Compile {

} // end of namespace Collections____Maps2__i_Compile
namespace LiveByzRSL____DistributedSystem__i_Compile {

  public interface _IRslState {
    bool is_RslState { get; }
    LiveByzRSL____Constants__i_Compile._ILConstants dtor_constants { get; }
    Environment__s_Compile._ILEnvironment<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage> dtor_environment { get; }
    Dafny.ISequence<LiveByzRSL____Replica__i_Compile._ILScheduler> dtor_replicas { get; }
    Dafny.ISet<Native____Io__s_Compile._IEndPoint> dtor_clients { get; }
    _IRslState DowncastClone();
  }
  public class RslState : _IRslState {
    public readonly LiveByzRSL____Constants__i_Compile._ILConstants _constants;
    public readonly Environment__s_Compile._ILEnvironment<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage> _environment;
    public readonly Dafny.ISequence<LiveByzRSL____Replica__i_Compile._ILScheduler> _replicas;
    public readonly Dafny.ISet<Native____Io__s_Compile._IEndPoint> _clients;
    public RslState(LiveByzRSL____Constants__i_Compile._ILConstants constants, Environment__s_Compile._ILEnvironment<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage> environment, Dafny.ISequence<LiveByzRSL____Replica__i_Compile._ILScheduler> replicas, Dafny.ISet<Native____Io__s_Compile._IEndPoint> clients) {
      this._constants = constants;
      this._environment = environment;
      this._replicas = replicas;
      this._clients = clients;
    }
    public _IRslState DowncastClone() {
      if (this is _IRslState dt) { return dt; }
      return new RslState(_constants, _environment, _replicas, _clients);
    }
    public override bool Equals(object other) {
      var oth = other as LiveByzRSL____DistributedSystem__i_Compile.RslState;
      return oth != null && object.Equals(this._constants, oth._constants) && object.Equals(this._environment, oth._environment) && object.Equals(this._replicas, oth._replicas) && object.Equals(this._clients, oth._clients);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._constants));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._environment));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._replicas));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._clients));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LiveByzRSL____DistributedSystem__i_Compile.RslState.RslState";
      s += "(";
      s += Dafny.Helpers.ToString(this._constants);
      s += ", ";
      s += Dafny.Helpers.ToString(this._environment);
      s += ", ";
      s += Dafny.Helpers.ToString(this._replicas);
      s += ", ";
      s += Dafny.Helpers.ToString(this._clients);
      s += ")";
      return s;
    }
    private static readonly LiveByzRSL____DistributedSystem__i_Compile._IRslState theDefault = create(LiveByzRSL____Constants__i_Compile.LConstants.Default(), Environment__s_Compile.LEnvironment<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>.Default(), Dafny.Sequence<LiveByzRSL____Replica__i_Compile._ILScheduler>.Empty, Dafny.Set<Native____Io__s_Compile._IEndPoint>.Empty);
    public static LiveByzRSL____DistributedSystem__i_Compile._IRslState Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<LiveByzRSL____DistributedSystem__i_Compile._IRslState> _TYPE = new Dafny.TypeDescriptor<LiveByzRSL____DistributedSystem__i_Compile._IRslState>(LiveByzRSL____DistributedSystem__i_Compile.RslState.Default());
    public static Dafny.TypeDescriptor<LiveByzRSL____DistributedSystem__i_Compile._IRslState> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IRslState create(LiveByzRSL____Constants__i_Compile._ILConstants constants, Environment__s_Compile._ILEnvironment<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage> environment, Dafny.ISequence<LiveByzRSL____Replica__i_Compile._ILScheduler> replicas, Dafny.ISet<Native____Io__s_Compile._IEndPoint> clients) {
      return new RslState(constants, environment, replicas, clients);
    }
    public static _IRslState create_RslState(LiveByzRSL____Constants__i_Compile._ILConstants constants, Environment__s_Compile._ILEnvironment<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage> environment, Dafny.ISequence<LiveByzRSL____Replica__i_Compile._ILScheduler> replicas, Dafny.ISet<Native____Io__s_Compile._IEndPoint> clients) {
      return create(constants, environment, replicas, clients);
    }
    public bool is_RslState { get { return true; } }
    public LiveByzRSL____Constants__i_Compile._ILConstants dtor_constants {
      get {
        return this._constants;
      }
    }
    public Environment__s_Compile._ILEnvironment<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage> dtor_environment {
      get {
        return this._environment;
      }
    }
    public Dafny.ISequence<LiveByzRSL____Replica__i_Compile._ILScheduler> dtor_replicas {
      get {
        return this._replicas;
      }
    }
    public Dafny.ISet<Native____Io__s_Compile._IEndPoint> dtor_clients {
      get {
        return this._clients;
      }
    }
  }

} // end of namespace LiveByzRSL____DistributedSystem__i_Compile
namespace DirectRefinement____StateMachine__i_Compile {

  public interface _IRSLSystemState {
    bool is_RSLSystemState { get; }
    Dafny.ISet<Native____Io__s_Compile._IEndPoint> dtor_server__addresses { get; }
    ulong dtor_app { get; }
    Dafny.ISet<LiveByzRSL____Types__i_Compile._IRequest> dtor_requests { get; }
    Dafny.ISet<LiveByzRSL____Types__i_Compile._IReply> dtor_replies { get; }
    _IRSLSystemState DowncastClone();
  }
  public class RSLSystemState : _IRSLSystemState {
    public readonly Dafny.ISet<Native____Io__s_Compile._IEndPoint> _server__addresses;
    public readonly ulong _app;
    public readonly Dafny.ISet<LiveByzRSL____Types__i_Compile._IRequest> _requests;
    public readonly Dafny.ISet<LiveByzRSL____Types__i_Compile._IReply> _replies;
    public RSLSystemState(Dafny.ISet<Native____Io__s_Compile._IEndPoint> server__addresses, ulong app, Dafny.ISet<LiveByzRSL____Types__i_Compile._IRequest> requests, Dafny.ISet<LiveByzRSL____Types__i_Compile._IReply> replies) {
      this._server__addresses = server__addresses;
      this._app = app;
      this._requests = requests;
      this._replies = replies;
    }
    public _IRSLSystemState DowncastClone() {
      if (this is _IRSLSystemState dt) { return dt; }
      return new RSLSystemState(_server__addresses, _app, _requests, _replies);
    }
    public override bool Equals(object other) {
      var oth = other as DirectRefinement____StateMachine__i_Compile.RSLSystemState;
      return oth != null && object.Equals(this._server__addresses, oth._server__addresses) && this._app == oth._app && object.Equals(this._requests, oth._requests) && object.Equals(this._replies, oth._replies);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._server__addresses));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._app));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._requests));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._replies));
      return (int) hash;
    }
    public override string ToString() {
      string s = "DirectRefinement____StateMachine__i_Compile.RSLSystemState.RSLSystemState";
      s += "(";
      s += Dafny.Helpers.ToString(this._server__addresses);
      s += ", ";
      s += Dafny.Helpers.ToString(this._app);
      s += ", ";
      s += Dafny.Helpers.ToString(this._requests);
      s += ", ";
      s += Dafny.Helpers.ToString(this._replies);
      s += ")";
      return s;
    }
    private static readonly DirectRefinement____StateMachine__i_Compile._IRSLSystemState theDefault = create(Dafny.Set<Native____Io__s_Compile._IEndPoint>.Empty, 0, Dafny.Set<LiveByzRSL____Types__i_Compile._IRequest>.Empty, Dafny.Set<LiveByzRSL____Types__i_Compile._IReply>.Empty);
    public static DirectRefinement____StateMachine__i_Compile._IRSLSystemState Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<DirectRefinement____StateMachine__i_Compile._IRSLSystemState> _TYPE = new Dafny.TypeDescriptor<DirectRefinement____StateMachine__i_Compile._IRSLSystemState>(DirectRefinement____StateMachine__i_Compile.RSLSystemState.Default());
    public static Dafny.TypeDescriptor<DirectRefinement____StateMachine__i_Compile._IRSLSystemState> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IRSLSystemState create(Dafny.ISet<Native____Io__s_Compile._IEndPoint> server__addresses, ulong app, Dafny.ISet<LiveByzRSL____Types__i_Compile._IRequest> requests, Dafny.ISet<LiveByzRSL____Types__i_Compile._IReply> replies) {
      return new RSLSystemState(server__addresses, app, requests, replies);
    }
    public static _IRSLSystemState create_RSLSystemState(Dafny.ISet<Native____Io__s_Compile._IEndPoint> server__addresses, ulong app, Dafny.ISet<LiveByzRSL____Types__i_Compile._IRequest> requests, Dafny.ISet<LiveByzRSL____Types__i_Compile._IReply> replies) {
      return create(server__addresses, app, requests, replies);
    }
    public bool is_RSLSystemState { get { return true; } }
    public Dafny.ISet<Native____Io__s_Compile._IEndPoint> dtor_server__addresses {
      get {
        return this._server__addresses;
      }
    }
    public ulong dtor_app {
      get {
        return this._app;
      }
    }
    public Dafny.ISet<LiveByzRSL____Types__i_Compile._IRequest> dtor_requests {
      get {
        return this._requests;
      }
    }
    public Dafny.ISet<LiveByzRSL____Types__i_Compile._IReply> dtor_replies {
      get {
        return this._replies;
      }
    }
  }

} // end of namespace DirectRefinement____StateMachine__i_Compile
namespace DirectRefinement____HandleRequestBatch__i_Compile {

} // end of namespace DirectRefinement____HandleRequestBatch__i_Compile
namespace CommonProof____Assumptions__i_Compile {

} // end of namespace CommonProof____Assumptions__i_Compile
namespace Temporal____Heuristics__i_Compile {

} // end of namespace Temporal____Heuristics__i_Compile
namespace Temporal____Rules__i_Compile {

} // end of namespace Temporal____Rules__i_Compile
namespace CommonProof____Constants__i_Compile {

} // end of namespace CommonProof____Constants__i_Compile
namespace CommonProof____Actions__i_Compile {

} // end of namespace CommonProof____Actions__i_Compile
namespace CommonProof____PacketSending__i_Compile {

} // end of namespace CommonProof____PacketSending__i_Compile
namespace CommonProof____Environment__i_Compile {

} // end of namespace CommonProof____Environment__i_Compile
namespace CommonProof____AcceptorState__i_Compile {

} // end of namespace CommonProof____AcceptorState__i_Compile
namespace CommonProof____QuorumOf2avs__i_Compile {

  public interface _IQuorumOf2avs {
    bool is_QuorumOf2avs { get; }
    LiveByzRSL____Constants__i_Compile._ILConstants dtor_c { get; }
    Dafny.ISet<BigInteger> dtor_indices { get; }
    Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> dtor_packets { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_bal { get; }
    BigInteger dtor_opn { get; }
    Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_v { get; }
    _IQuorumOf2avs DowncastClone();
  }
  public class QuorumOf2avs : _IQuorumOf2avs {
    public readonly LiveByzRSL____Constants__i_Compile._ILConstants _c;
    public readonly Dafny.ISet<BigInteger> _indices;
    public readonly Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> _packets;
    public readonly LiveByzRSL____Types__i_Compile._IBallot _bal;
    public readonly BigInteger _opn;
    public readonly Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> _v;
    public QuorumOf2avs(LiveByzRSL____Constants__i_Compile._ILConstants c, Dafny.ISet<BigInteger> indices, Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> packets, LiveByzRSL____Types__i_Compile._IBallot bal, BigInteger opn, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> v) {
      this._c = c;
      this._indices = indices;
      this._packets = packets;
      this._bal = bal;
      this._opn = opn;
      this._v = v;
    }
    public _IQuorumOf2avs DowncastClone() {
      if (this is _IQuorumOf2avs dt) { return dt; }
      return new QuorumOf2avs(_c, _indices, _packets, _bal, _opn, _v);
    }
    public override bool Equals(object other) {
      var oth = other as CommonProof____QuorumOf2avs__i_Compile.QuorumOf2avs;
      return oth != null && object.Equals(this._c, oth._c) && object.Equals(this._indices, oth._indices) && object.Equals(this._packets, oth._packets) && object.Equals(this._bal, oth._bal) && this._opn == oth._opn && object.Equals(this._v, oth._v);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._c));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._indices));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._packets));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._opn));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._v));
      return (int) hash;
    }
    public override string ToString() {
      string s = "CommonProof____QuorumOf2avs__i_Compile.QuorumOf2avs.QuorumOf2avs";
      s += "(";
      s += Dafny.Helpers.ToString(this._c);
      s += ", ";
      s += Dafny.Helpers.ToString(this._indices);
      s += ", ";
      s += Dafny.Helpers.ToString(this._packets);
      s += ", ";
      s += Dafny.Helpers.ToString(this._bal);
      s += ", ";
      s += Dafny.Helpers.ToString(this._opn);
      s += ", ";
      s += Dafny.Helpers.ToString(this._v);
      s += ")";
      return s;
    }
    private static readonly CommonProof____QuorumOf2avs__i_Compile._IQuorumOf2avs theDefault = create(LiveByzRSL____Constants__i_Compile.LConstants.Default(), Dafny.Set<BigInteger>.Empty, Dafny.Sequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>.Empty, LiveByzRSL____Types__i_Compile.Ballot.Default(), BigInteger.Zero, Dafny.Sequence<LiveByzRSL____Types__i_Compile._IRequest>.Empty);
    public static CommonProof____QuorumOf2avs__i_Compile._IQuorumOf2avs Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<CommonProof____QuorumOf2avs__i_Compile._IQuorumOf2avs> _TYPE = new Dafny.TypeDescriptor<CommonProof____QuorumOf2avs__i_Compile._IQuorumOf2avs>(CommonProof____QuorumOf2avs__i_Compile.QuorumOf2avs.Default());
    public static Dafny.TypeDescriptor<CommonProof____QuorumOf2avs__i_Compile._IQuorumOf2avs> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IQuorumOf2avs create(LiveByzRSL____Constants__i_Compile._ILConstants c, Dafny.ISet<BigInteger> indices, Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> packets, LiveByzRSL____Types__i_Compile._IBallot bal, BigInteger opn, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> v) {
      return new QuorumOf2avs(c, indices, packets, bal, opn, v);
    }
    public static _IQuorumOf2avs create_QuorumOf2avs(LiveByzRSL____Constants__i_Compile._ILConstants c, Dafny.ISet<BigInteger> indices, Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> packets, LiveByzRSL____Types__i_Compile._IBallot bal, BigInteger opn, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> v) {
      return create(c, indices, packets, bal, opn, v);
    }
    public bool is_QuorumOf2avs { get { return true; } }
    public LiveByzRSL____Constants__i_Compile._ILConstants dtor_c {
      get {
        return this._c;
      }
    }
    public Dafny.ISet<BigInteger> dtor_indices {
      get {
        return this._indices;
      }
    }
    public Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> dtor_packets {
      get {
        return this._packets;
      }
    }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_bal {
      get {
        return this._bal;
      }
    }
    public BigInteger dtor_opn {
      get {
        return this._opn;
      }
    }
    public Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_v {
      get {
        return this._v;
      }
    }
  }

} // end of namespace CommonProof____QuorumOf2avs__i_Compile
namespace CommonProof____Quorum__i_Compile {

} // end of namespace CommonProof____Quorum__i_Compile
namespace CommonProof____Received2av__i_Compile {

} // end of namespace CommonProof____Received2av__i_Compile
namespace CommonProof____Message2av__i_Compile {

} // end of namespace CommonProof____Message2av__i_Compile
namespace CommonProof____Message2b__i_Compile {

} // end of namespace CommonProof____Message2b__i_Compile
namespace CommonProof____LearnerState__i_Compile {

} // end of namespace CommonProof____LearnerState__i_Compile
namespace CommonProof____max__bal__i_Compile {

} // end of namespace CommonProof____max__bal__i_Compile
namespace CommonProof____max__balISent1a__i_Compile {

} // end of namespace CommonProof____max__balISent1a__i_Compile
namespace CommonProof____Received1b__i_Compile {

} // end of namespace CommonProof____Received1b__i_Compile
namespace CommonProof____Message1c__i_Compile {

} // end of namespace CommonProof____Message1c__i_Compile
namespace CommonProof____Votes__i_Compile {

} // end of namespace CommonProof____Votes__i_Compile
namespace CommonProof____Message1b__i_Compile {

} // end of namespace CommonProof____Message1b__i_Compile
namespace CommonProof____Received2b__i_Compile {

} // end of namespace CommonProof____Received2b__i_Compile
namespace CommonProof____Chosen__i_Compile {

  public interface _IQuorumOf2bs {
    bool is_QuorumOf2bs { get; }
    LiveByzRSL____Constants__i_Compile._ILConstants dtor_c { get; }
    Dafny.ISet<BigInteger> dtor_indices { get; }
    Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> dtor_packets { get; }
    LiveByzRSL____Types__i_Compile._IBallot dtor_bal { get; }
    BigInteger dtor_opn { get; }
    Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_v { get; }
    _IQuorumOf2bs DowncastClone();
  }
  public class QuorumOf2bs : _IQuorumOf2bs {
    public readonly LiveByzRSL____Constants__i_Compile._ILConstants _c;
    public readonly Dafny.ISet<BigInteger> _indices;
    public readonly Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> _packets;
    public readonly LiveByzRSL____Types__i_Compile._IBallot _bal;
    public readonly BigInteger _opn;
    public readonly Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> _v;
    public QuorumOf2bs(LiveByzRSL____Constants__i_Compile._ILConstants c, Dafny.ISet<BigInteger> indices, Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> packets, LiveByzRSL____Types__i_Compile._IBallot bal, BigInteger opn, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> v) {
      this._c = c;
      this._indices = indices;
      this._packets = packets;
      this._bal = bal;
      this._opn = opn;
      this._v = v;
    }
    public _IQuorumOf2bs DowncastClone() {
      if (this is _IQuorumOf2bs dt) { return dt; }
      return new QuorumOf2bs(_c, _indices, _packets, _bal, _opn, _v);
    }
    public override bool Equals(object other) {
      var oth = other as CommonProof____Chosen__i_Compile.QuorumOf2bs;
      return oth != null && object.Equals(this._c, oth._c) && object.Equals(this._indices, oth._indices) && object.Equals(this._packets, oth._packets) && object.Equals(this._bal, oth._bal) && this._opn == oth._opn && object.Equals(this._v, oth._v);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._c));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._indices));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._packets));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bal));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._opn));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._v));
      return (int) hash;
    }
    public override string ToString() {
      string s = "CommonProof____Chosen__i_Compile.QuorumOf2bs.QuorumOf2bs";
      s += "(";
      s += Dafny.Helpers.ToString(this._c);
      s += ", ";
      s += Dafny.Helpers.ToString(this._indices);
      s += ", ";
      s += Dafny.Helpers.ToString(this._packets);
      s += ", ";
      s += Dafny.Helpers.ToString(this._bal);
      s += ", ";
      s += Dafny.Helpers.ToString(this._opn);
      s += ", ";
      s += Dafny.Helpers.ToString(this._v);
      s += ")";
      return s;
    }
    private static readonly CommonProof____Chosen__i_Compile._IQuorumOf2bs theDefault = create(LiveByzRSL____Constants__i_Compile.LConstants.Default(), Dafny.Set<BigInteger>.Empty, Dafny.Sequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>>.Empty, LiveByzRSL____Types__i_Compile.Ballot.Default(), BigInteger.Zero, Dafny.Sequence<LiveByzRSL____Types__i_Compile._IRequest>.Empty);
    public static CommonProof____Chosen__i_Compile._IQuorumOf2bs Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<CommonProof____Chosen__i_Compile._IQuorumOf2bs> _TYPE = new Dafny.TypeDescriptor<CommonProof____Chosen__i_Compile._IQuorumOf2bs>(CommonProof____Chosen__i_Compile.QuorumOf2bs.Default());
    public static Dafny.TypeDescriptor<CommonProof____Chosen__i_Compile._IQuorumOf2bs> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IQuorumOf2bs create(LiveByzRSL____Constants__i_Compile._ILConstants c, Dafny.ISet<BigInteger> indices, Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> packets, LiveByzRSL____Types__i_Compile._IBallot bal, BigInteger opn, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> v) {
      return new QuorumOf2bs(c, indices, packets, bal, opn, v);
    }
    public static _IQuorumOf2bs create_QuorumOf2bs(LiveByzRSL____Constants__i_Compile._ILConstants c, Dafny.ISet<BigInteger> indices, Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> packets, LiveByzRSL____Types__i_Compile._IBallot bal, BigInteger opn, Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> v) {
      return create(c, indices, packets, bal, opn, v);
    }
    public bool is_QuorumOf2bs { get { return true; } }
    public LiveByzRSL____Constants__i_Compile._ILConstants dtor_c {
      get {
        return this._c;
      }
    }
    public Dafny.ISet<BigInteger> dtor_indices {
      get {
        return this._indices;
      }
    }
    public Dafny.ISequence<Environment__s_Compile._ILPacket<Native____Io__s_Compile._IEndPoint, LiveByzRSL____Message__i_Compile._IRslMessage>> dtor_packets {
      get {
        return this._packets;
      }
    }
    public LiveByzRSL____Types__i_Compile._IBallot dtor_bal {
      get {
        return this._bal;
      }
    }
    public BigInteger dtor_opn {
      get {
        return this._opn;
      }
    }
    public Dafny.ISequence<LiveByzRSL____Types__i_Compile._IRequest> dtor_v {
      get {
        return this._v;
      }
    }
  }

} // end of namespace CommonProof____Chosen__i_Compile
namespace DirectRefinement____Chosen__i_Compile {

} // end of namespace DirectRefinement____Chosen__i_Compile
namespace DirectRefinement____Execution__i_Compile {

} // end of namespace DirectRefinement____Execution__i_Compile
namespace CommonProof____Requests__i_Compile {

} // end of namespace CommonProof____Requests__i_Compile
namespace DirectRefinement____Requests__i_Compile {

} // end of namespace DirectRefinement____Requests__i_Compile
namespace DirectRefinement____Refinement__i_Compile {

} // end of namespace DirectRefinement____Refinement__i_Compile
namespace AbstractServiceRSL__s_Compile {

  public interface _IAppRequest {
    bool is_AppRequest { get; }
    Native____Io__s_Compile._IEndPoint dtor_client { get; }
    BigInteger dtor_seqno { get; }
    AppStateMachine__i_Compile._IAppMessage_k dtor_request { get; }
    _IAppRequest DowncastClone();
  }
  public class AppRequest : _IAppRequest {
    public readonly Native____Io__s_Compile._IEndPoint _client;
    public readonly BigInteger _seqno;
    public readonly AppStateMachine__i_Compile._IAppMessage_k _request;
    public AppRequest(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, AppStateMachine__i_Compile._IAppMessage_k request) {
      this._client = client;
      this._seqno = seqno;
      this._request = request;
    }
    public _IAppRequest DowncastClone() {
      if (this is _IAppRequest dt) { return dt; }
      return new AppRequest(_client, _seqno, _request);
    }
    public override bool Equals(object other) {
      var oth = other as AbstractServiceRSL__s_Compile.AppRequest;
      return oth != null && object.Equals(this._client, oth._client) && this._seqno == oth._seqno && object.Equals(this._request, oth._request);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._client));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._seqno));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._request));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AbstractServiceRSL__s_Compile.AppRequest.AppRequest";
      s += "(";
      s += Dafny.Helpers.ToString(this._client);
      s += ", ";
      s += Dafny.Helpers.ToString(this._seqno);
      s += ", ";
      s += Dafny.Helpers.ToString(this._request);
      s += ")";
      return s;
    }
    private static readonly AbstractServiceRSL__s_Compile._IAppRequest theDefault = create(Native____Io__s_Compile.EndPoint.Default(), BigInteger.Zero, AppStateMachine__i_Compile.AppMessage_k.Default());
    public static AbstractServiceRSL__s_Compile._IAppRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AbstractServiceRSL__s_Compile._IAppRequest> _TYPE = new Dafny.TypeDescriptor<AbstractServiceRSL__s_Compile._IAppRequest>(AbstractServiceRSL__s_Compile.AppRequest.Default());
    public static Dafny.TypeDescriptor<AbstractServiceRSL__s_Compile._IAppRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAppRequest create(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, AppStateMachine__i_Compile._IAppMessage_k request) {
      return new AppRequest(client, seqno, request);
    }
    public static _IAppRequest create_AppRequest(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, AppStateMachine__i_Compile._IAppMessage_k request) {
      return create(client, seqno, request);
    }
    public bool is_AppRequest { get { return true; } }
    public Native____Io__s_Compile._IEndPoint dtor_client {
      get {
        return this._client;
      }
    }
    public BigInteger dtor_seqno {
      get {
        return this._seqno;
      }
    }
    public AppStateMachine__i_Compile._IAppMessage_k dtor_request {
      get {
        return this._request;
      }
    }
  }

  public interface _IAppReply {
    bool is_AppReply { get; }
    Native____Io__s_Compile._IEndPoint dtor_client { get; }
    BigInteger dtor_seqno { get; }
    AppStateMachine__i_Compile._IAppMessage_k dtor_reply { get; }
    _IAppReply DowncastClone();
  }
  public class AppReply : _IAppReply {
    public readonly Native____Io__s_Compile._IEndPoint _client;
    public readonly BigInteger _seqno;
    public readonly AppStateMachine__i_Compile._IAppMessage_k _reply;
    public AppReply(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, AppStateMachine__i_Compile._IAppMessage_k reply) {
      this._client = client;
      this._seqno = seqno;
      this._reply = reply;
    }
    public _IAppReply DowncastClone() {
      if (this is _IAppReply dt) { return dt; }
      return new AppReply(_client, _seqno, _reply);
    }
    public override bool Equals(object other) {
      var oth = other as AbstractServiceRSL__s_Compile.AppReply;
      return oth != null && object.Equals(this._client, oth._client) && this._seqno == oth._seqno && object.Equals(this._reply, oth._reply);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._client));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._seqno));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._reply));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AbstractServiceRSL__s_Compile.AppReply.AppReply";
      s += "(";
      s += Dafny.Helpers.ToString(this._client);
      s += ", ";
      s += Dafny.Helpers.ToString(this._seqno);
      s += ", ";
      s += Dafny.Helpers.ToString(this._reply);
      s += ")";
      return s;
    }
    private static readonly AbstractServiceRSL__s_Compile._IAppReply theDefault = create(Native____Io__s_Compile.EndPoint.Default(), BigInteger.Zero, AppStateMachine__i_Compile.AppMessage_k.Default());
    public static AbstractServiceRSL__s_Compile._IAppReply Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AbstractServiceRSL__s_Compile._IAppReply> _TYPE = new Dafny.TypeDescriptor<AbstractServiceRSL__s_Compile._IAppReply>(AbstractServiceRSL__s_Compile.AppReply.Default());
    public static Dafny.TypeDescriptor<AbstractServiceRSL__s_Compile._IAppReply> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAppReply create(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, AppStateMachine__i_Compile._IAppMessage_k reply) {
      return new AppReply(client, seqno, reply);
    }
    public static _IAppReply create_AppReply(Native____Io__s_Compile._IEndPoint client, BigInteger seqno, AppStateMachine__i_Compile._IAppMessage_k reply) {
      return create(client, seqno, reply);
    }
    public bool is_AppReply { get { return true; } }
    public Native____Io__s_Compile._IEndPoint dtor_client {
      get {
        return this._client;
      }
    }
    public BigInteger dtor_seqno {
      get {
        return this._seqno;
      }
    }
    public AppStateMachine__i_Compile._IAppMessage_k dtor_reply {
      get {
        return this._reply;
      }
    }
  }

  public interface _IServiceState_k {
    bool is_ServiceState_k { get; }
    Dafny.ISet<Native____Io__s_Compile._IEndPoint> dtor_serverAddresses { get; }
    ulong dtor_app { get; }
    Dafny.ISet<AbstractServiceRSL__s_Compile._IAppRequest> dtor_requests { get; }
    Dafny.ISet<AbstractServiceRSL__s_Compile._IAppReply> dtor_replies { get; }
    _IServiceState_k DowncastClone();
  }
  public class ServiceState_k : _IServiceState_k {
    public readonly Dafny.ISet<Native____Io__s_Compile._IEndPoint> _serverAddresses;
    public readonly ulong _app;
    public readonly Dafny.ISet<AbstractServiceRSL__s_Compile._IAppRequest> _requests;
    public readonly Dafny.ISet<AbstractServiceRSL__s_Compile._IAppReply> _replies;
    public ServiceState_k(Dafny.ISet<Native____Io__s_Compile._IEndPoint> serverAddresses, ulong app, Dafny.ISet<AbstractServiceRSL__s_Compile._IAppRequest> requests, Dafny.ISet<AbstractServiceRSL__s_Compile._IAppReply> replies) {
      this._serverAddresses = serverAddresses;
      this._app = app;
      this._requests = requests;
      this._replies = replies;
    }
    public _IServiceState_k DowncastClone() {
      if (this is _IServiceState_k dt) { return dt; }
      return new ServiceState_k(_serverAddresses, _app, _requests, _replies);
    }
    public override bool Equals(object other) {
      var oth = other as AbstractServiceRSL__s_Compile.ServiceState_k;
      return oth != null && object.Equals(this._serverAddresses, oth._serverAddresses) && this._app == oth._app && object.Equals(this._requests, oth._requests) && object.Equals(this._replies, oth._replies);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._serverAddresses));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._app));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._requests));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._replies));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AbstractServiceRSL__s_Compile.ServiceState'.ServiceState'";
      s += "(";
      s += Dafny.Helpers.ToString(this._serverAddresses);
      s += ", ";
      s += Dafny.Helpers.ToString(this._app);
      s += ", ";
      s += Dafny.Helpers.ToString(this._requests);
      s += ", ";
      s += Dafny.Helpers.ToString(this._replies);
      s += ")";
      return s;
    }
    private static readonly AbstractServiceRSL__s_Compile._IServiceState_k theDefault = create(Dafny.Set<Native____Io__s_Compile._IEndPoint>.Empty, 0, Dafny.Set<AbstractServiceRSL__s_Compile._IAppRequest>.Empty, Dafny.Set<AbstractServiceRSL__s_Compile._IAppReply>.Empty);
    public static AbstractServiceRSL__s_Compile._IServiceState_k Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AbstractServiceRSL__s_Compile._IServiceState_k> _TYPE = new Dafny.TypeDescriptor<AbstractServiceRSL__s_Compile._IServiceState_k>(AbstractServiceRSL__s_Compile.ServiceState_k.Default());
    public static Dafny.TypeDescriptor<AbstractServiceRSL__s_Compile._IServiceState_k> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IServiceState_k create(Dafny.ISet<Native____Io__s_Compile._IEndPoint> serverAddresses, ulong app, Dafny.ISet<AbstractServiceRSL__s_Compile._IAppRequest> requests, Dafny.ISet<AbstractServiceRSL__s_Compile._IAppReply> replies) {
      return new ServiceState_k(serverAddresses, app, requests, replies);
    }
    public static _IServiceState_k create_ServiceState_k(Dafny.ISet<Native____Io__s_Compile._IEndPoint> serverAddresses, ulong app, Dafny.ISet<AbstractServiceRSL__s_Compile._IAppRequest> requests, Dafny.ISet<AbstractServiceRSL__s_Compile._IAppReply> replies) {
      return create(serverAddresses, app, requests, replies);
    }
    public bool is_ServiceState_k { get { return true; } }
    public Dafny.ISet<Native____Io__s_Compile._IEndPoint> dtor_serverAddresses {
      get {
        return this._serverAddresses;
      }
    }
    public ulong dtor_app {
      get {
        return this._app;
      }
    }
    public Dafny.ISet<AbstractServiceRSL__s_Compile._IAppRequest> dtor_requests {
      get {
        return this._requests;
      }
    }
    public Dafny.ISet<AbstractServiceRSL__s_Compile._IAppReply> dtor_replies {
      get {
        return this._replies;
      }
    }
  }

} // end of namespace AbstractServiceRSL__s_Compile
namespace MarshallProof__i_Compile {

} // end of namespace MarshallProof__i_Compile
namespace Main__i_Compile {

  public partial class __default {
    public static void _Main(Dafny.ISequence<Dafny.ISequence<char>> __noArgsParameter)
    {
      bool _1056_ok;
      LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl _1057_host__state;
      LiveByzRSL____ConstantsState__i_Compile._ICConstants _1058_config;
      Native____Io__s_Compile._IEndPoint _1059_id;
      bool _out242;
      LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl _out243;
      LiveByzRSL____ConstantsState__i_Compile._ICConstants _out244;
      Native____Io__s_Compile._IEndPoint _out245;
      Host__i_Compile.__default.HostInitImpl(out _out242, out _out243, out _out244, out _out245);
      _1056_ok = _out242;
      _1057_host__state = _out243;
      _1058_config = _out244;
      _1059_id = _out245;
      while (_1056_ok) {
        bool _out246;
        LiveByzRSL____ReplicaImplClass__i_Compile.ReplicaImpl _out247;
        Host__i_Compile.__default.HostNextImpl(_1057_host__state, out _out246, out _out247);
        _1056_ok = _out246;
        _1057_host__state = _out247;
      }
    }
  }
} // end of namespace Main__i_Compile
namespace _module {

} // end of namespace _module
class __CallToMain {
  public static void Main(string[] args) {
    Dafny.Helpers.WithHaltHandling(() => Main__i_Compile.__default._Main(Dafny.Sequence<Dafny.ISequence<char>>.FromMainArguments(args)));
  }
}
