% Created 2024-07-16 Tue 08:27
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{proof}
\author{Christa Jenkins}
\date{\today}
\title{AutoMan: Mode Analysis}
\hypersetup{
 pdfauthor={Christa Jenkins},
 pdftitle={AutoMan: Mode Analysis},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 29.4 (Org mode 9.6.15)}, 
 pdflang={English}}
\begin{document}

\maketitle

\section{Conventions}
\label{sec:org97aecb2}

The meta-variable conventions are as follows.
\begin{itemize}
\item \(x\) ranges over term variables, \(m\) over member name segments, and \(M\)
over module qualified names.
\item \(\Gamma_{\text{in}}, \Gamma_{\text{out}}\) range over contexts, that is,
partial maps from variable \(x\) to types \(T\) (and possibly \(x\)'s
definition, if it is let-bound)
\item \(\Sigma\) ranges over signatures, that is, \(\Sigma\) is a partial map from
qualified names \(M\) to \(M\)'s information (module, class, datatype,
function/predicate). If \(M\) is the name of a predicate declared in
\(\Sigma\), then \(\Sigma(M)\) contains the \emph{predicate mode description} for \(M\).
\item \(e\) ranges over \emph{expressions}.
\end{itemize}

\section{Judgments}
\label{sec:org1599a4b}

\begin{figure}
  \[
    \fbox{\(\Sigma, \Gamma_{\text{in}}, \Gamma_{\text{out}} \vdash e\ \text{evl}\)}
  \]
  \label{fig:judgment-listing}
  \caption{Mode analysis (judgments)}
\end{figure}

\subsection{Evaluatable judgment}
\label{sec:org817e32c}

Read \(\Sigma, \Gamma_{\text{in}}, \Gamma_{\text{out}} \vdash e\ \text{evl}\) as
\emph{"under signature \(\Sigma\), with input-moded formal parameters
\(\Gamma_{\text{in}}\) and output-moded formal parameters
\(\Gamma_{\text{out}}\), expression \(e\) is evaluatable}." This judgment is
invoked on certain subexpressions of the bodies of predicates marked as an
action type (describing either initialization or a state transition), and it
maintains the following invariants.

\begin{itemize}
\item \(\{\Gamma_{\text{in}}, \Gamma_{\text{out}}\}\) is a partition of the
predicate's formal parameters and previously encountered let bindings. These
sets are initially determined by mode annotations supplied by the programmer,
but may vary according to the judgment for generatable code.

\item Formal type parameters are always considered to be input.

\item \(\Sigma\) is a partial map from qualified identifiers to their \emph{predicate
mode descriptions}, that is, a mapping (by position) of formal parameters to
their input/output mode.

More formally, if defined then \(\Sigma(M) = (I,O)\) where \(\{I,O\}\) is a
partition on \(\{1 \ldots \mathit{arity}(M)\}\). When \(O = \emptyset\), \(M\)
is considered a \emph{proper function} (that is, one that does not need
translation); otherwise, \(M\) is considered to be the relational
specification of a function which we will generate.
\end{itemize}

\section{Rules}
\label{sec:orgddcea43}

\begin{figure}[h]
  \[
    \begin{array}{c}
      \begin{array}{cc}
        \infer{
          \Sigma,\Gamma_{\text{in}}, \Gamma_{\text{out}} \vdash x\ \text{evl}
        }{
          x \notin \Gamma_{\text{out}}
        }
       & \infer{
          \Sigma,\Gamma_{\text{in}}, \Gamma_{\text{out}} \vdash e.m\ \text{evl}
        }{
          m \text{ an id or nonneg int}
          & \Sigma,\Gamma_{\text{in}}, \Gamma_{\text{out}} \vdash e\ \text{evl}
        }
        \\ \\
        \infer{
          \Sigma,\Gamma_{\text{in}}, \Gamma_{\text{out}} \vdash e_0.\left(m_i := e_i\right)_{i \in \{1 \ldots n\}}\ \text{evl}
        }{
          \left(\Sigma,\Gamma_{\text{in}},\Gamma_{\text{out}} \vdash e_i \right)_{i \in \{0 \ldots n\}}
        }
        & \infer{
          \Sigma,\Gamma_{\text{in}}, \Gamma_{\text{out}} \vdash e_0[e_1 .. e_2]\ \text{evl}
        }{
          \left(\Sigma,\Gamma_{\text{in}},\Gamma_{\text{out}} \vdash e_i\ \text{evl}\right)_{i \in \{0 \ldots 2\}}
        }
      \end{array}
      \\ \\
      \infer{
        \Sigma,\Gamma_{\text{in}}, \Gamma_{\text{out}} \vdash M(e_1,\ldots,e_{n})\ \text{evl}
      }{
        \Sigma(M) = (\{1 \ldots n\},\emptyset)
        & \left(\Sigma,\Gamma_{\text{in}},\Gamma_{\text{out}} \vdash e_i \right)_{i \in \{1 \ldots n\}}
      }
      \\ \\
      \begin{array}{cc}
        \infer{
          \Sigma,\Gamma_{\text{in}},\Gamma_{\text{out}} \vdash \left(x_i:T_i\right)_{i \in \{1 \ldots n\}} \Rightarrow e\ \text{evl}
        }{
          \Sigma,\Gamma_{\text{in}}\left(x_i:T_i\right)_{i \in \{1 \ldots n\}},\Gamma_{\text{out}} \vdash e\ \text{evl}
        }
        & \infer{
          \Sigma,\Gamma_{\text{in}},\Gamma_{\text{out}} \vdash \textit{if}\ e_1\ \tetxit{then}\ e_2\ \textit{else}\ e_3\ \text{evl}
        }{
          \left(\Sigma, \Gamma_{\text{in}}, \Gamma_{\text{out}} \vdash e_i\ \text{evl}\right)_{i \in \{1,2,3\}}
        }
        \\ \\
        \infer{
          \Sigma,\Gamma_{\text{in}},\Gamma_{\text{out}} \vdash [e_1,\ldots,e_n]\ \text{evl}
        }{
          \left(\Sigma,\Gamma_{\text{in}},\Gamma_{\text{out}} \vdash e_i\right)_{i \in \{1 \ldots n\}}
        }
      \end{array}
    \end{array}
  \]
  \label{fig:rules-evaluatable}
  \caption{Mode analysis rules (evaluatable judgment)}
\end{figure}

\begin{figure}
  \[
    \begin{array}{c}
      \begin{array}{cc}
        \fbox{\(\Sigma,\Gamma_{\text{in}},\Gamma_{\text{out}} \vdash \mathcal{Q}_\text{dom}\ \text{evl}\)}
        & \infer{
          \Sigma,\Gamma_{\text{in}},\Gamma_{\text{out}} \vdash x:T \leftarrow e_1\ |\ e_2\ \text{evl}
        }{
          \left(\Sigma,\Gamma_{\text{in}},\Gamma_{\text{out}} \vdash e_i\ \text{evl}\right)_{i \in \{1,2\}}
        }
      \end{array}
    \end{array}
  \]
  \label{fig:rules-evaluatable-aux}
  \capition{Mode analysis rules (evaluatable judgment, auxiliary rules)}
\end{figure}

\subsection{Identifiers}
\label{sec:orgb29c0e7}

Identifiers can range over many different sorts of entities.
\begin{itemize}
\item Formal (term) parameters of a predicate.

These must not appear in the set of output-moded variables.
\item Module or class names.

These are always considered input.
\item Types (datatypes, primitives, formal type parameters)

These are always considered input.
\end{itemize}

\subsection{Member Access}
\label{sec:orgb54ab02}

\begin{itemize}
\item As long as \(e\) is evaluatable, so is \(e.m\).

\item In Dafny, \(m\) can be an identifier (or identifier segment, i.e., with type
instantiation) \emph{or} a nonnegative integer, such as in tuple component access
\end{itemize}


\subsection{Member update}
\label{sec:orgd34ce3f}

\begin{itemize}
\item As long as \(e_0\) is evaluatable, and each expression \(e_i\) that updates a
field is evaluatable, then the field update expression \(e_0.\left(m_i =:
  e_i\right)_{i \in \{1 \ldots n\}}\) is evaluatable.
\end{itemize}

\subsection{Sequence (slices, access, update)}
\label{sec:org324d9e5}

\begin{itemize}
\item As long as \(e_0, e_1, e_2\) are evaluatable, so is \(e_0[e_1 .. e_2]\).

\item Similarly for length subsequences (\(e_0[e_1 : e_2 : \ldots]\)), accesses
(\(e_0[e_1]\)), and updates \((e_0[e_{1,1} := e_{1,2}])\).
\end{itemize}

\subsection{Function calls}
\label{sec:org56012c4}

\begin{itemize}
\item The rule restricts called functions to be qualified identifiers defined within signature \(\Sigma\).
\begin{itemize}
\item Formal parameters with function types that are marked as input could be
permitted here, but we do not currently support function types
\item Lambda expressions could be permitted here, but rarely does one see a redex like this in practice
\end{itemize}

\item \(M\) must be a \emph{proper function}.
\begin{itemize}
\item This is not a hard requirement, just a simplification. In theory, \(M\)
could be a relational specification that assigns values to output
parameters, which would be acceptable to use in the evaluatable position.
However, this would make the evaluatable judgment mutually inductively
defined with the generatable judgment, and require the former to track the
assignments generated.
\end{itemize}
\end{itemize}
\end{document}
