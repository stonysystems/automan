# Notices

- Initially, I thought the harmony check could be implemented with little / no
  typing information. While this is still (AFAICT) possible, it is trickier in
  the case of functional record updates.
  ```
  && s' == s.(log_truncation_point := opn, votes := s'.votes)
  ```
  On a quick first glance, this assigns *all* values of `s'`. If you want to
  explicitly enumerate the members of `s'` that are set by this, you need the
  type information.
  - You might think "Ok, just make `s'` a leaf and store this as the associated
    value", but... notice the implicit reflexive identity `s'.votes ==
    s'.votes`. Without type information, it seems the only way forward is to
    have two sorts of branches, "positive" and "negative". Positive branches are
    the same as how you have been thinking about it, where each subtree denotes
    an assignment to (hereditarily) some member. Negative would mean "we have an
    assignment for the root **except** for these members" (in this case, the
    exception is `s'.votes`)
  - That all seems complicated, so probably the best bet is to make sure the
    type information is available (we need it anyway for saturation).

# Easy harmonious examples

In which analysis of the predicate body should not conclude any conflicting
assignments. This includes:
- equalities where one side is a (qualified) output variable
  ```
  && a.constants == c
  ```
  An earlier mode analysis pass will provide you with `ann: IOFlow.eq_t`
  ```
  type eq_t =
    | Remappable
    | Functionalizable of (is_left: bool, mq_id: id_t NonEmptyList.t, op: supported_op_t option)
  type supported_op_t = Cardinality
  ```
  Here you can expect `ann` to be
  `Functionalizable (true, NonEmptyList.( :: ) ("a",["constants"]), None)`

- equalities where one side is a (qualified) output variable under some known
  operation (for now, just length)
  ```
  && |a.last_checkpointed_operation| == |c.all.config.replica_ids|
  ```
  Here you can expect `ann` to be
  `Functionalizable (true, NonEmptyList.( :: ) ("a", ["last_checkpointed_operation"]), Some Cardinality)`

  **NOTE:** The annotations generated by previous mode analysis will probably
  group these together, with an additional (option) field specifiying whether a
  known operation is present and if so what it is.

- universal quantifications that (partially) determine a known collection type
  ```
    && (forall idx ::
          0 <= idx < |a.last_checkpointed_operation| ==>
          a.last_checkpointed_operation[idx] == 0)

  ```
  An earlier mode analysis pass will provide you with `ann: IOFlow.quantifier_forall_t`
  ```
  type quantifier_forall_t =
    { out_var: id_t NonEmptyList.t
    ; coll_tp: collection_type_tabulator_t
    }
  type collection_type_tabulator_t =
    | Seq of expr_t
    | ...
  ```
  Recall that the two things we need for building a sequence are the length and
  tabulation function (how to populate each entry). Expect universal quantifiers
  to provide the tabulation function (an earlier mode analysis pass will abort
  translation if the tabulation function infered from the universal
  quantification is partial, e.g., `0 <= idx < |a.last_checkpointed_operation| -
  1`)

- if-then-else conditionals
  ```
  if inp.src in s.constants.all.config.replica_ids && BalLt(s.max_bal, m.bal_1a) && LReplicaConstantsValid(s.constants) then
    && sent_packets == [ LPacket(inp.src, s.constants.all.config.replica_ids[s.constants.my_index],
                                RslMessage_1b(m.bal_1a, s.log_truncation_point, s.votes)) ]
    && s' == s.(max_bal := m.bal_1a)
  else
    s' == s && sent_packets == []
  ```
  An earlier mode analysis pass will provide you with `ann: IOFlow.ite_t`
  ```
  type ite_t =
    | Remappable
    | Functionalizable of
      { out_vars_then : (id_t NonEmptyList.t) NonEmptyList.t
      ; out_vars_else : (id_t NonEmptyList.t) NonEmptyList.t
      }
  ```
  It's the job of harmony checking to make sure the `then` and `else` branches
  have harmonious assignments to their respective output variable sets, and that
  the two output var sets agree (initially just that one is a permutation of the
  other; with the annotations for state-relationship / partial specifications,
  one must be a sublist of a permutation of the other)

  Since you're already here, it would be good to emit the annotation that fixes
  a canonical order for the output variable list of the whole conditional, for
  future passes.

- argument list suffixes
  ```
  && LBroadcastToEveryone(s.constants.all.config, s.constants.my_index, RslMessage_2b(m.bal_2a, m.opn_2a, m.val_2a), sent_packets)
  ```
  An earlier mode analysis pass will provide you with `ann: IOFlow.arglist_t`
  ```
  type arglist_t =
    | Remappable
    | Functionalizable of
        { callee : id_t NonEmptyList.t
        ; inp_vars: (id_t NonEmptyList.t) list
        ; out_vars: (id_t NonEmptyList.t) NonEmptyList.t
        }
  ```
  It's the job of harmony checking to make sure that `out_vars` is unique (no
  duplicate assignments), as well as checking that no entry of `out_vars` has
  already been determined.
## `RSL/Acceptor.i.dfy`

- `LAcceptorInit`
  ```
  predicate LAcceptorInit(a:LAcceptor, c:LReplicaConstants) {...}
  ```
  Input: `c`; Output: `a`
  - equalities over qualified output variables
  ```
  && a.constants == c
  ```
  - equalities over qualified output variables under some known operation
  ```
  && |a.last_checkpointed_operation| == |c.all.config.replica_ids|
  ```
  - universal quantification
  ```
  && (forall idx :: 0 <= idx < |a.last_checkpointed_operation| ==>
       a.last_checkpointed_operation[idx] == 0) {...}
  ```
- `LAcceptorProcess1a`
  ```
  predicate LAcceptorProcess1a(s:LAcceptor, s':LAcceptor, inp:RslPacket, sent_packets:seq<RslPacket>)
      requires inp.msg.RslMessage_1a?
  ```
  Input: `s, inp`; Output: `s', sent_packets`
  - if-then-else
    ```
    if inp.src in s.constants.all.config.replica_ids && BalLt(s.max_bal, m.bal_1a) && LReplicaConstantsValid(s.constants) then
        && sent_packets == [ LPacket(inp.src, s.constants.all.config.replica_ids[s.constants.my_index],
                                RslMessage_1b(m.bal_1a, s.log_truncation_point, s.votes)) ]
        && s' == s.(max_bal := m.bal_1a)
    else
        s' == s && sent_packets == []
    ```
    Note that `m` is a local (input-moded) variable. Both branches set
    `sent_packets` and `s'` (*but in different orders!*)

- `LAcceptorProcess2a`
  ```
  predicate LAcceptorProcess2a(s:LAcceptor, s':LAcceptor, inp:RslPacket, sent_packets:seq<RslPacket>)
  ```
  Input: `s, inp`; Output: `s', sent_packets`
  - arglist on predicate to functionalize
    ```
    LBroadcastToEveryone(s.constants.all.config, s.constants.my_index, RslMessage_2b(m.bal_2a, m.opn_2a, m.val_2a), sent_packets)
    ```
    **NOTE:** We will fail to translate the actual implementation of
    `LBroadcastToEveryone`, but if the user annotated it, we should still
    translate all call sites (leaving the actual functionalization of
    `LBroadcastToEveryone` as a stub).

# Tricky harmonious examples

- Reflexive identies
  ```
  /* obvious */
  s' = s'
  /* burried */
  && s' == s.(log_truncation_point := opn, votes := s'.votes)
  ```
  In the second example above, notice that when you flatten out the record
  update it reveals a reflexive identity `s'.votes = s'.votes`. There are a
  couple of ways to handle this, but the most direct way is to mark `s'.votes`
  as not having been assigned anything (yet).
## `RSL/Acceptor.i.dfy`

- `LAcceptorTruncateLog`
  ```
  predicate LAcceptorTruncateLog(s:LAcceptor, s':LAcceptor, opn:OperationNumber)
  ```
  Input: `s, opn`; Output: `s'`
  - Reflexive identity
    ```
    && RemoveVotesBeforeLogTruncationPoint(s.votes, s'.votes, opn)
    && s' == s.(log_truncation_point := opn, votes := s'.votes)
    ```
    Note that the first of the lines above determines `s'.votes`, and the second
    determines everything *except* `s'.votes`

# Inharmonious Examples

## `SHT/Host.i.dfy`

- `NextDelegate(s:Host, s':Host, pkt:Packet, out:set<Packet>)`
  Input: `s, pkt`; Output: `s', out`
  - Conflict (assume `SendNoMessage` and `ReceiveNoMessage` both have
    annotations (+,-))
    ```
    && SendNoMessage(s.sd, s'.sd)
    && ReceiveNoMessage(s.sd, s'.sd)
    ```
    Under the current model in which the functionalization of predicates should
    completely determine their inputs, we can only assume that since
    `SendNoMessage` and `ReceiveNoMessage` are annotated this way, they must
    both fully determine `s'.sd` (in this case, the user's annotation is at
    fault). So, this case (with those annotations) should fail the harmony check.
