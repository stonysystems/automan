open Syntax
open TypeTableBuilder
open Internal


module AST = AST(TranslatorMetadata.TranslationMetaData)
module TCommon = TranslatorCommon.TranslatorCommon
module Printer = Printer.PrettyPrinter(TranslatorMetadata.TranslationMetaData)
module Convert = 
  Convert (TrivMetaData) (TranslatorMetadata.TranslationMetaData)

(**
  * DataTracker is used for:
  * 1. Harmony Check: Each member cannot be assigned twice.
  * 2. Saturation Check: Each member must be assigned.
  * 3. Assisting in translating Moder MetaData to Translator MetaData,
  *    specifically determining the members created by an expression.
  *
  * DataUpdate case:
  *   An expression like s' == s.(x := s'.x) involves assigning a sub-member
  *   with the member value of the output state, which can be assigned in any
  *   other location of the logical expression.
  *  
  *)

module DataTracker = struct 

  (*
   * APIs for callers:

      let assign_top_lvl_lst 
        (top_lvl : t)
        (kv_lst : 
          (AST.Prog.expr_t * 
           AST.Prog.expr_t *
           AST.Prog.expr_t list) list) : t

      let build_top_lvl (fs : AST.TopDecl.formal_t list) : t
   *)

  type tracker_k = AST.TopDecl.formal_t

  and tracker_v = 
    {
      (* Assigned value; initially null *)
      assigned_v : AST.Prog.expr_t ;

      (* Tracker for this datatype *)
      t : t ;
      
      (**
        * Skipped member assignments when the data update has self-assignments.
        * For example, s' == s.(a := s'.a). 
        * Then `a` will be recorded here for node `s'`.
        * Info about the skipped self-assignments is provided by the Moder.
        *)
      skipped_members : AST.Prog.expr_t list ;

      (**
        * Assigned sub-members for this node.
        * For example, s'.x could contain s'.x.a and s'.x.b.
        *)
      assigned_members : AST.Prog.expr_t list ;
    }

  (**
    * formal (d : D)
    * datatype D = D (x : X, y : Y)
    * t ->
    *   Tracker (k = (d : D), list = [v0, v1])
    *   v0 ->
    *     t ->
    *       Tracker (k = (x : X), list = []) 
    *     i.e. the key for v0 is determined by v0.t.k
    *)
  and t = | Tracker of (tracker_k * tracker_v list) 

  let assert_helper = TranslatorCommon.assert_helper

  let fml_from_passerpass_to_translator 
    (fml : ParserPass.TopDecl.formal_t) : AST.TopDecl.formal_t = 
    match fml with ParserPass.TopDecl.Formal (is_ghost, id, tp) ->
    (
      let tp_handler_t (m : TrivMetaData.type_t) : 
        TranslatorMetadata.TranslationMetaData.type_t = 
        let _ = m in None 
      in
      let tp' = Convert.typ tp_handler_t tp
      in
      AST.TopDecl.Formal (is_ghost, id, tp')
    )

  let rec build 
    (k : tracker_k) : t = 
    match k with Formal (is_ghost, id, tp) ->
      let _ = is_ghost in
      let empty_t = Tracker (k, []) in
      match TCommon.is_tp_id tp with
      | true -> (
        match TypeTableBuilder.find_type_decl id with 
        | Some (module_name, (modifiers, decl_body)) ->
          let _ = module_name, modifiers in (
            match decl_body with 
            | DatatypeDecl datatype -> 
              let (meta, attrs, id', params, ctors) = datatype in
              let _ = meta, attrs, params in
              assert_helper (id = id') "data tracker: id of data type mismatch";
              let ctors_len = List.length (NonEmptyList.as_list ctors) in (
                match ctors_len with 
                | 0 ->
                  assert_helper 
                  false
                  "data tracker: no constructor; grammar error";
                assert false
                | 1 -> (
                    let (ctor, _) = NonEmptyList.uncons ctors in
                    match ctor with DataCtor (attrs, ctor_id, fmls) ->
                      let _ = attrs, ctor_id in
                      let vs = List.map (
                        fun (x : tracker_k) : tracker_v -> 
                          {
                            assigned_v = TCommon.expr_blank ;
                            t = build x ;
                            skipped_members = [] ; 
                            assigned_members = [] ; 
                          }
                      ) (
                        List.map fml_from_passerpass_to_translator fmls
                      ) in
                      Tracker (k, vs)
                  )
                | _ -> 
                  assert_helper 
                    false
                    "data tracker: cannot handle multi-constructors";
                  assert false
              )
            | SynonymTypeDecl synonym_type -> 
              let k' = AST.TopDecl.Formal (
                is_ghost, id, TCommon.tp_of_id synonym_type.id) in
              build k'
            | _ -> assert false
          )
        | None -> empty_t
      )
      | false -> empty_t

  let is_tracker_k_equals_to_id 
    (k : tracker_k) (id : string) : bool = 
    match k with AST.TopDecl.Formal (_, id', _) -> id = id'
    
  let is_t_for_this_id 
    (t : t) (id : string) : bool = 
    match t with Tracker (k, _) -> is_tracker_k_equals_to_id k id
  
  (**
    * Find the wanted tracker_v from t.tracker_v list
    *)
  let query_sub_v (tracker : t) (id : string) : tracker_v =   
    match tracker with Tracker (_, vs) ->
      let rec aux (lst : tracker_v NonEmptyList.t) = 
        let (h, rest) = NonEmptyList.uncons lst in
        let t = h.t in
        match is_t_for_this_id t id  with 
        | true -> h
        | false -> aux (NonEmptyList.coerce rest)
      in
      aux (NonEmptyList.coerce vs)

  let is_sub_member_in_skipped_members 
    (sub_member : AST.Prog.expr_t)
    (skipped_members : AST.Prog.expr_t list) : bool = 
    let rec aux lst = 
      match lst with 
      | [] -> false 
      | h :: rest -> (
        (TCommon.str_of_expr sub_member) = 
        (TCommon.str_of_expr h)
      ) || (aux rest)
    in
    aux skipped_members

  (**
    * Find a tracker from a v_lst that has a t with key = id 
    * Assing the value e' to it  
    *)
  let update_v_lst_with_assign_to_a_v
    (v_lst : tracker_v list)
    (id : string)
    (e' : AST.Prog.expr_t) 
    (skipped_members : AST.Prog.expr_t list): tracker_v list = 
    let rec aux lst : tracker_v list = 
      match lst with 
      | [] -> 
          assert_helper 
            false
            "data tracker: update failed; cannot find the member";
          assert false
      | h :: rest -> 
        match is_t_for_this_id h.t id with
        | true -> 
          
          (* Whether this node has been assigned before. *)
          assert_helper 
            (TCommon.is_expr_n_blank h.assigned_v)
            "data tracker: harmony check failed";

          (** 
            * Whether any sub-member of this node has been assigned before. 
            * If they do, they must be a skipped member for this assign.
            *)
          let harmony_check = 
            match h.assigned_members with 
            | [] -> true
            | _ -> (
              List.for_all (
                fun assigned_member -> 
                  is_sub_member_in_skipped_members
                    assigned_member
                    skipped_members
              ) h.assigned_members
            ) 
          in
          assert_helper
            harmony_check
            "data tracker: harmony check failed"
          ;

          {
            assigned_v = e' ;
            t = h.t ;
            skipped_members = skipped_members ;
            assigned_members = h.assigned_members ;
          } :: (aux rest)
        | false ->
          h :: (aux rest)
    in
    aux v_lst

  (**
    * For tracker t, find the node with key = k
    * Assign value v with skipped members (only for data update)
    *)
  let assign 
    (t : t)
    (k : AST.Prog.expr_t) 
    (v : AST.Prog.expr_t) 
    (skipped_members : AST.Prog.expr_t list) : t = 
    let rec aux 
      (exprs : AST.Prog.expr_t NonEmptyList.t) 
      (t : t) : t = 
      let (h, rest) = NonEmptyList.uncons exprs in
      let id = TCommon.str_of_expr h in
      match rest with 
      | [] -> ( 
        match t with Tracker (tracker_k, tracker_vs) ->
          (**
            * Replace the target tracker_v in tracker_vs with
            * a new one with updated v and skipped_members
            *)
          Tracker 
            (tracker_k, 
              update_v_lst_with_assign_to_a_v
                tracker_vs id v skipped_members)
        )
      | _ -> (
        let sub_tracker = query_sub_v t id in
        
        assert_helper 
          (
            (* Unassigned before *)
            (TCommon.is_expr_blank sub_tracker.assigned_v) || 
            (
              let sub_member = TCommon.expr_lst_to_dot_expr rest in
              (**
                * Assigned as Data Update before
                * Check whether we are trying to 
                * assign a member skipped before
                *)
              is_sub_member_in_skipped_members 
                sub_member sub_tracker.skipped_members 
            )
          )
          "data tracker: harmony check failed";
          
        aux (NonEmptyList.coerce rest) sub_tracker.t
      )
    in
    let exprs = TCommon.dot_expr_to_expr_lst k in
    aux (NonEmptyList.coerce exprs) t

  let assign_top_lvl 
    (top_lvl : t)
    (k : AST.Prog.expr_t) 
    (v : AST.Prog.expr_t)
    (skipped_members : AST.Prog.expr_t list) : t = 
    assign top_lvl k v skipped_members

  let assign_top_lvl_lst 
    (top_lvl : t)
    (kv_lst : 
      (AST.Prog.expr_t * AST.Prog.expr_t * AST.Prog.expr_t list) list) : t = 
    let rec aux lst t = 
      match lst with 
      | [] -> t
      | h :: rest -> (
        let (k, v, s_lst) = h in
        let t = aux rest t in
        assign_top_lvl t k v s_lst
      )
    in
    aux kv_lst top_lvl

  let build_top_lvl (fs : AST.TopDecl.formal_t list) : t =
    let empty_tracker_k = 
      AST.TopDecl.Formal 
        (false, "", TCommon.tp_of_id "") in
    let tracker_vs : tracker_v list = 
      List.map (
        fun (f : tracker_k) : tracker_v -> 
        {
          assigned_v = TCommon.expr_blank ;
          t = build f ;
          skipped_members = [] ; 
          assigned_members = [] ;
        }
      ) fs in
    Tracker (empty_tracker_k, tracker_vs)

  let query_sub_t 
    (tracker : t)
    (member : AST.Prog.expr_t) : t = 
    let rec aux (t : t) (member_id_lst : string list) : t = 
      match member_id_lst with 
      | [] -> t
      | h :: rest -> 
        let sub_v = query_sub_v t h in
        let sub_t = sub_v.t in
        aux sub_t rest
    in
    let member_lst = TCommon.dot_expr_to_expr_lst member in
    let member_id_lst = List.map (
      fun x -> TCommon.str_of_expr x
    ) member_lst in
    aux tracker member_id_lst

  let rec saturation_check (t : t) : bool = 
    match t with Tracker (_, vs) -> 
      let rec aux lst = 
      match lst with
      | [] -> true
      | h :: rest -> (
        match TCommon.is_expr_n_blank h.assigned_v with 
        | true -> (
          List.for_all 
            (fun sub_member -> 
              let sub_t = query_sub_t t sub_member in
              saturation_check sub_t) 
            h.skipped_members
        )
        | false -> 
          match h.t with Tracker (_, sub_vs) ->
            List.for_all (
              fun sub_v -> saturation_check sub_v.t
            ) sub_vs
      ) && (aux rest) in
      aux vs
  
  let rec construct (t : t) : AST.Prog.expr_t list = 
    match t with Tracker (tracker_k, tracker_vs) ->
      let rec aux (lst : tracker_v list) : AST.Prog.expr_t list = 
      match lst with 
      | [] -> []
      | h :: rest -> (
        match TCommon.is_expr_blank h.assigned_v with
        | false -> (
          let assigned_v = (
            match h.skipped_members with 
            | [] -> h.assigned_v
            | _ -> (
              let e = h.assigned_v in
              match e with 
              | AST.Prog.Suffixed (e, suffix) ->
                (
                  match suffix with 
                  | AST.Prog.DataUpd (_, member_bindings) ->
                    let aux v = 
                      assert_helper 
                        (is_sub_member_in_skipped_members 
                          v h.skipped_members) 
                        "data tracker : saturation check failed";
                      let sub_member = v in
                      let sub_t = query_sub_t h.t sub_member in
                      let c_lst = construct (sub_t) in
                      match c_lst with 
                      | [] -> assert false
                      | h :: _ -> h
                    in
                    let member_bindings = NonEmptyList.map (
                      fun x -> let (eit, v) = x in (eit, aux v) 
                    ) member_bindings in
                    AST.Prog.Suffixed 
                      (e, AST.Prog.DataUpd (None, member_bindings))
                  | _ -> assert false
                )
              | _ -> assert false
            )
          ) in
          assigned_v :: (aux rest)
        )
        | true -> (construct t) @ (aux rest)
      )
    in
    let args = aux tracker_vs in
    match tracker_k with AST.TopDecl.Formal (_, _, tp) ->
      let tp_id = TCommon.id_of_tp tp in
      match tp_id with 
      | "" -> args
      | _ -> 
        [AST.Prog.Suffixed 
          (TCommon.expr_of_str tp_id, 
            AST.Prog.ArgList 
              ({positional = args; named = []}, 
              None))]

end

